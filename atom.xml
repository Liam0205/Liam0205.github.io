<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2021-05-07T15:29:43.000Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语语法之九：忘记长难句，欢迎来到复合句的世界</title>
    <link href="https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/"/>
    <id>https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/</id>
    <published>2021-05-07T14:46:19.000Z</published>
    <updated>2021-05-07T15:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第九篇。<a href="/2021/05/06/model-verbs-and-moods-in-English/">前作</a>处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。</p><p>从此篇开始，我们要进入复合句的世界。</p><a id="more"></a><h2 id="忘记长难句"><a href="#忘记长难句" class="headerlink" title="忘记长难句"></a>忘记长难句</h2><p>前北京新东方 GMAT 名师杨鹏著有《GRE&amp;GMAT 阅读难句教程》一书。因书中对 GRE 和 GMAT 考试阅读题中常常出现的长句难句做了一些解读，故而被坊间惯称为「杨鹏长难句」。然而，以数学系学生的视角，我对这本书是不甚满意的。这种不满在于它没有很好地解决一个基本问题：到底多长算长句，又到底多难算难句？对于难句，是你觉得难算难，还是我觉得难算难？因为缺少一个客观稳定的标准，在我的视角，它很难提出一个完备的方案去处理所有的情况。</p><p>因此，虽然《长难句》一书仍可一看，但忘记「长难句」这一概念却是必要的。</p><h2 id="破而立……什么？"><a href="#破而立……什么？" class="headerlink" title="破而立……什么？"></a>破而立……什么？</h2><p>或曰：「你不能光顾着破坏，还要负责建设」。</p><p>忘记长难句，我们要以怎样的视角去切入英文中那些看起来很长又很难的句子呢？答案是，以简单句和复合句的视角。</p><p>我们在系列第一篇介绍了五种基本句型，在系列第五篇（非谓语动词篇）里又提到了独立子句（independent clause）的概念。据此，我们可以给出一个明确的结论：有且只有一套主谓结构的句子，是独立子句。独立子句必属于五种基本句型之一。独立子句单独成句时，就是简单句。</p><p>在简单句的定义基础上，我们又能「非此即彼」地定义出复合句：不是简单句的句子，就是复合句。复合句由若干个独立子句组合而成。独立子句组成复合句又有两种方式。一是由 and/or/but 等连接词连接的两个并列子句组成的合句（compound sentence）；二是由各种从句与主句连接而成的复句（complex sentence）。</p><p>你看，按照这样的定义，绝不会有一个句子被遗漏。于是我们有信心能处理所有的情况。</p><h2 id="怎样分析和练习复合句？"><a href="#怎样分析和练习复合句？" class="headerlink" title="怎样分析和练习复合句？"></a>怎样分析和练习复合句？</h2><p>系列的后续文章，会处理各种类型的复合句。这里提前讲一讲，在理解各种类型复合句的基础上，如何分析和练习。在这里，分析是为了解决阅读方面的问题，让你在阅读遇到复合句时不至于抓瞎；练习是为了解决写作方面的问题，让你在写作时能自如地应用复合句。</p><p>这里总结整理了一个四步分析法：</p><ol><li>标记出复合句当中的各个独立子句。</li><li>对于每个独立子句，识别其应用的基本句型，而后标出其中的主要成分。</li><li>对于每个独立子句，翻译之。</li><li>将独立子句的翻译组合起来，得到整个复合句的翻译。——注意，一定要写下来翻译成通顺的人话（可以打字）。</li></ol><p>反复应用这一分析法，按我这等笨人的经验，每天坚持分析五个句子并坚持一个月能在阅读 GRE/GMAT/LSAT 级别的文章上有一个质的飞跃。（当然 GRE 级别的文章不只是复合句一个问题需要解决就是了。）相信读者老爷们这么聪明，应当相比当年的我，能更快获得提升。</p><p>分析完成之后，就要练习。练习的方法也很简单：模仿造句——牙牙学语嘛！对每个你初时感到困难的复合句进行三到五次模仿造句——模仿它的句子结构，也模仿子句之间的逻辑关系。</p><p>按照这样分析和练习的方法，每天花费大概半个小时的时间，你将能一劳永逸地征服英语复合句。它不香吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第九篇。&lt;a href=&quot;/2021/05/06/model-verbs-and-moods-in-English/&quot;&gt;前作&lt;/a&gt;处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们要进入复合句的世界。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Single Sentence" scheme="https://liam.page/tags/Single-Sentence/"/>
    
      <category term="Compound Sentence" scheme="https://liam.page/tags/Compound-Sentence/"/>
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之八：情态动词与虚拟语气</title>
    <link href="https://liam.page/2021/05/06/model-verbs-and-moods-in-English/"/>
    <id>https://liam.page/2021/05/06/model-verbs-and-moods-in-English/</id>
    <published>2021-05-06T13:36:57.000Z</published>
    <updated>2021-05-06T15:24:09.394Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第八篇。<a href="/2021/04/29/adverbs/">前作</a>处理了副词，此篇我们引出语气的问题，然后处理情态动词。</p><a id="more"></a><h2 id="语气是什么"><a href="#语气是什么" class="headerlink" title="语气是什么"></a>语气是什么</h2><p>我们从<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>开始（在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇中又一次强调），就从表意的角度解读：一个完整句子表达的无非是「一个人/一个东西怎么样（了）」。但这其实是一个「善意的谎言」；若说它不是谎言，也至少是不完整的。它欠缺的部分，就是「语气」。</p><p>语气的英文是 mood。在 AHD 中可见它有几层与文法中的语气相关意思：</p><ul><li>心情、情绪：A state of mind or emotion.</li><li>印象、感受：A pervading impression of an observer.</li><li>倾向、意愿：Inclination; disposition.</li></ul><p>无论何种解释，mood 都是「唯心」的，天然带有一层模糊的、不确定的感觉；这与「一个人/一个东西怎么样（了）」这种确定性的表述有明显差别。于是我们有：</p><ul><li><strong>语气其实就是句子表意过程中的不确定性</strong>；</li><li>确定的表意总是相似的；</li><li>不确定的表意则各有各的不确定（在不确定的程度和不确定的方式上）。</li></ul><p>在英文中，普通动词本身只能表达确定性的语义。例如：I like math. 若是要表达不确定性的语义，则必须有其他动词的帮助才行。帮助其他动词进行表意的动词，通称「助动词」。表达各种类别和各种程度的不确定性的助动词，是情态动词（modal verbs）。</p><blockquote><p>情态动词这个翻译，我认为不好。但因已成惯例，所以不去改它。更好的翻译应该是「语气动词」。modal 这个词，在 AHD 当中关于文法的解释只有一条「Of, relating to, or expressing the mood of a verb.」，即：语气的：属于，有关或表达一个动词的语气的。可见「语气动词」翻译之贴切。</p></blockquote><p>接下来的问题是，英文当中都有哪些语气呢？这是个令人头秃的问题，因为不同的语法专家对此的认知并不相同。有人认为英文当中语气分三种：陈述语气、祈使语气、虚拟语气。有人认为英文当中语气分四类，在上述三类基础上增加「疑问语气」。有人认为应当分五类，在上述四类基础上增加「感叹语气」。</p><p>于我看来，不论如何分类，祈使语气、疑问语气和感叹语气是不会有太多争议的。表达这三种语气时，在句法上会有很规律的变化，以至于有「祈使句」、「疑问句」和「感叹句」之说。因而人们想要弄混它们都不太容易。我们的宗旨是从表意和修辞出发。既然它们不容易弄混，我们就干脆地将他们放下，不尊「务虚论理者多，经世致用者少」那等做派。这样一来，剩下的问题就在陈述语气和虚拟语气当中了。</p><h2 id="以简御繁：关于不确定性的讨论"><a href="#以简御繁：关于不确定性的讨论" class="headerlink" title="以简御繁：关于不确定性的讨论"></a>以简御繁：关于不确定性的讨论</h2><p>以简御繁的手段是去摸索句子表意当中的不确定性。</p><h3 id="陈述语气（indicative）"><a href="#陈述语气（indicative）" class="headerlink" title="陈述语气（indicative）"></a>陈述语气（indicative）</h3><p>如果一个句子的表意十分确定，那显然就是陈述语气了。例如有：</p><ul><li>It rains. | 天在下雨。</li><li>You are right. | 你是对的。</li><li>I like mathematics. | 我喜欢数学。</li><li>Sophia gives me her pencil. | Sophia 将她的铅笔给我。</li><li>Liam finds the house big. | Liam 发现房子很大。</li></ul><h3 id="条件语气（conditional）"><a href="#条件语气（conditional）" class="headerlink" title="条件语气（conditional）"></a>条件语气（conditional）</h3><p>若在陈述语气的基础上，加上心情、情绪（例如 must）或是印象、感受（例如 can/could, may/might）亦或是倾向、意愿（例如 will/would, shall/should；注意此处并不表示将来时态，而是表示倾向意愿），句子中就有了不确定性了。在上述例子的基础上，我们处理一下：</p><ul><li>It <em>may/might</em> rain. | 天可能在下雨。</li><li>You <em>must</em> be right. | 你一定是对的。</li><li>I <em>shall</em> like mathematics. | 我应当喜欢数学。</li><li>Sophia <em>can/could</em> give me her pencil. | Sophia 可以将她的铅笔给我。</li><li>Liam <em>shall/should</em> have found the house big. | Liam 应当已经发现房子很大了。</li></ul><p>此处有两点需要注意。一是我们在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇里讲过的，情态动词后面，实际上是无修饰的不定式，因而要用动词原型。二是尽管部分情态动词有其过去式的形态，但对「不确定性」表达过去本身无意义，因此需要借用完成式来表达对过去的猜测（或曰，表达过去时态下的不确定性）。</p><p>在陈述语气的句子上，直接加上情态动词（可能还需要对动词做一些变形）可以表达不同类型和程度的不确定性。但这些不确定性，都没有否定陈述句意本身，只是在语气上的弱化。为便于归纳，我们把这类语法现象称之为条件语气。</p><h3 id="虚拟语气（subjunctive）"><a href="#虚拟语气（subjunctive）" class="headerlink" title="虚拟语气（subjunctive）"></a>虚拟语气（subjunctive）</h3><p>还有一种情况，我们的表意需要否定陈述句意本身。这种表意发生在假定一个不存在的事实的基础上，作出的推定。这里有四点需要注意的地方：</p><ul><li>因为假定非事实，所以称为虚拟语气；</li><li>因为假定非事实，所以从句中假定本身需要比正常时态退一格（现在 -&gt; 过去；过去 -&gt; 过去完成；将来 -&gt; 过去将来）；</li><li>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式表达强烈的不确定性；</li><li>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式。</li></ul><p>对虚拟语气，举几个例子。</p><p><strong>If I <em>were</em> you, I <em>would</em> fend off that shot. | 要我是你的话，我会把那一球扑出去。</strong></p><p>表达「我是你」，应该用 I am you 才对。但我不是你，这非是事实，所以要退一格，用过去式来表意。那么为什么是 <code>were</code> 而非是 <code>was</code> 呢？因为 <code>be</code> 这个动词是这样的：</p><ul><li>原型：be</li><li>第一人称单数现在陈述语气：am</li><li>第三人称单数现在陈述语气：is</li><li>其余人称和单复数的现在陈述语气：are</li><li>现在分词：being</li><li>过去分词：been</li><li>第一和第三人称单数过去陈述语气：was</li><li>第二人称单数和复数，第一人称复数，第三人称复数，过去陈述语气：were</li><li>过去虚拟语气：were</li></ul><p>亦即，在虚拟语气中，be-动词的过去式就是 were，不区分单复数，也不区分人称。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>would</code> 表达强烈的不确定性。</p><p><strong>If I <em>had known</em> that earlier, I <em>might have revise</em> for the examination harder. | 要早知道的话，我会为考试更努力复习。</strong></p><p>表达「我知道」，应该用 I knew that earlier 才对。但实际我并不知道，这非是事实，所以要退一格，用过去完成式来表意，变成 <code>had known</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>might</code> 表达强烈的不确定性。</p><p>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式，有 <code>might have revise</code>。</p><p><strong>If I <em>should take</em> the bribe, <em>could</em> you <em>keep</em> the secret for me? | 要我收下了那笔贿赂，你能替我保守秘密吗？</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>should take</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><p><strong>If I <em>were to take</em> the bribe, my fingers <em>could be</em> illicit from then on. | 要我收下了那笔贿赂，我的手就再也不干净了。</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>were to take</code>。这和上例的 <code>should take</code> 又有所不同。虽然都非是事实，用 should take 表示还有一些 take 的可能性，而用 were to take 则十分决绝，毫无可能。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>借助「不确定性」的表意，我们轻而易举地处理了虚拟语气，可见其以简御繁的为例。</p><p>虚拟语气中还有一个倒装的问题，属修辞范畴。我们在后续的文章中再来讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第八篇。&lt;a href=&quot;/2021/04/29/adverbs/&quot;&gt;前作&lt;/a&gt;处理了副词，此篇我们引出语气的问题，然后处理情态动词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Model Verbs" scheme="https://liam.page/tags/Model-Verbs/"/>
    
      <category term="Moods" scheme="https://liam.page/tags/Moods/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之七：副词</title>
    <link href="https://liam.page/2021/04/29/adverbs/"/>
    <id>https://liam.page/2021/04/29/adverbs/</id>
    <published>2021-04-29T13:47:12.000Z</published>
    <updated>2021-04-30T14:47:48.651Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第七篇。<a href="/2021/04/21/adjectives/">前作</a>处理了形容词，此篇我们处理同为修饰词类的副词。</p><p>从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。</p><p>除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。</p><p>除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 <code>-ly</code>。因此，在双音节的副词变为比较级和最高级时，若是以 <code>-ly</code> 结尾，则应保持不变，通过联合 <code>more</code> 及 <code>most</code> 来实现。</p><a id="more"></a><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><p>如何以简御繁？这是很重要的问题。</p><p>从系列第一篇读至此的朋友，若是细心就会发现我们至今为止以简御繁的两大法宝：</p><ul><li>从表意上考量——我们相信文法是为表意服务的；</li><li>从修辞上考量——我们相信文法形成过程中，人们有趋同的修辞偏好。</li></ul><p>这两大法宝将在整个系列贯穿始终、提纲挈领。我们从表意上，把副词分为以下几大类，分别处理：</p><ul><li>表达方式方法的副词；</li><li>表达强调的副词；</li><li>修饰句子的副词。</li></ul><h2 id="表达方式方法的副词"><a href="#表达方式方法的副词" class="headerlink" title="表达方式方法的副词"></a>表达方式方法的副词</h2><p>表达方式方法的副词，在传统语法当中被称为「方式状语」。方式状语直接修饰动词，表达动作发出的方式方法。</p><p>至于副词的位置——因为方式状语直接修饰动词，所以理想状态，它应该距离动词较近；若不然，人们很难领会到二者之间修饰 - 被修饰的关系。又考虑到动词本身肯定比修饰语要重要一些，所以作为修饰语的副词，一般性应该要放在动词后面。这是表达方式方法的副词的典型位置。</p><p>接下来，我们按<a href="/2014/06/21/basic-sentence-and-the-complement/">五种基本句型</a>各举一例，说明表达方式方法的副词在句子中位置应当如何处理。</p><ul><li>The girl cries <em>sadly</em> after being betrayed by her ex-boyfriend. | 被前男友背叛后，女孩哭得很伤心。</li></ul><p>句子中，我们把表达方式方法的副词放在动词 cries 后面。可选的位置还有两个。一是放在 cries 之前。这样做是可以的，但是 cries 后面没有句子主干成分了（宾语、补语之类）；所以还是放在 cries 后面，凸显动词更佳。另一是放在整个 after 短语之后。但这样距离 cries 太远，反而距离另一个动词 betrayed 更近，造成句意不明。</p><ul><li>The girl swings her bat <em>vigorously</em>. | 女孩用力挥动她的棒球棒。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是和上例一样，放在动词 swing 后面。但这样就把句子的主干成分 her bat（句子中做宾语）挤到后面去了，不利于表意。另一是放在 swing 之前。这也属于可以考虑的方案，但此处宾语并不冗长，放在宾语之后距离被修饰的动词 swing 也不算太远，所以显得有些鸡肋。但如果换成下面的句子，副词就最好放在动词 swing 之前了——若不然，就距离动词太遥远了。</p><blockquote><p>The girl <em>vigorously</em> swings her brand new Italian aluminum alloy bat. | 女孩用力挥动她那崭新的意大利产铝合金棒球棒。</p></blockquote><ul><li>The girl becomes mature <em>gradually</em>. | 女孩逐渐变得成熟。</li></ul><p>句子中，我们表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一个是放在动词 becomes 之前，这没问题。另一是放在动词 becomes 之后，变成「The girl becomes <em>gradually</em> mature.」。这样一来，因为副词既可以修饰动词，又可以修饰形容词，放在这里的 gradually 很容易让人困惑它到底是修饰 becomes 的还是修饰 mature 的。</p><ul><li>The girl gave him a jar of honey <em>readily</em>. | 女孩爽快地给了他一罐蜂蜜。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是放在动词 gave 之前，这没问题。另一是放在动词 gave 之后，变成「The girl gave <em>readily</em> him a jar of honey.」。这样做，表意上倒是不至于有歧义，但副词 readily 把句子的主干成分（直接宾语 + 间接宾语）挤到后面去了，所以在修辞上不好。</p><ul><li>The priest <em>happily</em> announced the boy and the girl man and wife. | 神父高兴地宣布男孩和女孩结为夫妻。</li></ul><p>句子中，我们把表达方式方法的副词放在了动词 announced 之前。可选的位置还有两个。一是放在动词 announced 之后，但这会让句子的主干成分（宾语 + 宾语补语）后移，在修辞上不佳。二是放在句子最后。但这个句子重点是要强调二者结为夫妻，若是将 happily 放在句子最后，一则显得我们在强调神父是高兴的，二则让副词和被修饰的动词距离过远。</p><h2 id="表达强调的副词"><a href="#表达强调的副词" class="headerlink" title="表达强调的副词"></a>表达强调的副词</h2><p>副词当中，还有一大类是表达强调的副词（Intensifier）。这些副词的修饰对象广泛，可以修饰几乎全部词类，特别是可以修饰几种主要词类：名词、动词、形容词、副词。因之，这些副词必须和被修饰的对象紧密相连（而且通常都是放在被修饰对象的前面）。若不然，可能会被误以为是修饰其他句子成分，表意出现漂移。</p><p>表达强调意味的副词，大致有三类。以下分别处理。</p><h3 id="强调范围的副词"><a href="#强调范围的副词" class="headerlink" title="强调范围的副词"></a>强调范围的副词</h3><p>表达强调的副词中，有一部分是用来强调所谈事物的范围的，将所谈事物的范围限定在一个小的范围内。这类副词加与不加、加在何处，对句子的表意影响很大。这类副词中，一个典型是「只有」。举例如下。</p><p>原句：Liam studied mathematics when he was young. | Liam 年轻时学习数学。</p><p>添加「只有」：</p><ul><li><em>Only</em> Liam studied mathematics when he was young. | 只有 Liam 年轻时学习数学。——别人年轻时不学。</li><li>Liam <em>only</em> studied mathematics when he was young. | Liam 年轻时只学习数学。——但没对数学做别的事情；比如对数学并不热爱。</li><li>Liam studied <em>only</em> mathematics when he was young. | Liam 年轻时只学习数学。——但没学别的学科。</li><li>Liam studied mathematics <em>only</em> when he was young. | Liam 只在年轻时学习数学。——长大之后不学了。</li></ul><p>不难发现，添加「只有」之后的四个变种，其表意各不相同，亦与原句表意不同。由此可见「这类副词加与不加、加在何处，对句子的表意影响很大」之说。此又印证「这些副词必须和被修饰的对象紧密相连」之言。</p><p>常见的用于强调表意范围的副词还有：</p><ul><li>only / just / merely | 只有</li><li>also | 也</li><li>especially / particularly | 尤其、特别地</li><li>even | 更加、甚至、居然、恰如</li><li>exactly / precisely | 恰恰</li><li>……</li></ul><h3 id="强调程度的副词"><a href="#强调程度的副词" class="headerlink" title="强调程度的副词"></a>强调程度的副词</h3><p>表达强调的副词中的第二类是强调程度的副词。这些副词也是句子表意中很重要的一部分；同样地，这类副词加与不加对句意影响很大。举一例：</p><ul><li>原句：Liam knows Wenyue well. | Liam 了解 Wenyue。</li><li>改程度：Liam knows Wenyue <em>rather</em> well. | Liam 还算了解 Wenyue。</li></ul><p>再举一例：</p><ul><li>原句：The task is done. | 任务已完成。</li><li>改程度：The task is <em>almost</em> done. | 任务已近完成。</li></ul><p>不难发现，这些表达程度的副词也是句子表意的重要组成部分。若是去掉它们，句子表意会发生巨大变化。常见的用于强调程度的副词不少，就不举例了。</p><h3 id="强调语气的副词"><a href="#强调语气的副词" class="headerlink" title="强调语气的副词"></a>强调语气的副词</h3><p>强调语气的副词看起来和强调程度的副词很像。但是，去掉句子当中强调语气的副词只是影响语气，不影响句子表意。举几例：</p><ul><li>Fat XXX looks <em>very much</em> a ball. | 胖子 XXX 看着就是个球。</li><li>XXX is <em>absolutely</em> insane. | XXX 绝对是疯了。</li><li>XXX <em>urgently</em> need being hospitalized. | XXX急需入院治疗。</li></ul><h2 id="修饰句子的副词"><a href="#修饰句子的副词" class="headerlink" title="修饰句子的副词"></a>修饰句子的副词</h2><p>这是一类特殊的副词。和一般（狭隘的）认知不同，有些副词可以用来修饰整个句子。举例来说：</p><ul><li><em>Therefore</em>, Wenyue is less than too fat. | 因此，Wenyue 还称不上太胖。</li><li><em>Frankly</em>, Wenyue is very much a gentleman. | 坦率地说，Wenyue 是个绅♂士。</li></ul><p>例中，无论是 <em>therefore</em> 还是 <em>frankly</em>，在句中都找不到被它们直接修饰的句子成分。这是因为它们都是修饰整个句子的副词。此二例中，看着相似，但实际仍有区别。第二例中的 <em>frankly</em>，实际是一条件状语从句的缩写：</p><blockquote><p>If we are specking frankly, Wenyue is very much a gentleman.</p></blockquote><p>对于这类从副词从句缩写而来的副词，我们称之为分离副词。此外，不难发现，分离副词前后的逗号，原就是两个句子之间的逗号。这种简化，最早应是出于修辞的考虑；简化之后保留逗号，则是出自表意的考虑。</p><p>第一例中的 <em>therefore</em> 本身能表达逻辑关系。因之，此类副词被称为连接副词。这些副词还有</p><ul><li>表达逻辑等号的：therefore, besides, futhermore, ...</li><li>表达逻辑不等号的：however, nonetheless, ...</li></ul><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>此篇，我们通过「两大法宝」，串起了几大类副词，同时辨析了各类副词在句中的用法。所谓渔重于🐟，读者在了解各类副词用法的同时，更重要地是善用两大法宝，复习过去学过的文法和学习新的文法知识。</p><p>下一篇我们处理情态动词和虚拟语气。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第七篇。&lt;a href=&quot;/2021/04/21/adjectives/&quot;&gt;前作&lt;/a&gt;处理了形容词，此篇我们处理同为修饰词类的副词。&lt;/p&gt;
&lt;p&gt;从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。&lt;/p&gt;
&lt;p&gt;除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。&lt;/p&gt;
&lt;p&gt;除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 &lt;code&gt;-ly&lt;/code&gt;。因此，在双音节的副词变为比较级和最高级时，若是以 &lt;code&gt;-ly&lt;/code&gt; 结尾，则应保持不变，通过联合 &lt;code&gt;more&lt;/code&gt; 及 &lt;code&gt;most&lt;/code&gt; 来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adverbs" scheme="https://liam.page/tags/Adverbs/"/>
    
  </entry>
  
  <entry>
    <title>喉咙和声带的结构</title>
    <link href="https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/"/>
    <id>https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/</id>
    <published>2021-04-26T16:28:03.000Z</published>
    <updated>2021-04-26T16:34:00.953Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！</p><a id="more"></a><p>声带是两片相对的膜状韧带，有长度宽度和厚度。</p><p>声带附近有四块软骨：甲状软骨、勺状软骨（两块）和环状软骨。</p><p>连接软骨有肌肉：甲杓（读音：彪）肌（连接甲状软骨和勺状软骨；TA 肌）、杓间肌（连接两块勺状软骨，横向一条，斜向两条；IA 肌）、环杓侧肌（在侧面连接环状软骨和勺状软骨；LCA 肌）、环杓后肌（在后面连接勺状软骨和环状软骨；PCA 肌）、环甲肌（在前面连接环状软骨和甲状软骨；CT 肌）。</p><p>肌肉通过拉扯软骨，来改变连接着软骨的声带的形状。相对来说，有四种：</p><ul><li>变短变厚：甲杓肌收缩，发出响亮的中低音，传说中的「真声」。</li><li>变长变薄：环甲肌收缩，引起整个环状软骨绕环甲连接处转动，从而带动勺状软骨后移，拉动声带变长变薄。</li><li>闭合：杓间肌和环杓侧肌收缩，拉近两块勺状软骨之间的距离。</li><li>张开：环杓后肌收缩，拉开两块勺状软骨之间的距离，声带分开。</li></ul><p>当声带闭合，又有气流从下而上推出，两片声带在气流的冲击和伯努利效应（边界层表面效应）的作用下会不断相互拍击，发出声音。</p><p>接下来的问题就是，要想唱好歌，本质上就是要在各种情况下，相应的肌肉都有足够的力量，去使声带作出相应的动作。所以，练歌，本质上和去健身房撸铁没啥区别——都是要锻炼肌肉。下回如果有人跟你说要去撸铁，不一定是去健身房，也可能是去练歌房。</p><p>唔哈哈哈，是不是很有趣~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Vocal" scheme="https://liam.page/tags/Vocal/"/>
    
      <category term="Autopsy" scheme="https://liam.page/tags/Autopsy/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之六：形容词</title>
    <link href="https://liam.page/2021/04/21/adjectives/"/>
    <id>https://liam.page/2021/04/21/adjectives/</id>
    <published>2021-04-21T13:49:22.000Z</published>
    <updated>2021-04-22T14:24:34.516Z</updated>
    
    <content type="html"><![CDATA[<p>这个<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>最近<a href="https://github.com/Liam0205/liam0205.github.io/issues/333#issuecomment-808816973" target="_blank" rel="noopener">又被吐槽了</a>。<a href="https://github.com/PolyMark" target="_blank" rel="noopener">PolyMark</a> 讲我更新的太慢。遭不住催更的我，于是就又开始更新了。</p><p>英文当中，用来修饰其他词的词类有两种：形容词和副词。</p><p>大体上，形容词是修饰名词的词，副词则用来修饰名词以外的词类。不过也有少许例外。一方面，少数副词也可以修饰名词；另一方面，用来修饰名词的，不仅仅是狭义上的形容词。比方说，形容词性从句及其简化版本、介词短语、复合词等，在一些场合下，都能充当形容词，承担相应的表意功能。</p><p>此篇先介绍最简单的部分——单词形状的形容词。</p><a id="more"></a><p>单词形状的形容词是英文文法当中比较简单的部分，就只有三大主题：</p><ul><li>补语位置（包括主语补语和宾语补语）的形容词；</li><li>名词短语当中的形容词；</li><li>形容词的比较级。</li></ul><p>我们分别来处理。</p><h2 id="补语位置的形容词——从几个例子开始"><a href="#补语位置的形容词——从几个例子开始" class="headerlink" title="补语位置的形容词——从几个例子开始"></a>补语位置的形容词——从几个例子开始</h2><p>名词短语当中的形容词，在我们处理名词短语时已经见过。它出现在限定词和名词之间，是「属性形容词」（attribute adjectives），描述名词的一种属性。我们举几个例子复习一下。（下划线部分是限定词，加粗部分是形容词）：</p><ul><li><u>a</u> <strong>new</strong> book | 一本新书</li><li><u>many</u> <strong>good</strong> students | 许多好学生</li><li><u>his</u> <strong>beautiful</strong> wife | 他美丽的妻子</li><li><u>the</u> <strong>best</strong> answer | （那个）最佳答案</li><li><u>those</u> <strong>sweet</strong> roses | 那些芳香的玫瑰</li><li><strong>dirty</strong> water | 脏水</li><li><strong>Fat</strong> Wenyue doesn&#39;t like taking exercises. | 胖 Wenyue 不喜欢运动</li></ul><p>出现在补语位置的形容词则是「叙述形容词」（predicate adjectives），它通常是对名词做临时性、暂时性的叙述。同样举几个例子。</p><ul><li>Wenyue is <strong>fat</strong>. | Wenyue 很胖。</li><li>Eating too many junk foods and lack of working-out make Wenyue <strong>fat</strong>. | 吃过多垃圾食品又缺少锻炼导致 Wenyue 很胖。</li></ul><p>比较关于 Wenyue 的几个例子，我们不难发现：<strong>出现在名词短语当中的形容词，暗含一种固有、长期的感觉</strong>。「Fat Wenyue」的表述告诉大家，Wenyue 他就是个胖子，不管他说什么做什么，都很难瘦下来。反过来，<strong>出现在补语位置的形容词，则缺乏固有、长期的意味</strong>。不管是充作主语的补语还是充作宾语的补语，你都能感觉 Wenyue 只是暂时有点胖，过段时间还是有可能瘦下去的，还是有救的，不能放弃治疗。</p><blockquote><p>P.S. 此文的打赏请备注，我需要给模特儿 Wenyue 分润一些。哈哈~！</p></blockquote><p>我们知道，来自古英语中，有一些以「a-」开头的形容词，往往都表示短暂的状态。这类形容词就喜欢出现在补语位置——尽管他们也可以出现在名词短语中，但会有一些小的变化，而且显得多少有些奇怪。</p><ul><li>The sick man is still <strong>alive</strong>. | 那个久病之人仍旧活着。</li><li>The balloon stays <strong>afloat</strong>. | 气球保持漂浮。</li><li>Coffee keeps modern people <strong>awake</strong>. | 咖啡让现代人保持清醒。</li></ul><p>补语是对名词的一种补述，单靠一个单词显然是难以完成各种各样的表意的。因此，补语位置的形容词形式比较自由。除了单词形式的形容词之外，还可以是各种短语。举几个例子：</p><ul><li>She always wants to make everyone <strong>happy</strong>.</li><li>I heard her <strong>playing the violin</strong> yesterday.</li><li>The lake is <strong>large</strong>.</li></ul><h2 id="名词短语当中的形容词"><a href="#名词短语当中的形容词" class="headerlink" title="名词短语当中的形容词"></a>名词短语当中的形容词</h2><p>属性形容词这个主题下，我们已有名词短语当中的讨论打底，因此只需要处理几个问题就好。</p><ul><li>后置的形容词；</li><li>名词形容词化；</li><li>复合词做形容词；</li><li>属性形容词的相对顺序。</li></ul><h3 id="后置的形容词"><a href="#后置的形容词" class="headerlink" title="后置的形容词"></a>后置的形容词</h3><p>在处理名词短语时，我们讲修饰词要放在限定词（如果有）和名词（如果有）之间。也就是说，相对名词，修饰名词的形容词要前置。但是，有两种情形，形容词需要后置。</p><h4 id="复合名词与-else-联用"><a href="#复合名词与-else-联用" class="headerlink" title="复合名词与 else 联用"></a>复合名词与 else 联用</h4><p>首先还是看一个例子。</p><ul><li>Someone <strong>else</strong> will handle it well.</li></ul><p>在这个例子当中，形容词 else 放在名词 someone 的后面。这几乎已经是「习以为常」的用法了，在传统语法当中可能会被解释成「约定俗成」。但是我们就偏偏要掰扯掰扯到底是怎样「俗成」的。</p><p>其实这里，someone 是所谓「复合名词」。这类复合名词把名词短语当中的限定词和名词粘连到一起了，于是修饰词失去了位置，就只好往后放了。就这么简单。</p><blockquote><p>类似的复合名词还有（不完整举例）：someone, everyone, anyone, somebody, everybody, anybody...</p></blockquote><h4 id="古英语当中的-a-形容词"><a href="#古英语当中的-a-形容词" class="headerlink" title="古英语当中的 a- 形容词"></a>古英语当中的 <code>a-</code> 形容词</h4><p>之前我们已经讲到，古英语当中的 <code>a-</code> 形容词往往都表示短暂的状态，因此不适合放在名词之前作为属性，而只能后置。举一个例子看看：</p><ul><li>Money <strong>alone</strong> cannot solve every problem, meanwhile, without money solves no problem. | 钱不是万能的，没钱是万万不能的。</li></ul><p>显然，alone 不可能是 money 的一种属性。在句子当中，money alone 表示「只有钱」这一种特殊而暂时的状态。</p><h3 id="名词形容词化"><a href="#名词形容词化" class="headerlink" title="名词形容词化"></a>名词形容词化</h3><p>初看起来，可能会觉得名词形容词化是个很吓人的事情。但其实它真的很常见。比如，中文当中「校门」这个词，实际上「校」就是名词充作了形容词。所以名词形容词化不是什么值得大惊小怪的事情。我们看几个例子。</p><ul><li>a <strong>government</strong> shop | 一家公营商店</li><li><strong>movie</strong> theaters | 电影院（其实就是 cinema <code>: )</code>）</li></ul><p>值得一讲的是，名词既已形容词化，那就要遵循形容词的一些「规矩」。比如电影院，实际上不可能只放映一部电影。但由于形容词不存在复数的概念，所以我们不能写作 movies theaters。</p><h3 id="复合词做形容词"><a href="#复合词做形容词" class="headerlink" title="复合词做形容词"></a>复合词做形容词</h3><p>名词短语中的修饰词位置只能放单词形状的词。因此，如果有一个短语形状的形容词想要放进名词短语当中，就需要用连字符（hyphen）将短语连起来变成一个词；同时，为了遵循形容词的规矩，短语中如果有复数名词应该变成单数形式。举几个例子完事儿~</p><ul><li>an <strong>eye-opening</strong> show | 一场令人大开眼界的表演</li><li>a <strong>five-year-old</strong> girl | 一个五岁的小女孩儿</li></ul><h3 id="属性形容词的相对顺序"><a href="#属性形容词的相对顺序" class="headerlink" title="属性形容词的相对顺序"></a>属性形容词的相对顺序</h3><p>这又是国内英语考试喜欢考察的考点之一。传统语法书惯常让人背诵一个特定的顺序。然而，学生每次都会发现，考卷上的题目会涉及到一个之前没背过的东西，然后就抓耳挠腮。</p><p>实际上，稍作思考就能想清楚了。属性形容词表达的是名词的属性。那么，越接近名词本质的，就要越靠近名词；反过来，越是容易变化或是主观感受的，就要相对远离名词。</p><p>举个两栗子。</p><ul><li>A <strong>poisoned small green</strong> almost kills the White Snow. | 一个有毒的小小绿色苹果差点毒死了白雪公主。</li><li>The murderer left behind a <strong>bloody old black US leather</strong> glove. | 凶手在现场遗留了一个带血的老旧黑色美国皮手套。</li></ul><p>稍微体会一下就容易感受出来了，不是吗？</p><h2 id="形容词的比较级"><a href="#形容词的比较级" class="headerlink" title="形容词的比较级"></a>形容词的比较级</h2><p>形容词和副词都有比较级和最高级。二者有一个共同的问题需要处理：<strong>拼法</strong>。除此之外，最高级比较简单，只有一个定冠词的问题需要处理。比较级则复杂一些。因为比较就一定会导致句子当中出现重复的成分，于是就会有省略和倒装的语法现象。</p><p>我们先来看看比较级和最高级的几个基本例子，然后分别来看这几个问题。</p><h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><p>比较级就是为了解决表意中「大于」、「小于」、「等于」、「不等于」而出现的。前两者的基本形态是「A is <em>adj.-er</em> than B.」；后两者是同级比较，基本形态是「A is <em>(not) as adj. as</em> B」。</p><ul><li>Liam is <em>taller</em> than Sophia. | Liam 比 Sophia 高。</li><li>Liam is <em>as old as</em> Sophia. | Liam 和 Sophia 年岁一般大。</li></ul><p>最高级是为了解决表意中「最」的概念而出现的。举例：</p><ul><li>The Hua Mountain is the <em>most precipitous</em> mountain in China. | 华山是中国最险峻的山。</li><li>The Hua Mountain is <em>most crowded</em> in public holidays. | 华山在公共假期时最拥挤。</li></ul><h3 id="拼法"><a href="#拼法" class="headerlink" title="拼法"></a>拼法</h3><p>对于单音节形容词来说，比较级和最高级的拼法很简单——加 <code>-er</code> 或者 <code>-est</code> 即可。额外多一句就是，以 <code>y</code> 结尾的词，为发音规则计，需要改 <code>y</code> 为 <code>i</code> 再加 <code>-er</code> 或者 <code>-est</code>。对于三音节或更多音节的长词来说，比较级和最高级的拼法也很简单——联用用 <code>more adj.</code>/<code>most adj.</code> 来解决。</p><p>麻烦事儿出现在双音节上。它不长不短，到底是联用 <code>more</code> 好呢？还是加 <code>-er</code> 小尾巴好呢？传统语法书，又要让你背诵了。仔细观察，其实这事儿也很简单。一句话版本：如果形容词有典型的形容词后缀，那就和 <code>more</code> 联用；不然，两者皆可。</p><p>举几个典型形容词后缀的例子。</p><ul><li>act<em>ive</em> -&gt; more act<em>ive</em> -&gt; most act<em>ive</em></li><li>fam<em>ous</em> -&gt; more fam<em>ous</em> -&gt; most fam<em>ous</em></li><li>use<em>ful</em> -&gt; more use<em>ful</em> -&gt; most use<em>ful</em></li><li>lov<em>ing</em> -&gt; more lov<em>ing</em> -&gt; most lov<em>ing</em></li></ul><h3 id="定冠词与最高级"><a href="#定冠词与最高级" class="headerlink" title="定冠词与最高级"></a>定冠词与最高级</h3><p>「最高级前面要加定冠词」可能对于中国学生来说是深入人心的。但看看刚才华山的两个例子，立马就「打脸」了。</p><p>其实，回顾我们在名词短语篇中的讨论就知道，定冠词是限定词的一种，是名词短语的一部分。如果需要表达 that 语义的时候，就要用 the。但是，在有关华山的第二个例子当中，最高级 <em>most crowded</em> 根本就不是名词短语的一部分，当然就谈不上用定冠词了。</p><blockquote><p>我们继续走在秒杀英文文法要点的道路上……嘻嘻……</p></blockquote><h3 id="重复——省略和倒装"><a href="#重复——省略和倒装" class="headerlink" title="重复——省略和倒装"></a>重复——省略和倒装</h3><p>我们先来看两个例子。</p><ul><li>Children grown up in cities are likely to be somewhat more self-confident than children grown up in countryside. | 某种意义上，城里长大的小孩相比农村长大的小孩相较而言更显自信。</li><li>Golden retriever dog has as much I.Q. as a child of five or six has I.Q. | 金毛狗拥有和五六岁小孩一般多的智商。</li></ul><p>啥感觉？读起来累不累？是不是感觉累赘？那就对了！若非是简单的二者直接比较，而是比较具有不同属性的相同物体，物体本身就必然重复。若非是简单地二者直接比较，而是比较不同的二者做的同样的事，做的事情就必然重复。</p><p>那么，问题来了。有重复咋办呢？对于重复的物体，我们可以用代词来指代。对于重复的动作，我们可以用助动词来代替，在加入倒装以便让助动词和它代替的动作在句子里距离更近。我们来分析这两个例子。</p><p>在第一个例子中，重复的物体是 children。我们用 those 来代替它，句子变成：Children grown up in cities are likely to be somewhat more self-confident than <em>those</em> grown up in countryside.</p><p>在第二个例子中，重复的动作是 has I.Q.。我们用 does 来代替它，句子变成：Golden retriever dog has as much I.Q. as a child of five or six <em>does</em>. 此时我们发现助动词 does 距离它实际表意的 has I.Q. 特别远，于是我们来倒装，将助动词 <em>does</em> 提前：Golden retriever dog has as much I.Q. as <em>does</em> a child of five or six.</p><p>关于形容词的事情，就这样齐活儿啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;最近&lt;a href=&quot;https://github.com/Liam0205/liam0205.github.io/issues/333#issuecomment-808816973&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;又被吐槽了&lt;/a&gt;。&lt;a href=&quot;https://github.com/PolyMark&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PolyMark&lt;/a&gt; 讲我更新的太慢。遭不住催更的我，于是就又开始更新了。&lt;/p&gt;
&lt;p&gt;英文当中，用来修饰其他词的词类有两种：形容词和副词。&lt;/p&gt;
&lt;p&gt;大体上，形容词是修饰名词的词，副词则用来修饰名词以外的词类。不过也有少许例外。一方面，少数副词也可以修饰名词；另一方面，用来修饰名词的，不仅仅是狭义上的形容词。比方说，形容词性从句及其简化版本、介词短语、复合词等，在一些场合下，都能充当形容词，承担相应的表意功能。&lt;/p&gt;
&lt;p&gt;此篇先介绍最简单的部分——单词形状的形容词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adjectives" scheme="https://liam.page/tags/Adjectives/"/>
    
  </entry>
  
  <entry>
    <title>Again：不要重新造轮子</title>
    <link href="https://liam.page/2021/03/17/do-not-reinventing-the-wheel-again/"/>
    <id>https://liam.page/2021/03/17/do-not-reinventing-the-wheel-again/</id>
    <published>2021-03-17T03:56:10.000Z</published>
    <updated>2021-04-21T13:48:50.293Z</updated>
    
    <content type="html"><![CDATA[<p>最近，宝玉在群里抛了一个 case，大意是说，因为 <code>npm</code> 更新了上游一个包，导致他们的服务性能下降明显。排查之后发现，上游把一个处理字符串的函数（用于将 <code>&amp;&lt;&gt;&quot;</code> 替换为相应的 HTML 转义）从类似 <code>str.replace(/&quot;/g, &#39;&amp;quot;&#39;)</code> 的写法，改成了循环遍历 <code>str</code>，然后逐个字符检查，再用 <code>+=</code> 拼接到新的输出字符串上。</p><p>显然，这又是一个重新造的轮子不圆引发的问题。</p><a id="more"></a><p>为啥这么说呢？我不了解 JavaScript，但对 Python 有所了解。我找了一下 Python 对字符串 replace 的实现，一下就看明白了差距。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://svn.python.org/projects/python/trunk/Objects/stringobject.c</span></span><br><span class="line">Py_LOCAL(PyStringObject *)</span><br><span class="line">replace(PyStringObject *self,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *from_s, Py_ssize_t from_len,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *to_s, Py_ssize_t to_len,</span><br><span class="line">    Py_ssize_t maxcount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxcount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxcount = PY_SSIZE_T_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxcount == <span class="number">0</span> || PyString_GET_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* nothing to do; return the original string */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxcount == <span class="number">0</span> ||</span><br><span class="line">        (from_len == <span class="number">0</span> &amp;&amp; to_len == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/* nothing to do; return the original string */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle zero-length special cases */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from_len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* insert the 'to' string everywhere.   */</span></span><br><span class="line">        <span class="comment">/*    &gt;&gt;&gt; "Python".replace("", ".")     */</span></span><br><span class="line">        <span class="comment">/*    '.P.y.t.h.o.n.'                   */</span></span><br><span class="line">        <span class="keyword">return</span> replace_interleave(self, to_s, to_len, maxcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Except for "".replace("", "A") == "A" there is no way beyond this */</span></span><br><span class="line">    <span class="comment">/* point for an empty self string to generate a non-empty string */</span></span><br><span class="line">    <span class="comment">/* Special case so the remaining code always gets a non-empty string */</span></span><br><span class="line">    <span class="keyword">if</span> (PyString_GET_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* delete all occurances of 'from' string */</span></span><br><span class="line">        <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_delete_single_character(</span><br><span class="line">                self, from_s[<span class="number">0</span>], maxcount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_delete_substring(self, from_s, from_len, maxcount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special case where both strings have the same length */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from_len == to_len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_single_character_in_place(</span><br><span class="line">                self,</span><br><span class="line">                from_s[<span class="number">0</span>],</span><br><span class="line">                to_s[<span class="number">0</span>],</span><br><span class="line">                maxcount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_substring_in_place(</span><br><span class="line">                self, from_s, from_len, to_s, to_len, maxcount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise use the more generic algorithms */</span></span><br><span class="line">    <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace_single_character(self, from_s[<span class="number">0</span>],</span><br><span class="line">                                        to_s, to_len, maxcount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* len('from')&gt;=2, len('to')&gt;=1 */</span></span><br><span class="line">        <span class="keyword">return</span> replace_substring(self, from_s, from_len, to_s, to_len, maxcount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过边界检查，Python 的 C 实现当中，对 <code>from_s</code> 和 <code>to_s</code> 不同长度的情况作了不同的处理。当二者长度相同的时候，由于无需额外分配内存，可以使用 in-place 的方式解决问题。当二者长度不同时，若 <code>from_s</code> 的长度为 1，走特定优化的版本；否则，走最通用的版本。</p><p>对应到宝玉遇到的问题，显然落到了 <code>from_s</code> 长度为 1 的情形。我们继续再深入看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* len(self)&gt;=1, len(from)==1, len(to)&gt;=2, maxcount&gt;=1 */</span></span><br><span class="line">Py_LOCAL(PyStringObject *)</span><br><span class="line">replace_single_character(PyStringObject *self,</span><br><span class="line">                         <span class="keyword">char</span> from_c,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span> *to_s, Py_ssize_t to_len,</span><br><span class="line">                         Py_ssize_t maxcount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *self_s, *result_s;</span><br><span class="line">    <span class="keyword">char</span> *start, *next, *end;</span><br><span class="line">    Py_ssize_t self_len, result_len;</span><br><span class="line">    Py_ssize_t count, product;</span><br><span class="line">    PyStringObject *result;</span><br><span class="line"></span><br><span class="line">    self_s = PyString_AS_STRING(self);</span><br><span class="line">    self_len = PyString_GET_SIZE(self);</span><br><span class="line"></span><br><span class="line">    count = countchar(self_s, self_len, from_c, maxcount);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* no matches, return unchanged */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use the difference between current and new, hence the "-1" */</span></span><br><span class="line">    <span class="comment">/*   result_len = self_len + count * (to_len-1)  */</span></span><br><span class="line">    product = count * (to_len<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (product / (to_len<span class="number">-1</span>) != count) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">"replace string is too long"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result_len = self_len + product;</span><br><span class="line">    <span class="keyword">if</span> (result_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">"replace string is too long"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (result = (PyStringObject *)</span><br><span class="line">          PyString_FromStringAndSize(<span class="literal">NULL</span>, result_len)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    result_s = PyString_AS_STRING(result);</span><br><span class="line"></span><br><span class="line">    start = self_s;</span><br><span class="line">    end = self_s + self_len;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        next = findchar(start, end-start, from_c);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == start) &#123;</span><br><span class="line">            <span class="comment">/* replace with the 'to' */</span></span><br><span class="line">            Py_MEMCPY(result_s, to_s, to_len);</span><br><span class="line">            result_s += to_len;</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* copy the unchanged old then the 'to' */</span></span><br><span class="line">            Py_MEMCPY(result_s, start, next-start);</span><br><span class="line">            result_s += (next-start);</span><br><span class="line">            Py_MEMCPY(result_s, to_s, to_len);</span><br><span class="line">            result_s += to_len;</span><br><span class="line">            start = next+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Copy the remainder of the remaining string */</span></span><br><span class="line">    Py_MEMCPY(result_s, start, end-start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，这是一个对特定情况的专门优化。</p><ol><li>遍历原字符串，计数 <code>from_c</code> 出现的次数；</li><li>计算目标字符串的长度 <code>len(str) + count * (len(to_str) - 1)</code>，提前分配内存；</li><li>循环地找 from_str 下一次出现的位置，然后 memcpy 原始字符串 + memcpy to_str。</li></ol><p>这种操作，肯定会比不断用 <code>+=</code> 追加单个字符要快得多。因此有标题：Again, 不要重复造轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，宝玉在群里抛了一个 case，大意是说，因为 &lt;code&gt;npm&lt;/code&gt; 更新了上游一个包，导致他们的服务性能下降明显。排查之后发现，上游把一个处理字符串的函数（用于将 &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; 替换为相应的 HTML 转义）从类似 &lt;code&gt;str.replace(/&amp;quot;/g, &amp;#39;&amp;amp;quot;&amp;#39;)&lt;/code&gt; 的写法，改成了循环遍历 &lt;code&gt;str&lt;/code&gt;，然后逐个字符检查，再用 &lt;code&gt;+=&lt;/code&gt; 拼接到新的输出字符串上。&lt;/p&gt;
&lt;p&gt;显然，这又是一个重新造的轮子不圆引发的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="JavaScript" scheme="https://liam.page/tags/JavaScript/"/>
    
      <category term="Software Engineering" scheme="https://liam.page/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中类的构造函数中使用 this 指针</title>
    <link href="https://liam.page/2021/03/17/using-this-pointer-in-ctor/"/>
    <id>https://liam.page/2021/03/17/using-this-pointer-in-ctor/</id>
    <published>2021-03-17T03:44:57.000Z</published>
    <updated>2021-04-21T13:48:50.293Z</updated>
    
    <content type="html"><![CDATA[<p>遇见一个有趣的问题。</p><p>C++ 里面，在类的 constructor 当中使用 this 指针访问成员，是否是安全的？在哪些情况下安全？在哪些情况下不安全？</p><a id="more"></a><p>Ao Shen 给了一个<a href="https://isocpp.org/wiki/faq/ctors#using-this-in-ctors" target="_blank" rel="noopener">标准答案</a>，跟我之前的认知一致：只要对类内成员初始化顺序，以及对基类子类初始化顺序熟悉，就很容易理解了。</p><p>因为类内成员初始化顺序和类内成员声明顺序一致，基类总是在子类之前初始化。所以</p><ul><li>在父类初始化列表当中，使用 <code>this</code> 引用更早声明的变量初始化是安全的。</li><li>在父类构造函数体当中，使用 <code>this</code> 指针引用类内成员是安全的（不包括子类成员）。</li><li>在父类构造函数体当中，down-cast <code>this</code> 指针为子类指针，这一行为本身是安全的；但是使用 down-casted 指针访问子类成员是不安全的。</li><li>在子类初始化列表当中，使用 <code>this</code> 指针引用父类成员总是安全的。</li><li>访问函数的情况，则看对应的函数访问的类内成员是否已经初始化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇见一个有趣的问题。&lt;/p&gt;
&lt;p&gt;C++ 里面，在类的 constructor 当中使用 this 指针访问成员，是否是安全的？在哪些情况下安全？在哪些情况下不安全？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="this" scheme="https://liam.page/tags/this/"/>
    
      <category term="Constructor" scheme="https://liam.page/tags/Constructor/"/>
    
  </entry>
  
  <entry>
    <title>扩展版领口策略</title>
    <link href="https://liam.page/2021/03/16/the-extended-callar-strategy/"/>
    <id>https://liam.page/2021/03/16/the-extended-callar-strategy/</id>
    <published>2021-03-16T06:43:46.000Z</published>
    <updated>2021-04-21T13:48:50.292Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2021/03/15/price-of-option-and-the-collar-strategy/">前文</a>讨论了期权价格的决定因素并简单介绍了领口策略。</p><p>领口策略通过买入虚值看跌期权（后简称买入 PUT otm）并卖出虚值看涨期权（后简称卖出 CALL otm），在 CALL 有效期内放弃超额收益，在 PUT 有效期内控制风险。此篇我们在基础版领口策略的基础上进行一些扩展，以便能够让领口策略长期滚动起来，并持续获得收益/降低持仓成本。</p><blockquote><p>此篇文章介绍的策略，是我从 Ming Ma 先达处学到，而后加工整理的。感谢 Ming Ma 的无私分享和细心解读。</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基础版的领口策略的 PUT 和 CALL 的过期时间相同，这有一点不好。因为从本性来说，我们对下跌的担忧是长久的，对上涨的期待也是长久的。因此，对于固定行权价的保护性 PUT 来说，我们期待它的过期时间长；对于固定行权价的对冲性 CALL 来说，我们期待它过期时间短，以便能够及时根据市场行情作出调整。这促使我们在构建领口策略的时候，买入远期的 PUT，卖出相对短期的 CALL。</p><p>领口策略的本意，是利用卖出 CALL otm 的收入，抵消/降低买入 PUT otm 的成本。现在，我们打算买入远期 PUT otm。那么，它的价格就很难为短期 CALL otm 所抵消。在这种情况下，我们有两种选择。一是继续卖出更多的 CALL otm，二是选择也卖出一些 PUT otm。</p><p>若是继续卖出更多的 CALL otm，那么多出来的这部分 CALL，就会成为没有对应正股保护的敞口风险。构造领口策略是为了降低风险，因此，显然我们不会选择这种平白增加风险的行为。那么选择就很明朗了——卖出部分短期 PUT otm。</p><p>现在，我们的策略由以下部分组成：</p><ul><li>一份正股；</li><li>一份远期，紧跟正股成本价的 PUT otm；</li><li>卖出一份近期，价格稍高的 CALL otm；</li><li>卖出一份近期，价格稍低的 PUT otm。</li></ul><p>最理想的情况，是在卖出的两份近期 option 到期之前，正股价格波动没有击穿 CALL/PUT 的行权价格。在这种情况下，两份期权都不会被对家行权，我们白赚权利金。</p><p>但若</p><ul><li>在近期 CALL 到期之前，上涨击穿 CALL 的行权价，则我们持有的一份正股，会被 CALL 走；此时正股被迫平仓，远期 PUT 的保护就失去了意义。这种情况应当补仓。</li><li>或者，在近期 PUT 到期之前，下跌击穿 PUT 的行权价，则对家会 PUT 一份正股给我们；此时正股仓位高于远期 PUT 的保护，形成敞口风险。这种情况应当减仓。</li></ul><h2 id="补仓的策略"><a href="#补仓的策略" class="headerlink" title="补仓的策略"></a>补仓的策略</h2><p>无论是 CALL 还是 PUT 被击穿，恢复策略都涉及两个方面。一是正股，而是围绕正股当前价格的近期 PUT/CALL。我们先来讨论 CALL 被击穿时候，补仓的策略。</p><p>对于近期 PUT/CALL 来说。</p><p>考虑 PUT。如果 CALL 被提前行权（在到期日之前被行权，仅适用于美式期权），则 PUT 依然在履约期内。此时，由于 1) CALL 被击穿，正股价格相对卖出 PUT otm 时要高，以及 2) 时间的推移，此前我们卖出的 PUT 合约，价格会下跌，低于卖出时的价格。于是我们可以将它买回来。对于 PUT 来说，我们的权利金不会损失。</p><p>考虑 CALL。由于 CALL 被行权，合约结束，权利金完全落入我们的口袋。此时我们的权利金也不会损失。</p><p>因此，我们的结论是，我们应当：</p><ul><li>购回之前卖出的 PUT otm；</li><li>围绕正股当前价格，重新卖出近期的 PUT otm 和 CALL otm。</li></ul><p>对于正股来说，由于卖出的 CALL 被对家行权，我们此时手上没有正股。为了补仓，我们有两种选择。</p><ul><li>一是直接在高于刚刚被击穿的 CALL 行权价，直接购回一份正股。这种情况下，只要购回正股的价格与被击穿的行权价，价格差不超过两份权利金的收入，我们就没有吃亏。</li><li>二是，卖出一份行权价与被击穿的 CALL 的行权价相同的 PUT，并期待正股价格在履约期内跌破行权价，对家行权将正股 PUT 给你。这样操作的好处是，又可以赚一份权利金；但风险在于，如果股价一路上涨，则对家不会行权，我们手头没有正股，从而失去后续正股价格上涨的收益。</li></ul><p>考虑到我们购买远期 PUT 时，是为了在控制风险的情况下长期持有正股。<strong>在基本判断不发生变化的情况下</strong>，更好的选择应该是选择第一种方案：直接购入一份正股。</p><h2 id="减仓的策略"><a href="#减仓的策略" class="headerlink" title="减仓的策略"></a>减仓的策略</h2><p>接下来我们讨论减仓的策略。</p><p>同样地，对于近期 PUT/CALL 来说。</p><p>考虑 CALL。如果 PUT 被提前行权（在到期日之前被行权，仅适用于美式期权），则 CALL 依然在履约期内。此时，由于 1) PUT 被击穿，正股价格相对卖出 CALL otm 时要低，以及 2) 时间的推移，此前我们卖出的 CALL 合约，价格会下跌，低于卖出时的价格。于是我们可以将它买回来。对于 CALL 来说，我们的权利金不会损失。</p><p>考虑 PUT。由于 PUT 被行权，合约结束，权利金完全落入我们的口袋。此时我们的权利金也不会损失。</p><p>因此，我们的结论是，我们应当：</p><ul><li>购回之前卖出的 CALL otm；</li><li>围绕正股当前价格，重新卖出近期的 PUT otm 和 CALL otm。</li></ul><p>类似地，对于正股来说，由于卖出的 PUT 被对家行权，我们此时手上有两份正股。为了减仓，我们有两种选择。</p><ul><li>一是直接在低于刚刚被击穿的 PUT 行权价，直接卖出一份正股。（注意，此时手上还卖出了一份 CALL，所以只能卖出一份正股，不能两份全部卖出。）这种情况下，只要卖出正股的价格与被击穿的行权价，价格差不超过两份权利金的收入，我们就没有吃亏。</li><li>二是，卖出一份行权价与被击穿的 PUT 的行权价相同的 CALL，并期待正股价格在履约期内涨过行权价，对家行权将正股 CALL 走。这样操作的好处是，又可以赚一份权利金；但风险在于，如果股价一路下跌，则对家不会行权，我们手头有两份正股，从而需要承担额外的一份正股下跌带来的损失。</li></ul><p>考虑到我们购买远期 PUT 时，是为了在控制风险的情况下长期持有正股。<strong>在基本判断不发生变化的情况下</strong>，更好的选择应该是选择第二种方案：通过卖出 CALL，让对家主动行权，CALL 走我们手头额外的正股。</p><h2 id="风险的分析"><a href="#风险的分析" class="headerlink" title="风险的分析"></a>风险的分析</h2><p>在这个交易体系当中，存在的风险可以罗列如下。</p><ol><li>正股：下跌风险为远期 PUT 保护，在做好远期 PUT 过期的心理建设的情况下，相当于无风险。</li><li>远期 PUT：正股股价长期下跌，被迫行权远期 PUT，承担 otm 部分以及未被近期 option 权利金抵消的风险。</li><li>近期 CALL：正股股价暴涨，导致没有在击穿短期 CALL 后及时补仓，导致没有享受后续正股价格上涨的收益。</li><li>近期 PUT：正股股价暴跌，导致没有在击穿短期 PUT 后及时减仓，导致无远期 PUT 保护的敞口风险。</li></ol><p>可见，为避免这些风险，应用这一交易体系应当满足以下条件：</p><ol><li>正股股价长期看涨——公司基本面良好、正股股价处在低估区间；</li><li>正股股价波动幅度较小——公司体量相对较大。</li></ol><p>在满足这些条件的基础上，应用这一体系，可以在相当低的风险的情况下，获得可观的长期收益。并且，在这个过程中，操作者无需投入大量精力盯盘，只需在关键时间节点做少量操作即可。运作得好，可以以相当低的成本（甚至零成本）持有正股，从此享受股价上涨、分红带来的收益。</p><p>相对应地，这一系统，也不适和追求短期超额收益的投资风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2021/03/15/price-of-option-and-the-collar-strategy/&quot;&gt;前文&lt;/a&gt;讨论了期权价格的决定因素并简单介绍了领口策略。&lt;/p&gt;
&lt;p&gt;领口策略通过买入虚值看跌期权（后简称买入 PUT otm）并卖出虚值看涨期权（后简称卖出 CALL otm），在 CALL 有效期内放弃超额收益，在 PUT 有效期内控制风险。此篇我们在基础版领口策略的基础上进行一些扩展，以便能够让领口策略长期滚动起来，并持续获得收益/降低持仓成本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此篇文章介绍的策略，是我从 Ming Ma 先达处学到，而后加工整理的。感谢 Ming Ma 的无私分享和细心解读。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Collar Strategy" scheme="https://liam.page/tags/Collar-Strategy/"/>
    
  </entry>
  
  <entry>
    <title>期权价格与领口策略</title>
    <link href="https://liam.page/2021/03/15/price-of-option-and-the-collar-strategy/"/>
    <id>https://liam.page/2021/03/15/price-of-option-and-the-collar-strategy/</id>
    <published>2021-03-15T12:00:35.000Z</published>
    <updated>2021-04-21T13:48:50.292Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://liam.page/2019/11/24/option-and-hedge/">前作</a>简单讨论了期权，也提及了卖权价格变化的影响因素。不过，对于这些影响因素背后的原理并未深究。</p><p>此外，我们已经知道，合理利用期权可以对冲股票价格下跌的风险。但简单地买入卖权（long put options），也会对应增加持仓成本。</p><p>针对这两个话题，此篇做进一步讨论。</p><a id="more"></a><h2 id="期权的价格"><a href="#期权的价格" class="headerlink" title="期权的价格"></a>期权的价格</h2><p>要讨论期权的价格，就要搞清楚期权的本质究竟是什么。</p><p>可能你已经买过期权，或者打算买期权。那么，既然又买，就一定有卖。你有没有考虑过，究竟是谁在卖给你呢？以及，卖给你期权的人，究竟和你做了怎样一笔交易？</p><p>我们拿买权来说。假定你以 5 元的价格，购买了一份 3 个月后行权的看涨期权。期权的行权价是 100 元。显然，你之所以买这一期权，是有一定把握认为对应标的物的价格，在 3 个月后（内）会上涨超过 105 元（break-even price）。因为如此，你买入的看涨期权才会为你带来收益。相对应的，卖给你期权的那个人（虽然你不知道是谁），肯定认为 3 个月后（内），标的物的价格不会超过 100 元。因为这样一来，它就能稳赚这 5 元的期权权利金。</p><p>从这里出发，不难看出：期权的买卖双方，实际是在通过自己的认知，对标的物未来的价格进行判断，而后以期权合约做做媒介进行赌博。也就是说，期权实际是一种对赌。</p><p>既然是对赌，就涉及到概率（赌徒获胜的概率）和赔率（赌徒获胜的收益）。显然，赌徒获胜的概率越高，庄家设定的赔率就会越低。若不然，庄家肯定亏死了。在期权的语境里，期权的买方是赌徒，卖方是庄家。因此，对于买方来说，越容易赚钱的期权，其价格就越高。</p><p>因此，其他条件不变的情况下，不难有分析：</p><p>对于买权（call option）</p><ul><li>行权价格越高，正股价格上涨超过行权价的可能性越小，因此买权价格越低；——买权的内涵价值随行权价上升而减小</li><li>截止日期越近，正股价格上涨超过某个行权价需要的日均涨幅越大，因而可能性越小，因此买权价格越低；——期权的时间价值随到期日临近而衰减</li><li>标的物（预期）波动越大，正股价格上涨超过某个行权价格（哪怕只是一瞬间）的可能性越大，因而买权价格越高。</li></ul><p>对于卖权（put option）</p><ul><li>行权价格越高，正股价格下跌低于行权价的可能性越大，因此买权价格越高；——卖权的内涵价值随行权价上升而上升</li><li>截止日期越近，正股价格下跌低于某个行权价需要的日均跌幅越大，因而可能性越小，因此买权价格越低；——期权的时间价值随到期日临近而衰减</li><li>标的物（预期）波动越大，正股价格下跌低于某个行权价格（哪怕只是一瞬间）的可能性越大，因而买权价格越高。</li></ul><h2 id="领口策略（the-Collar-Strategy）"><a href="#领口策略（the-Collar-Strategy）" class="headerlink" title="领口策略（the Collar Strategy）"></a>领口策略（the Collar Strategy）</h2><p>市场行情不确定性高时，买股票是会有很大风险的。合理地利用期权，可以有效地对冲风险。当然，对冲风险的同时，不可避免地会让收益也有所缩减。这是因为，购买看跌期权以锁定亏损上限是有成本的。将标的物（比如正股）和期权看做一个整体时，计算收益时，应当把购买看跌期权的成本计算在内。比如你以 100 元的价格购入 1 股正股，然后以 2 元的价格购入行权价为 95 元的看跌期权。此时，你锁定了亏损上限，但同时拉高了持仓成本。此时你的持仓成本是买入股价与期权价格之和，即 102 元。</p><p>为了抵消因购入看跌期权带来的成本上升，很自然地，我们会想：要不我们卖点期权出去？显然，如果同样是卖出看跌期权是没意义的，所以，我们考虑卖出看涨期权。亦即，我们在买入正股的同时，买入一份虚值看跌期权（行权价比现价低的看跌期权），卖出一份虚值看涨期权（行权价比现价高的看涨期权）。其中看跌期权用来保护股价下跌，看涨期权则用来低消对冲成本。这种运用期权的策略，就是领口策略。</p><p>领口策略如何运用呢？我们来看一个例子：</p><blockquote><p>假定现在 01/01 正股价格是 100 元。此时，买入正股 1 股；卖出行权价 105 的 call（04/01），收入 20 元；买入行权价 95 的 put（04/01），成本 17.5 元。这样一来，实际成本 97.5 元（100 - 20 + 17.5）。</p><p>04/01，期权到期。</p><ul><li>若正股价格大于 105，卖出的 call 被行权，收入 105 元。净赚 7.5 元。</li><li>若正股价格小于 95，对买入的 put 行权，收入 95 元。净亏 2.5 元。</li><li>若正股价格位于 95 和 105 之间，期权失效，但持仓成本被策略从 100 拉低到 97.5 元，纸面收益（paper profit）是当前股价与 97.5 元之间的差值。</li></ul></blockquote><p>在这样的场景当中，如果正股价格疯涨，那么由于卖出的看涨期权被对家行权，相当于放弃了正股价格在 105 元之上的收益；如果正股价格暴跌，你可以选择行权买入的看跌期权，锁住最大亏损。因此，领口策略最适用的场景是：</p><ul><li>操作人<strong>不追求暴涨带来的超额收益</strong>（因为超额收益被 call option 截去）；</li><li>操作人<strong>长期看好标的价格上涨</strong>（因为如果标的物价格持续下跌，持续触发 put option，终将产生可观亏损）。</li></ul><p>因此，在上例中，若你是操作人，且依然长期看好标的物，那么你应该：</p><ul><li>如果期权被行权，你的正股被卖出，你应该重新建仓并建立领口策略；</li><li>如果期权没有被行权，你应该围绕最新的价格，继续建立领口策略。</li></ul><p>这样往复操作下去，如果通过合理的操作，最终将综合成本降低到看跌期权的行权价之下；那么，实际上在期权到期之前，策略就是稳赚不赔的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://liam.page/2019/11/24/option-and-hedge/&quot;&gt;前作&lt;/a&gt;简单讨论了期权，也提及了卖权价格变化的影响因素。不过，对于这些影响因素背后的原理并未深究。&lt;/p&gt;
&lt;p&gt;此外，我们已经知道，合理利用期权可以对冲股票价格下跌的风险。但简单地买入卖权（long put options），也会对应增加持仓成本。&lt;/p&gt;
&lt;p&gt;针对这两个话题，此篇做进一步讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Collar Strategy" scheme="https://liam.page/tags/Collar-Strategy/"/>
    
  </entry>
  
  <entry>
    <title>Dalio 经济学 ②：中央银行与货币政策</title>
    <link href="https://liam.page/2021/02/24/central-bank-and-monetary-policy/"/>
    <id>https://liam.page/2021/02/24/central-bank-and-monetary-policy/</id>
    <published>2021-02-24T15:18:10.000Z</published>
    <updated>2021-02-24T15:20:57.030Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Dalio 经济学的第二篇，我们来谈一谈中央银行和货币政策。</p><a id="more"></a><h2 id="中央银行"><a href="#中央银行" class="headerlink" title="中央银行"></a>中央银行</h2><p>在介绍中央银行之前，我们可以先复习一下各个主要经济体的中央银行。</p><ul><li>中国：中国人民银行<ul><li>香港：香港金融管理局</li><li>澳门：澳门金融管理局</li><li>台湾：中华民国中央银行</li></ul></li><li>美国：美国联邦储备系统（美联储）</li><li>欧元区：欧洲中央银行<ul><li>德国：德意志联邦银行</li><li>法国：法兰西银行</li></ul></li><li>英国：英格兰银行</li></ul><p>如果对这些主要经济体的中央银行至少有些熟悉，那么便不难了解中央银行的主要职责，即制定和执行货币政策：</p><ul><li>（直接或间接）负责发行经济体中流通的法定货币；</li><li>（直接或间接）调节经济体中的利率；</li><li>（直接或间接）控制汇率。</li></ul><p>那么央行是怎样做到这些的呢？这就涉及到央行的资产负债表。</p><h2 id="央行的资产与负债"><a href="#央行的资产与负债" class="headerlink" title="央行的资产与负债"></a>央行的资产与负债</h2><h3 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h3><p>央行的资产大约有以下种类：</p><ul><li>货币储备<ul><li>黄金</li><li>外汇</li></ul></li><li>对商业银行的债权（应收款项）</li><li>对公共财政的债权（购买国债、地方债）</li><li>其他资产（如有价证券）</li></ul><p>央行的负债大约有以下种类：</p><ul><li>流通中的现金</li><li>外国机构存款</li><li>商业银行转账账户存款（包含，比如说，最低准备金）</li><li>国家存款</li><li>其他负债</li></ul><p>这里有一个很有意思的点，即流通中的货币现金是发行该种货币的央行的负债。这是因为，货币实际上是发行者给出的一种承诺：你可以持有货币，到我这里兑换点什么东西出去（通常是货币储备之类的其他等价物，例如黄金）。于是，在这个意义上，持有货币的人，就是对应央行的债权人。</p><h3 id="超发货币"><a href="#超发货币" class="headerlink" title="超发货币"></a>超发货币</h3><p>货币是央行发行的，并且央行「承诺」货币可以兑换某些东西。于是就引出一个相当自然的问题：但如果央行超发货币（发行货币的量，超过实际可以兑换东西的量），会发生什么呢？</p><p>这里首先就要注意，并非所有货币，都是对应央行的负债。只有流通的那部分，才是央行的负债。如果央行印了很多钞票，但是没有投入市场。那么就没人能用这部分货币到央行处兑换些什么。于是这些未流通的货币，显然不是央行的负债。</p><p>那么，央行发行的货币，要怎样投入市场呢？答案是信贷。注意此时的央行和<a href="/2021/02/20/expenditure-receipt-credit/">前作</a>当中提到的那些「有很多自己暂时用不到的钱的贷款人」没什么两样。于是，央行可以贷款给中央政府或者商业银行，或者说央行可以购买中央政府的债务（即国债）或者商业银行的债务（或者有价证券），将货币经由财政或是商业银行经过进一步的投资或是信贷，投入流通市场。在这个过程中，央行的资产负债表的两端，分别增加了资产（某种债务/有价证券）和负债（流通中的现金）。显然，央行的资产负债表变得更长了。因此，我们将这个过程称为<strong>扩表</strong>或者是<strong>债务货币化</strong>。</p><p>至此，央行超发的货币就进入了流通市场。这是<strong>突然发生</strong>的，相对而言，市场能提供的的商品、服务、金融资产的数量，并没有变多。因此，一定有什么东西会涨价。具体而言，超发的货币流向哪里，哪里就会涨价。比如，流向房地产市场（通过给房企、购房者贷款），那么房地产市场就会火爆；流向证券市场（通过融资，比如说），股市就会大涨；流向实体经济，假定实体经济并没有相应增长的情况下，商品和服务的价格就会上升，也就是形成通货膨胀。</p><h3 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h3><p>由于央行可以购买商业银行的债券（以贷款给商业银行），所以央行可能成为信贷链条的最终购买者。于是，央行贷款给商业银行的利率（即贴现率），会成为制约下游所有信贷利率的下限利率。——如果低于这个下限利率，债权人就要亏钱（这还没有考虑通胀）。有鉴于此，央行能够轻易地控制某些短期利率，从而影响股市、债券市场、房地产和其他利率。</p><h3 id="汇率"><a href="#汇率" class="headerlink" title="汇率"></a>汇率</h3><p>当央行大量印钞而后扩表时，大量相应货币被投入市场，于是商品、服务、金融资产的价格被推高。站在货币以及以该种货币计价的债券的持有者看来，货币的购买力降低，可能贬值。货币的持有者关心的是货币购买力在将来的变化。通货膨胀以及汇率下跌会导致货币购买力下降。反过来，以该种货币计价的债务利率的上升，则会提升货币购买力。为了保值（保护购买力），人们会倾向于将货币（称为本币）兑换成没有超发的外币。当这种倾向形成规模，</p><ul><li>在外汇市场上出现大量卖出本币的现象，于是本币容易出现贬值；</li><li>央行为了保卫汇率，可能消耗外汇储备（央行自身的资产）购入本币（央行自身的负债），导致外汇储备下降。</li></ul><p>这二者反过来，又会加剧人们兑换外币的倾向。于是形成不断自我加强的循环，导致本币贬值。因此我们说，<strong>在其它条件不变的情况下，央行大量印钞将拉低汇率</strong>。</p><h2 id="货币政策"><a href="#货币政策" class="headerlink" title="货币政策"></a>货币政策</h2><p>央行宽松的货币政策（扩表、降息）会直接导致两方面：</p><ul><li>有些人（贷款人）手里闲钱变多；</li><li>有些人（借款人）负债成本下降。</li></ul><p>于是，市场中倾向于产生更多的信贷。这些信贷会推升金融资产的价格，从而使借款人的信用资质看上去变得更好，从而更容易获得贷款。于是形成不断自我加强的循环，使得信贷变得越来越多。</p><p>央行不希望这种现象发生。因为没有生产力提升做背书时，金融资产价格的不断攀升是不可持续的，泡沫终将破裂。未免与此，在到了一定程度时，央行会缩紧自身货币政策。</p><p>央行紧缩的货币政策（加息），将降低新的信贷的产生，因为资产价格下降而借款人信誉变差，并且负债成本上升。于是形成不断自我加强的循环，使得信贷变得越来越少。</p><p>因为信贷自身的周期性，央行必须周期性地调整货币政策，控制社会上的信贷总量。于此，我们又见到了<strong>周期</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Dalio 经济学的第二篇，我们来谈一谈中央银行和货币政策。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Dalio" scheme="https://liam.page/tags/Dalio/"/>
    
      <category term="Cycle" scheme="https://liam.page/tags/Cycle/"/>
    
      <category term="Central Bank" scheme="https://liam.page/tags/Central-Bank/"/>
    
      <category term="Monetary Policy" scheme="https://liam.page/tags/Monetary-Policy/"/>
    
      <category term="Interest Rate" scheme="https://liam.page/tags/Interest-Rate/"/>
    
      <category term="Exchange Rate" scheme="https://liam.page/tags/Exchange-Rate/"/>
    
  </entry>
  
  <entry>
    <title>Dalio 经济学 ①：支出、收入和信贷</title>
    <link href="https://liam.page/2021/02/20/expenditure-receipt-credit/"/>
    <id>https://liam.page/2021/02/20/expenditure-receipt-credit/</id>
    <published>2021-02-20T15:22:25.000Z</published>
    <updated>2021-02-21T09:05:00.063Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新的系列，讨论桥水基金创始人 Ray Dalio 的经济学理论。这些内容是我在读 Dalio 的书《A Template for Understanding BIG DEBT CRISES》之后，结合书中内容和自我思考总结出来的内容。</p><a id="more"></a><h2 id="支出和收入"><a href="#支出和收入" class="headerlink" title="支出和收入"></a>支出和收入</h2><p>整个经济是由无数的交易组成的。</p><p>交易涉及到的双方，一方支出购买力，收获标的物；另一方付出标的物，收获另一方支出的购买力。因此我们可以得到几个简单的结论：</p><ul><li>一个人的支出是另一个人的收入。</li><li>如果经济体中，大多数人减少支出，那么整体的收入就会减少，从而<ul><li>降低大家的生产积极性，导致通缩预期。</li></ul></li><li>如果经济体中，大多数人增加支出，那么整体的收入就会增加。</li></ul><p>交易涉及到的标的物分成三类：1. 商品，2. 服务，3. 金融资产。考虑到持有金融资产的人，是在将来能够变现，化为购买力；因此，金融资产的本质是将来的购买力。</p><p>在交易中，标的物的另一面，是起到交易媒介作用的货币或者信贷。货币很好理解，于是重点在信贷。</p><h2 id="信贷"><a href="#信贷" class="headerlink" title="信贷"></a>信贷</h2><p>信贷的双方，贷款人评估借款人的信用，使用自己暂时用不到的钱，购买债务资产，以期将来能获得利息收入；借款人凭借自己的信用，以将来提供利息汇报的代价，「购买」贷款人现金当下的使用权。</p><p>从贷款人的角度，他将自己暂时不用的钱借出，得到了将来的回报。如果相应货币发生通胀，那么将来的回报在购买力上会贬值，贷款人就会承受损失。不过，利息收入能对这种损失进行对冲。只要利息收入足够大，因通胀带来的损失就能被弥补。</p><p>从借款人的角度，他用未来的收入「购买」现金当下的使用权。这种行为看似是向他人借钱，实际是对自己的未来有良好预期，向未来的自己借钱。</p><p>如果借款人将通过信贷得来的现金用于扩大再生产，提高自己的生产效率，那么借款人将来能获得更多的收入。另一方面，贷款人也能确信在将来能够收回贷款。这种情况下，本不会流通的钱（贷款人暂时不用的钱）进入市场流通，并扩大了经济体总的生产力。于是，这是一件好事——贷款人、借款人、经济体加在一起赢了三次。</p><p>如果借款人将通过信贷得来的先进用于购买商品或服务；由于一个人的支出是另一个人的收入，提供商品或服务的人得到更多的收入，可用于扩大再生产，提高经济体总的生产力。只要借款人将来能够偿还债务，那么，这也是一件好事。从经济利益的角度来说，贷款人、经济体加在一起赢了两次；借款人获得商品或服务，也有所收获。</p><p>糟糕的情况在于，如果借款人没有将借贷得到的现金直接或间接地投入扩大再生产，且最终无力偿还债务，那就成了「全输」的局面。当这种问题大量发生，就会形成债务危机。</p><h2 id="信贷天然产生周期"><a href="#信贷天然产生周期" class="headerlink" title="信贷天然产生周期"></a>信贷天然产生周期</h2><p>从借款人的角度来说，在信贷凭空产生的那一瞬间，借款人获得了在当前时间超出自身收入水平的消费能力。但也意味着，在未来的一段时间，借款人必须控制自己的消费水平低于收入水平，以便偿还债务。因为借贷，借款人的消费能力的起伏，自然就构成了一个周期。</p><p>将经济体中所有的借款人当做一个整体，那么，在周期的早些阶段，大家的购买力都很强，于是：</p><ul><li>一个人的支出是另一个人的收入，商品的生产者和服务的提供者的收入增加，倾向于扩大再生产；</li><li>相对有限的金融资产涌入相对更多的资金（其实很大程度是信贷），金融资产价格被推高；</li><li>上述过程让借款人的「信用水平」提升，于是能借到更多的资金，也倾向于接入更多的资金，形成自我增强的正循环。</li></ul><p>但若没有生产力水平的提升，这种正循环是不可持续的。随着债务陆续到期、偿债负担日益增加，整个经济体必然进入周期的后半阶段。在周期的后半阶段，大家的购买力都减弱，于是：</p><ul><li>一个人的支出是另一个人的收入，商品的生产者和服务的提供者的收入减少，倾向于减少生产；</li><li>人们倾向于卖出金融资产，获得现金以偿债，这使得金融资产价格被拉低；</li><li>上述过程让借款人的「信用水平」降低，于是愈发难以接到足够资金，购买力水平进一步下降，形成自我增强的负循环。</li></ul><p>周期的前半部分和后半部分，都会形成自我加强的循环。若不加以控制，最终必然导致债务危机。央行和中央政府的责任之一，就是要运用自身的货币政策和财政政策，使得经济体总体的债务水平增长的幅度，不会显著偏离整体生产力水平的提升幅度。</p><p>这就引出了央行和中央政府的调控政策相关问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个新的系列，讨论桥水基金创始人 Ray Dalio 的经济学理论。这些内容是我在读 Dalio 的书《A Template for Understanding BIG DEBT CRISES》之后，结合书中内容和自我思考总结出来的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Dalio" scheme="https://liam.page/tags/Dalio/"/>
    
      <category term="Expenditure" scheme="https://liam.page/tags/Expenditure/"/>
    
      <category term="Receipt" scheme="https://liam.page/tags/Receipt/"/>
    
      <category term="Credit" scheme="https://liam.page/tags/Credit/"/>
    
      <category term="Cycle" scheme="https://liam.page/tags/Cycle/"/>
    
  </entry>
  
  <entry>
    <title>设计一个线程安全的数据重载器</title>
    <link href="https://liam.page/2021/01/03/design-a-thread-safe-data-reloader-in-cxx/"/>
    <id>https://liam.page/2021/01/03/design-a-thread-safe-data-reloader-in-cxx/</id>
    <published>2021-01-03T01:35:49.000Z</published>
    <updated>2021-04-22T14:22:45.562Z</updated>
    
    <content type="html"><![CDATA[<p>实际工程中，可能会遇见这样的场景：</p><p>一个词典，在 C++ 里实现为一个 <code>class</code>。它的生命周期从进程启动开始到进程杀死结束。这个词典很大，所以在多线程工作的时候，希望在全局共享一份。</p><p>现在的问题是，进程可能持续跑很长时间，比如跑几个月。在进程执行过程中，这个词典可能会更新。于是我需要重新载入词典。要求线程安全并且高效地做这个重新载入的工作。</p><p>今天我们来设计一下，要怎样实现它。</p><a id="more"></a><h2 id="初步讨论"><a href="#初步讨论" class="headerlink" title="初步讨论"></a>初步讨论</h2><p>比较显然的是，这一功能将代码分成了相对独立的两个部分：词典和重载器。词典负责数据的管理，并提供数据查询的功能。重载器负责按照一定规则，触发重载动作，以及负责提供安全的词典访问机制。</p><p>为通用计，我们希望重载器能够管理多种不同的词典。这些词典可能管理不同的数据类型、格式，也可能提供不同的访问接口。就后者而言，这意味着不同词典类可能提供了不同的查询函数签名。</p><p>为解决这个问题，考虑到重载器只需负责触发重载动作，而不需关心查询接口，在 C++ 里大体有两种比较成熟的思路：</p><ul><li>实现一个基类，其名为 <code>Reloadable</code>，并定义一个名为 <code>load</code> 的纯虚函数作为接口。所有词典继承 <code>Reloadable</code>，并实现该接口，而后作为模板类 <code>Reloader</code> 的模板参数，传递给重载器，重载器调用 <code>load</code> 接口。</li><li>无需基类，将词典类多种多样的读取接口，封装成各自的可调用对象（利用 <code>std::bind</code> 之类的工具），而后作为回调函数传递给 <code>Reloader</code>。</li></ul><p>前一种方式是面向对象和模板思路，后一种方式是函数式的思路。两种方式的共同特点，是都可以在少量修改的情况下，应用于已有的词典类。相较而言，后一种方式完全不用修改已有的词典类本身，提供了更大的自由度。</p><p>但在工程中，这种自由度累积起来，往往会泛滥成灾。因此我个人更倾向于使用第一个方案。</p><p>至此，我们需要设计一个 <code>Reloadable</code> 和一个 <code>Reloader</code> 类，来实现这个需求。</p><h2 id="Reloadable"><a href="#Reloadable" class="headerlink" title="Reloadable"></a><code>Reloadable</code></h2><p>按讨论，<code>Reloadable</code> 应该是一个虚基类，其有一个名为 <code>load</code> 的纯虚函数作为接口，负责读入数据。我们将其定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reloadable</span> &#123;</span></span><br><span class="line">  Reloadable() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~Reloadable() = <span class="keyword">default</span>;  <span class="comment">// 1.</span></span><br><span class="line"></span><br><span class="line">  Reloadable(<span class="keyword">const</span> Reloadable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.a.</span></span><br><span class="line">  Reloadable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Reloadable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.b.</span></span><br><span class="line"></span><br><span class="line">  Reloadable(Reloadable&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 3.a.</span></span><br><span class="line">  Reloadable&amp; <span class="keyword">operator</span>=(Reloadable&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 3.b.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>= <span class="number">0</span>;  <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li>我们将析构函数声明为 <code>virtual</code>，是因为显然 <code>Reloadable</code> 会是一个基类。为避免子类析构不完全造成内存泄露，我们都需要将基类的析构函数声明为虚函数。</li><li>由于词典数据往往很大，而又在多线程中共享。那么显然对数据的拷贝是不必要的。于是我们将拷贝构造和拷贝赋值都声明为 <code>delete</code>。</li><li>与 (2) 对应，移动操作是允许的。</li><li>我们将 <code>load</code> 接口声明为纯虚的，它留待子类实现。入参 <code>path</code> 是一个字符串，它通常会是一个路径，指向数据本身，或是词典的配置文件。</li></ol><h2 id="Reloader"><a href="#Reloader" class="headerlink" title="Reloader"></a><code>Reloader</code></h2><p>按讨论，<code>Reloader</code> 应该是一个虚基类模板。它有一个模板参数 <code>Payload</code>，是 <code>Reloadable</code> 的子类。而后提供几个关键接口：</p><ul><li><code>init</code>：负责初始化重载器。由于重载器会在多线程共享，所以初始化应该只执行一次。</li><li><code>inited</code>：负责观察重载器是否已初始化成功。</li><li><code>get</code>：负责返回 <code>Payload</code>，供外部使用。</li><li><code>terminate</code>：负责终止重载器，通常在进程终止时调用它。</li></ul><p>于是我们可以设计 <code>Reloader</code> 的大体框架。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload,</span><br><span class="line">          <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_base_of&lt;Reloadable, Payload&gt;::value, <span class="keyword">bool</span>&gt; = <span class="literal">true</span>&gt;  <span class="comment">// 4.</span></span><br><span class="line">class Reloader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">payload_t</span> = Payload;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">ptr_t</span> = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">payload_t</span>&gt;;  <span class="comment">// 1.a.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Reloader() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~Reloader() = <span class="keyword">default</span>;  <span class="comment">// 2.a.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Reloader(<span class="keyword">const</span> Reloader&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.b.</span></span><br><span class="line">  Reloader&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Reloader&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.c.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 3.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// observers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ptr_t</span> get() <span class="keyword">const</span>;  <span class="comment">// 1.b.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li><code>get</code> 接口的返回类型是 <code>Payload</code> 的智能指针。此处用智能指针，有两个考虑。一是避免值语义，使用引用语义。这样避免了数据的拷贝（实际上 <code>Payload</code> 已经禁止了拷贝，想用值语义必然报错）。二是管理 <code>Payload</code> 的生命周期，避免使用裸指针时，外部通过 <code>get</code> 拿到数据，却为 <code>reload</code> 析构，造成野指针。</li><li>基于类似的理由，我们将 <code>Reloader</code> 的析构函数声明为 <code>virtual</code>，将拷贝动作声明为 <code>delete</code>。</li><li>和 <code>init</code> 不同，<code>terminate</code> 接口被声明为纯虚。这是因为，适应不同的重载方式，其 <code>init</code> 都承担了相同的指责：第一次载入数据；而 <code>terminate</code> 则依据重载方式会有不同的写法。</li><li>这里 <code>std::enable_if_t</code>，强制保证了模板参数 <code>Payload</code> 是 <code>Reloadable</code>。这保证了 <code>Payload</code> 一定有符合规范的 <code>load</code> 接口。</li></ol><h3 id="inited"><a href="#inited" class="headerlink" title="inited"></a><code>inited</code></h3><p>我们首先考虑观察器 <code>inited</code>。重载器是否初始化，这个状态对于外部，有三种：</p><ul><li>未初始化</li><li>初始化中</li><li>已初始化</li></ul><p>当然，可能还有第四种：初始化失败。我们可将其归结于「未初始化」当中。</p><p>虽有三种状态，但对于外部来说，有意义的只有「是/否」。于是，我们可用一原子变量，来维护初始化状态。于是我们有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reloader</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> inited_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// observers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inited_.load();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><p>显然，<code>Reloader</code> 应该有一个成员，保存着由其管理的数据的智能指针。当外部调用 <code>get</code> 接口时，我们根据初始化状态，来判断如何返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reloader</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mtx_;  <span class="comment">// 1.a.</span></span><br><span class="line">  <span class="keyword">ptr_t</span> payload_;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// observers</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">ptr_t</span> get() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inited()) &#123;  <span class="comment">// 2.</span></span><br><span class="line">      <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lk(mtx_);  <span class="comment">// 1.b.</span></span><br><span class="line">      <span class="keyword">return</span> payload_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li>我们用一个读写锁（共享互斥量）来保护智能指针 <code>payload_</code>。这是因为，虽然 <code>std::shared_ptr</code> 当中的引用计数是原子的，但是 <code>std::shared_ptr</code> 本身并无线程安全保证。考虑到我们可能在多线程中同时读写 <code>payload_</code>，因此必须要加锁。此处细节，可参考<a href="https://blog.csdn.net/Solstice/article/details/8547547" target="_blank" rel="noopener">陈硕的雄文</a>。</li><li>这里是对 <code>Reloader</code> 状态的判断。若未初始化，则返回空指针。</li></ol><h3 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h3><p>有了这些铺垫，我们可以来实现修改器 <code>init</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reloader</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::once_flag init_flag_;  <span class="comment">// 1.a.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> path_;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(init_flag_, [&amp;]() -&gt; <span class="keyword">void</span> &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;path(path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (reload()) &#123;  <span class="comment">// 2.a.</span></span><br><span class="line">        launch();  <span class="comment">// 3.a.</span></span><br><span class="line">        inited_.store(<span class="literal">true</span>);  <span class="comment">//4.a.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> inited();  <span class="comment">// 4.b.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:  <span class="comment">// modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;  <span class="comment">// 2.b.</span></span><br><span class="line">    <span class="keyword">ptr_t</span> tmp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">payload_t</span>&gt;();  <span class="comment">// 5.a.</span></span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;load(path_)) &#123;  <span class="comment">// 5.b.</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;shared_mutex&gt; lk(mtx_);  <span class="comment">// 6.</span></span><br><span class="line">        payload_.swap(tmp);  <span class="comment">// 7.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    path_ = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 3.b.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li>为保证 <code>init</code> 只执行一次，我们使用 C++ 标准中提供的 <code>std::once_flag</code> 和 <code>std::call_once</code>。</li><li><code>reload</code> 接口如其名，每次重载器触发重载动作时，都应调用它。<code>init</code> 实际是第一次重载，当然也会调用它。</li><li><code>launch</code> 是一个纯虚函数，它由子类模板实现。<code>launch</code> 负责初始化重载器的一些细节工作，以便在进程声明周期中循环/监视文件变动，触发重载。</li><li>维护 <code>inited_</code> 原子变量，与 <code>inited</code> 接口遥相呼应。</li><li>重载时，为避免影响正在对外提供服务的 <code>payload_</code> 指针，我们通过临时指针来载入数据。</li><li>若临时指针载入数据成功，我们在读写锁（共享互斥量）的「写入状态」的保护下，更新 <code>payload_</code> 的值。</li><li>这里使用 <code>payload_.swap(tmp)</code> 而非 <code>payload_ = std::move(tmp)</code> 的原因在于，后者会导致立即析构 <code>payload_</code> 先前指向的对象。考虑到此时尚在写入锁保护下，而析构词典对象可能非常耗时，这种做法是不明智的。使用 <code>swap</code> 延迟析构旧对象（在 <code>return</code> 处，析构 <code>tmp</code> 时），是更好的选择。</li></ol><p>至此，<code>Reloader</code> 的主要接口，我们就已实现完备。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在现有的 <code>Reloadable</code> 和 <code>Reloader</code> 的基础上，我们可借助<a href="/2020/10/14/implement-a-timed-looper-in-cxx/">前文提到的时间循环器</a>来实现一个基于倒计时轮询的重载器；又可借助<a href="/2020/10/27/implement-a-singleton-class-template-in-cxx/">前文提到的单例模式</a>，让重载器于多线程共享。另附一个<a href="https://github.com/Liam0205/data-reloader" target="_blank" rel="noopener">仓库</a>，供来者学习参考。</p><h2 id="对不同意见的回复"><a href="#对不同意见的回复" class="headerlink" title="对不同意见的回复"></a>对不同意见的回复</h2><p>文章出来已经收到了一些反对意见。此处做一些回复。</p><h3 id="Reloadable-不是必须的，只需实现相同的接口即可。"><a href="#Reloadable-不是必须的，只需实现相同的接口即可。" class="headerlink" title="Reloadable 不是必须的，只需实现相同的接口即可。"></a><code>Reloadable</code> 不是必须的，只需实现相同的接口即可。</h3><p>诚然，若能保证所有用到 <code>Reloader</code> 的类，都实现了相同的接口，那么 <code>Reloadable</code> 及对应的 <code>std::enable_if_t</code> 可以去掉。但在实际工程中，这是一个相当高的要求，通常很难达到。这是因为，很可能在实现 <code>Reloader</code> 类模板时，代码库当中已有不少词典、模型类。这些 legacy codes 可能并不遵循现下定义的标准接口。若要使它们为 <code>Reloader</code> 所管理，则需要细致地修改，而后祈祷编译不出错。而若是使它们继承 <code>Reloadable</code>，则编译器会告诉你哪些词典/模型类还未正确修改。——编译器要么提示你，尚有纯虚函数未实现而无法实例化；要么提醒你 <code>Reloader</code> 的 <code>Payload</code> 类并非由 <code>Reloadable</code> 派生而得。</p><p>退一步说，即使能够通过口头/文档约束，达到接口统一的要求；那么，既然你已经在代码上约束大家实现 <code>load</code> 接口了，那么交给编译器去用 <code>std::enable_if_t</code> 做一次校验岂非更好？</p><p>因此，我们倾向于保留 <code>Reloadable</code> 及相应的 <code>std::enable_if_t</code> 之设计。</p><h3 id="在-Reloader-类当中，实现一个-lookup-接口，避免通过-get-接口返回词典类，是否更好？"><a href="#在-Reloader-类当中，实现一个-lookup-接口，避免通过-get-接口返回词典类，是否更好？" class="headerlink" title="在 Reloader 类当中，实现一个 lookup 接口，避免通过 get 接口返回词典类，是否更好？"></a>在 <code>Reloader</code> 类当中，实现一个 <code>lookup</code> 接口，避免通过 <code>get</code> 接口返回词典类，是否更好？</h3><p>若能约束所有词典类，都有一个统一的 <code>lookup</code> 接口，那这样做自然可以。但 <code>Reloader</code> 并非单纯针对词典类设计，例如带有 <code>predict</code> 接口的模型类，也能为 <code>Reloader</code> 所管理。讲到底，<code>Reloader</code> 只是为管理进程运行时可能需要重载的资源而设计的，对于资源是什么，<code>Reloader</code> 本身并不关心。</p><p>即便 <code>Reloader</code> 仅仅只为词典设计，这样封装接口也有至少三个劣势。</p><ul><li>基于与前一问题类似的理由，对于 legacy codes 的修改，会比较麻烦。</li><li>过早地约束了词典可用的接口，而忽略了词典的多样性。于是在将来的使用中，新的词典（比如涉及到二段查询的词典）可能无法轻易套用 <code>Reloader</code>。</li><li>在单次请求中，我们希望对词典的多次查询的结果稳定。但在 <code>Reloader&lt;Payload&gt;::lookup()</code> 当中，我们无法保证这一点。因为在单次请求过程中，可能触发了 <code>reload</code> 动作，于是相邻两次查询时，词典内容可能已经发生变化，造成对业务不可知的影响。</li></ul><p>反过来讲，通过对内部智能指针加锁，返回只能指针的拷贝，则基本避免了这种影响。</p><ul><li>legacy codes 只需 <code>sed</code> 替换即可。</li><li>不约束词典可用接口。</li><li>通过拷贝传递出去的智能指针，hook 住词典内容；即便在使用过程中触发 <code>reload</code> 动作，词典内容也不会提前析构，保证结果统一性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际工程中，可能会遇见这样的场景：&lt;/p&gt;
&lt;p&gt;一个词典，在 C++ 里实现为一个 &lt;code&gt;class&lt;/code&gt;。它的生命周期从进程启动开始到进程杀死结束。这个词典很大，所以在多线程工作的时候，希望在全局共享一份。&lt;/p&gt;
&lt;p&gt;现在的问题是，进程可能持续跑很长时间，比如跑几个月。在进程执行过程中，这个词典可能会更新。于是我需要重新载入词典。要求线程安全并且高效地做这个重新载入的工作。&lt;/p&gt;
&lt;p&gt;今天我们来设计一下，要怎样实现它。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Thread" scheme="https://liam.page/tags/Thread/"/>
    
      <category term="Thread-safe" scheme="https://liam.page/tags/Thread-safe/"/>
    
      <category term="Data" scheme="https://liam.page/tags/Data/"/>
    
      <category term="Dict" scheme="https://liam.page/tags/Dict/"/>
    
      <category term="Reloader" scheme="https://liam.page/tags/Reloader/"/>
    
  </entry>
  
  <entry>
    <title>让 Vim 在保存文件时自动格式化代码</title>
    <link href="https://liam.page/2020/11/04/Vim-auto-format-codes-on-save/"/>
    <id>https://liam.page/2020/11/04/Vim-auto-format-codes-on-save/</id>
    <published>2020-11-04T02:45:15.000Z</published>
    <updated>2021-01-02T07:32:18.202Z</updated>
    
    <content type="html"><![CDATA[<p>写代码时，遵循一定的代码风格是很有必要的。对于这种机械性的工作，我们的主张是要寻找自动化的解决方案。</p><p>对于 Vim 和 C++ 的组合，这里推荐以下搭配，并辅以适当配置：</p><ul><li><code>clang-format</code></li><li><a href="https://github.com/Chiel92/vim-autoformat" target="_blank" rel="noopener"><code>vim-autoformat</code> 插件</a></li></ul><a id="more"></a><p>配置分为两部分。一是实现在保存文件时自动格式化代码；二是实现在 visual 模式下格式化部分代码。</p><figure class="highlight vim"><figcaption><span>在保存文件时自动格式化代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">c</span>,cpp <span class="keyword">autocmd</span> BufWritePre * :Autoformat</span><br></pre></td></tr></table></figure><p>这里对 C 和 C++ 代码，在保存文件之前，自动执行 <code>:Autoformat</code>，以便使用 <code>vim-autoformat</code> 插件调用 <code>clang-format</code> 格式化代码。</p><figure class="highlight vim"><figcaption><span>在 visual 模式下格式化部分代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" autoformat</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>ff :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"file"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>ff :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"file"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>gf :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"Google"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>gf :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"Google"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cf</span> :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"Chromium"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cf</span> :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"Chromium"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">lf</span> :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"LLVM"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">lf</span> :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"LLVM"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line">func! FormatCode(exe_mode, style) <span class="built_in">range</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">a:exe_mode</span> == <span class="string">""</span></span><br><span class="line">    <span class="keyword">let</span> firstline_no = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> lastline_no = <span class="built_in">line</span>(<span class="string">"$"</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> firstline_no = <span class="variable">a:firstline</span></span><br><span class="line">    <span class="keyword">let</span> lastline_no = <span class="variable">a:lastline</span></span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">l:save_formatdef</span> = <span class="variable">g:formatdef_clangformat</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">l:tmpa</span> = <span class="keyword">join</span>([<span class="string">"clang-format --lines="</span>, firstline_no, <span class="string">":"</span>, lastline_no], <span class="string">""</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">g:formatdef_clangformat</span> = <span class="string">"'"</span> . <span class="variable">l:tmpa</span> . <span class="string">" --assume-filename=' . bufname('%') . ' -style="</span> . <span class="variable">a:style</span> . <span class="string">"'"</span></span><br><span class="line">  <span class="keyword">let</span> formatcommand = <span class="string">":Autoformat"</span></span><br><span class="line">  exec formatcommand</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">g:formatdef_clangformat</span> = <span class="variable">l:save_formatdef</span></span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure><p>这里利用 range 函数，根据调用时的所在的模式的不同，格式化整个文件，或者是在 Visual 模式下格式化选中的行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码时，遵循一定的代码风格是很有必要的。对于这种机械性的工作，我们的主张是要寻找自动化的解决方案。&lt;/p&gt;
&lt;p&gt;对于 Vim 和 C++ 的组合，这里推荐以下搭配，并辅以适当配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clang-format&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Chiel92/vim-autoformat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;vim-autoformat&lt;/code&gt; 插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Format" scheme="https://liam.page/tags/Format/"/>
    
      <category term="Vim" scheme="https://liam.page/tags/Vim/"/>
    
      <category term="Clang-format" scheme="https://liam.page/tags/Clang-format/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中实现一个单例类模板</title>
    <link href="https://liam.page/2020/10/27/implement-a-singleton-class-template-in-cxx/"/>
    <id>https://liam.page/2020/10/27/implement-a-singleton-class-template-in-cxx/</id>
    <published>2020-10-27T13:14:18.000Z</published>
    <updated>2020-10-27T14:08:32.815Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是最简单的设计模式之一。在实际工程中，如果一个类的对象重复持有资源的成本很高，且对外接口是线程安全的，我们往往倾向于将其以单例模式管理。</p><p>此篇我们在 C++ 中实现正确的单例模式。</p><a id="more"></a><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>在 C++ 中，单例模式有两种方案可选。</p><ul><li>一是实现一个没有可用的公开构造函数的基类，并提供 <code>GetInstance</code> 之类的静态接口，以便访问子类唯一的对象。由于子类构造必须调用基类构造，但基类无公开构造函数可用，这使得子类对象只能由基类及基类的友元来构造，从而在机制上保证单例。</li><li>二是实现一个类模板，其模板参数是希望由单例管理的类的名字，并提供 <code>GetInstance</code> 之类的静态接口。这种做法的好处是希望被单例管理的类，可以自由编写，而无需继承基类；并且在需要的时候，可以随时脱去单例外衣。</li></ul><p>此篇选择实现一个单例类模板，其形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里重载成员访问运算符，是为了可以实现这样的简写 <code>Singleton&lt;T&gt;()-&gt;func()</code>。</p><p>显然，单例的实现核心在于静态成员函数 <code>T* get()</code>。</p><h2 id="一个典型的错误实现"><a href="#一个典型的错误实现" class="headerlink" title="一个典型的错误实现"></a>一个典型的错误实现</h2><p>一个典型的错误实现，是使用所谓的双重检查（double check）。</p><figure class="highlight cpp"><figcaption><span>错误的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;mtx&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> T;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton&lt;T&gt;::mtx;</span><br></pre></td></tr></table></figure><p>外层的检查，是为了避免锁住过大的区域，从而导致锁的竞争特别频繁；内层的检查，是为了确保只在别的线程没有提前抢占锁完成初始化工作而设计的。这种做法在 Java 下是正确的，但是在 C++ 下则没有保证。具体解析可以参看<a href="/2017/01/17/layers-and-operation-system/#CPU-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6">这篇旧文</a>。</p><p>另外，值得一提的是，这里 <code>p</code> 的初始化的线程安全性，是由 C++ 标准保证的。——在 C++11 之后，标准保证函数静态成员的初始化是线程安全的；对其读写则不保证线程安全。</p><h2 id="使用标准库提供的设施"><a href="#使用标准库提供的设施" class="headerlink" title="使用标准库提供的设施"></a>使用标准库提供的设施</h2><p>在单例的实现中，我们实际上是希望实现「执行且只执行一次」的语义。C++11 之后，标准库实际已经提供了这样的设施。其名为 <code>std::once_flag</code> 和 <code>std::call_once</code>。它们内部利用互斥量和条件变量组合，实现这样的语义。值得一提的是，如果执行过程中抛出异常，标准库的设施不认为这是一次「成功的执行」。于是其他线程可以继续抢占锁来执行函数。</p><p>我们利用标准库设施来实现这个类模板。</p><figure class="highlight cpp"><figcaption><span>利用标准库设施的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">      p = <span class="keyword">new</span> T;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::once_flag Singleton&lt;T&gt;::flag;</span><br></pre></td></tr></table></figure><p>于是你可以写出类似这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;mtx&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">const_cast</span>&lt;Foo*&gt;(<span class="keyword">this</span>)) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Singleton&lt;Foo&gt;()-&gt;address();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt;&gt; futs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    futs.emplace_back(<span class="built_in">std</span>::async(&amp;Foo::address, Singleton&lt;Foo&gt;::get()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; fut : futs) &#123;</span><br><span class="line">    fut.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的输出类似这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br></pre></td></tr></table></figure><blockquote><p>Bonus：需要注意的是，所有的 <code>std::once_flag</code> 内部共享了同一对互斥量和条件变量。因此当存在很多 <code>std::call_once</code> 的时候，性能会有所下降。这一点可能需要注意一下。不过，如果存在很多 <code>std::call_once</code>，大概也说明程序设计不合理吧……</p></blockquote><blockquote><p>Bonus：注意我们这里没有释放 <code>p</code> 指向的对象。这是因为 C++ 程序对静态变量的析构顺序是不确定的。如果静态变量之间有相互依赖，析构被依赖的对象可能会导致段错误。因此干脆就不释放了，这是所谓的 <code>LeakySingleton</code>。当然，如果你的工程当中有实现一个通用的 <code>ExitManager</code>，是有可能正确析构的。但考虑到还可能大量使用第三方库，而第三方库不可能使用你实现的 <code>ExitManager</code>，于是管理所有静态变量的析构又变得不可能，于是干脆就不管它了。</p></blockquote><h2 id="如此如此，这般这般"><a href="#如此如此，这般这般" class="headerlink" title="如此如此，这般这般"></a>如此如此，这般这般</h2><p>如果你仔细读了这篇文章，你可能会忽然意识到刚才看到了这句话：「在 C++11 之后，标准保证函数静态成员的初始化是线程安全的；对其读写则不保证线程安全。」</p><p>既然如此，我们为啥还要费劲使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 呢？直接利用 <code>static</code> hack 出一个单例类模板不就好了吗？</p><figure class="highlight cpp"><figcaption><span>利用标准库设施的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T ins;</span><br><span class="line">    <span class="keyword">return</span> &amp;ins;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是最简单的设计模式之一。在实际工程中，如果一个类的对象重复持有资源的成本很高，且对外接口是线程安全的，我们往往倾向于将其以单例模式管理。&lt;/p&gt;
&lt;p&gt;此篇我们在 C++ 中实现正确的单例模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Mutex" scheme="https://liam.page/tags/Mutex/"/>
    
      <category term="Threading" scheme="https://liam.page/tags/Threading/"/>
    
      <category term="Singleton" scheme="https://liam.page/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中实现一个正确的时间循环器</title>
    <link href="https://liam.page/2020/10/14/implement-a-timed-looper-in-cxx/"/>
    <id>https://liam.page/2020/10/14/implement-a-timed-looper-in-cxx/</id>
    <published>2020-10-14T10:05:36.000Z</published>
    <updated>2020-10-27T13:14:49.582Z</updated>
    
    <content type="html"><![CDATA[<p>实际工程中可能会有这样一类普遍需求：在服务中，单独起一个线程，以一个固定的时间间隔，周期性地完成特定的任务。我们把这种问题抽象成一个时间循环器。</p><a id="more"></a><h2 id="Naive-Way"><a href="#Naive-Way" class="headerlink" title="Naive Way"></a>Naive Way</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerCircle</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> running_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="keyword">uint64_t</span>         sleep_&#123;<span class="number">0U</span>L&#125;;</span><br><span class="line">  <span class="built_in">std</span>::thread      thread_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit TimerCircle(uint64_t s) : sleep_&#123;s&#125; &#123;&#125;</span><br><span class="line">  ~TimerCircle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_.joinable()) &#123;</span><br><span class="line">      terminate();</span><br><span class="line">      thread_.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  TimerCircle(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_ = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(&amp;TimerCircle::loop, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    running_.store(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    running_.store(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">while</span> (running_.load()) &#123;</span><br><span class="line">      do_something();</span><br><span class="line">      <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(sleep_));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现简单平凡，一眼就能看出来没啥问题，于是也没啥好说的。</p><h2 id="细节里的魔鬼"><a href="#细节里的魔鬼" class="headerlink" title="细节里的魔鬼"></a>细节里的魔鬼</h2><p>唯一的魔鬼藏在细节里。如果 <code>TimerCircle</code> 类型的对象发生析构，那么析构该对象的线程最多会被阻塞 <code>sleep_</code> 秒。如果周期很长，比如长达 6 小时，那这显然是不可接受。</p><p>为此，我们需要借助标准库的<a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait_for" target="_blank" rel="noopener">条件变量 <code>std::condition_variable</code> 的 <code>wait_for</code> 函数</a>的帮助。首先看其函数签名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_for</span><span class="params">(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="function"><span class="params">              Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>函数接受三个参数。<code>lock</code> 是一个 <code>unique_lock</code>，它必须为调用 <code>wait_for</code> 的线程所锁住；<code>rel_time</code> 是一个时间段，表示超时时间；<code>pred</code> 是一个谓词，它要么返回 <code>true</code> 要么返回 <code>false</code>。</p><p>一旦调用，函数会阻塞当前线程，直到两种情况返回：</p><ul><li>超时；此时函数返回 <code>pred()</code>。</li><li>条件变量被通知，且谓词返回 <code>true</code>；此时函数返回 <code>true</code>。</li></ul><p>于是我们可以实现一个 <code>Countdown</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> <span class="title">final</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">bool</span>    running_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex              mutex_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Countdown() = <span class="keyword">default</span>;</span><br><span class="line">  ~Countdown() = <span class="keyword">default</span>;</span><br><span class="line">  Countdown(<span class="keyword">const</span> Countdown&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Countdown&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Countdown&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Countdown(Countdown&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Countdown&amp; <span class="keyword">operator</span>=(Countdown&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex_);</span><br><span class="line">      running_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv_.notify_all();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Peroid&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">wait_for</span><span class="params">(<span class="built_in">std</span>::chrono::duration&lt;Rep, Peroid&gt;&amp;&amp; duration)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex_);</span><br><span class="line">    <span class="keyword">bool</span> terminated = cv_.wait_for(lock, duration, [&amp;]() &#123; <span class="keyword">return</span> !running_; &#125;);</span><br><span class="line">    <span class="keyword">return</span> !terminated;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>于是，<code>TimerCircle</code> 就变成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerCircle</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span>    sleep_&#123;<span class="number">0U</span>L&#125;;</span><br><span class="line">  Countdown   cv_;</span><br><span class="line">  <span class="built_in">std</span>::thread thread_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit TimerCircle(uint64_t s) : sleep_&#123;s&#125; &#123;&#125;</span><br><span class="line">  ~TimerCircle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_.joinable()) &#123;</span><br><span class="line">      terminate();</span><br><span class="line">      thread_.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  TimerCircle(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_ = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(&amp;TimerCircle::loop, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv_.terminate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cv_.wait_for(<span class="built_in">std</span>::chrono::seconds(sleep_))) &#123;</span><br><span class="line">      do_something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单，明了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际工程中可能会有这样一类普遍需求：在服务中，单独起一个线程，以一个固定的时间间隔，周期性地完成特定的任务。我们把这种问题抽象成一个时间循环器。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Mutex" scheme="https://liam.page/tags/Mutex/"/>
    
      <category term="Threading" scheme="https://liam.page/tags/Threading/"/>
    
      <category term="ConditionVariable" scheme="https://liam.page/tags/ConditionVariable/"/>
    
  </entry>
  
  <entry>
    <title>手动安装 XCode Command Line Tools</title>
    <link href="https://liam.page/2020/10/13/install-XCode-Command-Line-Tools-manually/"/>
    <id>https://liam.page/2020/10/13/install-XCode-Command-Line-Tools-manually/</id>
    <published>2020-10-13T09:00:43.000Z</published>
    <updated>2020-10-14T14:54:47.143Z</updated>
    
    <content type="html"><![CDATA[<p>使用 macOS 时，Apple 自家的 XCode Command Line Tools 基本上很难绕开。比如你想用 Homebrew 安装点什么东西，它都会依赖 XCode CLT。</p><p>比较不幸地是，如果你更新了 macOS，那你就得重新安装 XCode。如果你重新安装 XCode，那么匹配版本的 CLT 也得重新安装。更为不幸的是，最近使用 <code>xcode-select --install</code> 安装 CLT，经常失败。遂起了手动安装的念头。</p><p>摸索后步骤如下：</p><ul><li>Apple 家官网：<a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">https://developer.apple.com/download/more/</a></li><li>以 Apple ID 登录</li><li>在搜索框搜索 <code>Command Line Tools</code></li><li>打开你 macOS 上的 XCode，检查其版本号</li><li>下载对应版本的 <code>Command Line Tools</code> 镜像（<code>*.dmg</code>）</li><li>从镜像里手工安装</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 macOS 时，Apple 自家的 XCode Command Line Tools 基本上很难绕开。比如你想用 Homebrew 安装点什么东西，它都会依赖 XCode CLT。&lt;/p&gt;
&lt;p&gt;比较不幸地是，如果你更新了 macOS，那你就得重新安装 XCode。如
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="XCode" scheme="https://liam.page/tags/XCode/"/>
    
      <category term="CLT" scheme="https://liam.page/tags/CLT/"/>
    
  </entry>
  
  <entry>
    <title>快速生成 HTML 表格代码</title>
    <link href="https://liam.page/2020/07/29/tools-for-generating-HTML-table/"/>
    <id>https://liam.page/2020/07/29/tools-for-generating-HTML-table/</id>
    <published>2020-07-28T16:27:53.000Z</published>
    <updated>2020-07-28T16:30:07.864Z</updated>
    
    <content type="html"><![CDATA[<p>最近写博客的时候，需要用到表格。然后不可避免地再次发现 Markdown 孱弱的表格语法，于是又一次不能忍。</p><p>于是发现了这个<a href="https://www.tablesgenerator.com/html_tables" target="_blank" rel="noopener">神奇的网站</a>。它允许你从 Excel 当中贴入设计好的表格，然后自动生成相应的 HTML 表格代码（及所需的 CSS 样式表）。</p><p>简直是神器！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写博客的时候，需要用到表格。然后不可避免地再次发现 Markdown 孱弱的表格语法，于是又一次不能忍。&lt;/p&gt;
&lt;p&gt;于是发现了这个&lt;a href=&quot;https://www.tablesgenerator.com/html_tables&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Markdown" scheme="https://liam.page/tags/Markdown/"/>
    
      <category term="HTML" scheme="https://liam.page/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>修改休眠模式以节省 macOS 睡眠时的电池电量</title>
    <link href="https://liam.page/2020/07/26/change-hibernatemode-to-save-battery-on-macOS/"/>
    <id>https://liam.page/2020/07/26/change-hibernatemode-to-save-battery-on-macOS/</id>
    <published>2020-07-26T10:38:06.000Z</published>
    <updated>2020-09-30T09:37:11.644Z</updated>
    
    <content type="html"><![CDATA[<p>切换到 Mac 已经有六年了；一直以来，就发现 MacBook Pro 在扣上盖子睡眠时，会有明显的掉电现象。我觉着这么多年，我一直没去处理它，也是挺能忍的。</p><p>然而今天忍不了了哇。</p><a id="more"></a><h2 id="GUI-设置"><a href="#GUI-设置" class="headerlink" title="GUI 设置"></a>GUI 设置</h2><p>一般用户自然是会从 GUI 设置当中找寻相关线索。</p><p>于是我们打开「系统偏好设置」-「节能」-「电池」标签。</p><p><img data-src="/uploads/images/macOS/energy-saving.jpg" alt></p><p>可见，除了关闭显示器的时间，我的设置已经尽可能节能了；而我们讨论的是合盖睡眠的场景，所以关闭显示器的时间在这里不影响。</p><h2 id="macOS-睡眠机制"><a href="#macOS-睡眠机制" class="headerlink" title="macOS 睡眠机制"></a>macOS 睡眠机制</h2><p>既然 GUI 设置不解决问题，我们就要考虑深入了解 macOS 的睡眠机制了。</p><p>在 Google 上检索 <em>macOS hibernate</em>，比较可惜的是未能找到 Apple 官方的文档。不过，在 Stack Exchange 上我找到了<a href="https://apple.stackexchange.com/questions/51725/do-macbooks-have-a-true-hibernate-option" target="_blank" rel="noopener">这篇回答</a>。</p><p>按照这篇回答的说法，macOS 默认的睡眠，会关闭屏幕，但会维持用于内存（RAM）的供电。这样一来，一旦打开盖子，macOS 就能立即恢复。若是电池电量低于某个预设阈值，则会将内存中的数据转储到硬盘，而后彻底断电。</p><p>这样一来，macOS 睡眠时掉电就解释得通了。</p><p>原作者还提供了一个 <a href="http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/pmset.1.html" target="_blank" rel="noopener">Apple 官方的链接</a>，但无法打开。根据链接内容，看起来是 <code>pmset</code> 这个命令的 <code>man</code> 内容。于是在终端中执行 <code>man pmset</code> 查看相关信息。</p><p>经查，</p><ul><li>macOS 的睡眠有两种状态<ul><li>不断电，数据存储在内存中，可以快速恢复。我们称这种状态为睡眠（Sleep）</li><li>断电，数据存储在硬盘中，恢复得较慢。我们称这种状态为休眠（Hibernate/Stand-by）</li></ul></li><li>睡眠和休眠可以组合出三种模式，由 <code>hibernatemode</code> 控制<ul><li><code>hibernatemode = 0</code>，这是桌面设备的默认值。系统只睡眠，不休眠，不将数据存储在硬盘中。</li><li><code>hibernatemode = 3</code>，这是移动设备的默认值。系统默认睡眠，在一定时间后或电量低于阈值将数据存储在硬盘中，而后休眠。这是所谓的安全睡眠（Safe-Sleep）。</li><li><code>hibernatemode = 25</code>。只休眠，不睡眠。</li></ul></li><li>无论是安全睡眠模式还是休眠模式，从磁盘上恢复时，都会需要一定的时间（经测试，大约 3 秒钟）屏幕才会被点亮。</li></ul><p>对于 <code>hibernatemode = 3</code>，即安全睡眠模式，又有几个参数来控制细节。</p><ul><li>当剩余电量大于 <code>highstandbythreshold</code>（默认 50%）时，在 <code>standbydelayhigh</code> 秒（默认 86,400，即一整天）后进入休眠。</li><li>当剩余电量小于 <code>highstandbythreshold</code> 时，在 <code>standbydelaylow</code> 秒（默认 10,800，即三小时）后进入休眠。</li></ul><h2 id="实际操作看看"><a href="#实际操作看看" class="headerlink" title="实际操作看看"></a>实际操作看看</h2><p>搞清楚具体机制之后，我们就可以做更多细节设置了。</p><p>如果你不在乎每次开盖后需要等待 3 -- 5 秒屏幕才电量，那么你可以直接禁用安全睡眠模式，盒盖休眠。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pmset -b hibernatemode 25</span><br></pre></td></tr></table></figure><p>如果你仍然希望使用安全睡眠模式，但希望不要掉电得太厉害，则可以适当修改 <code>highstandbythreshold</code> 和 <code>standbydelayhigh</code>/<code>standbydelaylow</code> 的值。比如我是这样设置的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When Using Battery</span></span><br><span class="line">sudo pmset -b hibernatemode 3</span><br><span class="line">sudo pmset -b highstandbythreshold 95</span><br><span class="line">sudo pmset -b standbydelayhigh 3600  <span class="comment"># 1 hour</span></span><br><span class="line">sudo pmset -b standbydelaylow  1800  <span class="comment"># half an hour</span></span><br><span class="line"><span class="comment"># When Using AC Power</span></span><br><span class="line">sudo pmset -c hibernatemode 3</span><br><span class="line">sudo pmset -c highstandbythreshold 80</span><br><span class="line">sudo pmset -c standbydelayhigh 86400  <span class="comment"># 24 hours</span></span><br><span class="line">sudo pmset -c standbydelaylow  10800  <span class="comment"># 3 hours</span></span><br></pre></td></tr></table></figure><p>如此一来，我的节能设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ pmset -g custom</span><br><span class="line">Battery Power:</span><br><span class="line"> lidwake              1</span><br><span class="line"> standbydelayhigh     3600</span><br><span class="line"> standbydelaylow      1800</span><br><span class="line"> standby              1</span><br><span class="line"> proximitywake        0</span><br><span class="line"> ttyskeepawake        1</span><br><span class="line"> highstandbythreshold 95</span><br><span class="line"> powernap             0</span><br><span class="line"> gpuswitch            2</span><br><span class="line"> hibernatefile        /var/vm/sleepimage</span><br><span class="line"> hibernatemode        3</span><br><span class="line"> displaysleep         64</span><br><span class="line"> sleep                1</span><br><span class="line"> tcpkeepalive         1</span><br><span class="line"> halfdim              1</span><br><span class="line"> acwake               0</span><br><span class="line"> lessbright           1</span><br><span class="line"> disksleep            5</span><br><span class="line">AC Power:</span><br><span class="line"> lidwake              1</span><br><span class="line"> standbydelayhigh     86400</span><br><span class="line"> standbydelaylow      10800</span><br><span class="line"> standby              1</span><br><span class="line"> proximitywake        1</span><br><span class="line"> ttyskeepawake        1</span><br><span class="line"> hibernatemode        3</span><br><span class="line"> powernap             1</span><br><span class="line"> gpuswitch            2</span><br><span class="line"> hibernatefile        /var/vm/sleepimage</span><br><span class="line"> highstandbythreshold 80</span><br><span class="line"> womp                 1</span><br><span class="line"> displaysleep         180</span><br><span class="line"> networkoversleep     0</span><br><span class="line"> sleep                1</span><br><span class="line"> tcpkeepalive         1</span><br><span class="line"> halfdim              1</span><br><span class="line"> acwake               0</span><br><span class="line"> disksleep            10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切换到 Mac 已经有六年了；一直以来，就发现 MacBook Pro 在扣上盖子睡眠时，会有明显的掉电现象。我觉着这么多年，我一直没去处理它，也是挺能忍的。&lt;/p&gt;
&lt;p&gt;然而今天忍不了了哇。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Hibernate" scheme="https://liam.page/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>何谓「内卷化」</title>
    <link href="https://liam.page/2020/07/22/what-is-involution/"/>
    <id>https://liam.page/2020/07/22/what-is-involution/</id>
    <published>2020-07-22T03:30:02.000Z</published>
    <updated>2020-07-26T10:20:06.458Z</updated>
    
    <content type="html"><![CDATA[<p>最近互联网上经常说内卷。特别是识得的一些清华大学的小同学们经常在我耳边卷啊卷。作为一个跟不上时代的过气年轻人，我无法理解内卷是什么意思，于是有上网检索。</p><a id="more"></a><h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><p>内卷的英文是 involution。在医学上，它表示萎缩或者退化。在 AHD 当中，它的解释是：</p><ul><li>A decrease in size of an organ, as of the uterus following childbirth.（器官在大小上的萎缩，例如生育之后女性子宫的萎缩。）</li><li>A progressive decline or degeneration of normal physiological functioning occurring as a result of the aging process.（因年龄增长而出现的身体正常功能的持续衰退或退化。）</li></ul><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p><a href="https://baike.baidu.com/item/%E5%86%85%E5%8D%B7%E5%8C%96" target="_blank" rel="noopener">百度百科</a>对内卷化的描述中，有如下内容：</p><blockquote><p>内卷化一词源于美国人类学家吉尔茨（Clifford Geertz）《农业内卷化——印度尼西亚的生态变化过程》（Agricultural Involution: The Processes of Ecological Change in Indonesia）。根据吉尔茨的定义，「内卷化」是指一种社会或文化模式在某一发展阶段达到一种确定的形式后，便停滞不前或无法转化为另一种高级模式的现象。这一概念最早是用来研究爪哇的水稻农业。在殖民地时代和后殖民地时代的爪哇，农业生产长期以来原地不动，未曾发展，只是不断地重复简单再生产。不能提高单位人均产值。</p><p>黄宗智在《长江三角洲小农家庭与乡村发展》中，把内卷化这一概念用于中国经济发展与社会变迁的研究，他把通过在有限的土地上投入大量的劳动力来获得总产量增长的方式，即边际效益递减的方式，称为没有发展的增长即「内卷化」。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从词典和百度百科的描述来看，内卷用在社会现象上时，表达的大概有几层含义：</p><ul><li>在宏观上，发展停滞不前，甚至在规模上萎缩退化。</li><li>在微观上，努力的效用停滞不前，甚至在边际效用上萎缩退化。</li></ul><p>用数学的语言来表述，就是社会发展水平和经济规模，一阶导数和二阶导数均为负数。</p><h2 id="生活化的理解"><a href="#生活化的理解" class="headerlink" title="生活化的理解"></a>生活化的理解</h2><p>上面的解释，都是比较学术派的解释，普通老百姓是不会满意于这种解释的。</p><h3 id="思维实验的结论"><a href="#思维实验的结论" class="headerlink" title="思维实验的结论"></a>思维实验的结论</h3><blockquote><p>以下没有参考来源，纯粹是不可靠的思维实验得出的结论。请谨慎参考。</p></blockquote><p>就我的观察，我理解内卷化现象是一种恶性循环。在恶性循环当中，大多数人的边际效用极低（因而获利极少）而极少数人边际效用极高（因而获利极大）。造成这种现象的原因主要是恶性竞争。而这种恶性竞争的起因至少有二：资源压力、信息不对称。用一句话说，内卷化现象是<strong>资源压力下信息不对称导致的恶性竞争导致大多数人边际效用极低而极少数人赚取到大量利益并陷入恶性循环</strong>。</p><p>这里有几个关键点。</p><p>首先是资源压力。</p><p>这里说的资源，是广义的资源。可以是钢铁、石油之类的实体资源；也可以是医疗、教育之类的社会资源；也可以是其它利用信息不对称，构建的心理资源。在发展的早期，社会整体资源利用率相对较低，并且人口数量也较少，因而人们感受不到资源压力。但发展到一定水平之后，资源的瓶颈就出现了。此时，社会内部的竞争就存在从良性竞争转向恶性竞争的趋势。</p><p>而后是信息不对称导致的边际效用的歧化。</p><p>某种意义上，对信息的全面了解，是作出正确决定的基石。当社会存在明显的信息不对称时，可能出现歧化现象：信息优势者，轻易作出正确决定，从而极大地提升生产效率；信息劣势者，容易作出错误决定，从而投入大量资源在低效的生产方式上。当歧化现象趋于严重且长期持续时，信息劣势者之间发生恶性竞争的可能性就会放大，从而出现「劣币驱逐良币」的现象。</p><p>最后是恶性循环。</p><p>信息不对称可能因正反馈而出现马太效应，从而使群体陷入恶性循环。假设在群体中，初始情况下人们对信息的了解程度是随机的。那么，具有相对信息优势的人，就容易做出正确决定，从而极大地提升生产效率，赚取大量利益。而当利益成为资本沉淀，又会相对更容易地获取信息优势，从而形成正反馈。简单来说，就是在信息优劣上，强者恒强、强者更强。在人性恶的一面被放大的情况下（毕竟，「资本永不眠」），具有绝对信息优势者，可能主动引导甚至加剧信息劣势者之间的恶性竞争，从而稳固自身的信息优势。</p><p>在内卷化的进程中，最令人感觉不公的，大概就是随机的初始条件。——最早你可能只是因为运气好，然后不断放大自己的优势，以至于现在无法逾越的优势鸿沟。</p><h3 id="破局之法"><a href="#破局之法" class="headerlink" title="破局之法"></a>破局之法</h3><p>内卷的产生，有几个先决条件：</p><ul><li>资源压力；</li><li>信息不对称；</li><li>恶性竞争。</li></ul><p>这里，基于我们尚未实现「世界大同」，因而在感受到资源压力且存在信息不对称现象的社会中，某种意义上，恶性竞争是人性的必然结果。因此，避免或减轻内卷，就要从资源压力和信息不对称上下手。我们有如下一些解法：</p><ul><li>知识和技术升级。通过技术升级，提升资源利用率，从而使有限的资源提供更大的社会生产，进而降低整体资源压力。</li><li>信息公平化。通过强制手段，维护和加强信息公平，避免信息为资本所控制。</li></ul><p>这里，知识和技术的升级是手段，而信息公平化是基石。之所以这样说，是因为在资本的加持下，知识和技术的升级会更容易和快速，若无信息公平，则知识和技术的升级反而可能会加剧内卷。在这个意义上，当今世界两种制度及其背后的意识形态之优劣，就很明显了。只可惜，「自由化」的糖衣炮弹太厉害，很多人是看不清的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近互联网上经常说内卷。特别是识得的一些清华大学的小同学们经常在我耳边卷啊卷。作为一个跟不上时代的过气年轻人，我无法理解内卷是什么意思，于是有上网检索。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Involution" scheme="https://liam.page/tags/Involution/"/>
    
  </entry>
  
  <entry>
    <title>Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</title>
    <link href="https://liam.page/2020/07/17/memory-stat-in-TOP/"/>
    <id>https://liam.page/2020/07/17/memory-stat-in-TOP/</id>
    <published>2020-07-17T07:30:36.000Z</published>
    <updated>2020-07-19T12:02:45.685Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统中，著名的 <code>top</code> 命令可列出各个进程对系统资源的利用情况。其中有 <code>VIRT</code>, <code>RES</code>, <code>SHR</code>, <code>CODE</code>, <code>DATA</code> 等几个字段，用来描述进程对内存的使用情况。（后二者默认不展示，需要按下 F 键，将相关字段调出来）。</p><p>但它们究竟表示什么含义呢？</p><a id="more"></a><h2 id="top-命令的文档"><a href="#top-命令的文档" class="headerlink" title="top 命令的文档"></a><code>top</code> 命令的文档</h2><p>执行 <code>man top</code> 可查看 <code>top</code> 命令的手册。可见这些字段的含义：</p><ul><li><code>VIRT</code> Virtual Memory Size (KiB)：进程使用的所有虚拟内存；包括代码（code）、数据（data）、共享库（shared libraries），以及被换出（swap out）到交换区和映射了（map）但尚未使用（未载入实体内存）的部分。</li><li><code>RES</code> Resident Memory Size (KiB)：进程所占用的所有实体内存（physical memory），不包括被换出到交换区的部分。</li><li><code>SHR</code> Shared Memory Size (KiB)：进程可读的全部共享内存，并非所有部分都包含在 <code>RES</code> 中。它反映了可能被其他进程共享的内存部分。</li><li><code>CODE</code> Code Size (KiB)：进程所占用的实体内存中，可执行代码所占用的内存大小。此项亦称为驻存代码集合（Text Resident Set, TRS）。</li><li><code>DATA</code> Data + Stack Size (KiB)：进程所占用的实体内存中，除去可执行代码所占用部分之外的内存大小。此项亦称为驻存数据集合（Data Resident Set, DRS）。</li></ul><p>但是，真的这样吗？</p><p><img data-src="/uploads/images/captures/top.jpg" alt></p><p>按照 <code>top</code> 命令的手册，应有等式 <code>CODE + DATA = RES</code> 成立。但这里，进程号为 22 的进程，<code>CODE</code> 为 59,984KiB，<code>DATA</code> 为 42.076GiB，<code>RES</code> 为 5.348GiB。显然不满足上述等式。</p><h2 id="top-命令的数据源"><a href="#top-命令的数据源" class="headerlink" title="top 命令的数据源"></a><code>top</code> 命令的数据源</h2><p>经查，<code>top</code> 命令读取的是 <code>/proc/&lt;pid&gt;/statm</code> 当中的数据。</p><blockquote><p>你可以通过 <code>cat /proc/&lt;pid&gt;/statm</code> 来查看。它有 7 列，分别是以内存页计算的 <code>VIRT</code>, <code>RES</code>, <code>SHR</code>, <code>CODE</code>, LRS, <code>DATA</code>, DIRTY。其中 LRS 和 DIRTY 自 Linux 2.6 开始不再使用。内存页的大小是 4KiB，因此，将内存页的数量乘以 4，就是以 KiB 计算的内存占用大小。</p></blockquote><p>而 <code>/proc/&lt;pid&gt;/statm</code> 当中的数据，是经过内核函数 <code>task_statm</code> 读取而后由 <code>procfs</code> 写入的。</p><p>我们来看看<a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/fs/proc/task_mmu.c#L87-L98" target="_blank" rel="noopener">内核函数 <code>task_statm</code></a> 是怎样定义的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">task_statm</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">unsigned</span> <span class="keyword">long</span> *shared, <span class="keyword">unsigned</span> <span class="keyword">long</span> *text,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">unsigned</span> <span class="keyword">long</span> *data, <span class="keyword">unsigned</span> <span class="keyword">long</span> *resident)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *shared = get_mm_counter(mm, MM_FILEPAGES) +</span><br><span class="line">      get_mm_counter(mm, MM_SHMEMPAGES);</span><br><span class="line">  *text = (PAGE_ALIGN(mm-&gt;end_code) - (mm-&gt;start_code &amp; PAGE_MASK))</span><br><span class="line">                &gt;&gt; PAGE_SHIFT;</span><br><span class="line">  *data = mm-&gt;data_vm + mm-&gt;stack_vm;</span><br><span class="line">  *resident = *shared + get_mm_counter(mm, MM_ANONPAGES);</span><br><span class="line">  <span class="keyword">return</span> mm-&gt;total_vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>get_mm_counter</code> 实际啥也没干，就是保证读取计数器的原子性——这是因为读取的是实体内存占用情况。</p><p>由此可知，并不一定有等式 <code>CODE + DATA = RES</code> 成立，但一定成立等式 <code>ANON = RES - SHR</code>。这里 <code>ANON</code> 表示在堆上分配的内存。</p><blockquote><p><a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm.h#L1843-L1856" target="_blank" rel="noopener"><code>get_mm_counter</code> 在 <code>mm.h</code> 中定义</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_mm_counter</span><span class="params">(struct mm_struct *mm, <span class="keyword">int</span> member)</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="keyword">long</span> val = atomic_long_read(&amp;mm-&gt;rss_stat.count[member]);</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> SPLIT_RSS_COUNTING</span></span><br><span class="line">&gt;   <span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;    * counter is updated in asynchronous manner and may go to minus.</span></span><br><span class="line"><span class="comment">&gt;    * But it's never be expected number for users.</span></span><br><span class="line"><span class="comment">&gt;    */</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (val &lt; <span class="number">0</span>)</span><br><span class="line">&gt;     val = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;   <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)val;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可见 <code>get_mm_counter</code> 其实啥也没干，就是保证读取计数器的原子性。</p></blockquote><!--* <https://github.com/torvalds/linux/blob/cbafe18c71028d5e0ee1626b4776fea5d5824a78/include/linux/mm_types_task.h>* <https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm_types.h#L384-L548> --><p>从代码可见</p><ul><li><code>shared</code> 是共享文件和动态库占用实体内存页（memory page）之和；它对应 <code>SHR</code>。</li><li><code>text</code> 是代码段占用内存页；它对应 <code>CODE</code>。</li><li><code>data</code> 是 <code>VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK</code> 与 <code>VM_STACK</code> 占用内存页之和，也就是所有非栈内存中可写但非共享内存页与栈内存页之和；它对应 <code>DATA</code>。</li><li><code>resident</code> 是 <code>shared</code> 和实体匿名内存页（memory page）之和；它对应 <code>RES</code>。</li><li>return value 是整个虚拟内存的内存页；它对应 <code>VIRT</code>。</li></ul><p>从代码来看，<code>VIRT</code>, <code>SHR</code>, <code>CODE</code>, <code>RES</code> 与 <code>top</code> 命令的手册吻合，区别在于 <code>DATA</code> 这个字段——从我们观察到的现象，也确实在 <code>DATA</code> 上有明显的问题。</p><h2 id="DATA-之谜"><a href="#DATA-之谜" class="headerlink" title="DATA 之谜"></a><code>DATA</code> 之谜</h2><p>在<a href="/2016/05/01/Introduction-to-Memory-Addressing/#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">老文</a>中，我们谈到了虚拟内存和物理内存（实体内存）之间的差别与联系。在 Linux 中，进程能直接看到的，都是虚拟内存。</p><p>对于每一个虚拟内存页，根据其是否有对应的实体内存帧对应，有三种状态：</p><ol><li>该页没有实体内存帧与之对应；记为 vm_unmapped。</li><li>该页有实体内存帧与之对应，且未被换出到交换区；记为 vm_physic。</li><li>该页有实体内存帧与之对应，但已被换出到交换区；记为 vm_swap。</li></ol><p>在本文讨论的五个字段当中，按照是否有强调为 vm_physic，记录如下：</p><table><thead><tr><th></th><th><code>top</code> 手册</th><th>内核代码</th></tr></thead><tbody><tr><td><code>VIRT</code></td><td>x</td><td>x</td></tr><tr><td><code>RES</code></td><td>y</td><td>y</td></tr><tr><td><code>SHR</code></td><td>x</td><td>y</td></tr><tr><td><code>CODE</code></td><td>y</td><td>y</td></tr><tr><td><code>DATA</code></td><td>y</td><td>x</td></tr></tbody></table><p>可见，比较明确的是 <code>VIRT</code>, <code>RES</code> 和 <code>CODE</code>。<code>SHR</code> 的情况也比较好理解，内核代码可以明确是只包含实体内存部分，而 <code>top</code> 手册里则没有说明，因此我们也将其理解为只包含实体内存部分。</p><p>现在，需要确认的，就是 <code>DATA</code> 了。我们看一下 <code>DATA</code> 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*data = mm-&gt;data_vm + mm-&gt;stack_vm;</span><br></pre></td></tr></table></figure><p>其中 <code>mm</code> 是 Linux 的内存描述符，它定义在 <a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm_types.h#L384-L548" target="_blank" rel="noopener"><code>linux/mm_types.h</code></a> 当中，是一个相当大的结构体。其中 <code>data_vm</code> 和 <code>stack_vm</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data_vm;     <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;     <span class="comment">/* VM_STACK */</span></span><br></pre></td></tr></table></figure><p>这里，显然后缀 <code>vm</code> 表示虚拟内存（Virtual Memory），因此 <code>DATA</code> 表示的不只是实体内存占用，这一点是显然的了。接下来的问题是，这里的注释表示什么呢？<code>VM_WRITE</code> 等宏，定义在 <a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm.h#L240-L391" target="_blank" rel="noopener"><code>linux/mm.h</code></a> 当中。这些宏表示虚拟内存区域（Virtual Memory Area, <code>vm_area</code>）的属性，由一些 one-hot 的整数来表示。于是，<code>VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK</code> 表示非栈且非共享的可写虚拟内存区域。因此 <code>DATA</code> 字段表达的是虚拟内存中，栈区域与非栈区域中非共享可写区域之和。</p><p>这也就能解释，为什么 <code>DATA</code> 看起来远远大于 <code>RES</code> 了。因为 <code>RES</code> 是实际占用的实体内存大小，而 <code>DATA</code> 计算的是数据部分占用虚拟内存的大小。后者可能包含了大量实际没有与实体内存帧映射的虚拟内存页，从而导致看起来虚高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>top</code> 的手册关于 <code>DATA</code> 的说明是错的，有 bug。更新如下：</p><ul><li><code>VIRT</code> Virtual Memory Size (KiB)：进程使用的所有<strong>虚拟内存</strong>；包括代码（code）、数据（data）、共享库（shared libraries），以及被换出（swap out）到交换区和映射了（map）但尚未使用（未载入实体内存）的部分。</li><li><code>RES</code> Resident Memory Size (KiB)：进程所占用的所有<strong>实体内存</strong>（physical memory），不包括被换出到交换区的部分。</li><li><code>SHR</code> Shared Memory Size (KiB)：进程可读的全部共享<strong>实体内存</strong>，并非所有部分都包含在 <code>RES</code> 中。它反映了可能被其他进程共享的内存部分。</li><li><code>CODE</code> Code Size (KiB)：进程所占用的<strong>实体内存</strong>中，可执行代码所占用的内存大小。此项亦称为驻存代码集合（Text Resident Set, TRS）。</li><li><code>DATA</code> Data + Stack Size (KiB)：进程所占用的<strong>虚拟内存</strong>中，栈区域与非栈区域中非共享可写区域之和。</li></ul><p>不一定有等式 <code>CODE + DATA = RES</code> 成立，但一定成立等式 <code>ANON = RES - SHR</code> 及不等式 <code>ANON &lt;= DATA (vm_physic) &lt;= DATA</code>。如果观察到程序稳定运行时 <code>RES - SHR</code> 不断增长，则可能预示着程序存在内存泄漏现象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 系统中，著名的 &lt;code&gt;top&lt;/code&gt; 命令可列出各个进程对系统资源的利用情况。其中有 &lt;code&gt;VIRT&lt;/code&gt;, &lt;code&gt;RES&lt;/code&gt;, &lt;code&gt;SHR&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;DATA&lt;/code&gt; 等几个字段，用来描述进程对内存的使用情况。（后二者默认不展示，需要按下 F 键，将相关字段调出来）。&lt;/p&gt;
&lt;p&gt;但它们究竟表示什么含义呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://liam.page/tags/Kernel/"/>
    
      <category term="VIRT" scheme="https://liam.page/tags/VIRT/"/>
    
      <category term="RES" scheme="https://liam.page/tags/RES/"/>
    
      <category term="SHR" scheme="https://liam.page/tags/SHR/"/>
    
      <category term="CODE" scheme="https://liam.page/tags/CODE/"/>
    
      <category term="DATA" scheme="https://liam.page/tags/DATA/"/>
    
  </entry>
  
</feed>
