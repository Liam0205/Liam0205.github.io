<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2023-01-21T09:55:15.571Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决 cisco.anyconnect.macos.acsockext 大量消耗 CPU 资源的问题</title>
    <link href="https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/"/>
    <id>https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/</id>
    <published>2023-01-21T09:47:04.000Z</published>
    <updated>2023-01-21T09:55:15.571Z</updated>
    
    <content type="html"><![CDATA[<p>最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。</p><span id="more"></span><p><img data-src="/uploads/images/computer-skills/acsockext-cpu-usage.jpg"></p><p>检查发现，这是因为在 4.10 版本开始，思科的 VPN 加入了 Socket 过滤功能。从现象来看，它几乎无时无刻不在 buzy loop。从功能来看，这种全方位的过滤功能，实在令人担忧其安全性。因此决定干掉他。以下是步骤：</p><ul><li>打开系统设置 -&gt; 网络</li><li>应能观察到三个以 <code>Cisco...</code> 开头的网络配置</li><li>选中它们，然后点下方的 <code>-</code>，删除他们</li><li>右下角，应用</li><li>应能观察到 CPU 利用率立刻下降</li><li>删除 <code>/Applications/Cisco/Cisco AnyConnect Socket Filter.app</code> 以免将来之虞</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="CPU" scheme="https://liam.page/tags/CPU/"/>
    
      <category term="Cisco" scheme="https://liam.page/tags/Cisco/"/>
    
      <category term="VPN" scheme="https://liam.page/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：速览 Objective-C</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/</id>
    <published>2023-01-21T01:32:37.000Z</published>
    <updated>2023-01-21T02:48:52.007Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。</p><p>这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&#x2F;C++ 的熟练使用者则更好。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 是 C 语言的严格超集。即是说，在 C 编译器下能够编译的代码，应当可以不加修改地使用 Objective-C 的编译器来编译。（尽管可能行为不完全相同）另一方面，在 Objective-C 当中，可以混合使用 C 风格的代码。</p><h2 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h2><table><thead><tr><th></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td>C</td><td><code>.h</code></td><td><code>.c</code></td></tr><tr><td>C++</td><td><code>.h</code>&#x2F;<code>.hpp</code></td><td><code>.cc</code>&#x2F;<code>.cpp</code>&#x2F;<code>.cxx</code></td></tr><tr><td>Objective-C</td><td><code>.h</code></td><td><code>.m</code></td></tr><tr><td>Objective-C++</td><td><code>.h</code></td><td><code>.mm</code></td></tr></tbody></table><p>为了兼容 C，我们依然可以使用预处理器指令 <code>#include</code> 来包含头文件。但是 Objective-C 提供了另一选项 <code>#import</code>。它与 <code>#include</code> 的作用几乎完全相同，但可以保证在一个编译单元中每个头文件都只被引入一次。即是说，它起到了传统 C&#x2F;C++ 变成中 <code>#pragma once</code> 或是 Guard Macro 的作用。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Objective-C&#x2F;C++ 中的基本类型和 C&#x2F;C++ 中的差不多。几种基本类型在 Objective-C&#x2F;C++ 中的长度分别是：</p><ul><li><code>char</code>: 1B</li><li><code>int</code>: 4B</li><li><code>float</code>: 4B</li><li><code>double</code>: 8B</li></ul><p>此外，Objective-C&#x2F;C++ 中也有 <code>short</code>&#x2F;<code>long</code>&#x2F;<code>long long</code>&#x2F;<code>signed</code>&#x2F;<code>unsigned</code> 之类的修饰。含义也和 C&#x2F;C++ 中的相同。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Objective-C 支持 C-style 字符串，并且也遵循 C 语言当中对引号使用的约定。亦即，使用单引号表示字符（例 <code>&#39;c&#39;</code>），使用双引号表示字符串（null termination）。但在 Objective-C 中也有实现 <code>NSString</code> 类（类似 C++ 中的 <code>std::string</code> 但更强大）。它更常用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>;  <span class="comment">// 字符类型字面量</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span>;  <span class="comment">// C-style string</span></span><br><span class="line"><span class="string">@&quot;hello world&quot;</span>;  <span class="comment">// Objective-C NSString</span></span><br></pre></td></tr></table></figure><p>此外，<code>NSString</code> 也支持 <code>printf</code> 风格的字符串构造方法，以及支持从 C-style 字符串中构造。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a NSString object from literal</span></span><br><span class="line"><span class="built_in">NSString</span>* myString = <span class="string">@&quot;My String\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from printf formatter</span></span><br><span class="line"><span class="built_in">NSString</span>* anotherString = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@&quot;%d %s&quot;</span>, <span class="number">1</span>, <span class="string">@&quot;String&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from C-style string</span></span><br><span class="line"><span class="built_in">NSString</span>*  fromCString = [<span class="built_in">NSString</span> stringWithCString: <span class="string">&quot;A C string&quot;</span> encoding: <span class="built_in">NSASCIIStringEncoding</span>];</span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><p>Objective-C 中的 <code>if</code> 语句和 C&#x2F;C++ 中的基本一致。唯独，在 Objective-C 中以 <code>0</code> 表示 <code>false</code>，而以其他值表示 <code>true</code>。例如说，其他任何数值，或是任何字符串，在 <code>Objective-C</code> 中都会被认为是 <code>true</code>。</p><h3 id="for-x2F-while"><a href="#for-x2F-while" class="headerlink" title="for&#x2F;while"></a><code>for</code>&#x2F;<code>while</code></h3><p>Objective-C 中的 <code>for</code>&#x2F;<code>while</code> 和 C 中的完全一致。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><table><thead><tr><th></th><th>名称</th><th>代码风格</th></tr></thead><tbody><tr><td>C&#x2F;C++</td><td>对象成员函数调用</td><td><code>obj.method(args)</code></td></tr><tr><td>Objective-C&#x2F;C++</td><td>向对象传递消息</td><td><code>[obj method: args]</code></td></tr></tbody></table><p>在 C++&#x2F;Java 中，类中定义有成员函数&#x2F;成员方法。我们可以通过类似 <code>obj.method(args)</code> 的方式调用 <code>obj</code> 对象的 <code>method</code> 成员函数。如果 <code>method</code> 在 <code>obj</code> 所属的类中没有定义，则在编译期就会报错。</p><p>Objective-C 则继承了 Smalltalk 的消息传递模型。在这一模型中，调用成员函数被视作是向对象发送一个消息。例如，<code>obj.method(args)</code> 式的调用会被写作是 <code>[obj method: args]</code>。这种写法的意思是，向 <code>obj</code> 这个对象发送名为 <code>method</code> 的消息，<code>args</code> 则是消息附带的参数。与 C++&#x2F;Java 风格的调用不同，<code>obj</code> 所属的类即便没有定义名为 <code>method</code> 的成员函数，我们在代码中依旧可以向 <code>obj</code> 发送这一消息。Objective-C 的编译器不会为此报错，但在程序执行时则会抛出一个异常。</p><p>对比下来，消息传递模型中类和成员函数的关系较为松散，这种调用方式总是在运行期动态绑定。于是，它不需要 C++ 当中的 <code>virtual</code>&#x2F;<code>override</code> 关键字。当然，这种做法也存在一定额外开销。（显然）</p><blockquote><p>空对象（<code>nil</code>）接受消息后默认不做任何事情。因此向 <code>nil</code> 传递消息是安全的。</p></blockquote><h2 id="类的声明与数据成员"><a href="#类的声明与数据成员" class="headerlink" title="类的声明与数据成员"></a>类的声明与数据成员</h2><p>在 C++ 中，我们称之为「声明一个类」。在 Objective-C&#x2F;C++ 中，我们说「定义类的接口（interface）」。</p><hr><p>在 C++ 中，定义一个空的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>注意，它不需要继承自一个作为占位符的父类。在 Objective-C&#x2F;C++ 中，定义一个空类形如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意，和 Python 中所有类都继承自 <code>object</code> 类似，Objective-C 中所有类都继承自 <code>NSObject</code>。</p><hr><p>在 C++ 中，定义一个包含有数据成员的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C&#x2F;C++ 中则是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Objective-C 的类分为接口（interface）和实现（implementation）。接口部分通常包含了类声明以及其中数据成员的定义，以及相关成员函数的声明。实现部分通常包含了成员函数的实现代码。</p><p>注意，C++ 中，<code>class</code> 中的数据成员默认是 <code>private</code> 的；在 Objective-C&#x2F;C++ 中，<code>@interface</code> 段定义的数据成员默认是 <code>protected</code> 的，<code>@implementation</code> 段定义的数据成员默认是 <code>private</code> 的。为了保持访问控制一致，额外在 C++ 代码中加上了 <code>protected</code> 关键字来指定 <code>data</code> 的访问控制类型。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在 C++ 中，成员函数的声明形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">class_method</span><span class="params">()</span></span>;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method1</span><span class="params">()</span></span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method2</span><span class="params">(<span class="type">int</span> p1)</span></span>;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method3</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span>;  <span class="comment">// 4.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C 中，则是如下形式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">Bar</span></span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line">+(<span class="type">void</span>) class_method;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>) instance_method1;  <span class="comment">// 3.a</span></span><br><span class="line">-(<span class="type">void</span>) instance_method2: (<span class="type">int</span>) p1;  <span class="comment">// 3.b</span></span><br><span class="line">-(<span class="type">void</span>) instance_method3: (<span class="type">int</span>) p1 and: (<span class="type">int</span>) p2;  <span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>首先关注 (1)。在 C++ 中，<code>class</code> 内的访问控制默认是 <code>private</code>。因此，要使声明的成员函数可用，我们需要显式地指明 <code>public</code>。在 Objective-C 中，<code>@interface</code> 段的方法默认是 <code>@public</code> 的。</p><p>接下来关注 (2)。在 C++ 中有所谓的 <code>static</code>-成员函数。此类成员函数是属于整个类的，不能修改类的对象内部的数据成员。Objective-C 中也有类似设定，即所谓的类方法（class method）。具体形式是在方法前加上一个 <code>+</code> 记号。</p><p>现在关注 (3)。这是典型的成员函数的声明方式。这样的成员函数是与具体的类的对象绑定的，必须要有一个构造好的对象才能执行这些成员函数。在 Objective-C 中，这是所谓的对象方法（instance method），也称为一般方法。</p><p>(4) 处也声明了一般意义上的成员函数，但在 Objective-C 这里稍有不同。对 Objective-C 的版本，它的函数全名（签名）是 <code>instance_method3:and:</code>。即是说，在声明时，函数的名称和参数列表交织在一起；每个冒号后面都带有一次参数传递。调用它的时候则类似：<code>[obj instance_method3: 0 and: 1]</code>。这是 Objective-C&#x2F;C++ 特有的。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>尽管我们也可以在 Objective-C 中定义数据成员，但实际上更好的方式是使用属性。例如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它等价于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;  <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;  <span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里，(1) 声明了类 <code>Foo</code> 的一个属性。它的类型是 <code>int</code>，名字是 <code>age</code>。如果没有显式地如 (2) 这样将属性和变量关联起来，则编译器会自动产生一个变量，并做这样的关联。注意，属性的声明应当位于 <code>@interface</code> 段，属性与变量的关联则应放在 <code>@implementation</code> 段。</p><p>你也可以使用别的变量与属性进行关联。例如 <code>@synthesize age = internal_age;</code>。这样会将 <code>age</code> 这个属性与 <code>internal_age</code> 这个数据成员进行关联。</p><p>声明属性，则编译器会为我们自动生成相应的 setter&#x2F;getter 方法。例如说，上面的代码，大致相当于会生成这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line">-(<span class="type">void</span>) setAge: (<span class="type">int</span>) n &#123;</span><br><span class="line">  <span class="keyword">self</span>-&gt;_age = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">int</span>) age &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说，通过属性，我们将类的数据成员封装了起来。外部不能直接操作类的数据成员，而要通过 setter&#x2F;getter 来操作。此外，Objective-C 还为此提供了类似 C++ 中成员访问运算符（<code>.</code>）的语法糖。我们可以写出类似下面的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.age = <span class="number">10</span>;  <span class="comment">// 1.a</span></span><br><span class="line">[p setAge: <span class="number">10</span>];  <span class="comment">// 1.b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, p.age);  <span class="comment">// 2.a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, [p age]);  <span class="comment">// 2.b</span></span><br></pre></td></tr></table></figure><p>其中 (1.a) 和 (1.b) 的含义相同，(2.a) 和 (2.b) 的含义也相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。&lt;/p&gt;
&lt;p&gt;这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&amp;#x2F;C++ 的熟练使用者则更好。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak" scheme="https://liam.page/categories/Jailbreak/"/>
    
    
      <category term="Language" scheme="https://liam.page/tags/Language/"/>
    
      <category term="Objective-C" scheme="https://liam.page/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS 上 VSCode 当中终端环境变量重复问题</title>
    <link href="https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/"/>
    <id>https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/</id>
    <published>2023-01-20T14:02:11.000Z</published>
    <updated>2023-01-20T14:06:49.900Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，<code>PATH</code> 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，<code>PATH</code> 变量则是正常的。</p><span id="more"></span><p>举例来说，VSCode 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin:/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>同期 Terminal 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>检查各种 <code>profile</code>&#x2F;<code>bashrc</code> 文件，均未发现异常。后查明是在 VSCode 当中启动嵌入的终端时，默认会继承 VSCode 启动时的环境变量。这导致后续在使用 <code>PATH = &quot;/path/to/foo/bar:$PATH&quot;</code> 这样的语法时，会将 <code>PATH</code> 复制一份。只需将 VSCode 中的下列设置改为 <code>false</code> 即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.inheritEnv&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，&lt;code&gt;PATH&lt;/code&gt; 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，&lt;code&gt;PATH&lt;/code&gt; 变量则是正常的。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="Terminal" scheme="https://liam.page/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：从 NIC 中创建项目</title>
    <link href="https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/"/>
    <id>https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/</id>
    <published>2023-01-19T16:21:45.000Z</published>
    <updated>2023-01-19T23:55:58.584Z</updated>
    
    <content type="html"><![CDATA[<p>安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。</p><span id="more"></span><h2 id="执行-NIC"><a href="#执行-NIC" class="headerlink" title="执行 NIC"></a>执行 NIC</h2><p>在安装好 Theos 的基础上，可以执行下列命令启动 NIC 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/nic.pl</span><br></pre></td></tr></table></figure><p>之后，NIC 会在终端上打印出一个列表，询问你想要创建何种类型的项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="variable">$THEOS</span>/bin/nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/control_center_module-11up</span><br><span class="line">  [6.] iphone/cydget</span><br><span class="line">  [7.] iphone/flipswitch_switch</span><br><span class="line">  [8.] iphone/framework</span><br><span class="line">  [9.] iphone/library</span><br><span class="line">  [10.] iphone/notification_center_widget</span><br><span class="line">  [11.] iphone/notification_center_widget-7up</span><br><span class="line">  [12.] iphone/preference_bundle</span><br><span class="line">  [13.] iphone/preference_bundle_swift</span><br><span class="line">  [14.] iphone/theme</span><br><span class="line">  [15.] iphone/tool</span><br><span class="line">  [16.] iphone/tool_swift</span><br><span class="line">  [17.] iphone/tweak</span><br><span class="line">  [18.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [19.] iphone/xpc_service</span><br><span class="line">  [20.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required):</span><br></pre></td></tr></table></figure><p>我们主要关注的是其中的 <code>iphone/tweak</code> 和 <code>iphone/tweak_with_simple_preferences</code>。后者会构造一个 <code>Preferences.plist</code> 文件，以便我们能在 iOS 的系统设置中配置该插件的行为。</p><p>这里我们选择 18。接下来，NIC 会交互式地要求我们键入一些插件的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Choose a Template (required): 18</span><br><span class="line">Project Name (required): PhantomSteps</span><br><span class="line">Package Name [com.yourcompany.phantomsteps]: page.liam.phantom_steps</span><br><span class="line">Author/Maintainer Name [Liam Huang]:</span><br><span class="line">[iphone/tweak_with_simple_preferences] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.Health</span><br><span class="line">[iphone/tweak_with_simple_preferences] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: com.apple.Health</span><br><span class="line">Instantiating iphone/tweak_with_simple_preferences <span class="keyword">in</span> phantomsteps/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>这里，我们给项目起名为 <code>PhantomSteps</code>，其包名称为 <code>page.liam.phantom_steps</code>。你可以按需修改。MobileSubstrate Bundle filter 这一项是说，你可能影响的 App 的名字。List of applications to terminate upon installation 这一项则是说，在安装你的插件时，需要杀死的程序的名字。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>创建成功后，目录结构应该类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── PhantomSteps.plist</span><br><span class="line">├── Tweak.x</span><br><span class="line">├── control</span><br><span class="line">└── layout</span><br><span class="line">    └── Library</span><br><span class="line">        └── PreferenceLoader</span><br><span class="line">            └── Preferences</span><br><span class="line">                └── PhantomSteps</span><br><span class="line">                    └── Preferences.plist</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure><p>这里</p><ul><li><code>PhantomSteps.plist</code> 记录了需要杀死的包的名称。</li><li><code>control</code> 包含了先前在 NIC 交互式环境中填写的信息。</li><li><code>Makefile</code> 是对应 GNU make 的文件。</li><li><code>Tweak.x</code> 是插件自身的代码。Theos 会从模板中创建一个带有各种注释的文件供参考。</li></ul><blockquote><p>通过 NIC 模板创建的项目可见：<a href="https://github.com/Liam0205/PhantomSteps/tree/c48a76ae16ea761b24bfa94524331a1b7523d0b0">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak" scheme="https://liam.page/categories/Jailbreak/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：安装 Theos</title>
    <link href="https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/"/>
    <id>https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/</id>
    <published>2023-01-19T15:16:51.000Z</published>
    <updated>2023-01-19T15:39:16.396Z</updated>
    
    <content type="html"><![CDATA[<p>Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。</p><blockquote><p>你也可以直接参考官方英文文档：<a href="https://theos.dev/docs/installation-macos">https://theos.dev/docs/installation-macos</a></p></blockquote><span id="more"></span><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><h3 id="安装-XCode"><a href="#安装-XCode" class="headerlink" title="安装 XCode"></a>安装 XCode</h3><p>打开 MAS，搜索 XCode，安装&#x2F;更新到最新。</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>打开 Terminal，执行下列命令（来自<a href="https://brew.sh/">Homebrew 官网</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="通过-brew-安装依赖库"><a href="#通过-brew-安装依赖库" class="headerlink" title="通过 brew 安装依赖库"></a>通过 brew 安装依赖库</h3><p>在 Terminal 中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid xz</span><br></pre></td></tr></table></figure><h2 id="下载和安装-Theos"><a href="#下载和安装-Theos" class="headerlink" title="下载和安装 Theos"></a>下载和安装 Theos</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export THEOS=~/theos&quot;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="comment"># 早期的系统应该加至 ~/.profile</span></span><br></pre></td></tr></table></figure><h3 id="下载-Theos"><a href="#下载-Theos" class="headerlink" title="下载 Theos"></a>下载 Theos</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/theos/theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，你也可以将 <code>$THEOS/bin/</code> 加到环境变量 <code>$PATH</code> 中去。</p></blockquote><h2 id="安装-SDK"><a href="#安装-SDK" class="headerlink" title="安装 SDK"></a>安装 SDK</h2><p>新版的 XCode 不提供插件可能使用到的私有框架，因此我们需要安装 Theos 维护的补丁版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/theos/sdks/archive/master.zip</span><br><span class="line">TTT=$(<span class="built_in">mktemp</span> -d)</span><br><span class="line">unzip master.zip -d <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$TTT</span>/sdks-master/*.sdk <span class="variable">$THEOS</span>/sdks</span><br><span class="line"><span class="built_in">rm</span> -r master.zip <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">unset</span> <span class="variable">$TTT</span></span><br></pre></td></tr></table></figure><h2 id="更新-Theos"><a href="#更新-Theos" class="headerlink" title="更新 Theos"></a>更新 Theos</h2><p>将来需要更新 Theos 时，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/update-theos</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你也可以直接参考官方英文文档：&lt;a href=&quot;https://theos.dev/docs/installation-macos&quot;&gt;https://theos.dev/docs/installation-macos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Jailbreak" scheme="https://liam.page/categories/Jailbreak/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>iOS 越狱后插件推荐</title>
    <link href="https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/"/>
    <id>https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/</id>
    <published>2023-01-19T02:53:10.000Z</published>
    <updated>2023-01-20T05:02:03.113Z</updated>
    
    <content type="html"><![CDATA[<p>手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。</p><span id="more"></span><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><ul><li>iPhone Xʀ</li><li>iOS 14.5.1</li><li>unc0ver 8.0.2</li></ul><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>首先是介绍一下我订阅的软件源。</p><ul><li>Zebra：<a href="https://getzbra.com/repo/">https://getzbra.com/repo/</a></li><li>BigBoss：<a href="http://apt.thebigboss.org/repofiles/cydia/">http://apt.thebigboss.org/repofiles/cydia/</a></li><li>Bingner&#x2F;Elucubratus：<a href="https://apt.bingner.com/">https://apt.bingner.com/</a></li><li>Limneos Repo：<a href="https://limneos.net/repo/">https://limneos.net/repo/</a></li><li>MERONA Repo：<a href="https://repo.co.kr/">https://repo.co.kr/</a></li><li>Chariz：<a href="https://repo.chariz.io/">https://repo.chariz.io/</a></li><li>Havoc：<a href="https://havoc.app/">https://havoc.app/</a></li><li>jjolano：<a href="https://ios.jjolano.me/">https://ios.jjolano.me/</a></li><li>opa334&#39;s Repo：<a href="https://opa334.github.io/">https://opa334.github.io/</a></li><li>ichitaso repository：<a href="http://cydia.ichitaso.com/">http://cydia.ichitaso.com/</a></li><li>蜗牛源：<a href="https://repo.snailovet.com/">https://repo.snailovet.com/</a></li><li>AutoTouch：<a href="https://repo.autotouch.net/">https://repo.autotouch.net/</a></li><li>Packix：<a href="https://repo.packix.com/">https://repo.packix.com/</a></li><li>Ginsu Tweaks：<a href="https://repo.ginsu.dev/">https://repo.ginsu.dev/</a></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里按照大致的安装时间顺序介绍我目前还在使用的插件。</p><ul><li>Zebra：替代 Cydia 的包管理器。其运行效率和操作流畅度远胜 Cydia。来源：Zebra。</li><li>CCPower：控制中心插件。点按后会弹出菜单。菜单上部显示电池状况、运行时间、闪存、运存等情况。下部允许进行重启、重新载入 SpringBoard 等动作。来源：BigBoss。</li><li>OpenSSH CC Toggle：控制中心插件，点按后可以切换手机中 sshd 的运行状态。来源：BigBoss。</li><li>iPonCC：控制中心插件。在控制中心显示 IP 地址。来源：BigBoss。</li><li>CCBadgeClear：控制中心插件。点按后可以清除 App 图标右上角的角标数字。来源：BigBoss。</li><li>LocationService (CCSupport)：控制中心插件。点按后可以切换系统定位服务的状态。来源：ichitaso repository。</li><li>CCVPN：控制中心插件。点按后可以切换 VPN 的状态。</li><li>Filza File Manager：著名的文件管理器。来源：BigBoss。</li><li>MTerminal：著名的终端模拟器。来源：Bingner&#x2F;Elucubratus。</li><li>左滑返回：允许从屏幕右侧向中间单指滑动执行返回操作（类似于系统默认提供的从屏幕左侧向中间单指滑动的操作）。对于大屏幕的机器，单手操作十分友好。来源：BigBoss。</li><li>kai：可以在锁屏界面和通知中心界面显示各个关联设备（耳机、Apple Watch 等）的电量状态。来源：Chariz。</li><li>NFCWriter XS：著名的 NFC 模拟&#x2F;写入 App。它可以读取外部的 NFC tag，然后模拟出来。例如，可以用来模拟小区门禁卡。来源：Limneos Repo。</li><li>BioProtect XS：著名的生物信安保护插件。它可以按照 App、Folder 等维度，设置是否需要验证生物信安（Face ID&#x2F;Touch ID）。来源：Limneos Repo。</li><li>AudioRecoder XS：著名的通话录音插件。它能自动录制呼入呼出的电话并保存在手机本地，还支持自动上传到云（Google Drive&#x2F;Dropbox）。来源：Limneos Repo。</li><li>vnodebypass：越狱检测屏蔽插件。是已安装的四个同类插件中整体效果最差者。注意，它依赖 libkrw（Bingner&#x2F;Elucubratus），需要手动安装。来源：ichitaso repository。</li><li>Hestia：越狱检测屏蔽插件。是已安装的四个同类插件中整体效果较差者。来源：Havoc。</li><li>A-Bypass：越狱检测屏蔽插件。是已安装四个同类插件中整体效果较好者。来源：MERONA Repo。</li><li>Shadow：越狱检测屏蔽插件。是已安装四个同类插件中整体效果最好者。来源：jjolano。</li><li>Aemulo：可能是最好的 NFC 模拟&#x2F;写入 App。它的功能和 NFCWriter XS 类似，但还额外提供了将 NFC tag 保存入 Apple Wallet 的功能。这使得我们可以在锁屏界面调出 NFC tag，解开小区门禁。来源：Chariz。</li><li>Activator：著名的手势操作插件。来源：BigBoss。</li><li>Choicy：注入管理插件。它可以按照 App 维度，以白名单&#x2F;黑名单的方式禁用插件。来源：opa334&#39;s Repo。</li><li>Apps Manager：可以清除、备份、恢复 App 的 AppData 的插件。来源：BigBoss。</li><li>iCleaner Pro：可以清理 iPhone 上的闪存空间的插件。它还可以对启动项进行调整。来源：MainRepo。</li><li>AppStore++：允许你对来自 AppStore 的 App 进行指定版本的升降级操作，还能设置屏蔽某些 App 的升级。来源：MainRepo。</li><li>AppStore++ 去广告：其功能显而易见。来源：蜗牛源。</li><li>位置自动允许一次 &#x2F;&#x2F; AllowLocationOnce：在 App 请求系统位置服务时，自动点选「允许一次」。来源：蜗牛源。</li><li>AutoTouch：类似 Windows 系统上的「按键精灵」。它可以录制你的手势操作，然后按照指定方式触发，并可搭配 Activator 使用。来源：AutoTouch。</li><li>SmartVPN：它可以按照 App 维度进行设置，在 App 运行时自动启动 VPN，在所有白名单 App 关闭时自动关闭 VPN。来源：BigBoss。</li><li>AutoFolderClose：在启动 App 后，自动关闭 Folder。即是说，从 App 回到主屏幕后，你不会看到还开着的 Folder。来源：Packix。</li><li>AppData：允许你在主屏幕状态下，通过单指向上扫 App icon 来打开菜单。允许你修改 App 在主屏幕上展示的名字，也允许你做一些清理工作。来源：MainRepo。</li><li>Crane：允许你创建 App 的分身，且每次运行前可以选择运行哪个分身。来源：Havoc。</li><li>App Library Disabler：无配置项的插件。安装后禁用 App 资源库。来源：BigBoss。</li><li>DockSearch：在 Dock 上添加一个搜索框，可以直接调起 Safari 进行搜索。来源：Ginsu Tweaks。</li><li>RAMUnderTime：在屏幕顶栏时间下方显示当前剩余的 RAM。来源：Ginsu Tweaks。</li><li>EnableBatteryPercent：在屏幕顶栏电量标志中显示具体的电量剩余百分比。来源：Ginsu Tweaks。</li><li>Acies：替换锁屏界面以及通知页面系统原版的正在播放组件。来源：Ginsu Tweaks。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
      <category term="Tweaks" scheme="https://liam.page/tags/Tweaks/"/>
    
  </entry>
  
  <entry>
    <title>清理加湿器振动片上的水垢以减小其噪声</title>
    <link href="https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/"/>
    <id>https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/</id>
    <published>2022-11-24T11:03:55.000Z</published>
    <updated>2022-11-24T11:23:55.081Z</updated>
    
    <content type="html"><![CDATA[<p>生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。</p><p>常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。</p><p>此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。</p><span id="more"></span><h2 id="水垢的成因"><a href="#水垢的成因" class="headerlink" title="水垢的成因"></a>水垢的成因</h2><p>自来水中不可避免会溶解一些无机盐。特别地，其中的钙盐和镁盐（以碳酸钙、碳酸镁为主，辅有硫酸钙、硫酸镁、氯化钙、氯化镁等）因溶解度较小，容易沉积形成水垢。</p><p>加湿器振动片使水雾化，导致振动片附近的水相对减少、无机盐浓度升高。溶解度较小的钙盐、镁盐便容易在振动片附近沉积。这些沉积的水垢附着在振动片上，导致振动片工作时发出噪声。</p><h2 id="去除水垢的原理和方法"><a href="#去除水垢的原理和方法" class="headerlink" title="去除水垢的原理和方法"></a>去除水垢的原理和方法</h2><p>既已知水垢的成因和主要成分，想要去除水垢便不难。此处我们只需用到初中化学和物理知识即可。</p><p>水垢的主要成分是碳酸、硫酸、盐酸对应的钙盐和镁盐。要软化、去除这些水垢，只需找一合适的阴离子对应的酸性溶液即可。此处我们可以选择生活中常见的醋酸。</p><p>醋酸容易获得，且醋酸是弱酸操作安全。最主要的是，醋酸钙和醋酸镁的溶解度较高，算是易溶解的物质。因此，醋酸与水垢反应，可有效软化、溶解水垢。</p><p>操作步骤：</p><ol><li>购买白醋一瓶（普通使用陈醋也可，但是黑乎乎一片看不清楚效果）。</li><li>将加湿器水槽取下，加湿器底座内余水倾倒干净。</li><li>将白醋倒入加湿器底座，覆盖、没过振动片及其周围水垢区域。</li><li>加入温水（温度不需要太高），以加快反应速度。</li><li>静置 10 -- 20 分钟。此过程可见水槽底座内不断有小气泡产生（二氧化碳），水垢逐渐脱落翻滚（被二氧化碳气体推动而翻滚运动）和逐渐溶解。</li><li>将底座内的醋酸溶液倾倒干净，用手指或软刷将剩余软化的水垢清理干净。</li><li>用清水反复冲洗三至五次底座，减少醋酸残留。（残留醋酸挥发，可能对呼吸道黏膜产生刺激，导致不适）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。&lt;/p&gt;
&lt;p&gt;常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。&lt;/p&gt;
&lt;p&gt;此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Scale" scheme="https://liam.page/tags/Scale/"/>
    
      <category term="Noise" scheme="https://liam.page/tags/Noise/"/>
    
      <category term="Humidifier" scheme="https://liam.page/tags/Humidifier/"/>
    
  </entry>
  
  <entry>
    <title>羽毛球步伐①：启动步</title>
    <link href="https://liam.page/2022/11/20/badminton-footwork-the-start-step/"/>
    <id>https://liam.page/2022/11/20/badminton-footwork-the-start-step/</id>
    <published>2022-11-20T06:29:26.000Z</published>
    <updated>2022-11-20T11:26:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。</p><p>从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。</p><span id="more"></span><h2 id="为什么需要启动步"><a href="#为什么需要启动步" class="headerlink" title="为什么需要启动步"></a>为什么需要启动步</h2><p>羽毛球运动的特点、基本的物理学定律、人的生理结构，三者共同决定了启动步的重要性和必要性。</p><p>羽毛球是速度最快的球类运动之一。若是限定在初始速度的概念上，我们还可以将「之一」去掉。因其速度快、场地小，所以从你击球结束到下一次击球之间的间隔十分短暂。即便在较为缓和的对抗中，这一时间间隔通常也不会超过 3s。在这短暂的间隔中，你需要完成收拍、移动回位、移动到位、准备击球的若干步骤，时间紧迫。此外，在对手击球之前，你无法判断对手回球的落点位置。因此，羽毛球的步伐移动同时具有快速和方向不确定两个重要特点。</p><p>基本的物理学定律告诉我们：若你想要向前加速运动，则势必要让外界对你有向前的合力；向后同理。若你想要相左加速运动，则势必要让外界对你有相左的合力；向右同理。这一合力越大，加速度就越大。在运动上就体现为移动的爆发力越大、突然性越强。在不打滑的情况下，这一水平反向的合力由地面给脚的静摩擦力提供。而静摩擦力的极限大小可由公式 <code>$f_&#123;\text&#123;静&#125;&#125; = \mu_&#123;\text&#123;静&#125;&#125; \cdot F_N$</code> 给出。这也就是说，</p><ul><li>穿一双好的羽毛球鞋（增大抓地力）有助于你快速移动；</li><li>你必须<strong>向斜下方蹬地发力</strong>，才能获得更大的静摩擦力和提供更大的加速度。</li></ul><p>人的生理结构决定了，若要向斜下方蹬地发力，则必须让发力腿的小腿和地面呈现一个 30° 至 60° 的夹角。最典型的例子是 100 米短跑。跑步项目的一个特点是它永远向前跑。因此运动员们在起步阶段会采用蹲立式起跑的方式获得极大的向前的加速度。但羽毛球的启动方向不确定，于是你必须用合理的方式启动，以便能够照顾尽可能多的潜在移动方向。这种合理的方式，即是所谓的「启动步」；具体来说，又有细分：</p><ul><li>当你预期主要向左右方向移动时，应做小跳&#x2F;分腿动作，将腿左右分开，以便向斜下方蹬地发力获得左右方向的加速度。一般而言，起高球应对对方进攻时应采用这种方式。</li><li>当你预期主要向前后方向移动时，应做小跳&#x2F;分腿动作，将腿前后分开，以便向斜下方蹬地发力获得前后方向的加速度。一般而言，自己处在仅供状态时应采用这种方式。</li></ul><p>总结一下。由于羽毛球运动移动的快速和不定向的特性、向斜下方蹬地发力的原理、人的生理结构特点，羽毛球的启动步是重要且必要的。若无合理的启动步，则往往无法击打到球，或只能陷入被动击球。</p><h2 id="启动步要领"><a href="#启动步要领" class="headerlink" title="启动步要领"></a>启动步要领</h2><p>此节我们讲解启动步的要领。首先我们从最简单的静止启动开始讲起，然后再过度到移动中的连贯启动步。</p><h3 id="从静止启动"><a href="#从静止启动" class="headerlink" title="从静止启动"></a>从静止启动</h3><p>首先是准备动作。</p><p>在对手可能击出攻击性的下压球的情况（你发后场高球、挑高球、击平高球、击高远球等），你应当采取双脚左右分立的防守站姿。具体来说，应当</p><ul><li>面向对手击球的方向，双腿左右分立与肩同宽，右脚可以适当向前半步；</li><li>双脚微踮，前脚掌着地、后脚跟微抬；</li><li>膝盖微屈、髋关节微屈；</li><li>上半身向前微弓；</li><li>左右大臂下垂、向外微张，持拍手在胸腹前，拍头在胸口正面前上方位置。</li></ul><p>在对手大概率作出防守的情况，你应当采取双脚前后分立的进攻站姿。具体来说，应当侧身使持拍手在前，面向对手击球方向，双腿前后分立与肩同宽，脚尖朝向斜前方向。其余身体姿态与防守站姿基本相同。</p><p>在对手引拍即将击球的瞬间，开始启动。具体来说：</p><ul><li>双腿分开（可以视情况带有一些小跳）到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里做一些额外说明。</p><ul><li>双腿分开的目的，是为了让小腿与地面呈现的角度便于蹬地发力。因此双腿分开的幅度不应过大（导致发力不便），也不应过小（导致更大比例的发力是水平向上而非水平）。</li><li>分腿&#x2F;小跳的瞬间，你尚未知晓对方的球路。因此<ul><li>在没有把握的情况下，不应做额外假设。也就是说，双腿分开应该基本呈现左右（防守站姿）或前后（进攻站姿），而非是斜前、斜后方向。若不然，将导致二次启动。</li><li>膝盖弯曲、降低重心的过程，需要紧盯对手击球动作和球路，迅速判断落点。</li></ul></li><li>前脚掌着地瞬间发力，不能迟疑。若不然，重心完全下沉后，反而不容易发力，造成二次启动。<ul><li>发力动作当是保证脚踝稳定性的前提下，使用小腿后侧肌肉群和大腿前侧肌肉群协同发力</li></ul></li></ul><h3 id="移动中连贯启动"><a href="#移动中连贯启动" class="headerlink" title="移动中连贯启动"></a>移动中连贯启动</h3><p>从静止启动是较为理想的情况，在实际对抗中较少出现。羽毛球球速极快，对手不可能等你回动到位后、站定后再击球。因此，更多的启动情况发生在回动的过程中的顺势连贯启动。</p><p>举例来说，当你在后场击出高远、平高球，你应当迅速回动至球场中部区域。在回动的过程，应密切注意观察对手击球情况，随时准备启动。此时，可能你尚在回动过程中。例如说，右手持拍的你，重心放在左腿上，而右腿正处在委屈膝盖向前迈步的阶段。此时你的启动应当是（其他情况类比即可）：</p><ul><li>右腿发力，顺势向左垫出一小步；右腿同时协同分开，双腿分开到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里着重讲一下顺势的含义。顺势在此处有几层含义：</p><ul><li>首先，你尚在从后向前回动的过程中，身体具有向前运动的惯性。因此，你主观上向左垫出的一小步，实际效果应当是向左前方垫出一小步。若是刻意在垫布的过程中改变方向向后垫步，则是一个容易导致受伤的动作。</li><li>其次，顺势表示不做过多调整。特别地，不能等待右脚落地，再从静止启动。这是因为你尚在向前回动过程中，若要让身体静止下来，势必要双脚着地、下沉重心。这实际上已经是一次启动，只不过是一次对抗自身惯性的一次启动而已。于是，这会事实上造成二次启动。</li></ul><p>为了做到这一点，我个人总结了四个字：<strong>快回·慢踩</strong>。也就是，</p><ul><li>在击球完成后瞬间，应当爆发式地回动。体现在后场正手击球上，就是（以右手持拍为例）左腿应该向后蹬直发力、同时收紧核心，以便快速抵消向后的冲力而后向前回动。这是「快回」。</li><li>「慢踩」是说，在回动的过程中，不用过于着急，而要保持重心稳定、适度慢踩，给移动中连贯启动留下空间。当然，「两步一冲」的李矛步除外。——那是杀上网、吊上网的连贯动作。</li></ul><h2 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h2><p>启动步本身值得持续练习。以下是从入门到高阶的一些练习方式。</p><ul><li>左右开合跳。<ul><li>起始姿势：双脚与肩同宽，前脚掌着地，膝盖微屈，双手向上合掌</li><li>动作（开跳）：发力向上跳，双脚分开至两倍肩宽，前脚掌着地，膝盖弯屈下沉重心，双手两侧分开平举</li><li>复位动作（合跳）：发力向上跳，双脚合拢至一倍肩宽，前脚掌着地，膝盖微屈，双手向上击掌</li><li>目的：强壮踝关节，锻炼小腿后侧肌肉群爆发力</li><li>30 个&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步）：双腿分开至两倍肩宽，膝盖弯曲下沉重心。</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地，回归起始姿势。</li><li>目的：启动步肌肉记忆。</li><li>15 慢速 + 15 快速&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动，左右蹬跨接杀步伐。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步 + 蹬跨）：双腿分开至两倍肩宽，膝盖弯曲下沉重心；单侧腿发力，转髋蹬跨。（注意弓箭步着地动作，避免受伤）</li><li>复位动作：蹬转回位。</li><li>目的：启动步肌肉记忆 + 左右蹬跨肌肉记忆。</li><li>15 个&#x2F;组，间隔 20s 做 3 组。</li></ul></li><li>交叉步行进间启动步（两步一启动为例，还可做一步一启动、交叉步后退中启动）。<ul><li>起始动作：先左后右分别迈步向前（击后场球回动）。</li><li>动作（行进间启动步）：重心在右腿，左腿微屈（第三步尚未踩下），右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：交叉步行进间启动连贯。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li><li>并步行进间启动步（两步一启动为例，还可做并步后退中启动）。<ul><li>起始动作：右脚在前，左脚在后，向前做一次并步（出右脚，左脚并步跟上）。</li><li>动作（行进间启动步）：第二次并步做一半，即是说出右脚，在左脚并步跟上的同时，右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：并步行进间启动丽娜管。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li></ul><!-- 谨以此文，献给我曾爱过的刘曼沁女士，祝她 30 周岁生日快乐~！ -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Footwork" scheme="https://liam.page/tags/Footwork/"/>
    
      <category term="Start Step" scheme="https://liam.page/tags/Start-Step/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上双开微信</title>
    <link href="https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/"/>
    <id>https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/</id>
    <published>2022-11-02T09:53:57.000Z</published>
    <updated>2022-11-20T06:16:50.322Z</updated>
    
    <content type="html"><![CDATA[<p>特点：</p><ul><li>不安装第三方插件，无封号之虞。</li><li>双击即可启动。</li><li>启动后不需要维持「终端」；事实上它会自动关闭。</li></ul><span id="more"></span><p>解法：</p><ul><li>打开终端，执行下列代码，而后在桌面双击 <code>WeChat.command</code> 即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将启动命令写入桌面上的文件 WeChat.<span class="built_in">command</span>；如果已有重名文件，请注意修改。</span></span><br><span class="line">echo &quot;nohup /Applications/WeChat.app/Contents/MacOS/WeChat &gt;/dev/null 2&gt;&amp;1 &amp;&quot; &gt; ~/Desktop/WeChat.command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予其可执行属性</span></span><br><span class="line">chmod +x ~/Desktop/WeChat.command</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不安装第三方插件，无封号之虞。&lt;/li&gt;
&lt;li&gt;双击即可启动。&lt;/li&gt;
&lt;li&gt;启动后不需要维持「终端」；事实上它会自动关闭。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="WeChat" scheme="https://liam.page/tags/WeChat/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Yonex AX100zz 打感自测</title>
    <link href="https://liam.page/2022/10/29/Yonex-AX100zz/"/>
    <id>https://liam.page/2022/10/29/Yonex-AX100zz/</id>
    <published>2022-10-29T10:48:51.000Z</published>
    <updated>2022-10-29T11:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是 Yonex AX100zz 的打感自测。</p><span id="more"></span><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>新入手的球拍（简写 AX100zz）情况：</p><ul><li>Yonex Astrox 100zz（老色，藏青色）</li><li>4U&#x2F;G6</li><li>保留底胶 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><p>作为对比，过去六年常用的球拍（简写 Arc11）情况：</p><ul><li>Yonex ArcSaber 11（老色，带亮黄色带）</li><li>3U&#x2F;G5</li><li>去除底胶 + 缓震膜 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><h2 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h2><p>挥重方面，实测 AX100zz 和 Arc11 的挥重接近。大约是因为 Arc11 去除底胶的缘故，实际平衡点有所前移。</p><p>挥速方面，相同发力的条件下，AX100zz 的挥速较 Arc11 慢。这主要应该是 AX100zz 采用盒式拍框而 Arc11 采用破风拍框的缘故。</p><p>中杆方面，AX100zz 的中杆相对较硬，但硬得有限。传统上，我们习惯用软硬来评价中杆。但 AX100zz 的中杆更为显著的特性是回弹快。这一特性是建立在实心中杆 + 钨丝的黑科技结构上的。这一特性要求你能用 AX100zz 做出足够快的挥速。若然，相较 Arc11，击球感明显更加干脆；若不然，AX100zz 的击球会显得有一些「木」。</p><p>这即是说，AX100zz 对小臂内旋和屈指发力的技术动作要求更高。而一旦动作到位，AX100zz 的击球球速会比 Arc11 要更快。</p><h2 id="后场击球"><a href="#后场击球" class="headerlink" title="后场击球"></a>后场击球</h2><p>高远方面，步伐到位的情况下，AX100zz 的击球感和 Arc11 差别不算很大；被动的情况下，AX100zz 会稍微更废力一些。</p><p>重杀方面，第一次杀球用的还是 Arc11 的发力习惯。相较而言，球路稍微有些发飘，落点更长。稍作调整后，能够感受到更明显的下压感，暴击音也不出期待地非常舒爽。按对手的反馈，球速有区别，但不大。</p><p>点杀方面。有重杀的经验，点杀时加大了屈指的力量，效果喜人。实战中，头顶突击点杀对角，落点可以比较轻松做到在发球线附近。相同的条件，Arc11 打出同样的落点个人感觉更困难一些。</p><p>劈杀方面，这本身不是我可称擅长的技术，平时用得也偏少。实战中，尝试正手区劈杀斜线，许是还没有完全适应发力变化的缘故，总体感觉和 Arc11 区别不算大。</p><p>吊球方面，劈吊和 Arc11 区别不大；而滑板吊的动作由于本身发力更难，使用 AX100zz 的失误率比 Arc11 要明显高一些。</p><p>反手高远方面，AX100zz 对发力的要求明显更高。前三拍感觉都没能很好发力，打得有点木木的。调整后整体感觉 AX100zz 明显吃力一些。</p><h2 id="前场击球"><a href="#前场击球" class="headerlink" title="前场击球"></a>前场击球</h2><p>个人感觉，前场的搓放由于发力小而巧，影响回球质量更多的是拍面大小和拍线（型号和磅数）。实际 AX100zz 的拍面和 Arc11 相比只是稍微小一些，而拍线又完全相同（穿线师傅都是同一个），整体感觉前场搓放差异不大。但是，不知是不是错觉，使用 AX100zz 做假动作搓放时，感觉更得心应手一些。</p><p>挑推方面，个人感觉差异不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>4U 版本的 AX100zz 属于相对容易上手的高端拍。但其对发力的要求，不那么糖水，需要更短粗的爆发发力才能驾驭。</p><p>个人意见，可以视作是 3U 版本 Arc11 的进攻加强版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇是 Yonex AX100zz 的打感自测。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Yonex" scheme="https://liam.page/tags/Yonex/"/>
    
      <category term="Racket" scheme="https://liam.page/tags/Racket/"/>
    
  </entry>
  
  <entry>
    <title>为英文信件选用合适的结束语</title>
    <link href="https://liam.page/2022/06/19/Email-Closing-Lines/"/>
    <id>https://liam.page/2022/06/19/Email-Closing-Lines/</id>
    <published>2022-06-19T09:55:23.000Z</published>
    <updated>2022-06-20T04:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。</p><span id="more"></span><h2 id="对熟人"><a href="#对熟人" class="headerlink" title="对熟人"></a>对熟人</h2><p>从自然到刻意，可选项有：</p><ul><li>什么都不留：都已经比较熟悉了，还留啥结束语呢？</li><li>XOXO：这是表示好友间拍对方屁股那种熟稔的情感表达。</li><li>Tnx：Thanks 的缩写，因为是熟人，所以缩写也没毛病。</li><li>Love&#x2F;With Love&#x2F;Much love：刻意程度依次增加，但都还好。</li><li>Sincerely：熟人用 Sincerely 还是可以的，但是显得刻意。</li><li>Yours truly&#x2F;Yours sincerely：就很刻意有没有！</li></ul><h2 id="对不熟悉的人"><a href="#对不熟悉的人" class="headerlink" title="对不熟悉的人"></a>对不熟悉的人</h2><p>从自然到刻意，可选项有：</p><ul><li>Best&#x2F;Best regards：万金油，如果拿捏不准，就一个 Best 完事儿就好了。完全体的 Best regards 会显得有些生分，初次沟通可以用。</li><li>Cheers：好像是和不熟悉的人，远远干一杯的感觉。</li><li>Sincerely：跟不熟悉的人说 Sincerely 也是合适的，而且因为不熟悉，所以也不会显得那么刻意。</li><li>All the best：不那么自然，但是也不会显得刻意。相对来说比较正式。</li><li>Thank you：正常人谁说「Thank you」呀！</li><li>With warm regards：艾玛，老古板的形象跃然纸上啊哈哈哈！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Mail" scheme="https://liam.page/tags/Mail/"/>
    
      <category term="E-Mail" scheme="https://liam.page/tags/E-Mail/"/>
    
      <category term="Closing" scheme="https://liam.page/tags/Closing/"/>
    
  </entry>
  
  <entry>
    <title>提升时间机器（Time Machine）的备份速度</title>
    <link href="https://liam.page/2022/05/07/speed-up-time-machine-backup/"/>
    <id>https://liam.page/2022/05/07/speed-up-time-machine-backup/</id>
    <published>2022-05-07T09:47:17.000Z</published>
    <updated>2022-05-07T09:56:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。</p><span id="more"></span><p>经查，类似时间机器备份或是自 MAS 下载和安装软件的行为，苹果将其优先级调低，并设置有限流（throttle）这一设定。这是为了保证这些优先级较低的行为不会占用过多的系统资源，干扰正常的工作。</p><p>这个设定的出发点是好的，但存在一个问题。比如说，对我而言，使用时间机器备份通常发生在无需使用电脑工作的时间段。此时，限流的这个设定就十分让人蛋疼了。为此，我们可以在命令行暂时关闭限流，待备份完成后再重新打开。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭限流功能，加速备份</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=0</span><br><span class="line"><span class="comment"># 备份完成，重新打开限流功能，避免意外的干扰</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="Time Machine" scheme="https://liam.page/tags/Time-Machine/"/>
    
  </entry>
  
  <entry>
    <title>设计一个线程池</title>
    <link href="https://liam.page/2022/05/05/design-a-thread-pool/"/>
    <id>https://liam.page/2022/05/05/design-a-thread-pool/</id>
    <published>2022-05-05T12:30:35.000Z</published>
    <updated>2022-05-05T15:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。</p><span id="more"></span><h2 id="初步讨论"><a href="#初步讨论" class="headerlink" title="初步讨论"></a>初步讨论</h2><h3 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h3><p>自 C++11 起，在 C++ 中使用线程就变得很简单。最基本地，可以用 <code>std::thread</code> 来管理一个线程。若是要异步地执行任务，搭配使用 <code>std::async</code> 和 <code>std::future</code> 也很方便。在有这些基础设施的基础上，我们为什么还需要线程池？或者说，我们什么时候需要线程池？</p><p>众所周知，线程作为一种系统资源，其创建和销毁是需要时间的。因此，如果创建和销毁线程的时间和执行任务所需的时间处在同一个数量级，那么频繁地创建和销毁线程带来的性能损耗就会变得十分可观。此时，我们就要考虑使用线程池。</p><h3 id="线程池应有哪些特点？"><a href="#线程池应有哪些特点？" class="headerlink" title="线程池应有哪些特点？"></a>线程池应有哪些特点？</h3><p>线程池的本质就是一组待用的线程。在 C++ 中，它可以表示为一个 <code>std::thread</code> 的数组或是向量。在实际工程中，为便于进行可能的扩展，使用 <code>std::vector&lt;std::thread&gt;</code> 显然会更加合适。</p><p>对于线程池中的每个线程，它都可能在某个时刻接收到一个任务。而这个任务具体是什么，在线程创建时并不知道。用 C++ 的语言表达就是说，线程池中的线程：</p><ul><li>应当可以执行任意函数——支持任何参数列表，也支持任何返回值类型；</li><li>应当可以将任务的执行结果反馈给任务的发布者；</li><li>应当可以在需要时被唤醒执行任务，而在无需时不占用过多 CPU 资源；</li><li>应当可以被主控线程控制，在适当的时候暂停任务、停止接收任务、丢弃未完成任务等。</li></ul><p>对于第一条，modern C++ 的做法应该是利用 <code>functional</code> 头文件提供的基础设施（<code>std::bind</code>, <code>std::function</code> 等）结合模板参数包来实现。对于第二条，old-fashion 的做法是在发布任务时同时注册回调函数；modern C++ 的做法应该是利用 <code>std::packaged_task</code> 结合 <code>std::future</code> 来实现。对于第三条，若是任务来得不那么频繁，应当考虑使用 <code>std::condition_variable</code> 来实现；若是任务十分频繁，则可以考虑使用 <code>std::this_thread::yield</code>。对于第四条，则可以设置一个内部变量作为标记，让每个工作线程都定期检查该标记来实现。</p><p>我们讨论到了任务。显然，我们会需要一个线程安全的队列来管理其他线程发布的任务。</p><h2 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h2><p>我们不妨直接从代码入手，逐步分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocking_queue</span> : <span class="keyword">protected</span> std::queue&lt;T&gt; &#123;  <span class="comment">// 1.</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> wlock = std::unique_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.a</span></span><br><span class="line">  <span class="keyword">using</span> rlock = std::shared_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.b</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">blocking_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">blocking_queue</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">blocking_queue</span>(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="built_in">blocking_queue</span>(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.b</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>; <span class="comment">// 3.c</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.d</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.a</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.b</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.a</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">push</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.b</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">emplace</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; holder)</span> </span>&#123;  <span class="comment">// 6.</span></span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      holder = std::<span class="built_in">move</span>(std::queue&lt;T&gt;::<span class="built_in">front</span>());</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::shared_mutex mtx_;  <span class="comment">// 7.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>blocking_queue</code> 继承 <code>std::queue</code>，最基本的队列的实现交给标准库。</li><li>利用 <code>std::shared_mutex</code> 结合 <code>std::unique_lock</code> 和 <code>std::shared_lock</code> 实现读写锁。</li><li>此处我们禁用了拷贝和移动构造函数及对应的赋值运算符。这纯粹是因为在实现线程池的过程中我们用不到它们。如果需要，是可以按需实现的。</li><li>在两个 observers 当中，我们使用了只读锁。</li><li><code>push</code> 和 <code>emplace</code> 是类似的操作，都是在队尾追加元素。他们的区别与联系就和标准库容器的接口一样。注意在 <code>emplace</code> 当中，我们用到了完美转发技术。</li><li>这里的 <code>pop</code> 其实更合适称作 <code>try_pop</code>。因为 <code>pop</code> 动作在此处并不一定成功，在队列为空时，函数返回 <code>false</code> 而不会对队列做任何修改。</li><li>这是一把针对整个队列的粗粒度锁。实际上，因为队列的 push 和 pop 一定程度上是分开的，小心地话，可以实现一个细粒度版本的锁，在 push 和 pop 操作都频繁的情况下会有显著的性能提升。关于这一点，我们之后可以单列一篇文章进行讨论。</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>按先前的讨论，我们可以整理出线程池的大致模样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;  <span class="comment">// stop and process all delegated tasks</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">()</span></span>;     <span class="comment">// stop and drop all tasks remained in queue</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 2.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_running</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;  <span class="comment">// 4.</span></span><br><span class="line">  <span class="keyword">mutable</span> blocking_queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks_;  <span class="comment">// 5.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一组的三个接口是整个线程池的控制接口。<code>init</code> 接口启动线程池，其参数 <code>num</code> 即是线程池中线程的数量。<code>terminate</code> 接口终止线程池，不再接受新的任务，并保证将已接受的任务处理完毕。<code>cancel</code> 与 <code>terminate</code> 类似，但它将丢弃已接受但未处理完毕的任务。</li><li>第二组的三个接口均是 observers。</li><li>第三组中的唯一一个接口是线程池接受外部任务的接口。它和标准库提供的 <code>std::async</code> 几乎一致，接受任意函数，并返回一个 <code>std::future</code>。</li><li>这是线程池本体。</li><li>这是任务队列。</li></ol><h3 id="线程池的控制接口"><a href="#线程池的控制接口" class="headerlink" title="线程池的控制接口"></a>线程池的控制接口</h3><p>接下来我们讨论控制接口的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::init</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_, [<span class="keyword">this</span>, num]() &#123;  <span class="comment">// 1.</span></span><br><span class="line">    wlock <span class="built_in">lock</span>(mtx_);  <span class="comment">// 2.</span></span><br><span class="line">    stop_ = <span class="literal">false</span>;</span><br><span class="line">    cancel_ = <span class="literal">false</span>;</span><br><span class="line">    workers_.<span class="built_in">reserve</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      workers_.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;threadpool::spawn, <span class="keyword">this</span>));  <span class="comment">// 3.a</span></span><br><span class="line">    &#125;</span><br><span class="line">    inited_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::spawn</span><span class="params">()</span> </span>&#123;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">bool</span> pop = <span class="literal">false</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">      cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, &amp;pop, &amp;task] &#123;</span><br><span class="line">        pop = tasks_.<span class="built_in">pop</span>(task);</span><br><span class="line">        <span class="keyword">return</span> cancel_ || stop_ || pop;  <span class="comment">// 4.</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cancel_ || (stop_ &amp;&amp; !pop)) &#123;  <span class="comment">// 5.a</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 5.b</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::terminate</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.a</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      stop_ = <span class="literal">true</span>;  <span class="comment">// 7.a</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::cancel</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.b</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      cancel_ = <span class="literal">true</span>;  <span class="comment">// 7.b</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tasks_.<span class="built_in">clear</span>();  <span class="comment">// 8.</span></span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> threadpool::_is_running() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> inited_ &amp;&amp; !stop_ &amp;&amp; !cancel_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>init</code> 完成的工作，在逻辑上只能进行一次。但我们无法保证用户代码确实如我们所想地这样执行。因此，我们利用 <code>std::call_once</code> 保证相关工作只执行一次。</li><li>因为涉及到修改 <code>threadpool</code> 的状态，所以此处使用写入锁。</li><li><code>spawn</code> 接口是线程函数，也就是线程启动后一直运行的函数。</li><li>当线程被唤醒时（无论是意外唤醒，还是被 <code>notify_*</code> 函数唤醒），若线程池没有被 <code>cancel</code> 或是 <code>terminate</code>，也没能从任务队列中取出任务，则线程应该继续沉眠，否则就应该醒来继续处理。</li><li>如果线程池被 <code>cancel</code>，则不执行当前任务；如果线程池被停止并且没能从任务队列中取出任务，则也不执行当前任务；否则就执行当前任务。</li><li><code>terminate</code> 和 <code>cancel</code> 的实现几乎完全相同；</li><li>唯独 <code>terminate</code> 修改 <code>stop_</code> 变量而 <code>cancel</code> 修改 <code>cancel_</code> 变量。</li><li>此外，<code>cancel</code> 接口显式地清空了任务队列。</li></ol><h3 id="线程池的观察器"><a href="#线程池的观察器" class="headerlink" title="线程池的观察器"></a>线程池的观察器</h3><p>观察器比较简单，唯一值得一提的是这里使用了读取锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::inited</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> inited_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::is_running</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> _is_running();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">threadpool::size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> workers_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务接口"><a href="#任务接口" class="headerlink" title="任务接口"></a>任务接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">threadpool::async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">return_t</span> = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 1.a</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">future_t</span> = std::future&lt;<span class="type">return_t</span>&gt;;  <span class="comment">// 1.b</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">task_t</span> = std::packaged_task&lt;<span class="built_in">return_t</span>()&gt;;  <span class="comment">// 1.c</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span> (stop_ || cancel_)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">          <span class="string">&quot;Delegating task to a threadpool &quot;</span></span><br><span class="line">          <span class="string">&quot;that has been terminated or canceled.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bind_func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);  <span class="comment">// 3.</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">task_t</span>&gt; task = std::<span class="built_in">make_shared</span>&lt;<span class="type">task_t</span>&gt;(std::<span class="built_in">move</span>(bind_func));  <span class="comment">// 4.a</span></span><br><span class="line">  <span class="type">future_t</span> fut = task-&gt;<span class="built_in">get_future</span>();  <span class="comment">// 4.b</span></span><br><span class="line">  tasks_.<span class="built_in">emplace</span>([task]() -&gt; <span class="type">void</span> &#123; (*task)(); &#125;);  <span class="comment">// 5.</span></span><br><span class="line">  cond_.<span class="built_in">notify_one</span>();  <span class="comment">// 6.</span></span><br><span class="line">  <span class="keyword">return</span> fut;  <span class="comment">// 4.c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>using</code> 定义的三个类型，见文知意。</li><li>这里不涉及对线程池状态的修改，因此只需要读取锁即可。显然，此处我们禁止对已经 <code>terminate</code> 或是 <code>cancel</code> 的线程池继续发布任务。</li><li>由于任务队列只接收 <code>std::function&lt;void()&gt;</code> 的可调用对象，此处我们利用 <code>std::bind</code> 先匹配参数列表。</li><li>此处我们利用 <code>std::packaged_task</code> 将待执行的任务与一个 <code>std::future</code> 关联起来，并将 <code>std::future</code> 返回给外界，以便任务发布者可以在将来取得任务执行结果。</li><li>这里我们利用一个 lambda，既执行了任务，又将返回值抹去（但会被 future 管理），以便匹配 <code>std::function&lt;void()&gt;</code>。</li><li>此处我们通过条件变量唤醒工作线程。</li></ol><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>完整实现可见 <a href="https://github.com/Liam0205/toy-threadpool">Liam0205&#x2F;toy-threadpool</a>，其中包括了单元测试和相比 <code>std::async</code> 的性能对比。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>这里我们实现了一个可看使用的线程池。但如 GitHub 的 repo 名字一样，它还只是个玩具。若要在工程中使用，还可以做一系列优化。例如说：</p><ul><li>对线程安全队列进行优化，使用更细粒度的锁（完整实现当中已有），或者换用无锁实现。</li><li>完善的线程池，除了支持本文提到的几种状态，还可以有暂停、扩张（任务过多时自动扩张）、收缩（空闲线程过多时自动收缩）等能力。</li></ul><p>这些内容都可以继续去深挖、优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Thread" scheme="https://liam.page/tags/Thread/"/>
    
      <category term="Threadpool" scheme="https://liam.page/tags/Threadpool/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS Monterey 12.3 上因缺失 Python 2.7 导致的问题</title>
    <link href="https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/"/>
    <id>https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/</id>
    <published>2022-04-01T04:10:06.000Z</published>
    <updated>2022-04-16T12:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Termination Reason: Namespace DYLD, Code 1 Library missing</span><br><span class="line">Library not loaded: /System/Library/Frameworks/Python.framework/Versions/2.7/Python</span><br><span class="line">Referenced from: /Applications/CHIRP.app/Contents/CHIRP</span><br><span class="line">Reason: tried: &#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file), &#x27;/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file)</span><br></pre></td></tr></table></figure><p>这是由于 Apple 在 macOS Monterey 12.3 开始，<a href="https://developer.apple.com/documentation/macos-release-notes/macos-12_3-release-notes#Python">移除了随系统发行的 Python 2.7</a>；于是，尚在依赖 Python 2.7 的 App 在启动时的动态链接阶段就会出错而崩溃。</p><p>考虑到部分 App 尚未更新以解除对 Python 2.7 的依赖，这里我们需要手动安装 Python 2.7。为此，我们可在 Python 官网上找到历史版本（<a href="https://www.python.org/ftp/python/2.7.18/python-2.7.18-macosx10.9.pkg">Python 2.7.18</a>）并下载安装。按我的经验，自主安装 Python 2.7.18 之后，问题即得到解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Monterey" scheme="https://liam.page/tags/Monterey/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑬）：C++ 的内存顺序·下</title>
    <link href="https://liam.page/2021/12/14/memory-order-cpp-03/"/>
    <id>https://liam.page/2021/12/14/memory-order-cpp-03/</id>
    <published>2021-12-13T16:14:42.000Z</published>
    <updated>2021-12-18T11:52:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于<a href="/2021/06/05/memory-model-cpp/">内存模型</a>和内存顺序（<a href="/2021/06/06/memory-order-cpp-01/">上</a>、<a href="/2021/12/11/memory-order-cpp-02/">中</a>）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。</p><p>此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。</p><span id="more"></span><h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>让我们从一个最简单的生产者&#x2F;消费者的例子出发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;  <span class="comment">// 1.a.</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 1.b.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">1024</span>);  <span class="comment">// 2.</span></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready.<span class="built_in">load</span>()) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; data[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 5.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::thread a&#123;producer&#125;, b&#123;consumer&#125;;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，(1) 初始化了全局共享的数据 <code>data</code> 和原子标记 <code>ready</code>。生产者线程中，(2) 对全局共享的数据进行修改，并在 (3) 处将标记设置为 <code>true</code>。消费者线程中，(4) 循环等待原子标记（当然，它效率极低；作为示例我们暂时忽略这个问题），而后在 (5) 处读取共享数据。</p><p>我们知道，在多个线程中，并发读写同一个内存位置（此处的 <code>&amp;data[0]</code>）可能造成数据竞争，必须有相应的同步机制。此处同步机制由原子标记 <code>ready</code> 协助建立。</p><ul><li>(2) <ins>先于（happens-before）</ins> (3)；</li><li><strong>当 (4) 读到 <code>ready.load()</code> 为真</strong>，则 (3) 与 (4) 建立<ins>同步（synchronizes-with）</ins>关系，因而有 (3) <ins>先于（happens-before）</ins> (4)；</li><li>(4) <ins>先于（happens-before）</ins> (5)。</li></ul><p>在原子标记 <code>ready</code> 的协助下，我们建立了对 <code>data</code> 的写<ins>先于（happens-before）</ins>读的顺序关系，数据竞争的风险就此解除。</p><p>整体看下来，这一过程非常符合直觉。而我们知道，原子变量除了保证其上原子操作的原子性之外，各个操作还有内存顺序标记。不同的顺序标记会影响编译器优化和 CPU 执行时的行为；更准确地，影响原子操作附近访问内存的顺序。默认的顺序标记是 <code>std::memory_order_seq_cst</code>。之所以将它作为默认标记，是因为它能带来这一符合直觉的结果。</p><p>接下来，我们顺势讨论<ins>先于（happens-before）</ins>关系和<ins>同步（synchronizes-with）</ins>关系。</p><h2 id="两种关系"><a href="#两种关系" class="headerlink" title="两种关系"></a>两种关系</h2><h3 id="同步（synchronizes-with）关系"><a href="#同步（synchronizes-with）关系" class="headerlink" title="同步（synchronizes-with）关系"></a><ins>同步（synchronizes-with）</ins>关系</h3><p><ins>同步（synchronizes-with）</ins>关系，追根究底只能由原子操作提供。我们能见到的所有产生同步关系的办法，其底层都包含了某些原子操作。同步关系是这样建立的，</p><ul><li>首先有在线程 A 中对原子变量 <code>x</code> 打上恰当标记的写入操作 <code>W</code>；</li><li>而后有在线程 B 中对原子变量 <code>x</code> 打上恰当标记的读取操作 <code>R</code>。</li></ul><p>若 <code>R</code> 读到的值，来自以下任意一种情况，则说 <code>W</code> 与 <code>R</code> <ins>同步（synchronizes-with）</ins>。</p><ul><li><code>W</code> 的写入；或者</li><li>线程 A（<code>W</code> 所在线程）中，<code>W</code> 之后的某次写入；或者</li><li>任意线程中的一系列 read-modify-write 操作中的写入值，其中第一次 read-modify-write 操作读到的值来自 <code>W</code> 的写入。</li></ul><p>这得到一个最基本的认知：（在顺序标记恰当的情况下，）如果线程 B 的读取操作读到的是线程 A 的写入操作的写入值，则写入操作与读取操作同步。</p><p>如此一来，所有的细节就在「恰当」二字之上了。不过，我们先来讨论<ins>先于（happens-before）</ins>关系。</p><h2 id="先于（happens-before）关系"><a href="#先于（happens-before）关系" class="headerlink" title="先于（happens-before）关系"></a><ins>先于（happens-before）</ins>关系</h2><p><ins>先于（happens-before）</ins>关系是讨论内存顺序中最重要的基石。若 A <ins>先于（happens-before）</ins> B，则 B 能看到 A 带来的副作用。</p><p>在单线程里面，<ins>先于（happens-before）</ins>关系很简单。单线程当中的<ins>先于（happens-before）</ins>关系即是<ins>先序（sequenced-before）</ins>关系。一般来说，不考虑编译器优化重排和 CPU 乱序执行重排时，在代码当中，靠前的语句当中的操作<ins>先于（happens-before）</ins>靠后的语句当中的操作。但实际上，我们需要考虑编译器优化和 CPU 乱序执行对先序关系带来的影响。</p><p>在线程之间，若线程 A 的写入操作与线程 B 的读取操作<ins>同步（synchronizes-with）</ins>，则该写入操作<ins>线程间先于（inter-thread happens-before）</ins>该读取操作，也因此该写入操作<ins>先于（happens-before）</ins>该读取操作。</p><h2 id="三种顺序模型"><a href="#三种顺序模型" class="headerlink" title="三种顺序模型"></a>三种顺序模型</h2><p>按前文，顺序标记共有六种：</p><ul><li><code>std::memory_order_relaxed</code></li><li><code>std::memory_order_consume</code></li><li><code>std::memory_order_acquire</code></li><li><code>std::memory_order_release</code></li><li><code>std::memory_order_acq_rel</code></li><li><code>std::memory_order_seq_cst</code></li></ul><p>六种标记又能组成三种顺序模型：</p><ul><li>顺序一致模型（sequentially consistent ordering）：最强的顺序模型。对编译器优化限制最多，所需额外 CPU 同步指令最多，性能也最差；但最符合直觉。涉及到的顺序标记是 <code>std::memory_order_seq_cst</code>。</li><li>宽松模型（relaxed ordering）：最弱的顺序模型。对编译器优化限制最少（几乎没有），所需额外 CPU 同步指令最少（几乎没有），性能也最好；但无法建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_relaxed</code>。</li><li>获取-释放模型（acquire-release ordering）：介于二者之间。对编译器优化限制适中，所需额外的 CPU 同步指令也适中（在部分平台上，不许额外同步指令），性能也适中；可以建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_acq_rel</code>, <code>std::memory_order_acquire</code>, <code>std::memory_order_release</code> 和 <code>std::memory_order_consume</code>。</li></ul><blockquote><p>注意，<code>std::memory_order_consume</code> 与 <code>std::memory_order_acquire</code> 相似，但比后者更弱。但完整地实现 <code>std::memory_order_consume</code> 的语义，需要追踪变量之间的依赖链。目前，还没有已知的编译器实现了它。现有的编译器，都将 <code>std::memory_order_consume</code> 提升为 <code>std::memory_order_acquire</code>。故而此处也将 <code>std::memory_order_consume</code> 归在获取-释放模型当中。此外，考虑 <code>std::memory_order_consume</code> 的语义可能发生变化，目前标准也不建议使用 <code>std::memory_order_consume</code>。</p></blockquote><h3 id="顺序一致模型（sequentially-consistent-ordering）"><a href="#顺序一致模型（sequentially-consistent-ordering）" class="headerlink" title="顺序一致模型（sequentially consistent ordering）"></a>顺序一致模型（sequentially consistent ordering）</h3><p>默认的顺序模型是「顺序一致模型」。如果所有原子操作的顺序标记都是 <code>std::memory_order_seq_cst</code>，那么多线程程序的行为就好像这些操作以某一特定的顺序在单一的线程中执行一样。特别地，站在所有被打上 <code>std::memory_order_seq_cst</code> 标记的操作上来看，所有先于该操作发生的原子操作（<code>std::memory_order_seq_cst</code>），都具有同样的顺序。</p><p>这是最符合直觉的模型。多数人第一次接触到多线程，会假定多线程中的各个操作是可能并发执行的，因此将他们理解为按照某个不确定的顺序穿插执行。然后在脑海中想象并构建这一固定的顺序，并按照这一顺序假定各个线程会如何工作。但这种符合直觉的模型并不总是成立。这种多线程之间全局统一的顺序，即是顺序一致性带来的保证。一旦保证不了顺序一致性，则这种基于「穿插执行」假定出来的全局统一顺序也就不成立了。</p><!-- From the point of view of synchronization, a sequentially consistent store synchronizes-with a sequentially consistent load of the same variable that reads the value stored. This provides one ordering constraint on the operation of two (or more) threads, but sequential consistency is more powerful than that. Any sequentially con- sistent atomic operations done after that load must also appear after the store to other threads in the system using sequentially consistent atomic operations. The example in listing 5.4 demonstrates this ordering constraint in action. This constraint doesn’t carry forward to threads that use atomic operations with relaxed memory orderings; they can still see the operations in a different order, so you must use sequentially con- sistent operations on all your threads in order to get the benefit. --><p>站在同步的角度来看，顺序一致 store 操作与读到本次写入值的顺序一致的 load 操作<ins>同步（synchronizes-with）</ins>。如前所述，这种同步关系在线程之间提供了一定的顺序限制。但顺序一致模型还保证，在这一顺序一致的 load 操作之后的顺序一致操作，在其他所有使用顺序一致原子操作的线程看来，也是发生在此次顺序一致 store 之后的。注意，如若某一线程中的某个原子操作没有使用 <code>std::memory_order_seq_cst</code> 标记，则在该操作看来，顺序一致的诸多操作的顺序可能与其他线程看到的不同。</p><p>前作当中的<a href="/2021/12/11/memory-order-cpp-02/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E9%A1%BA%E5%BA%8F%EF%BC%88Sequentially-consistent-ordering%EF%BC%89">例子</a>很好地说明了顺序一致性的效果。</p><!-- This ease of understanding can come at a price, though. On a weakly ordered machine with many processors, it can impose a noticeable performance penalty, because the overall sequence of operations must be kept consistent between the pro- cessors, possibly requiring extensive (and expensive!) synchronization operations between the processors. That said, some processor architectures (such as the common x86 and x86-64 architectures) offer sequential consistency relatively cheaply, so if you’re concerned about the performance implications of using sequentially consis- tent ordering, check the documentation for your target processor architectures. --><p>这种便利是有代价的。在默认的顺序保证相对较弱的平台上（如 ARM），顺序一致模型会引入可观的性能代价。这是因为，全局顺序一致需要在 CPU 逻辑核心之间保持一致性，这使得 CPU 逻辑核心之间需要使用代价高昂的同步操作。相较而言，部分处理器架构（例如 x86 和 x86-64）保证顺序一致性的代价较低。为避免这种同步代价，我们需要拥抱非顺序一致性模型。</p><hr><p>在处理非顺序一致性模型时，我们就要丢弃脑海中那种简洁漂亮的交替执行的思维模型。<strong>它不存在了</strong>。在没有顺序一致性保障的情况下，各个线程看到的原子操作的顺序并不保证统一。也就是说，虽然依旧是并发（所以穿插执行），但是每个线程看到的穿插的顺序可能是不一样的。在非顺序一致模型下写代码时，要时刻关注这一点。</p><p>不过，也有一致的地方。虽说各个线程观察到的原子操作发生的顺序可能不一致，但是，对于<strong>每一个特定的原子变量</strong>，作用在其上的原子操作的修改顺序（modification-order），在各个线程看来是统一的。</p><p>为了充分理解非顺序一致性模型，我们可以先考虑宽松模型。待对非顺序一致性有足够了解之后，再回到获取-释放模型。</p><h3 id="宽松模型（relaxed-ordering）"><a href="#宽松模型（relaxed-ordering）" class="headerlink" title="宽松模型（relaxed ordering）"></a>宽松模型（relaxed ordering）</h3><p>顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作不参与构建<ins>同步（synchronizes-with）</ins>关系。在同一线程中，对<strong>同一</strong>原子变量的原子操作的顺序遵循源代码中的<ins>先序（sequenced-before）</ins>关系（从而有<ins>先于（happens-before）</ins>关系）。但是，在另外的线程看来，这种顺序无法保证。由于未加任何同步限制，顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作只是简单地遵循各个原子变量自身的修改顺序（modification-order）而已。</p><p>首先看一段简单的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    z.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(<span class="number">0</span> != z.<span class="built_in">load</span>());  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照经典的「穿插思维模型」（即顺序一致性模型），(3) 处循环等待直到 <code>y</code> 为真，那么<strong>由于 (1) 先于 (2) 发生，(3) 先于 (4) 发生</strong>，所以 (4) 必然为真，因此 (5) 的断言永不失效。但实际上，由于 (1) -- (4) 的顺序标记都是 <code>std::memory_order_relaxed</code>，此处并无同步保证，也没有单线程中的先序关系保证。这也就是说，上述两个先于关系不一定成立；即便成立，(2) 不必然与 (3) <ins>同步（synchronizes-with）</ins>，因此也就无法传递上述两个先于关系。所以站在 (4) 的角度看，并不保证 (1) <ins>先于（happens-before）</ins> (4) 发生。所以 (4) 可能读到 <code>false</code> 导致断言失败。</p><p>接下来再看一个更加复杂的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> upper&#123;<span class="number">10UL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Snapshot t1[upper];</span><br><span class="line">Snapshot t2[upper];</span><br><span class="line">Snapshot t3[upper];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;* var, Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.a.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.a.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.a.</span></span><br><span class="line">    var-&gt;<span class="built_in">store</span>(i + <span class="number">1</span>, std::memory_order_relaxed);  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; snapshot.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; snapshot.y &lt;&lt; <span class="string">&quot;)&quot;</span>;  <span class="comment">// 5.</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">T1</span><span class="params">(increase, &amp;x, t1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T2</span><span class="params">(increase, &amp;y, t2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T3</span><span class="params">(observe, t3)</span></span>;</span><br><span class="line"></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 1.c.</span></span><br><span class="line"></span><br><span class="line">  T3.<span class="built_in">join</span>();</span><br><span class="line">  T2.<span class="built_in">join</span>();</span><br><span class="line">  T1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(t1);</span><br><span class="line">  <span class="built_in">print</span>(t2);</span><br><span class="line">  <span class="built_in">print</span>(t3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">(0,2),(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,10),(9,10)</span><br><span class="line">(0,0),(0,1),(0,2),(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9)</span><br><span class="line">(1,3),(2,4),(2,5),(3,6),(4,7),(5,8),(6,8),(7,9),(8,10),(8,10)</span><br></pre></td></tr></table></figure><p>我们首先来观察一下代码和结果。</p><p>代码部分，</p><ul><li><code>increase</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 次循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中，而后以 <code>std::memory_order_relaxed</code> 的顺序标记更新 <code>var</code> 指向的原子变量（要么是 <code>x</code>，要么是 <code>y</code>）。</li><li><code>observe</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 词循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中。</li><li><code>print</code> 打印历次循环得到的快照 (5)。每个二元组中，第一个数是当次循环读到的 <code>x</code> 的值；第二个数是对应的 <code>y</code> 的值。</li><li><code>ready</code> 变量确保三个线程在几乎相同的时间开始，以防（例如说）<code>T1</code> 已经执行完毕而 <code>T3</code> 还尚未开始执行。</li></ul><p>结果部分，</p><ul><li>第一行、第二行、第三行分别记录了 <code>T1</code>, <code>T2</code>, <code>T3</code> 在历次循环过程中记录下来的 <code>x</code> 和 <code>y</code> 的值的快照。</li><li>关于写<ul><li>对于 <code>T1</code> 来说，只有该线程修改 <code>x</code> 的值，每次读到它，都恰好自增 <code>1</code>；</li><li>同样对于 <code>T2</code> 来说，<code>y</code> 每次自增 <code>1</code>。</li></ul></li><li>关于读<ul><li>对于 <code>T1</code> 和 <code>T3</code> 来说，它们只读 <code>y</code> 的值。因为 <code>y</code> 的修改序列中，<code>y</code> 的值是递增的；因此 <code>T1</code> 和 <code>T3</code> 每次读到的 <code>y</code> 的值都不小于前一次读到的 <code>y</code> 的值；但递增的步长不一定均衡。</li><li>对于 <code>T2</code> 和 <code>T3</code> 来说，它们只读 <code>x</code> 的值。基于同样的理由，它们每次读到的 <code>x</code> 的值都是非递减的；但递增的步长不一定均衡。</li></ul></li></ul><p>这里我们只给出了一个可能的结果，实际上，符合上述规律的结果，都是可能出现的。</p><p>接下来我们正式地描述宽松模型下的规律。</p><ul><li>对于任意给定的原子变量，其<ins>修改顺序（modification-order）</ins>是全局唯一的。</li><li>对于任意线程，<ul><li>若未曾读取过该变量的值，则可能读取到修改顺序上任意可能的值。</li><li>一旦读取了某个原子变量在修改顺序上的某个值，将来再读取时，要么读取相同的值，要么读取到在修改顺序上更靠后的值，而不可能读到在修改顺序上更靠前的值。</li></ul></li><li>对于任意线程，一旦写入了某个原子变量，将来再读取时，要么读取到此次写入的值，要么读取到修改顺序上相对此次写入更靠后的值。</li></ul><p>我们可以使用这一规律来回顾本节第一段代码。对于变量 <code>x</code> 来说，其修改顺序是：默认值 <code>false</code>，由 <code>write_x_then_y</code> 写入的值 <code>true</code>。在 <code>read_y_then_x</code> 线程当中，由于从未读取过 <code>x</code> 的值，因此可能读到 <code>x</code> 的修改顺序上的任意值。——可能是 <code>false</code>，亦可能是 <code>true</code>。故而断言可能失败。</p><h3 id="获取-释放模型（acquire-release-ordering）"><a href="#获取-释放模型（acquire-release-ordering）" class="headerlink" title="获取-释放模型（acquire-release ordering）"></a>获取-释放模型（acquire-release ordering）</h3><p>接下来，我们讨论居于宽松模型和顺序一致模型当中的获取-释放模型（acquire-release ordering）。</p><p>获取-释放模型当中，依然不存在顺序一致模型当中那样的全局唯一操作顺序，但相较宽松模型，增加了部分同步能力。在获取-释放模型当中，</p><ul><li>原子-store 操作是<ins>释放操作（release-operation）</ins>（<code>std::memory_order_acquire</code>）；</li><li>原子-load 操作是<ins>获取操作（acquire-operation）</ins>（<code>std::memory_order_release</code>）；</li><li>原子-read-modify-write 操作（例如 <code>fetch_add</code> 或是 <code>exchange</code>）则要么是释放操作，要么是获取操作，要么同时是释放-获取操作（<code>std::memory_order_acq_rel</code>）。</li></ul><p>同步总是在线程之间成对出现的。一个线程中的释放操作与另一个线程中读到该次写入的获取操作<ins>同步（synchronizes-with）</ins>。这意味着，不同线程可能观察到不同的操作顺序，但这些顺序是有所限制的。</p><p>同样地，我们来看一个示例。这个例子是从顺序一致性模型的例子上稍加修改而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 6.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// can fire</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，断言可能失败。我们来做进一步分析。</p><p>(1) 处是释放操作；(3) 处通过循环确保读到 (1) 写入的值。因而 (1) 的释放操作与 (3) 的获取操作配对，建立<ins>同步（synchronizes-with）</ins>关系，于是 (1) 顺势与 (4) 建立<ins>先于（happens-before）</ins> 关系。同理，(2) 与 (5) 之间也有同步关系，(2) 顺势与 (6) 建立<ins>先于（happens-before）</ins> 关系。</p><p>然而，我们无法建立 (1) <ins>先于（happens-before）</ins> (6) 的关系。故而 (6) 可能读到变量 <code>x</code> 的修改序列上的任意值。例如说，可能读到 <code>false</code>。同理 (4) 也可能读到 <code>false</code>。二者同时发生时，断言失败。</p><p>因为 store 操作发生在不同的线程，故而我们无法借助一个原子变量的同步关系，构造另一个原子变量的写与读之间的先于关系。这告诉我们两件事情。一是，对于多写多读的场景，我们往往需要顺序一致性模型。二是，若要应用获取-释放模型，store 操作应当发生在同一线程。</p><p>接下来我们再看一例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 3.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑 (1) 和 (2) 在同一线程中，有<ins>先序（sequenced-before）</ins>关系（release 语义保证不乱序）；(3) 处的 spin-wait 保证读到 (2) 的写入，因而 (2) 与 (3) <ins>同步（synchronizes-with）</ins>，再有 (3) 与 (4) 在同一线程中，也有先序关系（acquire 语义保证不乱序）。故而 (1) 必须先于 (4)，从而 (4) 的判断必定成立，而 (5) 的断言永不失败。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>C++ 标准库也提供了内存屏障 <code>std::atomic_thread_fence</code>，它也可以打上顺序标签。</p><p>理解起来，带上 <code>std::memory_order_release</code> 的内存屏障，倾向于向下结合一个 store 操作，将它的内存顺序提升为 <code>std::memory_order_release</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。带上 <code>std::memory_order_acquire</code> 的内存屏障，倾向于向上结合一个 load 操作，将它的内存顺序提升为 <code>std::memory_order_acquire</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。从而建立获取-释放的同步关系。</p><p>我们可以将上例稍加修改得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2.a.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 3.a.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 3.b.</span></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，(2.a) 的 release-屏障向下与 (2.b) 的宽松-store 操作结合，使得该操作提升为 release-store；(3.b) 的 acquire-屏障向上与 (3.a) 的宽松-load 操作结合，使得该操作提升为 acquire-load。reloease-store 和 acquire-load 构成<ins>同步（synchronizes-with）</ins>，又有 release&#x2F;acquire 语义保证局部顺序，因此有 (1) <ins>先于（happens-before）</ins> (4)，从而 (5) 的断言不会失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;和内存顺序（&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;上&lt;/a&gt;、&lt;a href=&quot;/2021/12/11/memory-order-cpp-02/&quot;&gt;中&lt;/a&gt;）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。&lt;/p&gt;
&lt;p&gt;此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑫）：C++ 的内存顺序·中</title>
    <link href="https://liam.page/2021/12/11/memory-order-cpp-02/"/>
    <id>https://liam.page/2021/12/11/memory-order-cpp-02/</id>
    <published>2021-12-11T00:27:42.000Z</published>
    <updated>2021-12-13T16:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇（<a href="/2021/06/05/memory-model-cpp/">内存模型</a>与<a href="/2021/06/06/memory-order-cpp-01/">内存顺序·上</a>）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>的翻译，但会展开做一些讨论。</p><span id="more"></span><h2 id="六种内存顺序标记"><a href="#六种内存顺序标记" class="headerlink" title="六种内存顺序标记"></a>六种内存顺序标记</h2><p>C++ 标准库定义了六中内存顺序标记（memory order tag）。他们被定义为一个枚举类型。在 C++11 之后、C++20 之前，定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p>在 C++20 中，则使用新的 <code>enum class</code> 重新定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">memory_order</span> : <span class="comment">/*unspecified*/</span> &#123;</span><br><span class="line">    relaxed, consume, acquire, release, acq_rel, seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_relaxed = memory_order::relaxed;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_consume = memory_order::consume;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acquire = memory_order::acquire;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_release = memory_order::release;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acq_rel = memory_order::acq_rel;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_seq_cst = memory_order::seq_cst;</span><br></pre></td></tr></table></figure><p>我们知道，原子变量上没有数据竞争，从而提供了良定义的多线程并发读写能力。因此，原子变量有可能实际上建立了线程间的同步关系，于是建立了某种<ins>先于（happens-before）</ins>关系。</p><p>在原子操作上添加六种内存顺序标记（中的一部分），会<strong>影响（但不一定改变；视 CPU 架构）原子操作附近的内存访问顺序（包括其他原子操作，亦包含对非原子变量的读写操作）</strong>。注意，内存顺序（通过六种标记）讨论的实际上是线程内原子操作附近非原子操作访问内存的顺序，而非是多线程之间的执行顺序。只不过，因为原子变量自身可能建立了线程间的同步关系，所以<strong>两个线程内各自的内存顺序会经由原子变量的同步建立间接的顺序关系</strong>。亦即，<strong>内存顺序本质上是在讨论单线程内指令执行顺序对多线程影响</strong>的问题。显然，通过添加内存顺序标记，编译器优化和 CPU 指令多发射（multiple issue）、CPU 乱序执行（out-of-order execution）都可能受到一定影响。</p><p>所有原子操作默认的内存顺序标记是 <code>std::memory_order_seq_cst</code>，亦即，提供顺序一致性的顺序保证（后续讨论）。目前而言，在绝大多数 CPU 架构上，顺序一致性模型都需要或多或少地在原子操作前后加上内存屏障（memory fence）。因而，顺序一致性虽好，但会损失部分性能。使用其它内存顺序标记则或多或少降低顺序一致性的保证。</p><table><thead><tr><th>标记</th><th>作用</th></tr></thead><tbody><tr><td><code>memory_order_relaxed</code></td><td>宽松操作：仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。</td></tr><tr><td><code>memory_order_consume</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E6%B6%88%E8%B4%B9%E6%93%8D%E4%BD%9C%EF%BC%88consume-operation%EF%BC%89">消费操作（consume operation）</a></ins>：当前线程中，所有依赖当前 load 操作读取的值的读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>依赖的变量的写入，对当前线程是可见的。多数平台上，该标记仅影响编译器优化。</td></tr><tr><td><code>memory_order_acquire</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E5%8D%A0%E6%9C%89%E6%93%8D%E4%BD%9C%EF%BC%88aquire-operation%EF%BC%89">占有操作（aquire operation）</a></ins>：当前线程中，所有读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前线程是可见的。</td></tr><tr><td><code>memory_order_release</code></td><td>打上此标记的 store 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%EF%BC%88release-operation%EF%BC%89">释放操作（release operation）</a></ins>：当前线程中，所有读写操作不得重排至当前操作之后。因此，当前操作所在线程之前的写入操作，在其他线程中，对该原子变量施加<ins>占有操作（aquire operation）</ins>之后是可见的。也因此，当前操作所在线程中，当前操作所依赖的写入操作，在其他线程中，对该原子变量施加<ins>消费操作（consume operation）</ins>之后是可见的。</td></tr><tr><td><code>memory_order_acq_rel</code></td><td>打上此标记的 read-modify-write 操作既是<ins>占有操作（aquire operation）</ins>又是<ins>释放操作（release operation）</ins>：当前线程中的读写操作不能重排至当前操作之后（如果原本在之前），亦不能重排至当前操作之前（如果原本在之后）。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前 modification 是可见的；该 modification 对其他线程中相同原子变量<ins>占有操作（aquire operation）</ins>之后亦是可见的。</td></tr><tr><td><code>memory_order_seq_cst</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins>占有操作（aquire operation）</ins>；打上此标记的 store 操作对相关内存位置施加<ins>释放操作（release operation）</ins>；打上此标记的 read-modify-write 对相关内存位置施加<ins>占有操作（aquire operation）</ins>和<ins>释放操作（release operation）</ins>。此外，对所有线程来说，所有打上该标记的写操作，存在一个全局修改顺序（尽管具体顺序在执行时才确定）。也就是说，对于所有线程来说，看见的这些写操作的顺序是一致的。</td></tr></tbody></table><h2 id="宽松顺序（Relaxed-ordering）"><a href="#宽松顺序（Relaxed-ordering）" class="headerlink" title="宽松顺序（Relaxed ordering）"></a>宽松顺序（Relaxed ordering）</h2><p>宽松顺序仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。因此，它们不是同步操作，仅保证原子变量上读写操作的原子性，以及各个原子变量自身修改顺序的一致性（对于同一个变量的两次修改，虽然顺序不一定，但是所有其他线程观察到的修改顺序都是相同的）。</p><p>假定 <code>x</code> 和 <code>y</code> 是两个全局变量，均被初始化为零，则下列代码执行完毕之后，存在 <code>r1 == r2 == 42</code> 的可能性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed);  <span class="comment">// B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// C</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// D</span></span><br></pre></td></tr></table></figure><p>这是因为，虽然在线程 1 和线程 2 之间没有任何同步；于是，对于原子变量 <code>y</code> 的<ins>修改顺序（Modification Order）</ins>来说，D 可能先于 A 发生；同样，对于原子变量 <code>x</code> 的<ins>修改顺序（Modification Order）</ins>来说，B 可能先于 C 发生。</p><p>宽松顺序的典型场景是不断增加的计数器。计数器的增加只需有原子性的保证，而对同步或是内存顺序没有要去。例如，<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> 当中的引用计数的增加。实例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        cnt.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : v) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final counter value is 10000</span><br></pre></td></tr></table></figure><p>不过，对于 <code>std::shard_ptr</code> 当中的引用计数来说，其减少需要与析构函数当中的 load 操作有 acquire-release 的同步。</p><h2 id="释放-获取顺序（Release-Acquire-ordering）"><a href="#释放-获取顺序（Release-Acquire-ordering）" class="headerlink" title="释放-获取顺序（Release-Acquire ordering）"></a>释放-获取顺序（Release-Acquire ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_acquire</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行释放操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在部分强顺序的 CPU 架构中（例如 <code>x86</code>, SPARC TSO, IBM mainframe 等），释放-获取顺序对大多数操作来说都是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将非原子的 load 操作挪到原子 load-acquire 操作之前）。</p><p>在弱顺序的 CPU 架构中（例如 ARM,Itanium, PowerPC），则需加入额外的 CPU 指令或是内存屏障。</p><p>互斥锁（例如 <a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>&#x2F;<a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag">atomic spinlock</a>）亦属于释放-获取同步：当锁被线程 A 释放而后被线程 B 获取，则在锁被释放之前临界区中所有对共享变量的写入操作在线程 B 获取锁之后均可见。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的获取-释放同步，因此两个 <code>assert</code> 永远不会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="type">int</span> data&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_acquire)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例则展示了在三个线程之中，获取-释放顺序的传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_acq_rel)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放-消费顺序（Release-Consume-ordering）"><a href="#释放-消费顺序（Release-Consume-ordering）" class="headerlink" title="释放-消费顺序（Release-Consume ordering）"></a>释放-消费顺序（Release-Consume ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_consume</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中依赖该原子变量的表达式和函数看来都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 中依赖该原子变量的表达式和函数可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行消费操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在除 DEC Alpha 之外的主流 CPU 上，释放-消费顺序（亦称：依赖顺序）是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将涉及到依赖链的非原子的 load 操作挪到原子 load-consume 操作之前）。</p><p>该顺序的使用，往往见于对并发共享数据结构有频繁读取而极少写入的场景（例如路由表、安全策略、防火墙规则等）。</p><p>注意，截至 2015 年 2 月，尚未有编译器追踪了依赖链条，因此，消费操作被提升为获取操作。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的释放-消费同步，因此第一个 <code>assert</code> 永远不会失败，但第二个 <code>assert</code> 可能失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序一致顺序（Sequentially-consistent-ordering）"><a href="#顺序一致顺序（Sequentially-consistent-ordering）" class="headerlink" title="顺序一致顺序（Sequentially-consistent ordering）"></a>顺序一致顺序（Sequentially-consistent ordering）</h2><p>标记上 <code>std::memory_order_seq_cst</code> 的原子操作不仅满足释放-获取顺序的要求（一个线程中 store-release 之前的写入操作在另一个 load-acquire 之后都可见），而且为所有如此标记的原子操作建立了<strong>唯一的全局统一修改顺序（single total modification order）</strong>。</p><p>正式地说，在不考虑 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence"><code>std::atomic_thread_fence</code></a> 的情况下，对于每个 load 原子变量 M 的操作 B（标记为 <code>std::memory_order_seq_cst</code>），它读取到的值来自以下三种可能：</p><ul><li>在上述<strong>唯一的全局统一修改顺序</strong>中的上一个修改了 M 的操作 A 的结果；</li><li>若存在这样的 A，B 还可能读到另一个修改了 M 的操作 C，它没有标记为 <code>std::memory_order_seq_cst</code>，并且不<ins>先于（happens-before）</ins> A；</li><li>若不存在这样的 A，B 读取的结果来自另一个修改了 M 的没有标记为 <code>std::memory_order_seq_cst</code>的操作 D。</li></ul><!-- Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order. --><p>顺序一致对于多生产者多消费者的情形是必要的。这是因为，所有消费者必须能够以相同的顺序观察到所有生产者的行为。</p><!-- Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core. --><p>在所有多核系统中（注：逻辑核），完全的顺序一致都会插入大量内存屏障指令。这使得相应的内存访问需要对所有核心进行广播，因而可能成为性能瓶颈。</p><!-- This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads c and d to observe changes to the atomics x and y in opposite order. --><p>下例中，顺序一致即是必要的。其他更弱的顺序模型可能导致线程 C 和线程 D 观察到原子变量 <code>x</code> 和 <code>y</code> 以不同的顺序修改，从而导致 <code>assert</code> 失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// will never happen</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与-volatile-的关系"><a href="#与-volatile-的关系" class="headerlink" title="与 volatile 的关系"></a>与 <code>volatile</code> 的关系</h2><!-- Within a thread of execution, accesses (reads and writes) through volatile glvalues cannot be reordered past observable side-effects (including other volatile accesses) that are sequenced-before or sequenced-after within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. --><p>在<strong>同一线程</strong>中，对 <code>volatile</code> 修饰的<a href="https://en.cppreference.com/w/cpp/language/value_category#glvalue">泛左值</a>（包括左值和将亡值）的访问（包括读写）不允许被重排序至<ins>先序于（sequenced-before）</ins>该操作的可观测的副作用（包括其他 <code>volatile</code> 访问）之前，亦不允许被重排序至<ins>后序于（sequenced-after）</ins>该操作的可观测的副作用（同上）之后。然而，<code>volatile</code> 访问并未建立线程之间的同步，故而在其他线程中，上述顺序无法得到保证。</p><!-- In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access). --><p>此外，对 <code>volatile</code> 修饰的泛左值的访问不是原子的（这意味着读写同一内存位置上的 <code>volatile</code> 变量属于<a href="https://en.cppreference.com/w/cpp/language/memory_model">数据竞争</a>），同时也不影响内存顺序（非 <code>volatile</code>-访问可以在 <code>volatile</code>-访问附近自由重排序）。</p><!-- One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (Microsoft Docs), and thus volatiles may be used for inter-thread synchronization. Standard volatile semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a std::signal handler that runs in the same thread when applied to sig_atomic_t variables. --><p>一个例外是 Visual Studio。根据<a href="https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp">微软提供的文档</a>，在默认设置下，<code>volatile</code>-读自带 acquire 语义而 <code>volatile</code>-写自带 release 语义。因此，这些 <code>volatile</code>-访问可被用来建立线程间的同步。但要注意，标准的 <code>volatile</code> 语义不应被用于多线程编程。（这一点在<a href="/2018/01/18/volatile-in-C-and-Cpp/">前作</a>中也有讨论）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇（&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;与&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;内存顺序·上&lt;/a&gt;）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;对应页面&lt;/a&gt;的翻译，但会展开做一些讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
  <entry>
    <title>论善良</title>
    <link href="https://liam.page/2021/06/17/discussion-on-kind/"/>
    <id>https://liam.page/2021/06/17/discussion-on-kind/</id>
    <published>2021-06-17T13:07:31.000Z</published>
    <updated>2021-06-17T15:52:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。</p><span id="more"></span><h2 id="善良是什么？"><a href="#善良是什么？" class="headerlink" title="善良是什么？"></a>善良是什么？</h2><p>善良一词，与我所见最早者，当出自《礼记·学记》。曰：「发虑宪，求善良，足以謏闻，不足以动众。」</p><p>按文言一贯作风，善良虽在现代汉语中成词已久，但在文言中大概是分别表意的。在文言文词典中，<a href="https://wyw.hwxnet.com/view/hwxE5hwx96hwx84.html">善</a>作名词表示「好的行为」，作形容词表示「赞许的」或是「熟悉」。显然，此处应取「值得赞许的」的含义。<a href="https://wyw.hwxnet.com/view/hwxE8hwx89hwxAF.html">良</a>作形容词表示「好」。因此，讲白了，文言中的「善良」大约就是人类品德中所有好的品德的集合体。</p><p>在现代汉语中，善良的表意某种意义上被圈定在「和善」、「心地好」这样的意思上了。</p><h2 id="人善被人欺？"><a href="#人善被人欺？" class="headerlink" title="人善被人欺？"></a>人善被人欺？</h2><p>大多数生长于传统中国家庭的孩子，大都从小被教育「要善良」。与之相应，孩子被要求「爱分享」、「乐于助人」等。</p><p>然而，步入社会之后，或多或少地，这些从小被教育要善良的孩子，都因「善良」吃过亏。其中不乏「屡教不改」抑或是「执迷不悔」的人，当然也有些人从此「黑化」或是抑郁。</p><p>这些时候，「孩子们」大约会想起父母的另一句话「害人之心不可有，防人之心不可无」。可是，爸爸妈妈，你们从来没教过我们要如何才能「防人」呀……</p><p>所以，到底要怎么办？</p><h2 id="善心？善举？"><a href="#善心？善举？" class="headerlink" title="善心？善举？"></a>善心？善举？</h2><p>面对这个问题，我们不能逃避。因为你能逃一次，但将来不断发生的事情，会不断质疑你的内心。最终逃无可逃，必须直面。</p><p>为了解决这个问题，我们将善良分为两个部分，或者说两个层次：善心和善举。善心是无条件的，行善举是有条件的。若是行善举会危害到自己的核心利益，那便要慎重。世人多被要求善良，却不分善举和善心。无差别的善举最终往往害人害己。</p><p>对于以善良为代表的一切「美好的德行」，都有<strong>论心不论迹</strong>。也就是说，我们要将善心和善举区分开来；而后，常怀善心，擅行善举。</p><h2 id="何时行善举？"><a href="#何时行善举？" class="headerlink" title="何时行善举？"></a>何时行善举？</h2><p>是否要行善举，这其实是一个选择题。</p><p>在我看来，这一选择题理当无有特殊性。也就是说，人生中其他类似的选择题如何做，这一道选择题就如何做。亦即，人自身的一切行为，都要有统一的标准去考量。不能因为善举于道德地位更高，就降低评判标准，而后决定施行，而不顾其可能带来的负面影响。</p><p>操作层面上，当意图行善时，脑回路里加一个步骤：这事儿做了之后最坏的结果自己能不能接受。如果不能接受的话，哪怕是善举，也慎重一些。</p><h2 id="不为善其与为恶异乎？"><a href="#不为善其与为恶异乎？" class="headerlink" title="不为善其与为恶异乎？"></a>不为善其与为恶异乎？</h2><p>或曰：「不为善者与为恶者，无异也」。曰：「道德绑架者也。」</p><p>有人认为，善而不为，其与恶无异。此类谬误有二。一者，忽略世界的多样性，将善恶二元对立，认为非善即恶。他们认为，不做善事就是恶；不作恶事就是善。二者，将善良至于绝对片面的语境之下，忽略实际情况，忽略自身自我，将善良狭隘化为一个放之四海而皆准的道德标尺。殊不知，因为行善举，而将自己置于无法承受的危险之下，实际上是忽略了自我。「我」都没有了，还谈什么善良呢？这不是善良，而是伪善。</p><p>这些人可能也会拿汉昭烈帝的「勿以善小而不为」来做例证。然而，刘备遗诏中的意思，是强调善举大小、影响范围，却没有教刘禅不分青红皂白应当一律行善。</p><p>因此，认为不行善举即是作恶的人，其实就是道德绑架罢了。</p><h2 id="真正的英雄主义"><a href="#真正的英雄主义" class="headerlink" title="真正的英雄主义"></a>真正的英雄主义</h2><p>罗曼·罗兰说：「世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它」。</p><p>如何能做到这一点？</p><p>自己的善举可能为自己带来危害，这也是生活的真相之一。被伤害过后，你还愿意保持善良吗？被伤害过后，你能控制自己不去伤害别人吗？换言之，被伤害过后，你还热爱这个世界吗？</p><p>广义地看待善良，将善心和善举分开，常怀善心、擅行善举，则哪怕不能成为真的英雄，也常在成为英雄的路上了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Kind" scheme="https://liam.page/tags/Kind/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑪）：C++ 的内存顺序·上</title>
    <link href="https://liam.page/2021/06/06/memory-order-cpp-01/"/>
    <id>https://liam.page/2021/06/06/memory-order-cpp-01/</id>
    <published>2021-06-06T04:16:06.000Z</published>
    <updated>2021-06-06T12:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇继<a href="/2021/06/05/memory-model-cpp/">前文</a>讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>术语部分的翻译，有删减和补充。</p><span id="more"></span><p>线程间同步及内存顺序决定表达式的<ins>求值（evaluations）</ins>及其<ins>副作用（side effects）</ins>在不同线程中的顺序。首先有相关术语的定义。</p><h2 id="消费操作（consume-operation）"><a href="#消费操作（consume-operation）" class="headerlink" title="消费操作（consume operation）"></a>消费操作（consume operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_consume</code></a> 或更强的内存顺序的原子读操作是消费操作（consume operation）。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比消费操作更强。</p><h2 id="占有操作（aquire-operation）"><a href="#占有操作（aquire-operation）" class="headerlink" title="占有操作（aquire operation）"></a>占有操作（aquire operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_acquire</code></a> 或更强的内存顺序的原子读操作是占有操作（aquire operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex">互斥量（mutex）</a>上执行 <code>lock()</code> 操作亦属于占有操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比占有操作更强。</p><h2 id="释放操作（release-operation）"><a href="#释放操作（release-operation）" class="headerlink" title="释放操作（release operation）"></a>释放操作（release operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_release</code></a> 或更强的内存顺序的原子读操作是释放操作（release operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex">互斥量（mutex）</a>上执行 <code>unlock()</code> 操作亦属于释放操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比释放操作更强。</p><h2 id="表达式求值（evaluations-of-expressions）"><a href="#表达式求值（evaluations-of-expressions）" class="headerlink" title="表达式求值（evaluations of expressions）"></a>表达式求值（evaluations of expressions）</h2><p>对一个表达式<ins>求值（evaluation）</ins>包含以下两个部分：</p><ul><li><ins>值计算（value computations）</ins>：计算表达式的返回值。其中可能涉及到对象的识别（identity of the object；左值求值）或是读取对象中保存的值（右值求值）。前者例如返回某个对象的引用，后者例如返回一个数值。</li><li><ins>副作用（side effect）</ins>：通过一个易变左值访问（读&#x2F;写）对象；修改对象；调用函数库中的 I&#x2F;O 函数；或调用包含上述操作的其他函数。</li></ul><h2 id="先序（sequenced-before）关系"><a href="#先序（sequenced-before）关系" class="headerlink" title="先序（sequenced-before）关系"></a>先序（sequenced-before）关系</h2><p>先序关系描述同一个线程中两次求值之间的偏序关系。</p><ul><li>若 A <ins>先序于（sequenced-before）</ins> B，则 A 将在 B 开始执行之前完成。</li><li>若 A 不先序于 B，而 B 先序于 A，则 B 将在 A 开始执行之前完成。</li><li>若 A 不先序于 B 而 B 亦不先序于 A，则有两种可能性<ul><li>A 和 B 的求值不存在序列关系：二者可能以任意顺序求值，并且它们的求值动作在时间上可能重叠（在同一线程中，编译器可能打乱组成 A 和 B 的指令的顺序，使他们相互穿插）。</li><li>A 和 B 的求值序列关系不确定：二者可能以任意顺序求值，但它们的求值动作在时间上不可能重叠。此外，程序再次执行时，二者的执行顺序可能和上一次不同。</li></ul></li></ul><h2 id="带去依赖（Carries-dependency）"><a href="#带去依赖（Carries-dependency）" class="headerlink" title="带去依赖（Carries dependency）"></a>带去依赖（Carries dependency）</h2><p>在同一线程中，若 A <ins>先序于</ins> B，则在下列情况下，A 为 B 带去依赖（即，B 依赖于 A）：</p><ul><li>A 的返回值是 B 的操作数，但下列情形除外：<ul><li>B 是对 <a href="https://en.cppreference.com/w/cpp/atomic/kill_dependency"><code>std::kill_dependency</code></a> 的调用；</li><li>A 的返回值是内建 <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code> 或是 <code>,</code> 运算符的左操作数。</li></ul></li><li>执行 A 的过程中写入标量 M，而执行 B 的过程读取标量 M。</li><li>A 为 X 带去依赖，而 X 为 B 带去依赖。（即依赖关系具有传递性）</li></ul><h2 id="修改顺序（Modification-Order）"><a href="#修改顺序（Modification-Order）" class="headerlink" title="修改顺序（Modification Order）"></a>修改顺序（Modification Order）</h2><p>对于某个原子变量来说，其全部写入操作组成一个全局修改顺序。</p><p>所有原子操作都保证符合以下四个要求：</p><ol><li>写写一致性：若对原子变量 M 的写入操作 A <ins>先于（happens-before）</ins>对同一原子变量的写入操作 B。则在 M 的<ins>修改顺序（modification order）</ins>中，A 在 B 之前。</li><li>读读一致性：若 A 和 B 的值计算均读取原子变量 M，且 A <ins>先于</ins> B；又假定 A 读到的原子变量 M 的值来自某个对 M 有写操作的表达式 X；则 B 读到的值，要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li><li>读写一致性：若 A 的值计算读取原子变量 M 而 B 写入 M，且 A <ins>先于</ins> B；则 A 读到的值来自在 M 的<ins>修改顺序（modification order）</ins>中早于 B 的某个写入 X。</li><li>写读一致性：若 X 对原子变量 M 有写入，而 B 的值计算读取原子变量 M；又假定 X <ins>先于</ins> B；则 B 读到的值要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li></ol><h2 id="释放序列（Release-sequence）"><a href="#释放序列（Release-sequence）" class="headerlink" title="释放序列（Release sequence）"></a>释放序列（Release sequence）</h2><p>假定 A 是原子变量 M 上的一个<ins>释放操作（release operation）</ins>。则在 M 的修改顺序中，<strong>位于 A 之后</strong>的由下列操作组成的最长连续子序列被称为以 A 为首的<ins>释放序列（release sequence）</ins>：</p><ol><li>执行 A 的线程中，对 M 的写入操作（until C++20）；</li><li>任意线程对 M 的读-改-写操作（CAS 成功时的操作）。</li></ol><h2 id="依赖顺序上先于（Dependency-ordered-before）"><a href="#依赖顺序上先于（Dependency-ordered-before）" class="headerlink" title="依赖顺序上先于（Dependency-ordered before）"></a>依赖顺序上先于（Dependency-ordered before）</h2><p>满足下列某个情况时，我们称表达式 A 在<ins>依赖顺序上先于（dependency-ordered before）</ins>表达式 B——其中 A 和 B 处于不同线程。</p><ol><li>A 对原子变量 M 执行<ins>释放操作（release operation）</ins>，在另一线程中 B 对同一原子变量 M 执行<ins>消费操作（consume operation）</ins>，且 B 读取的值来自 A（以 A 为首的<ins>释放序列（release sequence）</ins>中的任意部分（until C++20））的写入。</li><li>A 在依赖顺序上先于 X，而 X 为 B 带去依赖。</li></ol><h2 id="线程间先于（Inter-thread-happens-before）"><a href="#线程间先于（Inter-thread-happens-before）" class="headerlink" title="线程间先于（Inter-thread happens-before）"></a>线程间先于（Inter-thread happens-before）</h2><p>若满足下列条件之一，则称对表达式 A 的求值<ins>线程间先于（inter-thread happens-before）</ins>对表达式 B 的求值：</p><ol><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>依赖顺序上先于</ins> B；</li><li>A 与某个表达式 X <ins>同步</ins>，而 X <ins>先序于</ins> B；</li><li>A <ins>先序于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B；</li><li>A <ins>线程间先于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B。</li></ol><h2 id="先于（happens-before）"><a href="#先于（happens-before）" class="headerlink" title="先于（happens-before）"></a>先于（happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>线程间先于（inter-thread happens-before）</ins> B。</li></ol><p>编译器实现应当引入必要的同步措施，以保证表达式求值之间的先于关系链不成环。（仅当引入消费操作（consume operation）时有此必要；参见 <a href="http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf">Betty 等的论文</a>）</p><p>若某个求值操作修改了一个内存位置（见<a href="/2021/06/05/memory-model-cpp/">前文</a>），另一个求值操作读写同一内存位置，且至少其一不是原子操作，除非二者之间存在<ins>先于</ins>关系，程序行为未定义（程序有数据竞争）。</p><h2 id="简单先于（Simply-happens-before；since-C-20）"><a href="#简单先于（Simply-happens-before；since-C-20）" class="headerlink" title="简单先于（Simply happens-before；since C++20）"></a>简单先于（Simply happens-before；since C++20）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>简单先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>简单先于</ins> 某个表达式 X 的求值，而 X <ins>简单先于</ins> B。</li></ol><p>注：没有消费操作（consume operation）时，简单先于等价于先于。</p><h2 id="强先于（Strongly-happens-before）"><a href="#强先于（Strongly-happens-before）" class="headerlink" title="强先于（Strongly happens-before）"></a>强先于（Strongly happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>强先于（strongly happens-before）</ins>对表达式 B 的求值：</p><h3 id="until-C-20"><a href="#until-C-20" class="headerlink" title="until C++20"></a>until C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：C++20 之前的强先于，即是 C++20 及之后的简单先于。</p><h3 id="since-C-20"><a href="#since-C-20" class="headerlink" title="since C++20"></a>since C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>，且 A&#x2F;B 均为顺序一致（sequentially consistent）的原子操作；</li><li>A <ins>先序于（sequenced-before）</ins> X，X <ins>简单先于</ins> Y，Y <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：不正式地讲，若 A <ins>强先于（strongly happens-before）</ins> B，则在任何上下文中，A 都先于 B 求值。</p><p>注：强先于关系排除了消费操作（consume operation）。</p><h2 id="可见副作用（Visible-side-effects）"><a href="#可见副作用（Visible-side-effects）" class="headerlink" title="可见副作用（Visible side-effects）"></a>可见副作用（Visible side-effects）</h2><p>若下列条件均成立，则 A 对于标量 M 的副作用（写操作）于在标量 M 上的求值 B（读操作）可见：</p><ol><li>A <ins>先于</ins> B；</li><li>任意满足 A <ins>先于</ins> X 且 X <ins>先于</ins> B 的表达式 X 对标量 M 没有副作用。</li></ol><p>若 A 的副作用对 B 可见，则在 M 的修改顺序当中 B 之前的最长连续副作用子集称之为 B 可见的副作用序列。（B 见到的 M 的值是上述副作用其中之一写入的）</p><p>注：线程间同步本质是要通过建立<ins>先于（happens-before）</ins>关系来避免数据竞争以及定义在哪些条件下哪些副作用可见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇继&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;前文&lt;/a&gt;讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;对应页面&lt;/a&gt;术语部分的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（十）：C++ 的内存模型</title>
    <link href="https://liam.page/2021/06/05/memory-model-cpp/"/>
    <id>https://liam.page/2021/06/05/memory-model-cpp/</id>
    <published>2021-06-05T02:36:41.000Z</published>
    <updated>2021-12-11T14:18:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/language/memory_model">对应页面</a>的翻译，有删减和补充。</p><span id="more"></span><p>内存模型为 C++ 抽象机器定义了计算机内存存储语义。</p><p>C++ 程序可用的内存是一个或多个连续的字节序列。每个字节有自己独有的内存地址。</p><h2 id="字节（Byte）"><a href="#字节（Byte）" class="headerlink" title="字节（Byte）"></a>字节（Byte）</h2><p>字节是内存中的最小可寻址单元，由连续的多个比特组成。C++ 中，<code>char</code>&#x2F;<code>unsigned char</code>&#x2F;<code>signed char</code> 的对象存储和<a href="https://en.cppreference.com/w/cpp/language/object">值表示</a>均使用恰好 1 字节。于是，字节中有多少比特，可以通过 <a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><code>std::numeric_limits&lt;unsigned char&gt;::digits</code></a>取得。</p><h2 id="内存位置（Memory-Location）"><a href="#内存位置（Memory-Location）" class="headerlink" title="内存位置（Memory Location）"></a>内存位置（Memory Location）</h2><p>内存位置是</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/type">标量类型</a>（算数类型、指针类型、枚举类型或是 <code>std::nullptr_t</code>）的对象；</li><li>或是，长度不为零的<a href="https://en.cppreference.com/w/cpp/language/bit_field">位域</a>组成的最长连续序列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">// memory location #1</span></span><br><span class="line">    <span class="type">int</span> b : <span class="number">5</span>;  <span class="comment">// memory location #2</span></span><br><span class="line">    <span class="type">int</span> c : <span class="number">11</span>, <span class="comment">// memory location #2 (continued)</span></span><br><span class="line">          : <span class="number">0</span>,  <span class="comment">// zero-length, as a delimiter of continued sequence of bit-fields</span></span><br><span class="line">        d : <span class="number">8</span>;  <span class="comment">// memory location #3</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">int</span> ee : <span class="number">8</span>; <span class="comment">// memory location #4</span></span><br><span class="line">    &#125; e;</span><br><span class="line">&#125; obj; <span class="comment">// The object &#x27;obj&#x27; consists of 4 separate memory locations</span></span><br></pre></td></tr></table></figure><p>注意：语言中的许多特性会引入额外的内存位置。这些内存位置程序无法访问，而是为编译器实现自行管理。这些特性例如：<a href="https://en.cppreference.com/w/cpp/language/reference">引用</a>和<a href="https://en.cppreference.com/w/cpp/language/virtual">虚函数</a>。</p><h2 id="线程与数据竞争（Thread-and-data-races）"><a href="#线程与数据竞争（Thread-and-data-races）" class="headerlink" title="线程与数据竞争（Thread and data races）"></a>线程与数据竞争（Thread and data races）</h2><p>程序中的线程是自 <a href="https://en.cppreference.com/w/cpp/thread/thread/thread"><code>std::thread::thread</code></a>, <a href="https://en.cppreference.com/w/cpp/thread/async"><code>std::async</code></a> 或者其他方式调用顶层函数开始的控制流。</p><p>任一线程都可能访问程序中的任意对象。其中，原子及<a href="https://en.cppreference.com/w/cpp/language/storage_duration">线程内部存储</a>亦可能为其它线程通过指针或引用来访问。</p><p>在没有同步或阻塞的情况下，不同线程可并发访问（读&#x2F;写）不同内存位置。</p><p>若一个表达式求值对某一内存位置进行写操作，而另一求值过程对同一内存位置进行读或写操作，则两个求值过程存在冲突。除非满足下列条件，程序中冲突的求值操作将引发数据竞争：</p><ul><li>存在冲突的求值操作在同一线程中执行，或在同一<a href="https://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler">信号处理函数</a>中执行；或者</li><li>存在冲突的求值操作均是原子操作（参见 <a href="https://en.cppreference.com/w/cpp/atomic/atomic"><code>std::atomic</code></a>）；或者</li><li>存在冲突的求值操作，其一<ins>先于（happens-before）</ins>另一发生（参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order</code></a>）。</li></ul><p>数据竞争将导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using atomic variable</span></span><br></pre></td></tr></table></figure><p>特别地，对于同一个 <a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>，在一个线程中释放它与在另一线程中获取它是<ins>同步的（synchronized-with）</ins>，故而释放动作<ins>先于（happens-before）</ins>获取动作。因此，可用 <code>std::mutex</code> 来避免数据竞争。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; std::lock_guard&lt;std::mutex&gt; <span class="built_in">lk</span>(mtx); cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using mutex to ensure happens-before semantic</span></span><br></pre></td></tr></table></figure><h2 id="内存顺序（Memory-Order）"><a href="#内存顺序（Memory-Order）" class="headerlink" title="内存顺序（Memory Order）"></a>内存顺序（Memory Order）</h2><p>线程自某个内存位置取值时，读到的可能是它的初始值，也可能是当前线程写入的值，亦可能是其他线程写入的值。有关内存顺序的细节可参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order</code></a>；其中讨论了线程的写入操作在其他线程可见性的问题。</p><h2 id="前向执行（Forward-Progress）"><a href="#前向执行（Forward-Progress）" class="headerlink" title="前向执行（Forward Progress）"></a>前向执行（Forward Progress）</h2><h3 id="无阻塞（Obstruction-freedom）"><a href="#无阻塞（Obstruction-freedom）" class="headerlink" title="无阻塞（Obstruction freedom）"></a>无阻塞（Obstruction freedom）</h3><p>仅有一个未被标准库函数阻塞的线程在执行无锁<a href="https://en.cppreference.com/w/cpp/atomic">原子函数（atomic function）</a>时，该原子函数必能执行完毕（标准库内所有无锁操作均<a href="obstruction-free">无阻塞</a>）。</p><h3 id="无锁（Lock-freedom）"><a href="#无锁（Lock-freedom）" class="headerlink" title="无锁（Lock freedom）"></a>无锁（Lock freedom）</h3><p>一个或更多无锁原子函数并发执行时，至少其中之一必能执行完毕（标准库内所有无所操作均<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom">无锁</a>——编译器实现会保证它们不会被一直锁住，例如持续地被窃走缓存行（cache-line stealing；一种因为执行其他线程的 CPU 核心对内存数据做预取而导致当前 CPU 核心缓存行变脏的现象））。</p><blockquote><p>关于 cache-line stealing，参见：<a href="https://www.researchgate.net/publication/221497089_Tackling_Cache-Line_Stealing_Effects_Using_Run-Time_Adaptation">这篇论文</a>。</p></blockquote><h3 id="执行之担保（Progress-guarantee）"><a href="#执行之担保（Progress-guarantee）" class="headerlink" title="执行之担保（Progress guarantee）"></a>执行之担保（Progress guarantee）</h3><p>在正确的 C++ 程序当中，所有线程终将执行到下列情形之一：</p><ul><li>终止；</li><li>调用 I&#x2F;O 库的函数；</li><li>经由<a href="https://en.cppreference.com/w/cpp/language/cv">易变（volatile）</a>的左值（lvalue）或者将亡值（xvalue）——拥有内存地址的长寿对象——访问外部设备；</li><li>执行原子操作或是同步操作。</li></ul><p>若一个线程执行上述任一操作（I&#x2F;O, volatile, 原子操作或是同步操作），或是阻塞在标准库函数当中，亦或是因其他为阻塞线程正在并发执行导致调用一个无锁原子操作却尚未完成，则称该线程<ins>有进展（make progress）</ins>。</p><h3 id="并发前向执行（Concurrent-forward-progress-since-C-17）"><a href="#并发前向执行（Concurrent-forward-progress-since-C-17）" class="headerlink" title="并发前向执行（Concurrent forward progress; since C++17）"></a>并发前向执行（Concurrent forward progress; since C++17）</h3><p>若某线程有<ins>并发前向执行之担保（concurrent forward progress guarantee）</ins>，则在它终止之前，无论其他线程（若有）是否有进展，它都将于有限时间内取得如上定义之<ins>进展（make progress）</ins>。</p><p>C++ 标准鼓励（但并不强求）主线程和其他由 <code>std::thread</code> 启动的线程提供<ins>并发前向执行之担保</ins>。</p><h3 id="并行前向执行（Parallel-forward-progress-since-C-17）"><a href="#并行前向执行（Parallel-forward-progress-since-C-17）" class="headerlink" title="并行前向执行（Parallel forward progress; since C++17）"></a>并行前向执行（Parallel forward progress; since C++17）</h3><p>若某线程有<ins>并行前向执行之担保（parallel forward progress guarantee）</ins>，则</p><ul><li>在它尚未执行任何步骤（I&#x2F;O, volatile, 原子操作或是同步操作）时，编译器实现不保证它在有限时间内有<ins>进展</ins>；</li><li>而一旦它执行了某一步骤，它提供<ins>并发前向执行之担保</ins>。</li></ul><p>此规则表明，线程池中的线程可以按照任意顺序执行任务。</p><h3 id="弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）"><a href="#弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）" class="headerlink" title="弱并行前向执行（Weakly parallel forward progress; since C++17）"></a>弱并行前向执行（Weakly parallel forward progress; since C++17）</h3><p>若某线程有<ins>弱并行前向执行之担保（weakly parallel forward progress guarantee）</ins>，则无论其他线程是否有<ins>进展</ins>，它都不保证它在有限时间内有<ins>进展</ins>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/memory_model&quot;&gt;对应页面&lt;/a&gt;的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>xTR 预估任务中的特征工程</title>
    <link href="https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/"/>
    <id>https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/</id>
    <published>2021-05-23T13:59:12.000Z</published>
    <updated>2021-07-31T07:45:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&gt; W&amp;D 系列 -&gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。</p><p>此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。</p><span id="more"></span><h2 id="时间类特征"><a href="#时间类特征" class="headerlink" title="时间类特征"></a>时间类特征</h2><blockquote><p>作者：大博<br>链接：<a href="https://www.zhihu.com/question/350863682/answer/860524396">https://www.zhihu.com/question/350863682/answer/860524396</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>考虑问题中的「时间」。从三个角度：用户的时间，商品的时间，用户与商品间的时间。每个角度可以包括的时间类型：时间绝对值，时间间隔值。每个时间类型可以有不同的计算方法：统计型，独立型。（备注：一下就计算来的值算独立型，通过一堆独立值统计来的，用「平均&#x2F;最大」等描述的特征算统计型。）</p><ul><li>用户的时间：(刻画用户本身的习惯)<ul><li>时间绝对值<ul><li>统计型：一个月内最高频的浏览时间</li><li>独立型：用户当前浏览时间&#x2F;用户上一次浏览时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户曾经两次浏览的时间间隔的「平均」</li><li>独立型：用户本次浏览与上次浏览的时间间隔</li></ul></li></ul></li><li>商品的时间：(刻画商品本身的属性)<ul><li>时间绝对值<ul><li>统计型：商品最常被购买的时间</li><li>独立型：商品上架时间&#x2F;预计下架时间（上下架指一个动作）</li></ul></li><li>时间间隔值<ul><li>统计型：三天除以三天内商品被购买次数</li><li>独立型：商品的在线时间&#x2F;当前时间与商品常被购买时间的间隔</li></ul></li></ul></li><li>用户与商品间的时间：(刻画该用户到该商品的匹配程度)<ul><li>时间绝对值<ul><li>统计型：用户历史购买该商品的平均时间分布</li><li>独立型：用户上次购买该商品的时间&#x2F;用户上次购买该商品所属品类的时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户历史购买该品类商品的平均时间间隔</li><li>独立型：用户上次购买该商品到当前时间的时间间隔</li></ul></li></ul></li></ul><p>最后总结下思路：</p><ol><li>一般强特征都是用户到商品的交叉特征，「商品」要从商品id扩展到「品类」&#x2F;「商户」&#x2F;「标签」等等能交叉的角度。</li><li>时间间隔一般是强特。</li><li>历史统计型特征可以用条件概率去理解，虽不是强特，但多了是有用的。</li><li>哪怕是从「时间」考虑特征，特征所反应的含义应该是：这个人平时愿不愿意买东西，这件商品平时的受众是怎样的，这个人对这个商品的敏感程度是怎样的。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&amp;gt; W&amp;amp;D 系列 -&amp;gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。&lt;/p&gt;
&lt;p&gt;此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="xTR" scheme="https://liam.page/tags/xTR/"/>
    
  </entry>
  
</feed>
