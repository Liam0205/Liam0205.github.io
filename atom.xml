<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2024-04-21T14:39:22.778Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有氧适能水平是什么？</title>
    <link href="https://liam.page/2024/04/21/VO2-Max/"/>
    <id>https://liam.page/2024/04/21/VO2-Max/</id>
    <published>2024-04-21T14:33:16.000Z</published>
    <updated>2024-04-21T14:39:22.778Z</updated>
    
    <content type="html"><![CDATA[<p>用了 8 年的 Apple Watch，一直就知道其中有「有氧适能水平」这一身体指标。由于最近自身身体上出现的一些问题，开始更加关注它。</p><p>由于 Apple 健康中给出的有氧适能相关的解释不甚清晰，所以检索资料后，对有氧适能水平做一些简单的记录。</p><span id="more"></span><p>有氧适能是评估身体摄取（与肺脏关系最大）、运输（和心脏关系较大）、利用（和肌肉组织关系较大）能力的指标。其公式可以表述为</p><p><code>$\text&#123;$\text&#123;VO&#125;_2$ MAX&#125; = \text&#123;MHR&#125;\times\text&#123;SV MAX&#125;\times\text&#123;A-V $\text&#123;O&#125;_2$ diff&#125;.$</code></p><p>这里</p><ul><li>MHR 是最大心率。这是一个估算值。对于身体健康的成人来说，它与年龄（周岁）负相关。具体计算方法为 <code>$220 - \text&#123;年龄&#125;$</code>。对于有特别的病史的人（比如有过心肺手术术后病史的人），MHR 的计算方法不能就此预估，应当咨询医生。</li><li>SV MAX 是心脏每一次搏动射血量（每搏输出量）的最大值，是评估心脏能力的重要指标。</li><li>A-V O2 diff 则是动静脉中含氧量的差异，是评估机体利用氧气能力的重要指标。</li></ul><p>可见，在 SV Max 和 A-V O2 diff 不变的情况下，随着年龄的增长，VO2 Max 的指标确实会逐渐降低。但若保持运动，可使指标降低的速率变慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用了 8 年的 Apple Watch，一直就知道其中有「有氧适能水平」这一身体指标。由于最近自身身体上出现的一些问题，开始更加关注它。&lt;/p&gt;
&lt;p&gt;由于 Apple 健康中给出的有氧适能相关的解释不甚清晰，所以检索资料后，对有氧适能水平做一些简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Apple Watch" scheme="https://liam.page/tags/Apple-Watch/"/>
    
      <category term="有氧适能水平" scheme="https://liam.page/tags/%E6%9C%89%E6%B0%A7%E9%80%82%E8%83%BD%E6%B0%B4%E5%B9%B3/"/>
    
  </entry>
  
  <entry>
    <title>这书有点甜——《数理化通俗演义》读后感</title>
    <link href="https://liam.page/2024/04/21/book-review-a-general-narration-of-math-physics-and-chemistry/"/>
    <id>https://liam.page/2024/04/21/book-review-a-general-narration-of-math-physics-and-chemistry/</id>
    <published>2024-04-21T13:17:44.000Z</published>
    <updated>2024-04-21T14:31:34.584Z</updated>
    
    <content type="html"><![CDATA[<p>《数理化通俗演义》是梁衡的作品。本书初版于 1984 年，距今已有 40 年的历史。</p><p>初次知道这本书，大约是 2019 年时候在知乎上浏览时看到网友推荐。至今的 5 年时间里，我也不知读了它多少遍。萦绕在我脑海里的一个问题就是，这么好的一本科普书，为什么在我年少时没有读到过？——实际上，少时的我，读类似的书并不少。</p><span id="more"></span><p>《数理化通俗演义》以小说的形式，让我们仿佛穿越回那些科学大发现的时代。看着书里一个个栩栩如生的科学家形象和他们的故事，不仅能让读者学到了很多科学知识，更能让读者感受到科学探索的那份激情和艰辛。</p><p>想想看，那些年我们在学校里学习的时候，数理化总是让很多同学觉得头大。尤其那些偏爱文科的同学，大约对那些公式和定理更是又爱又恨。但是，如果当年我们能有机会读到《数理化通俗演义》，可能会完全改观。这本书用它那富有感染力的叙述方式，简直是为数理化课本的生硬知识点披上了一层浓厚的糖衣。</p><p>书中不仅仅是把科学知识简化了，更重要的是，它让我们看到了科学家们的人性光辉。他们不是高高在上的圣人，而是有血有肉、有情有义的普通人。他们在科学的道路上也会跌跌撞撞，甚至犯错。这样的描写，让我深刻体会到，科学不仅是理智的积累，更是情感与智慧的结合。</p><p>特别是在介绍生物链和细菌病毒的章节，我不由得联想到几年前的新冠疫情。如果不是有那么多科学家前赴后继的研究和牺牲，我们现在可能还在与病毒斗争的更加艰难的境地。这本书中关于科学发展的历史回顾，不只是让我们了解过去，更是让我们对未来充满了希望。</p><p>所以，是的。在我眼里，这是一本好书，一本值得推荐的书。我特别推荐这本书给那些对数理化感到害怕或者不感兴趣的人。你们会发现，从探索者的角度出发，科学其实并不是那么的难懂，它充满了探险和发现的乐趣。书中的科学家们用他们的智慧和毅力，为我们展示了一个又一个令人兴奋的科学世界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《数理化通俗演义》是梁衡的作品。本书初版于 1984 年，距今已有 40 年的历史。&lt;/p&gt;
&lt;p&gt;初次知道这本书，大约是 2019 年时候在知乎上浏览时看到网友推荐。至今的 5 年时间里，我也不知读了它多少遍。萦绕在我脑海里的一个问题就是，这么好的一本科普书，为什么在我年少时没有读到过？——实际上，少时的我，读类似的书并不少。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature and Social Sciences" scheme="https://liam.page/categories/Literature-and-Social-Sciences/"/>
    
    
      <category term="Book review" scheme="https://liam.page/tags/Book-review/"/>
    
      <category term="数理化通俗演义" scheme="https://liam.page/tags/%E6%95%B0%E7%90%86%E5%8C%96%E9%80%9A%E4%BF%97%E6%BC%94%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>《谈人生》读后感</title>
    <link href="https://liam.page/2024/03/17/book-review-tanrensheng/"/>
    <id>https://liam.page/2024/03/17/book-review-tanrensheng/</id>
    <published>2024-03-17T05:32:33.000Z</published>
    <updated>2024-04-21T14:20:32.081Z</updated>
    
    <content type="html"><![CDATA[<p>最近读完了季羡林先生的《谈人生》。此处要感谢 Millie 赠书。</p><p>这是季先生万年在医院疗养期间亲自编选的作品集。文集收录了季先生在人生各个阶段的代表作品。从文体上说，涵盖散文、随笔、邮寄、回忆录、日记、讲演报告等。</p><p>在读书的过程中，遇到一些自觉有趣的文字，就随手摘录，并作感想。这里同季先生选编文集一样，将这些摘录和感想选编在一起，形成此文。</p><span id="more"></span><blockquote><p>时光流逝，一转眼，自己已经到了望九之年，活得远远超过了我的预算。有人认为长寿是福，我看也不尽然。人活得大久了，对人生的种种相、众生的种种相，看得透透彻彻，反而鼓舞时少，叹息时多，远不如早一点离开人世这个是非之地，落一个耳根清净。</p><p>……</p><p>话说到这里，我想把上面说的意思简短扼要地归纳一下：如果人生真有意义与价值的话，其意义与价值就在于对人类发展的承上启下、承前启后的责任感。</p><p>——《人生的意义与价值》 季羡林</p></blockquote><p>季先生的文字还是有趣的。</p><p>「活得超过了预算」初看到真的会笑死，然后反思自己好像没有做这样的预算，又继而想是否有必要做这样的预算？乐而又乐。</p><p>「被困于名缰，被缚于利索」这一句容易理解，但应该惊叹大师练字的本领。名缰利索算是一般常见的词。单独用，大体上也就感觉是有那么个东西。拆开使用平添不少意味，「作茧自缚」的感觉被加强，终知名缰利索是自困、自缚，而不是他困、他缚。</p><p>文末的总结很有中华文人的古典气质：追求传世，追求大同。</p><p>若说印度之类的国家修来世（做好事是为了来生转世得好缘法），沙漠三教修今世（做好事是为了今生赎罪得上天堂），那中华文化圈就是修传世。即是说，人总要留下或是血脉传承或是文脉传承的东西，为民族、人类的发展留下自己的印记。而若再进步一点者，可以推动人类向前，那便可以在生命最后一刻坦然地说「我已尽到责任」了。</p><hr><blockquote><p>现在杨女士却对我垂青，要我作“哲学思考”，侈谈“禅趣”，我焉得不诚惶诚恐呢？这就是我把来信搁置不答的真正原因。我的如意算盘是，我稍搁置，杨女士担当编辑重任，时间一久，就会把此事忘掉，我就可以逍遥自在了。</p><p>然而事实却大出我意料，她不但没有忘掉，而且打来长途电话，直捣黄龙，令我无所逃于天地之间。我有点惭愧，又有点惶恐。但是，心里想的却是：按既定方针办。我连忙解释，说我写惯了考据文章。关于“禅”，我只写过一篇东西，而且是被赶上了架才写的，当然属于“野狐”一类。我对她说了许多话，实际上却是“居心不良”，想推掉了事，还我一个逍遥自在身。</p><p>可是我万万没有想到，正当我颇为得意的时候，杨女士的长途电话又来了，而且还是两次。昔者刘先主三顾茅庐，躬请卧龙先生出山，共图霸业。藐予小子，焉敢望卧龙先生项背！三请而仍拒，岂不是太不识相了吗？我痛自谴责，要下决心认真对待此事了。我拟了一个初步选目。过后自己一看，觉得好笑，选的仍然多是考据的东西。我大概已经病入膏肓，脑袋瓜变成了花岗岩，已经快到不可救药的程度了。于是决心改弦更张，又得我多年的助手李铮先生之助，终于选成了现在这个样子。这里面不能说没有涉及禅趣，也不能说没有涉及人生。但是，把这些文章综合起来看，我自己的印象是一碗京海杂烩。可这种东西为什么竟然敢拿出来给人看呢？自己“藏拙”不是更好吗？我的回答是：我在任何文章中讲的都是真话，我不讲半句谎话。而且我已经到了耄耋之年，一生并不是老走阳光大道，独木小桥我也走过不少。因此，酸、甜、苦、辣，悲、欢、离、合，我都尝了个够。发为文章，也许对读者，特别是青年读者，不无帮助。这就是我斗胆拿出来的原因。倘若读者—不管是老中青年—真正能从我在长达八十多年对生活的感悟中学到一点有益的东西，那我就十分满意了。至于杨女士来信中提到的那一些想法或者要求，我能否满足或者满足到什么程度，那就只好请杨女士自己来下判断了。</p><p>——《禅趣人生》 季羡林</p></blockquote><p>如先前所说，季先生的文字属实有趣。今日始知这份有趣来自「不作伪」。</p><p>大师也有七情六欲，遇事也会有退缩逃避，然后打起如意算盘。<br>大师在如意算盘被瞧破之后，也会有惶恐（也许心虚脸红？）。<br>大师也会有思维定式，然后感叹自己的脑袋瓜变成了花岗岩。</p><p>真诚而不作伪是打动读者的「大杀器」，写文十年深以为然。然则想要真诚而不作伪，需得首先与自己握手言和，内照己心而圆融无碍。若不然，为了所谓的「面子」或者时下流行的「人设」，则难免带上偏见，从而在自知或者不自知的情况下作伪。</p><hr><blockquote><p>敌兵压境，应当振作起来，鼓励士兵，同仇敌忾，可是苻坚自己却先泄了气。这样的人不称为孱头，又称之为什么呢？结果留下了两句著名的话：“风声鹤唳，草木皆兵。”至今还流传在人民的口中，也可以说是流什么千古了。</p><p>——《论恐惧》季羡林</p></blockquote><p>我快要被「流什么千古」笑死了。</p><p>文人笔墨，果然有趣。放着有「遗臭万年」不用，偏生要去用「流什么千古」（显然这里的什么代指臭）。用这种小朋友也能懂的小手法表达「遗臭万年」的含义，有多出俏皮和趣味。</p><hr><blockquote><p>对此我有自己的哲学基础：吃饭是为了自己，而穿衣则是为了别人。道理自明，不用辩证。哪有一个人穿着华丽，珠光宝气，天天坐在菱花镜前，顾影自怜？如果真正有的话，他或她距入疯人院的日期也不会远了。</p><p>——《衣着的款式》季羡林</p></blockquote><blockquote><p>至于衣着，更不在我考虑之列。在这方面，我是一个“利己主义者”。衣足以蔽体而已，何必追求豪华。一个人穿衣服，是给别人看的。如果一个人穿上十分豪华的衣服，打扮得珠光宝气，天天坐在穿衣镜前，自我欣赏，他（她）不是一个疯子，就是一个傻子。如果只是给别人去看，则观看者的审美能力和审美标准，千差万别，你满足了这一帮人，必然开罪于另一帮人，绝不能使人人都高兴，皆大欢喜。反不如我行我素，我就是这一身打扮，你爱看不看，反正我不能让你指挥我，我是个完全自由自主的人。</p><p>——《漫谈消费》季羡林</p></blockquote><p>看到前一篇文章部分时候，我还在诧异什么叫做「穿衣是为了别人」。这与我心中所想相差颇大，也与认知中的季老影响相去甚远。</p><p>继续读到后一篇文章才明白季老想表达的意思。这个「给别人看的」其实是说，别人看看就好，至于看过之后意见如何则不必在意。</p><p>穿衣服嘛，蔽体、得体即可。</p><hr><blockquote><p>不管你意识到还是没有意识到，大自然还是把虚无缥缈的时间用具体的东西暗示给了人们。比如用日出日落标志出一天，用月亮的圆缺标志出一月，用四季（在印度是六季或者两季）标志出一年。</p><p>——《时间》季羡林</p></blockquote><p>印度居然有六季的说法。原来蟪蛄不知春秋不只是说说。若在印度，我岂不就是阿成不知雨风吗？</p><p>查阅得印度一年分为六个季节，这六个季节分别是春季、夏季、雨季、秋季、风季、冬季。<br>春季（3月20——5月19）  金星主宰<br>夏季（5月20——7月19）  太阳与火星主宰<br>雨季（7月20——9月19）  月亮主宰<br>秋季（9月20——11月19） 水星主宰<br>风季（11月20——1月19）  木星主宰<br>冬季（1月20——3月19）  土星主宰</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读完了季羡林先生的《谈人生》。此处要感谢 Millie 赠书。&lt;/p&gt;
&lt;p&gt;这是季先生万年在医院疗养期间亲自编选的作品集。文集收录了季先生在人生各个阶段的代表作品。从文体上说，涵盖散文、随笔、邮寄、回忆录、日记、讲演报告等。&lt;/p&gt;
&lt;p&gt;在读书的过程中，遇到一些自觉有趣的文字，就随手摘录，并作感想。这里同季先生选编文集一样，将这些摘录和感想选编在一起，形成此文。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature and Social Sciences" scheme="https://liam.page/categories/Literature-and-Social-Sciences/"/>
    
    
      <category term="Book review" scheme="https://liam.page/tags/Book-review/"/>
    
      <category term="季羡林" scheme="https://liam.page/tags/%E5%AD%A3%E7%BE%A1%E6%9E%97/"/>
    
      <category term="谈人生" scheme="https://liam.page/tags/%E8%B0%88%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>百度大搜的一些历史经验</title>
    <link href="https://liam.page/2024/01/04/legacy-experience-of-Baidu-search/"/>
    <id>https://liam.page/2024/01/04/legacy-experience-of-Baidu-search/</id>
    <published>2024-01-04T01:10:24.000Z</published>
    <updated>2024-01-04T01:27:36.108Z</updated>
    
    <content type="html"><![CDATA[<p>这是 2016 年 6 月和百度的技术专家交流的一些经验总结。近期翻出来，记录在这里。</p><span id="more"></span><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>AC：高级搜索（AS 拆出来的），类似于 tuner 上移后的 merger</li><li>DX：存储正排相关的内容，最简单的是存储每个 url 的所有文字内容，然后可以存储各种离线 parse 出来的内容（包括各种段落、命名实体等信息）</li><li>GBRank：可以认为是 GBDT 的同义词</li><li>BS：基于倒排索引的分布式索引的基础检索，类似于 qsrchd 或者 leaf</li></ul><h2 id="百度的在线-ranking-相关架构"><a href="#百度的在线-ranking-相关架构" class="headerlink" title="百度的在线 ranking 相关架构"></a>百度的在线 ranking 相关架构</h2><p>基本如图。这个应该是表意的，不是完全和实际情况对应的。</p><p><img data-src="/uploads/images/algorithms/baidu-ranking-arch-2016.jpg"></p><p>重点说明：</p><p>DX - 正排库，对前 300 条结果进行精细正排计算，会重新计算 proximity。这个模块我们当前（2016）是缺失的，我们只有前 100 条结果的title。对方描述里这个模块是非常重要的，是百度 12 年相关性提升最大的项目。</p><p>百度的基本流程应该是 BS（qsrchd&#x2F;leaf）返回结果，merge 后对前 300 条在 DX 重新排序，返回给 AC，AC 继续重新排序，然后返回。</p><p>DX 和 AC 各有一个 GBRank 模型来负责排序。</p><h2 id="百度-LTR-的发展历程"><a href="#百度-LTR-的发展历程" class="headerlink" title="百度 LTR 的发展历程"></a>百度 LTR 的发展历程</h2><h3 id="第一阶段：线性模型"><a href="#第一阶段：线性模型" class="headerlink" title="第一阶段：线性模型"></a>第一阶段：线性模型</h3><p>特征的线性拟合：$Y &#x3D; \sum_{i}\omega_if_i$。</p><p>效果：和手写规则基本打平。</p><p>好处：基本验证机器学习是可行的，同时，可以得到每个特征有多大作用，即每个特征的 weight，这个 weight 的概念对于理解机器学习有非常大的作用，在后面用非线性模型时，他们依然找到一种计算特征weight的方法，这个方法在debug中也起到很大的作用。</p><h3 id="第二阶段：GBRank"><a href="#第二阶段：GBRank" class="headerlink" title="第二阶段：GBRank"></a>第二阶段：GBRank</h3><p>这个和我们用的lambdaMart基本类似。</p><ol><li>标注量：DX 的 GBRank 当标注 query 上升到 7--8w 量级时，有明显提升，对比目前我们的标注量是不到 4w。</li><li>特征数量：100 左右，比我们少。他们每个特征都做的很细，都有可解释的物理意义，大部分特征会有相应的评测。相反我们有 180 个特征，但是大部分都是围绕点击来做的，同时特征可解释性差，没有单独评测。</li><li>debug 平台：强大的 debug 平台，可以计算每个特征的 weight，在树模型里，对方描述的计算 weight 的方法是在给定的数据集上，固定其他的特征，观察目标特征的变化导致的预测值的变化，用这个变化来计算 weight 的权重。对于具体的 badcase，如果是由于这个 case 在某些特征上不合理，预期 debug 平台是能够发现，所以通过 badcase + debug 平台，能够逐步地改进特征。</li><li>控制diff，当新加特征时，diff率太大的问题。对方的描述中也提到尝试过 continue train。但是他们最后使用的是bagging的方法来提升模型的稳定性，这个思路我们之前没有想到过，可以借鉴。</li></ol><h3 id="第三阶段：深度学习"><a href="#第三阶段：深度学习" class="headerlink" title="第三阶段：深度学习"></a>第三阶段：深度学习</h3><p>基本思路和我们目前做的是一样的，但是各种细节还是不一样</p><ol><li>使用长尾 query 的点击与未点击的数据作为训练数据，他们并没有观察过数据的准确率，但估计还行。相反地，我们用各种方法得到的数据准确率偏低，这个可以在多尝试一些方法。</li><li>大数据量，100 亿规模，与之对比的是我们只有 1 亿的规模。</li><li>模型简单，基本上只有一个隐层。</li><li>多机并行版本，百度 IDL 提供的平台。</li><li>将深度学习得到的语义相似度作为模型加入到 BRank 里。</li></ol><h2 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h2><p>Q： 百度如何评测</p><p>A： 测试集 ndcg + 人工 side by side + 线上小流量实验</p><hr><p>Q：DX 的作用</p><p>A：DX 提供的正排对于计算 proximity，term 紧密度非常重要，是必不可少的一个模块，并且为后续的一些质量改进可能也提供了基础，对长尾 query 的提升非常大</p><hr><p>Q：DX 具体存了什么</p><p>A：url 的正排，同时包括 entity&#x2F;anchor 等，提到分域存储（这个回答貌似不是很全面）</p><hr><p>Q：GBRank 如何控制 diff</p><p>A：用 bagging 来提升模型稳定性，可以是几个 bagging 的 GBRank，也可以是 GBRank 里面每棵树用 bagging 的方法来生成多个树。Bagging 的 GBDT 已经有人做过了，但是效果和非 bagging 的差不多，但是之前没有人从模型稳定性来看这个问题，从稳定性的角度来看，bagging 就比较重要了。</p><hr><p>Q：ltr 的标注规模</p><p>A：DX 上升到 7--8w 时效果提升比较大，百度的整体标注规模在几十万 query 级别。每个 query 标注了 20 条。</p><hr><p>Q：ltr 标注 query 是怎么选取的</p><p>A： 随机，偏向长尾，40%是长尾的。还说看长尾是怎样定义，貌似听见一个搜索次数小于 10 次。</p><hr><p>Q：是否采用 active learning 来选取标注集</p><p>A： 没有，但是后来在 spam 的机器学习上有采用，因为 spam 的样本少。</p><hr><p>Q：百度的标注人力是怎样的</p><p>A：全公司的标注是外包的，只需要在平台提交标注任务就可以了</p><hr><p>Q：新特征的开发过程是怎样的，是否需要先经过评测，还是直接放到 GBRank 里，通过 debug 来发现特征是否符合预期</p><p>A： 新特征一般来讲还是要先经过评测，确保和 label 有一定的相关性</p><hr><p>Q：一些需要组合的特征，是否直接加入模型</p><p>A：从理论上来讲，直接加入，期望模型学习出来各种组合是可以的，但百度不是这样干的，如果你觉得一些特征需要组合，最好手动组合，把组合后的特征加入到模型</p><hr><p>Q：特征的 weight 是如何计算的</p><p>A：类似于算导数的方法，上面已经大概说过了。</p><hr><p>Q：LTR 的工作方向，模型为主还是特征为主</p><p>A：经历不同时期，一开始模型为主，后面加入 DNN 后，特征变的很大，很难做，当然这些特征也是 LTR 团队做。LTR 团队一开始 4 个人，后面发展到接近 20 人。</p><hr><p>Q：新特征的上线方式</p><p>A：如果另外一个团队升级了一个特征，一般来讲不重新训练，直接上线。如果是新加了特征，ltr 团队会负责重新训练。如果同时加了多个特征，也是 ltr 团队负责重新训练上线</p><hr><p>Q：GBRank 上面是否还有 ranksvm</p><p>A： 没有</p><hr><p>Q：DNN 的并行化方式</p><p>A：用的 IDL 的平台，100 多台机器？100 亿的数据规模， 一开始模型比较简单，经过 4--5 个月做出来后，效果非常好。后面也逐渐尝试 cnn，rnn 等</p><hr><p>Q：目前我们 1 亿的数据，有啥建议</p><p>A：先把数据加到 10 亿，看看效果。他们在 1 亿的时候效果也不明显。可以把 1kw&#x2F;5kw 数据时的结果拿来观察</p><hr><p>Q：ltr 标注量多少比较合适</p><p>A：DX在标注到 7--8w 时有比较大的突破。 这个数据提到好几次，可能他们的实际情况确实是数据量提升到 7--8w 时产生了一个质变。</p><hr><p>Q：DX 也是 GBRank</p><p>A：是，DX 也是用 GBRank 来排序</p><hr><p>Q：AC 还有多少基于规则的排序</p><p>A：基本没有了，都被替换了，但是 AC 的上游 US 还有一些规则，例如合并 onebox 等</p><hr><p>Q：百度结果里经常靠百度知道顶着，大搜索是否对百度知道有特殊处理，例如单字检索等</p><p>A：没有对百度知道特殊处理。但是百度知道是一个垂搜， US会请求。同时百度知道有很多站内的权重数据，可能做的比较好</p><hr><p>Q：DNN 出来的值是作为特征加入到 GBRank 里的吗？</p><p>A：是的</p><hr><p>Q：LTR 技术的发展过程</p><p>A：先是把 rank 的 LTR 做好，站住脚，然会向外输出技术，例如泛时效性 query 的识别，省略与 termweight、spam 等。</p><hr><p>Q：DNN 的关键</p><p>A：数据量，必须上大数据量。与 msra 的 gaojianhong 交流是，对于 msra 只用了 1 亿的数据量很鄙视</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LTR 使用的特征非常谨慎：对特征做了很多特征工程，尽量让每个特征有意义。</li><li>DX 起到关键作用，DX 在长尾 query 的基础相关性上起到决定性作用，提供了很多特征。</li><li>GBRank 的 debug 平台非常重要，必不可少。</li><li>DNN 必须上大数据量。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 2016 年 6 月和百度的技术专家交流的一些经验总结。近期翻出来，记录在这里。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Search" scheme="https://liam.page/tags/Search/"/>
    
      <category term="Baidu" scheme="https://liam.page/tags/Baidu/"/>
    
  </entry>
  
  <entry>
    <title>教程：如何在越狱设备上映射目录？</title>
    <link href="https://liam.page/2023/04/21/Toturial-how-to-bind-and-mount-folders-on-a-jailbroken-device/"/>
    <id>https://liam.page/2023/04/21/Toturial-how-to-bind-and-mount-folders-on-a-jailbroken-device/</id>
    <published>2023-04-21T06:57:12.000Z</published>
    <updated>2023-04-30T08:33:09.962Z</updated>
    
    <content type="html"><![CDATA[<p>字体替换、生效替换、动画效果资源替换……这些都是越狱圈经久不衰的美化需求。</p><p>在 iOS 15 以前，因为没有 SSV，所以用户可以在越狱后的设备上直接替换系统目录下的文件达成效果。实际上，当年的很多「字体插件」就是干的这么个事情。但从 iOS 15 开始，事情发生了变化。Apple 向 iOS 引入了在 macOS 上已经成熟的技术：SSV。用普通人能理解的话说，SSV 是一个在系统启动阶段的密码学校验机制。它会校验整个系统目录是否完整无修改，而如果校验失败则会拒绝启动（表现为反复白苹果）。因此，我们需要新的方案。</p><span id="more"></span><h2 id="目录映射是什么？"><a href="#目录映射是什么？" class="headerlink" title="目录映射是什么？"></a>目录映射是什么？</h2><p>对于普通用户，目录映射理解为是一种可以达到「指鹿为马」效果的机制。即是说，当系统或者某个软件想要访问某个路径 A 时，通过建立 A 与 B 的映射关系，让系统或者软件实际访问到的是 B 而不自知。</p><p>以字体为例。iOS 系统所用的字体存放于 <code>/System/Library/Fonts</code> 这个目录下。显然，我们无法修改其中的内容，否则 SSV 校验失败，机器就变砖了。但是，我们可以做目录映射，比如将其映射到 <code>/var/jb/System/Library/Fonts</code> 这个目录下。其中 &#x2F;var&#x2F;jb 是越狱后我们有权限修改而无需担心破坏 SSV 的路径。这样一来，我们只需要修改 <code>/var/jb/System/Library/Fonts</code> 下的文件内容，就能让系统和软件读取到替换后的字体了。</p><p>但要注意，<code>/var/jb/System/Library/Fonts</code> 这个路径下原本是没有内容的。因此，建立这种映射关系的前提是要将原始目录（source）当中的内容拷贝一份到目标目录（target）中去，然后再建立这一映射关系。这是有代价的。尽管 iOS 使用的文件系统 APFS 有 Copy-on-Write 的能力，但它对跨 Volumn 的拷贝并不生效（而 <code>/System</code> 和 <code>/var/jb</code> 就是在不同 Volumn 中的）。因此，这种拷贝会占用系统的存储空间，尽管可用，但不是没有代价。</p><h2 id="Fugu15-Max-怎样开启目录映射？"><a href="#Fugu15-Max-怎样开启目录映射？" class="headerlink" title="Fugu15 Max 怎样开启目录映射？"></a>Fugu15 Max 怎样开启目录映射？</h2><p>很遗憾，Fugu15 Max 的官方版本并不支持用户自定义的目录映射，而且大概率在将来也不会添加这一功能。因此，想要自定义目录映射的用户只能选择第三方修改的越狱包。这其中也存着风险——你并不知道第三方有没有往里面「加料」。</p><p>目前，已知支持用户自定义目录映射功能的有</p><ul><li><a href="https://github.com/Liam0205/Dopamine/releases/tag/auto_1681979446">我维护的 Fugu15 Max（可以与官方版本共存）</a>，以及</li><li>真皮维护的 Fugu15 Max。</li></ul><p>普通用户只需安装上述越狱包即可开启自定义的目录映射。默认已开启映射的目录有：</p><ul><li><code>/System/Library/Fonts</code></li><li><code>/System/Library/PrivateFrameworks/CoverSheet.framework/zh_CN.lproj</code></li><li><code>/System/Library/PrivateFrameworks/SpringBoardUIServices.framework/zh_CN.lproj</code></li><li><code>/System/Library/PrivateFrameworks/UserNotificationsUIKit.framework/zh_CN.lproj</code></li></ul><p>这两个版本都已开源。并且，真皮的开源修改版我已完整检查过代码，确认没有加料。我自己的改版当然也是开源不加料的。这里要特别感谢真皮：我维护的版本里目录映射的功能代码最初就是来自真皮的开源改版。（俗称：抄代码）</p><h2 id="怎样进行替换？"><a href="#怎样进行替换？" class="headerlink" title="怎样进行替换？"></a>怎样进行替换？</h2><p>以 <code>AppleSymbols.ttf</code> 这个字体为例。它是 Apple 官方提供的字体，包含了各种特殊符号；其默认路径位于 <code>/System/Library/Fonts/Core/AppleSymbols.ttf</code>。</p><p>假使我们获得了一个改版的 <code>AppleSymbols.ttf</code> 文件（例如，网上广泛流传的所谓盲文修改版），就可以利用 Filza（可通过 TrollStore 安装）将它复制并粘贴到 <code>/var/jb/System/Library/Fonts/Core/AppleSymbols.ttf</code>，然后注销（Restart SpringBoard）即可使其生效。</p><p>有时，你也可能获得一组字体。此时，若你想要替换，则需要逐个目录地对字体文件进行替换（可以多选文件，但是不要替换目录本身）。</p><h2 id="想要映射更多目录怎么办？"><a href="#想要映射更多目录怎么办？" class="headerlink" title="想要映射更多目录怎么办？"></a>想要映射更多目录怎么办？</h2><p>我的修改版和真皮的修改版都支持用户自己添加更多映射目录。但这需要用户通过 Filza 自己修改相应的 plist 配置文件。</p><ul><li>我的版本，配置文件位于 <code>/var/mobile/prefixers.plist</code>，在 <code>Root/source</code> 下添加你想要映射的目录，然后重启再越狱即可。</li><li>真皮的版本，配置文件位于 <code>/var/mobile/newFakePath.plist</code>，在 <code>Root/path</code> 下添加你想要映射的目录，然后重启再越狱即可。</li></ul><p>进阶用户（需要会使用命令行）也可以做到无需重启越狱即可实现新增映射目录。</p><ul><li>我的版本，复制配置文件至 <code>/var/mobile/update.prefixers.plist</code>，在 <code>Root/source</code> 下添加你想要映射的目录，然后在命令行执行 <code>/var/jb/basebin/jbctl update_bindmount</code> 即可。</li><li>我的版本，复制配置文件至 <code>/var/mobile/otaFakePath.plist</code>，删除 <code>Root/pat</code>h 下的已有目录，再添加你想要映射的目录，然后在命令行执行 <code>/var/jb/basebin/jbctl OTAFake</code> 即可。</li></ul><h2 id="迁移到-Dopamine-之后呢？"><a href="#迁移到-Dopamine-之后呢？" class="headerlink" title="迁移到 Dopamine 之后呢？"></a>迁移到 Dopamine 之后呢？</h2><p>我也将修改并维护中文版的 Dopamine（多巴胺）。迁移到多巴胺后，用户需要在设置中打开「启用目录映射」再进行越狱。</p><p>若想要增加自定义的目录映射，则可按照同样的方法修改 <code>/var/mobile/Library/Preferences/page.liam.prefixers.plist</code>（再次越狱生效），或是在越狱状态下修改 <code>/var/mobile/Library/Preferences/update.page.liam.prefixers.plist</code> 后执行命令 <code>/var/jb/basebin/jbctl update_bindmount</code> 以立即生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字体替换、生效替换、动画效果资源替换……这些都是越狱圈经久不衰的美化需求。&lt;/p&gt;
&lt;p&gt;在 iOS 15 以前，因为没有 SSV，所以用户可以在越狱后的设备上直接替换系统目录下的文件达成效果。实际上，当年的很多「字体插件」就是干的这么个事情。但从 iOS 15 开始，事情发生了变化。Apple 向 iOS 引入了在 macOS 上已经成熟的技术：SSV。用普通人能理解的话说，SSV 是一个在系统启动阶段的密码学校验机制。它会校验整个系统目录是否完整无修改，而如果校验失败则会拒绝启动（表现为反复白苹果）。因此，我们需要新的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>通过 Apple Configurator 安装 TrollStore</title>
    <link href="https://liam.page/2023/04/04/Install-TrollStore-by-Apple-Configurator/"/>
    <id>https://liam.page/2023/04/04/Install-TrollStore-by-Apple-Configurator/</id>
    <published>2023-04-04T03:39:46.000Z</published>
    <updated>2023-04-13T12:57:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>近日有朋友问到，当无法通过<a href="https://github.com/opa334/TrollStore">标准的网页安装</a>的方式安装 TrollStore 时，应当怎么办。</p><p>这里提供一个利用 Apple Configurator 安装的办法。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>一台 Mac（此处测试的是 macOS 12.6.1）</li><li>一台可安装 TrollStore 的 iDevice（此处测试的是 iPhone Xʀ, iOS 15.1）</li><li>一根可以连接 Mac 和 TrollStore 的线缆</li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>打开 Mac，并打开 App Store.app</li><li>搜索并安装：Apple Configurator</li><li>打开 Apple Configurator，将手机和 Mac 连接</li><li>在 Apple Configurator 中，选中你的手机，然后在上方点 + 号，选择 App</li><li>左下角，选择「从我的 Mac 选取」，找到 GTA Car Tracker.ipa，等待安装</li><li>等待手机上安装好 GTA Car Tracker 后，打开它，选择 Install TrollStore</li><li>打开 TrollStore，install ldid</li><li>在 TrollStore 的设置页选择 Install Presistence Helper，选一个你不会用到的系统 App（我选的是 Home&#x2F;家庭）</li><li>如常使用</li></ol><p>这种方法因为 GTA Car Tracker 的权限不够，所以不能被选为 Presistence Helper，只能选择一个平常不用的系统 App。之后，如果 TrollStore 及其安装的 App 闪退&#x2F;无法打开，则可以打开 Home&#x2F;家庭 App，刷新 App。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日有朋友问到，当无法通过&lt;a href=&quot;https://github.com/opa334/TrollStore&quot;&gt;标准的网页安装&lt;/a&gt;的方式安装 TrollStore 时，应当怎么办。&lt;/p&gt;
&lt;p&gt;这里提供一个利用 Apple Configurator 安装的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="TrollStore" scheme="https://liam.page/tags/TrollStore/"/>
    
      <category term="Configurator" scheme="https://liam.page/tags/Configurator/"/>
    
  </entry>
  
  <entry>
    <title>越狱后 iDevice 的重启、重启用户空间、软重启、注销、重建图标之间的关系</title>
    <link href="https://liam.page/2023/03/17/difference-between-reboot-reboot-userspace-ldrestart-respring-and-unicache/"/>
    <id>https://liam.page/2023/03/17/difference-between-reboot-reboot-userspace-ldrestart-respring-and-unicache/</id>
    <published>2023-03-17T03:39:50.000Z</published>
    <updated>2023-04-13T12:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<p>越狱用户在将 iDevice 越狱后往往会接触到重启、重启用户空间、软重启、注销、重建图标这些概念。但中文互联网圈子内似乎还没有对它们做完整解释的帖子，故有此篇。</p><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h3><p>内存对于程序的运行是必不可少的。程序需要将自身的可执行代码以及运行过程中处理的数据结构存放在内存当中。操作系统内核也是一种程序，因此也和普通的用户应用程序一样需要内存。</p><p>为了安全起见，防止普通的用户应用程序不小心地（当然，也防止恶意地）访问并修改内核保存在内存中的内容，现代计算机的操作系统（iDevice 等手持设备也属于广义的计算机）会将整个内存寻址空间（这里的内存指得是虚拟内存）切出一块来单独给内核使用。这块空间就是所谓的内核空间。普通用户程序的权限较低，无权访问内核空间的内容，只能通过系统调用（System Call）来与内核进行交互。</p><p>与此相对应地，内核之外的所有其他用户应用程序都运行在内核空间之外的部分，即用户空间。</p><h3 id="launchd"><a href="#launchd" class="headerlink" title="launchd"></a><code>launchd</code></h3><p>在 macOS 和 iOS (包括衍生的 iPad OS 和 TVOS) 中，进程 ID（PID）为 1 的进程即是 <code>launchd</code>。这是操作系统内核启动后启动的第一个程序。它负责按需启动守护进程（不运行在前台的进程）和应用程序，并负责监控守护进程。操作系统启动后，所有后续启动的进程都是它的子子孙孙（直接或间接 <code>fork</code> 自 <code>launchd</code>）。</p><p><code>launchd</code> 还有一个配套的命令行应用程序 <code>launchctl</code>。它可以与 <code>launchd</code> 通讯，以便管理系统的各个守护进程。</p><h3 id="SpringBoard"><a href="#SpringBoard" class="headerlink" title="SpringBoard"></a>SpringBoard</h3><p>SpringBoard 是 iDevice 上管理主屏幕界面的标准应用程序。它也负责启动 WindowServer、启动 App 等工作。因此它也成为越狱后众多 Tweak 的注入目标。</p><h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><p>有了这些前置知识，我们就能对这些概念进行辨析了。</p><ul><li>重启（Reboot）：和普通意义上的「重启计算机」是同样的含义。它几乎相当于给设备断电，然后从零开始启动系统和其他应用程序。因此，如果你的 iDevice 运行的越狱不是完美越狱（Untethered Jailbreak），那么重启后将会丢掉越狱状态。在 iDevice 命令行中运行 <code>reboot</code> 可使设备重启。</li><li>重启用户空间（Reboot Userspace）：保持内核持续运行，但杀死所有运行在用户空间的进程，包括 <code>launchd</code>，然后重启。这种情况下，因为内核未受影响，所以重启用户空间后仍处于越狱状态。在 iDevice 命令行中运行 <code>launchctl reboot userspace</code> 可使设备重启用户空间。</li><li>软重启（<code>ldrestart</code>）：这是 Apple 官方提供的能力。和重启用户空间类似，但 <code>launchd</code> 本身并不会杀死然后重启。同样，为内核未受影响，所以重启用户空间后仍处于越狱状态。在 iDevice 命令行中运行 <code>ldrestart</code> 可使设备软重启。</li><li>注销（Respring）：杀死 SpringBoard，然后重启它。我们通常会在一些影响到 SpringBoard 的设置之后执行注销指令。显然，注销不会掉出越狱状态。在 iDevice 命令行中运行 <code>killall -9 backboardd</code> 可使设备注销。</li><li>重建图标（UICache）：SpringBoard 存有一份 App 图标、状态栏、Dock 等的缓存（UICache）。若你修改了这些内容，那么可能需要重建这一缓存来使你的变更生效。显然，重建图标不会掉出越狱状态。在 iDevice 命令行中运行 <code>uicache</code> 可使设备重建图标。</li></ul><p>注意，在重启用户空间和软重启的过程中，你可能有一定概率遇见内核错误（Kernel Panic），从而导致 iDevice 从重启用户空间&#x2F;软重启 fallback 到直接重启。这种情况，是会丢掉越狱状态的。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Netskao 开发的 PowerSelector 插件可在控制中心（Control Center）中添加一个插件。点按该插件的图标后会弹出一个窗口。在窗口中可以按需选择关机、重启、重启用户空间、软重启、注销、重建图标等操作。可谓十分方便，在此推荐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越狱用户在将 iDevice 越狱后往往会接触到重启、重启用户空间、软重启、注销、重建图标这些概念。但中文互联网圈子内似乎还没有对它们做完整解释的帖子，故有此篇。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Reboot" scheme="https://liam.page/tags/Reboot/"/>
    
      <category term="Userspace" scheme="https://liam.page/tags/Userspace/"/>
    
      <category term="LDRestart" scheme="https://liam.page/tags/LDRestart/"/>
    
      <category term="Respring" scheme="https://liam.page/tags/Respring/"/>
    
      <category term="UICache" scheme="https://liam.page/tags/UICache/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 14.5.1/unc0ver 8.0.2 上解决电池用量信息无法载入的问题</title>
    <link href="https://liam.page/2023/02/12/fix-battery-usage-graph-on-iOS-14-5-1-unc0ver-8-0-2/"/>
    <id>https://liam.page/2023/02/12/fix-battery-usage-graph-on-iOS-14-5-1-unc0ver-8-0-2/</id>
    <published>2023-02-12T11:01:30.000Z</published>
    <updated>2023-04-13T12:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<p>手头的 iOS 14.5.1 自使用 unc0ver 8.0.2 越狱起就一直困扰于无法正确载入电池用量信息。今日终于无法忍受这一问题，遂解决它。</p><span id="more"></span><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>经过一番检索，在 <a href="https://github.com/SongXiaoXi">@SongXiaoXi</a> 的<a href="https://github.com/LinusHenze/Fugu14/pull/242#issue-1242075829">这篇帖子</a>中找到了问题的原因。具体来说，Fugu14 在越狱过程中，将用户名 <code>_analyticsd</code> 改为了 <code>_nanalyticsd</code>，但其 ID 和 <code>$HOME</code> 则保持不变。但随后其他的某个守护进程将 <code>/private/var/db/analyticsd</code> 及其子目录的所有者改为了 <code>_analyticsd</code>（ID 变更为 <code>264</code>）。这造成 <code>_analyticsd.back</code> 以 <code>263</code> 启动时无法读取 <code>/private/var/db/analyticsd</code> 下的数据库信息，导致电池用量信息无法渲染。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决起来也很简单。我写了一个插件来完成所有需要的工作。你需要添加以下两个源，然后搜索安装 <code>FixBetteryUsageFugu14</code>：</p><ul><li><code>https://liam.page/apt/</code></li><li><code>https://liam.page/apt-beta/</code></li></ul><p>插件会在每次 SpringBoard 启动时执行一些 Shell 命令。</p><blockquote><p>你也可以手工执行这些命令观察其效果。但请确认你知道每一步在做什么之后再操作。</p><p>首先，你需要在 Cydia&#x2F;Zebra 等包管理器中安装 <code>file-cmds</code> 这一软件包。它提供了 <code>chflags</code> 命令。（或者，对于高级用户，也可以考虑安装 <a href="http://newosxbook.com/tools/iOSBinaries.html"><code>binpack64</code></a>）。</p><p>而后，你需要在 iOS 命令行（或者 SSH 过去）中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/mobile/Containers/Data/Fugu14Untether/Library/Caches/com.apple.dyld/</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo chflags -v noschg,nouchg *.closure</span><br><span class="line">sudo <span class="built_in">chown</span> 263:263 *.closure</span><br><span class="line">sudo chflags -v schg,uchg *.closure</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/mobile/Containers/Data/Fugu14Untether</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo <span class="built_in">chown</span> -h 263:263 /var/mobile/Containers/Data/Fugu14Untether/Library <span class="comment"># 只修改 Library 这一 symlink 的所有者</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/db</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo <span class="built_in">chown</span> -R 263:263 /var/db/analyticsd/</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line">sudo launchctl stop com.apple.analyticsd</span><br><span class="line"><span class="built_in">sleep</span> 3</span><br><span class="line">sudo launchctl start com.apple.analyticsd</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头的 iOS 14.5.1 自使用 unc0ver 8.0.2 越狱起就一直困扰于无法正确载入电池用量信息。今日终于无法忍受这一问题，遂解决它。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Fixing" scheme="https://liam.page/tags/Fixing/"/>
    
  </entry>
  
  <entry>
    <title>TrollStore 及常用 IPA 官方下载</title>
    <link href="https://liam.page/2023/02/08/TrollStore-and-useful-IPA-files/"/>
    <id>https://liam.page/2023/02/08/TrollStore-and-useful-IPA-files/</id>
    <published>2023-02-08T09:39:04.000Z</published>
    <updated>2023-04-13T12:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<p>TrollStore 是一个永久签名的非越狱 App。通过它，我们可以安装任意未签名的 IPA 文件。它基于一个存在于 iOS 14.0 -- iOS 15.4.1 当中的 AMFI&#x2F;CoreTrust 漏洞：iOS 不验证用于签署二进制文件的根证书是否合法。因此，如果你的 i-设备的系统版本在这个范围内，则可以安装 TrollStore，而不论是否越狱。</p><span id="more"></span><h2 id="TrollStore"><a href="#TrollStore" class="headerlink" title="TrollStore"></a>TrollStore</h2><p>TrollStore 由社区著名开发者 opa334 开发，安装方法及完整的支持列表可见其<a href="https://github.com/opa334/TrollStore#installation-guides">官方 GitHub 页面</a>。</p><h2 id="常用-IPA-官方下载"><a href="#常用-IPA-官方下载" class="headerlink" title="常用 IPA 官方下载"></a>常用 IPA 官方下载</h2><ul><li><a href="https://github.com/powenn/ModMyIPA/releases/">ModMyIPA</a>：它可以修改 IPA 文件的 Package 名字等信息。于是你可以利用它做 App 多开。</li><li><a href="https://github.com/sourcelocation/DebToIPA">DebToIPA</a>：它可以将 <code>.deb</code> 格式的 App 转成 <code>.ipa</code> 格式。</li><li><a href="https://www.tigisoftware.com/default/?p=439">Filza</a>：iOS 平台上著名的文件管理器。特别地，它可以访问系统根目录下的文件。（当然，最好不要在不熟悉的情况下对其中文件进行修改）</li><li><a href="https://github.com/D0m0/CocoaTop/releases/">CocoaTop</a>：iOS 平台上著名的进程管理器。</li><li><a href="https://github.com/CokePokes/AppStorePlus-TrollStore">AppStore++</a>：允许你自由降级从 AppStore 安装的 App。</li><li><a href="https://github.com/SmileZXLee/IpaDownloadTool">IPA 提取器</a>：允许你捕获网页安装的 IPA。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TrollStore 是一个永久签名的非越狱 App。通过它，我们可以安装任意未签名的 IPA 文件。它基于一个存在于 iOS 14.0 -- iOS 15.4.1 当中的 AMFI&amp;#x2F;CoreTrust 漏洞：iOS 不验证用于签署二进制文件的根证书是否合法。因此，如果你的 i-设备的系统版本在这个范围内，则可以安装 TrollStore，而不论是否越狱。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="TrollStore" scheme="https://liam.page/tags/TrollStore/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：给 App 砸壳</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-dumpdecrypted-IPA/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-dumpdecrypted-IPA/</id>
    <published>2023-01-21T14:47:07.000Z</published>
    <updated>2023-01-25T13:16:25.236Z</updated>
    
    <content type="html"><![CDATA[<p>在真正开始编写插件之前，我们还必须要分析我们的目标对象。只有进行了妥善的分析之后，我们才能确定要在何处进行注入、修改。</p><p>现代软件通常会加上一层加密的壳，必须经过脱壳才能分析。脱壳也常被戏称为砸壳。此篇我们介绍可用于 iOS 平台的脱壳工具。</p><span id="more"></span><h2 id="iOS-端：安装-frida-server"><a href="#iOS-端：安装-frida-server" class="headerlink" title="iOS 端：安装 frida-server"></a>iOS 端：安装 frida-server</h2><p>Frida 是跨平台的脱壳工具。首先我们需要在 iOS 上安装其服务端。</p><ul><li>源：<code>https://build.frida.re/</code></li><li>搜索 Frida 安装即可。</li></ul><blockquote><p>目前最新版本的 Frida (16.0.8) 存在 bug 会导致无法安装。蜗牛源（<code>https://repo.snailovet.com/</code>）提供了其早先版本（15.2.2）。经测试可用。</p></blockquote><h2 id="macOS-端：安装-frida-tools"><a href="#macOS-端：安装-frida-tools" class="headerlink" title="macOS 端：安装 frida-tools"></a>macOS 端：安装 frida-tools</h2><p>Terminal 中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-tools</span><br></pre></td></tr></table></figure><blockquote><p>为与 15.2.2 版本的 frida-server 匹配，你可能需要安装指定版本的 frida-tools。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-tools==11.0.0</span><br></pre></td></tr></table></figure></blockquote><p>而后，我们可以下载 dump 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump</span><br></pre></td></tr></table></figure><h2 id="Dumpdecrypting"><a href="#Dumpdecrypting" class="headerlink" title="Dumpdecrypting"></a>Dumpdecrypting</h2><p>使用 USB 线缆，连接手机和电脑。以不加载任何插件的方式启动你要砸壳的 App。（你可能需要 Choicy 这一插件来实现）</p><p>在 macOS 的 Terminal 中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/frida-ios-dump</span><br><span class="line">python3 dump.py -H 192.168.1.3 -p 22 -u root -P <span class="string">&#x27;alpine&#x27;</span> <span class="string">&quot;健康&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>-H</code> 指定你手机的 IP 地址，<code>-p</code> 指定 ssh 的端口，<code>-P</code> 指定 <code>root</code> 账户的密码（默认是 <code>alpine</code>）。<br>最后的程序名字，可以是显示在你手机上的名字，也可以是它的 Package ID。所有可用的 name&#x2F;ID 可以通过下列命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dump.py -H 192.168.1.3 -p 22 -u root -P <span class="string">&#x27;alpine&#x27;</span> -l</span><br></pre></td></tr></table></figure></blockquote><p>如此，即可在当前目录下生成 <code>健康.ipa</code> 可供后续分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真正开始编写插件之前，我们还必须要分析我们的目标对象。只有进行了妥善的分析之后，我们才能确定要在何处进行注入、修改。&lt;/p&gt;
&lt;p&gt;现代软件通常会加上一层加密的壳，必须经过脱壳才能分析。脱壳也常被戏称为砸壳。此篇我们介绍可用于 iOS 平台的脱壳工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Dumpdecrypting" scheme="https://liam.page/tags/Dumpdecrypting/"/>
    
  </entry>
  
  <entry>
    <title>解决 cisco.anyconnect.macos.acsockext 大量消耗 CPU 资源的问题</title>
    <link href="https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/"/>
    <id>https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/</id>
    <published>2023-01-21T09:47:04.000Z</published>
    <updated>2023-01-21T10:00:26.987Z</updated>
    
    <content type="html"><![CDATA[<p>最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。</p><span id="more"></span><p><img data-src="/uploads/images/computer-skills/acsockext-cpu-usage.jpg"></p><p>检查发现，这是因为在 4.10 版本开始，思科的 VPN 加入了 Socket 过滤功能。从现象来看，它几乎无时无刻不在 buzy loop（哪怕把所有网络连接都断掉），这应当是个 bug。从功能来看，这种全方位的过滤功能，实在令人担忧其安全性。因此决定干掉他。以下是步骤：</p><ul><li>打开系统设置 -&gt; 网络</li><li>应能观察到三个以 <code>Cisco...</code> 开头的网络配置</li><li>选中它们，然后点下方的 <code>-</code>，删除他们</li><li>右下角，应用</li><li>应能观察到 CPU 利用率立刻下降</li><li>删除 <code>/Applications/Cisco/Cisco AnyConnect Socket Filter.app</code> 以免将来之虞</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="CPU" scheme="https://liam.page/tags/CPU/"/>
    
      <category term="Cisco" scheme="https://liam.page/tags/Cisco/"/>
    
      <category term="VPN" scheme="https://liam.page/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：速览 Objective-C</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/</id>
    <published>2023-01-21T01:32:37.000Z</published>
    <updated>2023-01-21T14:47:48.481Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。</p><p>这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&#x2F;C++ 的熟练使用者则更好。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 是 C 语言的严格超集。即是说，在 C 编译器下能够编译的代码，应当可以不加修改地使用 Objective-C 的编译器来编译。（尽管可能行为不完全相同）另一方面，在 Objective-C 当中，可以混合使用 C 风格的代码。</p><h2 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h2><table><thead><tr><th></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td>C</td><td><code>.h</code></td><td><code>.c</code></td></tr><tr><td>C++</td><td><code>.h</code>&#x2F;<code>.hpp</code></td><td><code>.cc</code>&#x2F;<code>.cpp</code>&#x2F;<code>.cxx</code></td></tr><tr><td>Objective-C</td><td><code>.h</code></td><td><code>.m</code></td></tr><tr><td>Objective-C++</td><td><code>.h</code></td><td><code>.mm</code></td></tr></tbody></table><p>为了兼容 C，我们依然可以使用预处理器指令 <code>#include</code> 来包含头文件。但是 Objective-C 提供了另一选项 <code>#import</code>。它与 <code>#include</code> 的作用几乎完全相同，但可以保证在一个编译单元中每个头文件都只被引入一次。即是说，它起到了传统 C&#x2F;C++ 变成中 <code>#pragma once</code> 或是 Guard Macro 的作用。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Objective-C&#x2F;C++ 中的基本类型和 C&#x2F;C++ 中的差不多。几种基本类型在 Objective-C&#x2F;C++ 中的长度分别是：</p><ul><li><code>char</code>: 1B</li><li><code>int</code>: 4B</li><li><code>float</code>: 4B</li><li><code>double</code>: 8B</li></ul><p>此外，Objective-C&#x2F;C++ 中也有 <code>short</code>&#x2F;<code>long</code>&#x2F;<code>long long</code>&#x2F;<code>signed</code>&#x2F;<code>unsigned</code> 之类的修饰。含义也和 C&#x2F;C++ 中的相同。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Objective-C 支持 C-style 字符串，并且也遵循 C 语言当中对引号使用的约定。亦即，使用单引号表示字符（例 <code>&#39;c&#39;</code>），使用双引号表示字符串（null termination）。但在 Objective-C 中也有实现 <code>NSString</code> 类（类似 C++ 中的 <code>std::string</code> 但更强大）。它更常用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>;  <span class="comment">// 字符类型字面量</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span>;  <span class="comment">// C-style string</span></span><br><span class="line"><span class="string">@&quot;hello world&quot;</span>;  <span class="comment">// Objective-C NSString</span></span><br></pre></td></tr></table></figure><p>此外，<code>NSString</code> 也支持 <code>printf</code> 风格的字符串构造方法，以及支持从 C-style 字符串中构造。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a NSString object from literal</span></span><br><span class="line"><span class="built_in">NSString</span>* myString = <span class="string">@&quot;My String\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from printf formatter</span></span><br><span class="line"><span class="built_in">NSString</span>* anotherString = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@&quot;%d %s&quot;</span>, <span class="number">1</span>, <span class="string">@&quot;String&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from C-style string</span></span><br><span class="line"><span class="built_in">NSString</span>*  fromCString = [<span class="built_in">NSString</span> stringWithCString: <span class="string">&quot;A C string&quot;</span> encoding: <span class="built_in">NSASCIIStringEncoding</span>];</span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><p>Objective-C 中的 <code>if</code> 语句和 C&#x2F;C++ 中的基本一致。唯独，在 Objective-C 中以 <code>0</code> 表示 <code>false</code>，而以其他值表示 <code>true</code>。例如说，其他任何数值，或是任何字符串，在 <code>Objective-C</code> 中都会被认为是 <code>true</code>。</p><h3 id="for-x2F-while"><a href="#for-x2F-while" class="headerlink" title="for&#x2F;while"></a><code>for</code>&#x2F;<code>while</code></h3><p>Objective-C 中的 <code>for</code>&#x2F;<code>while</code> 和 C 中的完全一致。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><table><thead><tr><th></th><th>名称</th><th>代码风格</th></tr></thead><tbody><tr><td>C&#x2F;C++</td><td>对象成员函数调用</td><td><code>obj.method(args)</code></td></tr><tr><td>Objective-C&#x2F;C++</td><td>向对象传递消息</td><td><code>[obj method: args]</code></td></tr></tbody></table><p>在 C++&#x2F;Java 中，类中定义有成员函数&#x2F;成员方法。我们可以通过类似 <code>obj.method(args)</code> 的方式调用 <code>obj</code> 对象的 <code>method</code> 成员函数。如果 <code>method</code> 在 <code>obj</code> 所属的类中没有定义，则在编译期就会报错。</p><p>Objective-C 则继承了 Smalltalk 的消息传递模型。在这一模型中，调用成员函数被视作是向对象发送一个消息。例如，<code>obj.method(args)</code> 式的调用会被写作是 <code>[obj method: args]</code>。这种写法的意思是，向 <code>obj</code> 这个对象发送名为 <code>method</code> 的消息，<code>args</code> 则是消息附带的参数。与 C++&#x2F;Java 风格的调用不同，<code>obj</code> 所属的类即便没有定义名为 <code>method</code> 的成员函数，我们在代码中依旧可以向 <code>obj</code> 发送这一消息。Objective-C 的编译器不会为此报错，但在程序执行时则会抛出一个异常。</p><p>对比下来，消息传递模型中类和成员函数的关系较为松散，这种调用方式总是在运行期动态绑定。于是，它不需要 C++ 当中的 <code>virtual</code>&#x2F;<code>override</code> 关键字。当然，这种做法也存在一定额外开销。（显然）</p><blockquote><p>空对象（<code>nil</code>）接受消息后默认不做任何事情。因此向 <code>nil</code> 传递消息是安全的。</p></blockquote><h2 id="类的声明与数据成员"><a href="#类的声明与数据成员" class="headerlink" title="类的声明与数据成员"></a>类的声明与数据成员</h2><p>在 C++ 中，我们称之为「声明一个类」。在 Objective-C&#x2F;C++ 中，我们说「定义类的接口（interface）」。</p><hr><p>在 C++ 中，定义一个空的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>注意，它不需要继承自一个作为占位符的父类。在 Objective-C&#x2F;C++ 中，定义一个空类形如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意，和 Python 中所有类都继承自 <code>object</code> 类似，Objective-C 中所有类都继承自 <code>NSObject</code>。</p><hr><p>在 C++ 中，定义一个包含有数据成员的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C&#x2F;C++ 中则是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Objective-C 的类分为接口（interface）和实现（implementation）。接口部分通常包含了类声明以及其中数据成员的定义，以及相关成员函数的声明。实现部分通常包含了成员函数的实现代码。</p><p>注意，C++ 中，<code>class</code> 中的数据成员默认是 <code>private</code> 的；在 Objective-C&#x2F;C++ 中，<code>@interface</code> 段定义的数据成员默认是 <code>protected</code> 的，<code>@implementation</code> 段定义的数据成员默认是 <code>private</code> 的。为了保持访问控制一致，额外在 C++ 代码中加上了 <code>protected</code> 关键字来指定 <code>data</code> 的访问控制类型。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在 C++ 中，成员函数的声明形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">class_method</span><span class="params">()</span></span>;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method1</span><span class="params">()</span></span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method2</span><span class="params">(<span class="type">int</span> p1)</span></span>;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method3</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span>;  <span class="comment">// 4.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C 中，则是如下形式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">Bar</span></span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line">+(<span class="type">void</span>) class_method;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>) instance_method1;  <span class="comment">// 3.a</span></span><br><span class="line">-(<span class="type">void</span>) instance_method2: (<span class="type">int</span>) p1;  <span class="comment">// 3.b</span></span><br><span class="line">-(<span class="type">void</span>) instance_method3: (<span class="type">int</span>) p1 and: (<span class="type">int</span>) p2;  <span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>首先关注 (1)。在 C++ 中，<code>class</code> 内的访问控制默认是 <code>private</code>。因此，要使声明的成员函数可用，我们需要显式地指明 <code>public</code>。在 Objective-C 中，<code>@interface</code> 段的方法默认是 <code>@public</code> 的。</p><p>接下来关注 (2)。在 C++ 中有所谓的 <code>static</code>-成员函数。此类成员函数是属于整个类的，不能修改类的对象内部的数据成员。Objective-C 中也有类似设定，即所谓的类方法（class method）。具体形式是在方法前加上一个 <code>+</code> 记号。</p><p>现在关注 (3)。这是典型的成员函数的声明方式。这样的成员函数是与具体的类的对象绑定的，必须要有一个构造好的对象才能执行这些成员函数。在 Objective-C 中，这是所谓的对象方法（instance method），也称为一般方法。</p><p>(4) 处也声明了一般意义上的成员函数，但在 Objective-C 这里稍有不同。对 Objective-C 的版本，它的函数全名（签名）是 <code>instance_method3:and:</code>。即是说，在声明时，函数的名称和参数列表交织在一起；每个冒号后面都带有一次参数传递。调用它的时候则类似：<code>[obj instance_method3: 0 and: 1]</code>。这是 Objective-C&#x2F;C++ 特有的。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>尽管我们也可以在 Objective-C 中定义数据成员，但实际上更好的方式是使用属性。例如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它等价于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;  <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;  <span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里，(1) 声明了类 <code>Foo</code> 的一个属性。它的类型是 <code>int</code>，名字是 <code>age</code>。如果没有显式地如 (2) 这样将属性和变量关联起来，则编译器会自动产生一个变量，并做这样的关联。注意，属性的声明应当位于 <code>@interface</code> 段，属性与变量的关联则应放在 <code>@implementation</code> 段。</p><p>你也可以使用别的变量与属性进行关联。例如 <code>@synthesize age = internal_age;</code>。这样会将 <code>age</code> 这个属性与 <code>internal_age</code> 这个数据成员进行关联。</p><p>声明属性，则编译器会为我们自动生成相应的 setter&#x2F;getter 方法。例如说，上面的代码，大致相当于会生成这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line">-(<span class="type">void</span>) setAge: (<span class="type">int</span>) n &#123;</span><br><span class="line">  <span class="keyword">self</span>-&gt;_age = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">int</span>) age &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说，通过属性，我们将类的数据成员封装了起来。外部不能直接操作类的数据成员，而要通过 setter&#x2F;getter 来操作。此外，Objective-C 还为此提供了类似 C++ 中成员访问运算符（<code>.</code>）的语法糖。我们可以写出类似下面的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.age = <span class="number">10</span>;  <span class="comment">// 1.a</span></span><br><span class="line">[p setAge: <span class="number">10</span>];  <span class="comment">// 1.b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, p.age);  <span class="comment">// 2.a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, [p age]);  <span class="comment">// 2.b</span></span><br></pre></td></tr></table></figure><p>其中 (1.a) 和 (1.b) 的含义相同，(2.a) 和 (2.b) 的含义也相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。&lt;/p&gt;
&lt;p&gt;这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&amp;#x2F;C++ 的熟练使用者则更好。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Language" scheme="https://liam.page/tags/Language/"/>
    
      <category term="Objective-C" scheme="https://liam.page/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS 上 VSCode 当中终端环境变量重复问题</title>
    <link href="https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/"/>
    <id>https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/</id>
    <published>2023-01-20T14:02:11.000Z</published>
    <updated>2023-01-20T14:06:49.900Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，<code>PATH</code> 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，<code>PATH</code> 变量则是正常的。</p><span id="more"></span><p>举例来说，VSCode 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin:/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>同期 Terminal 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>检查各种 <code>profile</code>&#x2F;<code>bashrc</code> 文件，均未发现异常。后查明是在 VSCode 当中启动嵌入的终端时，默认会继承 VSCode 启动时的环境变量。这导致后续在使用 <code>PATH = &quot;/path/to/foo/bar:$PATH&quot;</code> 这样的语法时，会将 <code>PATH</code> 复制一份。只需将 VSCode 中的下列设置改为 <code>false</code> 即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.inheritEnv&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，&lt;code&gt;PATH&lt;/code&gt; 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，&lt;code&gt;PATH&lt;/code&gt; 变量则是正常的。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="Terminal" scheme="https://liam.page/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：从 NIC 中创建项目</title>
    <link href="https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/"/>
    <id>https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/</id>
    <published>2023-01-19T16:21:45.000Z</published>
    <updated>2023-01-21T14:47:54.899Z</updated>
    
    <content type="html"><![CDATA[<p>安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。</p><span id="more"></span><h2 id="执行-NIC"><a href="#执行-NIC" class="headerlink" title="执行 NIC"></a>执行 NIC</h2><p>在安装好 Theos 的基础上，可以执行下列命令启动 NIC 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/nic.pl</span><br></pre></td></tr></table></figure><p>之后，NIC 会在终端上打印出一个列表，询问你想要创建何种类型的项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="variable">$THEOS</span>/bin/nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/control_center_module-11up</span><br><span class="line">  [6.] iphone/cydget</span><br><span class="line">  [7.] iphone/flipswitch_switch</span><br><span class="line">  [8.] iphone/framework</span><br><span class="line">  [9.] iphone/library</span><br><span class="line">  [10.] iphone/notification_center_widget</span><br><span class="line">  [11.] iphone/notification_center_widget-7up</span><br><span class="line">  [12.] iphone/preference_bundle</span><br><span class="line">  [13.] iphone/preference_bundle_swift</span><br><span class="line">  [14.] iphone/theme</span><br><span class="line">  [15.] iphone/tool</span><br><span class="line">  [16.] iphone/tool_swift</span><br><span class="line">  [17.] iphone/tweak</span><br><span class="line">  [18.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [19.] iphone/xpc_service</span><br><span class="line">  [20.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required):</span><br></pre></td></tr></table></figure><p>我们主要关注的是其中的 <code>iphone/tweak</code> 和 <code>iphone/tweak_with_simple_preferences</code>。后者会构造一个 <code>Preferences.plist</code> 文件，以便我们能在 iOS 的系统设置中配置该插件的行为。</p><p>这里我们选择 18。接下来，NIC 会交互式地要求我们键入一些插件的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Choose a Template (required): 18</span><br><span class="line">Project Name (required): PhantomSteps</span><br><span class="line">Package Name [com.yourcompany.phantomsteps]: page.liam.phantom_steps</span><br><span class="line">Author/Maintainer Name [Liam Huang]:</span><br><span class="line">[iphone/tweak_with_simple_preferences] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.Health</span><br><span class="line">[iphone/tweak_with_simple_preferences] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: com.apple.Health</span><br><span class="line">Instantiating iphone/tweak_with_simple_preferences <span class="keyword">in</span> phantomsteps/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>这里，我们给项目起名为 <code>PhantomSteps</code>，其包名称为 <code>page.liam.phantom_steps</code>。你可以按需修改。MobileSubstrate Bundle filter 这一项是说，你可能影响的 App 的名字。List of applications to terminate upon installation 这一项则是说，在安装你的插件时，需要杀死的程序的名字。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>创建成功后，目录结构应该类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── PhantomSteps.plist</span><br><span class="line">├── Tweak.x</span><br><span class="line">├── control</span><br><span class="line">└── layout</span><br><span class="line">    └── Library</span><br><span class="line">        └── PreferenceLoader</span><br><span class="line">            └── Preferences</span><br><span class="line">                └── PhantomSteps</span><br><span class="line">                    └── Preferences.plist</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure><p>这里</p><ul><li><code>PhantomSteps.plist</code> 记录了需要杀死的包的名称。</li><li><code>control</code> 包含了先前在 NIC 交互式环境中填写的信息。</li><li><code>Makefile</code> 是对应 GNU make 的文件。</li><li><code>Tweak.x</code> 是插件自身的代码。Theos 会从模板中创建一个带有各种注释的文件供参考。</li></ul><blockquote><p>通过 NIC 模板创建的项目可见：<a href="https://github.com/Liam0205/PhantomSteps/tree/c48a76ae16ea761b24bfa94524331a1b7523d0b0">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：安装 Theos</title>
    <link href="https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/"/>
    <id>https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/</id>
    <published>2023-01-19T15:16:51.000Z</published>
    <updated>2023-01-21T14:47:57.362Z</updated>
    
    <content type="html"><![CDATA[<p>Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。</p><blockquote><p>你也可以直接参考官方英文文档：<a href="https://theos.dev/docs/installation-macos">https://theos.dev/docs/installation-macos</a></p></blockquote><span id="more"></span><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><h3 id="安装-XCode"><a href="#安装-XCode" class="headerlink" title="安装 XCode"></a>安装 XCode</h3><p>打开 MAS，搜索 XCode，安装&#x2F;更新到最新。</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>打开 Terminal，执行下列命令（来自<a href="https://brew.sh/">Homebrew 官网</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="通过-brew-安装依赖库"><a href="#通过-brew-安装依赖库" class="headerlink" title="通过 brew 安装依赖库"></a>通过 brew 安装依赖库</h3><p>在 Terminal 中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid xz</span><br></pre></td></tr></table></figure><h2 id="下载和安装-Theos"><a href="#下载和安装-Theos" class="headerlink" title="下载和安装 Theos"></a>下载和安装 Theos</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export THEOS=~/theos&quot;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="comment"># 早期的系统应该加至 ~/.profile</span></span><br></pre></td></tr></table></figure><h3 id="下载-Theos"><a href="#下载-Theos" class="headerlink" title="下载 Theos"></a>下载 Theos</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/theos/theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，你也可以将 <code>$THEOS/bin/</code> 加到环境变量 <code>$PATH</code> 中去。</p></blockquote><h2 id="安装-SDK"><a href="#安装-SDK" class="headerlink" title="安装 SDK"></a>安装 SDK</h2><p>新版的 XCode 不提供插件可能使用到的私有框架，因此我们需要安装 Theos 维护的补丁版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/theos/sdks/archive/master.zip</span><br><span class="line">TTT=$(<span class="built_in">mktemp</span> -d)</span><br><span class="line">unzip master.zip -d <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$TTT</span>/sdks-master/*.sdk <span class="variable">$THEOS</span>/sdks</span><br><span class="line"><span class="built_in">rm</span> -r master.zip <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">unset</span> <span class="variable">$TTT</span></span><br></pre></td></tr></table></figure><h2 id="更新-Theos"><a href="#更新-Theos" class="headerlink" title="更新 Theos"></a>更新 Theos</h2><p>将来需要更新 Theos 时，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/update-theos</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你也可以直接参考官方英文文档：&lt;a href=&quot;https://theos.dev/docs/installation-macos&quot;&gt;https://theos.dev/docs/installation-macos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>iOS 越狱后插件推荐</title>
    <link href="https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/"/>
    <id>https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/</id>
    <published>2023-01-19T02:53:10.000Z</published>
    <updated>2023-06-27T10:52:54.611Z</updated>
    
    <content type="html"><![CDATA[<p>手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。</p><span id="more"></span><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><ul><li>iPhone Xʀ</li><li>iOS 14.5.1</li><li>unc0ver 8.0.2</li></ul><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>首先是介绍一下我订阅的软件源。</p><ul><li>Zebra：<code>https://getzbra.com/repo/</code></li><li>BigBoss：<code>http://apt.thebigboss.org/repofiles/cydia/</code></li><li>Bingner&#x2F;Elucubratus：<code>https://apt.bingner.com/</code></li><li>Limneos Repo：<code>https://limneos.net/repo/</code></li><li>MERONA Repo：<code>https://repo.co.kr/</code></li><li>Chariz：<code>https://repo.chariz.io/</code></li><li>Havoc：<code>https://havoc.app/</code></li><li>jjolano：<code>https://ios.jjolano.me/</code></li><li>opa334&#39;s Repo：<code>https://opa334.github.io/</code></li><li>ichitaso repository：<code>http://cydia.ichitaso.com/</code></li><li>蜗牛源：<code>https://repo.snailovet.com/</code></li><li>AutoTouch：<code>https://repo.autotouch.net/</code></li><li>Packix：<code>https://repo.packix.com/</code></li><li>Ginsu Tweaks：<code>https://repo.ginsu.dev/</code></li><li>Liam-apt：<code>https://liam.page/apt/</code>&#x2F;<code>https://liam.page/apt-beta/</code></li><li>Liam - oldabi：<code>https://liam.page/oldabi</code></li><li>Ivano Bilenchi：<code>https://ib-soft.net/repo/</code></li><li>subdiox&#39;s Repo：<code>https://subdiox.com/cydia/</code></li><li>Cydiakk：<code>https://apt.cydiakk.com/</code></li><li>CokePokes：<code>https://www.ios-repo-updates.com/repository/cokepokes/</code></li><li>Fouadraheb：<code>https://apt.fouadraheb.com/</code></li><li>电话助手作者源：<code>https://apt.htv123.com/</code></li><li>老牌猫源：<code>https://apt.25mao.com/</code></li><li>Netskao：<code>https://repo.initnil.com/</code></li><li>Procursus：<code>https://apt.procursus.us/</code></li><li>Acreson：<code>https://repo.acreson.cn/</code></li><li>Lenglengyu：<code>https://lenglengyu.com/</code></li><li>SOPPPra：<code>https://sopppra.mooo.com/</code></li><li>PoomSmart：<code>https://poomsmart.github.io/repo/</code></li><li>alias20：<code>https://alias20.gitlab.io/apt/</code></li><li>c1d3r：<code>https://c1d3r.com/repo/</code></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里按照大致的安装时间顺序介绍我目前还在使用的插件。其中，插件名字后面带有星号标记的表示已适配 Fugu15 Rootless 越狱。</p><ul><li>CCPower⭐️（Netskao）：控制中心插件。点按后会弹出菜单。菜单上部显示电池状况、运行时间、闪存、运存等情况。下部允许进行重启、重新载入 SpringBoard 等动作。来源：BigBoss。</li><li>CCBadgeClear⭐️（Netskao）：控制中心插件。点按后可以清除 App 图标右上角的角标数字。来源：BigBoss。</li><li>CCVPN⭐️（Acreson）：控制中心插件。点按后可以切换 VPN 的状态。来源：BigBoss。</li><li>CCSwitchData⭐️（Netskao）：控制中心插件，可以切换用来访问移动网络的 Sim 卡。来源：BigBoss。</li><li>CCCellularRate⭐️（Netskao）：控制中心插件，可以用来控制蜂窝网络的速率。来源：Netskao。</li><li>CCNC⭐️（Liam - oldabi）：控制中心插件，点按后可以切换 AirPods Pro 的降噪状态。来源：BigBoss。</li><li>iPonCC⭐️：控制中心插件。在控制中心显示 IP 地址。来源：BigBoss。</li><li>Filza File Manager⭐️（TrollStore）：著名的文件管理器。来源：BigBoss。</li><li>FLEXList⭐️（Netskao）：开发者工具。著名的开发者动态调试工具 FLEX 的包装。它允许你在任意 App 运行时动态加载 FLEX 库以调试其界面元素。来源：BigBoss。</li><li>Vi Improved⭐️（Procursus）：著名的命令行编辑器。来源：Bingner&#x2F;Elucubratus。</li><li>AppStore++⭐️（TrollStore）：允许你对来自 AppStore 的 App 进行指定版本的升降级操作，还能设置屏蔽某些 App 的升级。来源：CokePokes。</li><li>zfbbs⭐️（Liam-apt，改名 zfbstep）：随机生成支付宝步数，蚂蚁森林好帮手。来源：Cydiakk。</li><li>ShowTouch⭐️（Acreson）：显示触碰手势，在录屏时很有用。来源：Cydiakk。</li><li>SettingsRevamp⭐️：重新组织设置 App 中的项目，将系统 App、Tweak、用户 App 分别收至单独的二级目录中。来源：SOPPPra。</li><li>NFCWriter XS⭐️：著名的 NFC 模拟&#x2F;写入 App。它可以读取外部的 NFC tag，然后模拟出来。例如，可以用来模拟小区门禁卡。来源：Limneos Repo。</li><li>BioProtect XS⭐️：著名的生物信安保护插件。它可以按照 App、Folder 等维度，设置是否需要验证生物信安（Face ID&#x2F;Touch ID）。来源：Limneos Repo。</li><li>AudioRecoder XS⭐️：著名的通话录音插件。它能自动录制呼入呼出的电话并保存在手机本地，还支持自动上传到云（Google Drive&#x2F;Dropbox）。来源：Limneos Repo。</li><li>VoiceChanger XS⭐️：著名的变声器插件。来源：Limneos Repo。</li><li>PhantomSteps⭐️（Liam-apt）：自研的生成虚拟步数的插件。来源：Liam-apt。</li><li>Choicy⭐️（opa334）：注入管理插件。它可以按照 App 维度，以白名单&#x2F;黑名单的方式禁用插件。来源：opa334&#39;s Repo。</li><li>Zebra⭐️：替代 Cydia 的包管理器。其运行效率和操作流畅度远胜 Cydia。来源：Zebra。</li><li>Shadow⭐️：越狱检测屏蔽插件。是已安装四个同类插件中整体效果最好者。来源：jjolano。</li><li>位置自动允许一次 &#x2F;&#x2F; AllowLocationOnce⭐️：在 App 请求系统位置服务时，自动点选「允许一次」。来源：蜗牛源。</li><li>AppData⭐️（Netskao）：允许你在主屏幕状态下，通过单指向上扫 App icon 来打开菜单。允许你修改 App 在主屏幕上展示的名字，也允许你做一些清理工作。来源：Fouadraheb。</li><li>StoreSwitcher 2⭐️（Lenglengyu）：允许在 AppStore 中快速切换账号。在需要跨区下载 App 时非常实用。来源：subdiox&#39;s Repo。</li><li>电话助手⭐️：一个集成式的强大插件。它的功能涵盖系统电话增强、系统短信增强、通话录音、状态栏美化等等，是优秀的国产插件。来源：电话助手作者源。</li><li>魔术师⭐️：电话助手作者退出的越狱屏蔽插件。来源：电话助手作者源。</li><li>微信净化⭐️：还原微信聊天本质。来源：Netskao。</li><li>微信助手⭐️：给微信添加强大的功能。来源：老牌猫源。</li><li>斗图助手⭐️：给微信添加斗图功能。来源：老牌猫源。</li><li>左滑返回⭐️：允许从屏幕右侧向中间单指滑动执行返回操作（类似于系统默认提供的从屏幕左侧向中间单指滑动的操作）。对于大屏幕的机器，单手操作十分友好。来源：老牌猫源。</li><li>SmallBanners⭐️：将系统通知横幅改为只能容纳一行文字的横向滚动消息。来源：Netskao。</li><li>New Term 3 Beta⭐️：基于 zsh 的终端模拟器。来源：Chariz。</li><li>Ersatz⭐️：全局替换字符串的插件。比如将「向上滑动解锁」替换成任意你想要的字符串。来源：lenglengyu</li><li>iCleaner Pro⭐️：可以清理 iPhone 上的闪存空间的插件。它还可以对启动项进行调整。来源：Ivano Bilenchi。</li><li>Crane⭐️：允许你创建 App 的分身，且每次运行前可以选择运行哪个分身。来源：Havoc。</li><li>Aemulo⭐️：可能是最好的 NFC 模拟&#x2F;写入 App。它的功能和 NFCWriter XS 类似，但还额外提供了将 NFC tag 保存入 Apple Wallet 的功能。这使得我们可以在锁屏界面调出 NFC tag，解开小区门禁。来源：Chariz。</li><li>Snapper 3⭐️：允许在 iOS 设备上自由截图。来源：Havoc</li><li>ColorBadge⭐️（Liam - oldabi）：让右上角的数字角标染上颜色。来源：BigBoss。</li><li>DumpDecrypter⭐️（替代品：DumpApps）：砸壳工具。来源：Cydiakk。</li><li>Pullover Pro⭐️（Netskao）：侧边分屏，超好用，比 o2 Pro 好用。来源：c1d3r。</li><li>OneHandWizard 2⭐️（Liam - oldabi）：通过自上向下扫过 iPhone 全面屏底部的 Gesture Bar 触发真·单手操作模式。来源：Havoc。</li><li>Hammer It⭐️：文字大爆炸插件。与 Snapper 3 继承良好，可以轻松地控制你选定的文字&#x2F;OCR 从图片中提取的文字，然后进行分词，在自由组合、操控他们。来源：Havoc。</li><li>CopyLog⭐️：设计良好的剪贴板插件。可以管理剪贴历史，并带有收藏功能。来源：Havoc。</li><li>Tanslomatic⭐️：著名的翻译类插件。来源：Havoc。</li><li>ShutupShortcuts⭐️：禁用 Apple 自带的捷径的恼人的提示消息。来源：Liam - rehosts。</li><li>LastLook⭐️：熄屏显示插件。来源：Chariz。<!-- * InApp Purchase 内购破解：可以破解大部分软件的内购，从而可以获得免费试用的机会。来源：Cydiakk。 --></li><li>kai：可以在锁屏界面和通知中心界面显示各个关联设备（耳机、Apple Watch 等）的电量状态。来源：Chariz。<!-- 依赖 Cephei, 破解 --></li><li>Appaze 2：在 Haptic Touch 菜单中添加 Appaze 选项，支持对 App 做个性化的设置。来源：Chariz。<!-- 依赖 Cephei, flipswitch, rocketbootstrap --></li><li>SmartVPN：它可以按照 App 维度进行设置，在 App 运行时自动启动 VPN，在所有白名单 App 关闭时自动关闭 VPN。来源：BigBoss。<!-- 依赖 Cephei, applist, rocketbootstrap --></li><li>IAmLazy：备份和恢复插件的插件。来源：Chariz。</li><li>AltDeamon：一个 AltServer 的守护进程。安装后可以不借助电脑实用 AltStore 对应用进行自签 Side load。来源：Chariz。</li><li>Frida：开发者工具。著名的 Frida 的服务端。来源：蜗牛源。</li><li>Activator：著名的手势操作插件。来源：BigBoss。</li><li>FixBatteryUsageFugu14：解决 Fugu14 越狱导致无法查看电池用量信息的问题。来源：Liam-apt。</li><li>LocationService (CCSupport)：控制中心插件。点按后可以切换系统定位服务的状态。来源：ichitaso repository。</li><li>OpenSSH CC Toggle：控制中心插件，点按后可以切换手机中 sshd 的运行状态。来源：BigBoss。</li><li>EnableBatteryPercent：在屏幕顶栏电量标志中显示具体的电量剩余百分比。来源：Ginsu Tweaks。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
      <category term="Tweaks" scheme="https://liam.page/tags/Tweaks/"/>
    
  </entry>
  
  <entry>
    <title>清理加湿器振动片上的水垢以减小其噪声</title>
    <link href="https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/"/>
    <id>https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/</id>
    <published>2022-11-24T11:03:55.000Z</published>
    <updated>2022-11-24T11:23:55.081Z</updated>
    
    <content type="html"><![CDATA[<p>生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。</p><p>常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。</p><p>此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。</p><span id="more"></span><h2 id="水垢的成因"><a href="#水垢的成因" class="headerlink" title="水垢的成因"></a>水垢的成因</h2><p>自来水中不可避免会溶解一些无机盐。特别地，其中的钙盐和镁盐（以碳酸钙、碳酸镁为主，辅有硫酸钙、硫酸镁、氯化钙、氯化镁等）因溶解度较小，容易沉积形成水垢。</p><p>加湿器振动片使水雾化，导致振动片附近的水相对减少、无机盐浓度升高。溶解度较小的钙盐、镁盐便容易在振动片附近沉积。这些沉积的水垢附着在振动片上，导致振动片工作时发出噪声。</p><h2 id="去除水垢的原理和方法"><a href="#去除水垢的原理和方法" class="headerlink" title="去除水垢的原理和方法"></a>去除水垢的原理和方法</h2><p>既已知水垢的成因和主要成分，想要去除水垢便不难。此处我们只需用到初中化学和物理知识即可。</p><p>水垢的主要成分是碳酸、硫酸、盐酸对应的钙盐和镁盐。要软化、去除这些水垢，只需找一合适的阴离子对应的酸性溶液即可。此处我们可以选择生活中常见的醋酸。</p><p>醋酸容易获得，且醋酸是弱酸操作安全。最主要的是，醋酸钙和醋酸镁的溶解度较高，算是易溶解的物质。因此，醋酸与水垢反应，可有效软化、溶解水垢。</p><p>操作步骤：</p><ol><li>购买白醋一瓶（普通使用陈醋也可，但是黑乎乎一片看不清楚效果）。</li><li>将加湿器水槽取下，加湿器底座内余水倾倒干净。</li><li>将白醋倒入加湿器底座，覆盖、没过振动片及其周围水垢区域。</li><li>加入温水（温度不需要太高），以加快反应速度。</li><li>静置 10 -- 20 分钟。此过程可见水槽底座内不断有小气泡产生（二氧化碳），水垢逐渐脱落翻滚（被二氧化碳气体推动而翻滚运动）和逐渐溶解。</li><li>将底座内的醋酸溶液倾倒干净，用手指或软刷将剩余软化的水垢清理干净。</li><li>用清水反复冲洗三至五次底座，减少醋酸残留。（残留醋酸挥发，可能对呼吸道黏膜产生刺激，导致不适）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。&lt;/p&gt;
&lt;p&gt;常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。&lt;/p&gt;
&lt;p&gt;此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Scale" scheme="https://liam.page/tags/Scale/"/>
    
      <category term="Noise" scheme="https://liam.page/tags/Noise/"/>
    
      <category term="Humidifier" scheme="https://liam.page/tags/Humidifier/"/>
    
  </entry>
  
  <entry>
    <title>羽毛球步伐①：启动步</title>
    <link href="https://liam.page/2022/11/20/badminton-footwork-the-start-step/"/>
    <id>https://liam.page/2022/11/20/badminton-footwork-the-start-step/</id>
    <published>2022-11-20T06:29:26.000Z</published>
    <updated>2022-11-20T11:26:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。</p><p>从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。</p><span id="more"></span><h2 id="为什么需要启动步"><a href="#为什么需要启动步" class="headerlink" title="为什么需要启动步"></a>为什么需要启动步</h2><p>羽毛球运动的特点、基本的物理学定律、人的生理结构，三者共同决定了启动步的重要性和必要性。</p><p>羽毛球是速度最快的球类运动之一。若是限定在初始速度的概念上，我们还可以将「之一」去掉。因其速度快、场地小，所以从你击球结束到下一次击球之间的间隔十分短暂。即便在较为缓和的对抗中，这一时间间隔通常也不会超过 3s。在这短暂的间隔中，你需要完成收拍、移动回位、移动到位、准备击球的若干步骤，时间紧迫。此外，在对手击球之前，你无法判断对手回球的落点位置。因此，羽毛球的步伐移动同时具有快速和方向不确定两个重要特点。</p><p>基本的物理学定律告诉我们：若你想要向前加速运动，则势必要让外界对你有向前的合力；向后同理。若你想要相左加速运动，则势必要让外界对你有相左的合力；向右同理。这一合力越大，加速度就越大。在运动上就体现为移动的爆发力越大、突然性越强。在不打滑的情况下，这一水平反向的合力由地面给脚的静摩擦力提供。而静摩擦力的极限大小可由公式 <code>$f_&#123;\text&#123;静&#125;&#125; = \mu_&#123;\text&#123;静&#125;&#125; \cdot F_N$</code> 给出。这也就是说，</p><ul><li>穿一双好的羽毛球鞋（增大抓地力）有助于你快速移动；</li><li>你必须<strong>向斜下方蹬地发力</strong>，才能获得更大的静摩擦力和提供更大的加速度。</li></ul><p>人的生理结构决定了，若要向斜下方蹬地发力，则必须让发力腿的小腿和地面呈现一个 30° 至 60° 的夹角。最典型的例子是 100 米短跑。跑步项目的一个特点是它永远向前跑。因此运动员们在起步阶段会采用蹲立式起跑的方式获得极大的向前的加速度。但羽毛球的启动方向不确定，于是你必须用合理的方式启动，以便能够照顾尽可能多的潜在移动方向。这种合理的方式，即是所谓的「启动步」；具体来说，又有细分：</p><ul><li>当你预期主要向左右方向移动时，应做小跳&#x2F;分腿动作，将腿左右分开，以便向斜下方蹬地发力获得左右方向的加速度。一般而言，起高球应对对方进攻时应采用这种方式。</li><li>当你预期主要向前后方向移动时，应做小跳&#x2F;分腿动作，将腿前后分开，以便向斜下方蹬地发力获得前后方向的加速度。一般而言，自己处在仅供状态时应采用这种方式。</li></ul><p>总结一下。由于羽毛球运动移动的快速和不定向的特性、向斜下方蹬地发力的原理、人的生理结构特点，羽毛球的启动步是重要且必要的。若无合理的启动步，则往往无法击打到球，或只能陷入被动击球。</p><h2 id="启动步要领"><a href="#启动步要领" class="headerlink" title="启动步要领"></a>启动步要领</h2><p>此节我们讲解启动步的要领。首先我们从最简单的静止启动开始讲起，然后再过度到移动中的连贯启动步。</p><h3 id="从静止启动"><a href="#从静止启动" class="headerlink" title="从静止启动"></a>从静止启动</h3><p>首先是准备动作。</p><p>在对手可能击出攻击性的下压球的情况（你发后场高球、挑高球、击平高球、击高远球等），你应当采取双脚左右分立的防守站姿。具体来说，应当</p><ul><li>面向对手击球的方向，双腿左右分立与肩同宽，右脚可以适当向前半步；</li><li>双脚微踮，前脚掌着地、后脚跟微抬；</li><li>膝盖微屈、髋关节微屈；</li><li>上半身向前微弓；</li><li>左右大臂下垂、向外微张，持拍手在胸腹前，拍头在胸口正面前上方位置。</li></ul><p>在对手大概率作出防守的情况，你应当采取双脚前后分立的进攻站姿。具体来说，应当侧身使持拍手在前，面向对手击球方向，双腿前后分立与肩同宽，脚尖朝向斜前方向。其余身体姿态与防守站姿基本相同。</p><p>在对手引拍即将击球的瞬间，开始启动。具体来说：</p><ul><li>双腿分开（可以视情况带有一些小跳）到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里做一些额外说明。</p><ul><li>双腿分开的目的，是为了让小腿与地面呈现的角度便于蹬地发力。因此双腿分开的幅度不应过大（导致发力不便），也不应过小（导致更大比例的发力是水平向上而非水平）。</li><li>分腿&#x2F;小跳的瞬间，你尚未知晓对方的球路。因此<ul><li>在没有把握的情况下，不应做额外假设。也就是说，双腿分开应该基本呈现左右（防守站姿）或前后（进攻站姿），而非是斜前、斜后方向。若不然，将导致二次启动。</li><li>膝盖弯曲、降低重心的过程，需要紧盯对手击球动作和球路，迅速判断落点。</li></ul></li><li>前脚掌着地瞬间发力，不能迟疑。若不然，重心完全下沉后，反而不容易发力，造成二次启动。<ul><li>发力动作当是保证脚踝稳定性的前提下，使用小腿后侧肌肉群和大腿前侧肌肉群协同发力</li></ul></li></ul><h3 id="移动中连贯启动"><a href="#移动中连贯启动" class="headerlink" title="移动中连贯启动"></a>移动中连贯启动</h3><p>从静止启动是较为理想的情况，在实际对抗中较少出现。羽毛球球速极快，对手不可能等你回动到位后、站定后再击球。因此，更多的启动情况发生在回动的过程中的顺势连贯启动。</p><p>举例来说，当你在后场击出高远、平高球，你应当迅速回动至球场中部区域。在回动的过程，应密切注意观察对手击球情况，随时准备启动。此时，可能你尚在回动过程中。例如说，右手持拍的你，重心放在左腿上，而右腿正处在委屈膝盖向前迈步的阶段。此时你的启动应当是（其他情况类比即可）：</p><ul><li>右腿发力，顺势向左垫出一小步；右腿同时协同分开，双腿分开到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里着重讲一下顺势的含义。顺势在此处有几层含义：</p><ul><li>首先，你尚在从后向前回动的过程中，身体具有向前运动的惯性。因此，你主观上向左垫出的一小步，实际效果应当是向左前方垫出一小步。若是刻意在垫布的过程中改变方向向后垫步，则是一个容易导致受伤的动作。</li><li>其次，顺势表示不做过多调整。特别地，不能等待右脚落地，再从静止启动。这是因为你尚在向前回动过程中，若要让身体静止下来，势必要双脚着地、下沉重心。这实际上已经是一次启动，只不过是一次对抗自身惯性的一次启动而已。于是，这会事实上造成二次启动。</li></ul><p>为了做到这一点，我个人总结了四个字：<strong>快回·慢踩</strong>。也就是，</p><ul><li>在击球完成后瞬间，应当爆发式地回动。体现在后场正手击球上，就是（以右手持拍为例）左腿应该向后蹬直发力、同时收紧核心，以便快速抵消向后的冲力而后向前回动。这是「快回」。</li><li>「慢踩」是说，在回动的过程中，不用过于着急，而要保持重心稳定、适度慢踩，给移动中连贯启动留下空间。当然，「两步一冲」的李矛步除外。——那是杀上网、吊上网的连贯动作。</li></ul><h2 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h2><p>启动步本身值得持续练习。以下是从入门到高阶的一些练习方式。</p><ul><li>左右开合跳。<ul><li>起始姿势：双脚与肩同宽，前脚掌着地，膝盖微屈，双手向上合掌</li><li>动作（开跳）：发力向上跳，双脚分开至两倍肩宽，前脚掌着地，膝盖弯屈下沉重心，双手两侧分开平举</li><li>复位动作（合跳）：发力向上跳，双脚合拢至一倍肩宽，前脚掌着地，膝盖微屈，双手向上击掌</li><li>目的：强壮踝关节，锻炼小腿后侧肌肉群爆发力</li><li>30 个&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步）：双腿分开至两倍肩宽，膝盖弯曲下沉重心。</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地，回归起始姿势。</li><li>目的：启动步肌肉记忆。</li><li>15 慢速 + 15 快速&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动，左右蹬跨接杀步伐。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步 + 蹬跨）：双腿分开至两倍肩宽，膝盖弯曲下沉重心；单侧腿发力，转髋蹬跨。（注意弓箭步着地动作，避免受伤）</li><li>复位动作：蹬转回位。</li><li>目的：启动步肌肉记忆 + 左右蹬跨肌肉记忆。</li><li>15 个&#x2F;组，间隔 20s 做 3 组。</li></ul></li><li>交叉步行进间启动步（两步一启动为例，还可做一步一启动、交叉步后退中启动）。<ul><li>起始动作：先左后右分别迈步向前（击后场球回动）。</li><li>动作（行进间启动步）：重心在右腿，左腿微屈（第三步尚未踩下），右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：交叉步行进间启动连贯。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li><li>并步行进间启动步（两步一启动为例，还可做并步后退中启动）。<ul><li>起始动作：右脚在前，左脚在后，向前做一次并步（出右脚，左脚并步跟上）。</li><li>动作（行进间启动步）：第二次并步做一半，即是说出右脚，在左脚并步跟上的同时，右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：并步行进间启动丽娜管。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li></ul><!-- 谨以此文，献给我曾爱过的刘曼沁女士，祝她 30 周岁生日快乐~！ -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Footwork" scheme="https://liam.page/tags/Footwork/"/>
    
      <category term="Start Step" scheme="https://liam.page/tags/Start-Step/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上双开微信</title>
    <link href="https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/"/>
    <id>https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/</id>
    <published>2022-11-02T09:53:57.000Z</published>
    <updated>2022-11-20T06:16:50.322Z</updated>
    
    <content type="html"><![CDATA[<p>特点：</p><ul><li>不安装第三方插件，无封号之虞。</li><li>双击即可启动。</li><li>启动后不需要维持「终端」；事实上它会自动关闭。</li></ul><span id="more"></span><p>解法：</p><ul><li>打开终端，执行下列代码，而后在桌面双击 <code>WeChat.command</code> 即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将启动命令写入桌面上的文件 WeChat.<span class="built_in">command</span>；如果已有重名文件，请注意修改。</span></span><br><span class="line">echo &quot;nohup /Applications/WeChat.app/Contents/MacOS/WeChat &gt;/dev/null 2&gt;&amp;1 &amp;&quot; &gt; ~/Desktop/WeChat.command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予其可执行属性</span></span><br><span class="line">chmod +x ~/Desktop/WeChat.command</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不安装第三方插件，无封号之虞。&lt;/li&gt;
&lt;li&gt;双击即可启动。&lt;/li&gt;
&lt;li&gt;启动后不需要维持「终端」；事实上它会自动关闭。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="WeChat" scheme="https://liam.page/tags/WeChat/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Yonex AX100zz 打感自测</title>
    <link href="https://liam.page/2022/10/29/Yonex-AX100zz/"/>
    <id>https://liam.page/2022/10/29/Yonex-AX100zz/</id>
    <published>2022-10-29T10:48:51.000Z</published>
    <updated>2022-10-29T11:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是 Yonex AX100zz 的打感自测。</p><span id="more"></span><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>新入手的球拍（简写 AX100zz）情况：</p><ul><li>Yonex Astrox 100zz（老色，藏青色）</li><li>4U&#x2F;G6</li><li>保留底胶 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><p>作为对比，过去六年常用的球拍（简写 Arc11）情况：</p><ul><li>Yonex ArcSaber 11（老色，带亮黄色带）</li><li>3U&#x2F;G5</li><li>去除底胶 + 缓震膜 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><h2 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h2><p>挥重方面，实测 AX100zz 和 Arc11 的挥重接近。大约是因为 Arc11 去除底胶的缘故，实际平衡点有所前移。</p><p>挥速方面，相同发力的条件下，AX100zz 的挥速较 Arc11 慢。这主要应该是 AX100zz 采用盒式拍框而 Arc11 采用破风拍框的缘故。</p><p>中杆方面，AX100zz 的中杆相对较硬，但硬得有限。传统上，我们习惯用软硬来评价中杆。但 AX100zz 的中杆更为显著的特性是回弹快。这一特性是建立在实心中杆 + 钨丝的黑科技结构上的。这一特性要求你能用 AX100zz 做出足够快的挥速。若然，相较 Arc11，击球感明显更加干脆；若不然，AX100zz 的击球会显得有一些「木」。</p><p>这即是说，AX100zz 对小臂内旋和屈指发力的技术动作要求更高。而一旦动作到位，AX100zz 的击球球速会比 Arc11 要更快。</p><h2 id="后场击球"><a href="#后场击球" class="headerlink" title="后场击球"></a>后场击球</h2><p>高远方面，步伐到位的情况下，AX100zz 的击球感和 Arc11 差别不算很大；被动的情况下，AX100zz 会稍微更废力一些。</p><p>重杀方面，第一次杀球用的还是 Arc11 的发力习惯。相较而言，球路稍微有些发飘，落点更长。稍作调整后，能够感受到更明显的下压感，暴击音也不出期待地非常舒爽。按对手的反馈，球速有区别，但不大。</p><p>点杀方面。有重杀的经验，点杀时加大了屈指的力量，效果喜人。实战中，头顶突击点杀对角，落点可以比较轻松做到在发球线附近。相同的条件，Arc11 打出同样的落点个人感觉更困难一些。</p><p>劈杀方面，这本身不是我可称擅长的技术，平时用得也偏少。实战中，尝试正手区劈杀斜线，许是还没有完全适应发力变化的缘故，总体感觉和 Arc11 区别不算大。</p><p>吊球方面，劈吊和 Arc11 区别不大；而滑板吊的动作由于本身发力更难，使用 AX100zz 的失误率比 Arc11 要明显高一些。</p><p>反手高远方面，AX100zz 对发力的要求明显更高。前三拍感觉都没能很好发力，打得有点木木的。调整后整体感觉 AX100zz 明显吃力一些。</p><h2 id="前场击球"><a href="#前场击球" class="headerlink" title="前场击球"></a>前场击球</h2><p>个人感觉，前场的搓放由于发力小而巧，影响回球质量更多的是拍面大小和拍线（型号和磅数）。实际 AX100zz 的拍面和 Arc11 相比只是稍微小一些，而拍线又完全相同（穿线师傅都是同一个），整体感觉前场搓放差异不大。但是，不知是不是错觉，使用 AX100zz 做假动作搓放时，感觉更得心应手一些。</p><p>挑推方面，个人感觉差异不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>4U 版本的 AX100zz 属于相对容易上手的高端拍。但其对发力的要求，不那么糖水，需要更短粗的爆发发力才能驾驭。</p><p>个人意见，可以视作是 3U 版本 Arc11 的进攻加强版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇是 Yonex AX100zz 的打感自测。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Yonex" scheme="https://liam.page/tags/Yonex/"/>
    
      <category term="Racket" scheme="https://liam.page/tags/Racket/"/>
    
  </entry>
  
</feed>
