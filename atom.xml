<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2020-01-09T13:05:14.703Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>向 non-bare 仓库的检出分支推送提交</title>
    <link href="https://liam.page/2020/01/09/git-push-to-a-non-bare-repository-with-checked-out-branch/"/>
    <id>https://liam.page/2020/01/09/git-push-to-a-non-bare-repository-with-checked-out-branch/</id>
    <published>2020-01-09T12:59:13.000Z</published>
    <updated>2020-01-09T13:05:14.703Z</updated>
    
    <content type="html"><![CDATA[<p>假设有本地 Git 仓库 A，而后在本地自 A 克隆仓库 B（即，在 B 的视角，A 是远程仓库，只不过物理位置在本机）。若从 B 向 A 推送提交，则 Git 可能会报错。这是因为，A 默认是 non-bare 的仓库，粗略理解即是工作区不为空；此时，从 B 向 A 推送的话，A 仓库中的内容可能和 A 工作区内容不一致。</p><p>解决该问题的办法之一，是将 A 设置为 bare 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line">mv .git ../repo.git <span class="comment"># renaming just for clarity</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -fr repo</span><br><span class="line"><span class="built_in">cd</span> repo.git</span><br><span class="line">git config --bool core.bare <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但若 A 是 <code>git svn</code> 桥接的仓库，则 Git 不允许我们将其设置为 bare 仓库。此时，应在仓库 A 执行下列代码，告知 Git 在仓库 A 接受检出分支推送时，同步修改工作区的内容。不过这样的话，我们要保证仓库 A 的工作区没有未提交的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config receive.denyCurrentBranch updateInstead</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有本地 Git 仓库 A，而后在本地自 A 克隆仓库 B（即，在 B 的视角，A 是远程仓库，只不过物理位置在本机）。若从 B 向 A 推送提交，则 Git 可能会报错。这是因为，A 默认是 non-bare 的仓库，粗略理解即是工作区不为空；此时，从 B 向 A 推送
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="SVN" scheme="https://liam.page/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>跳过冗余 revisions 以加速 git svn fetch</title>
    <link href="https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/"/>
    <id>https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/</id>
    <published>2020-01-09T11:41:55.000Z</published>
    <updated>2020-01-09T11:58:41.950Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 <code>git clone</code> 会消耗很长时间。使用 <code>git svn</code> 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 <code>git svn fetch</code> 会花费很长时间（可能超过 24 hours）。</p><p>如果你觉得，<code>git svn fetch</code> 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。</p><a id="more"></a><p>SVN 相较 Git 的一个优势在于它可以针对仓库里的各个子路径进行权限设置。于是，我们可以假设这样一种场景：</p><ul><li>SVN 仓库中，有例如 100,000 次修订。</li><li>你使用 <code>git svn clone -s &lt;uri of svn repository&gt;</code> 将这 10 万次修订都下载到本地，行程了一个 Git 本地仓库。</li><li>在开发的过程中，你发现你缺少某些子路径的权限，于是你找到 SVN 管理员，为你授权了这些子路径。</li><li>而后，你会使用 <code>git svn fetch</code> 来更新你的本地仓库。这时，你会发现报错 <code>&lt;file&gt; was not found in commit &lt;hash&gt;</code>。其原因在于，由于之前你的权限缺失，导致前次 <code>git svn clone</code> 以及历次 <code>git svn fetch</code> 的过程中，这些路径在 <code>git-svn</code> 看来是「空的」；但在这次 <code>git svn fetch</code> 时，这些路径突然有了东西，但是缺少相应的历史。</li><li>为了修正这个问题，有以下一些解决办法：<ul><li>干掉整个本地仓库，从头再 <code>git svn clone -s &lt;uri of svn repository&gt;</code> 一次。这相当于从 <code>r1</code> 开始重新 <code>git svn fetch</code> 一次。</li><li>使用 <code>git svn reset -p &lt;revision&gt;</code> 将本地仓库回退到一个早先的版本，然后从该版本 <code>git svn fetch</code>。需要注意的是，涉及到权限缺失的路径，必须在该 <code>&lt;revision&gt;</code> 之后创建。定位这个 <code>&lt;revision&gt;</code> 本身就很困难，更不用说若是这些路径有过移动的话，又会有一系列的问题。因此，虽然该方案相当于从 <code>&lt;revision&gt;</code> 开始重新 <code>git svn fetch</code>；能省下 <code>r1 -- &lt;revision&gt;</code> 之间的修订，但仍然十分麻烦。</li></ul></li></ul><p>在这种情况下，从头再来，似乎是唯一的选择了。而后，你终于不得不承认曾经的自己「太年轻」。</p><p>为了解决这个困局，我们不得不做一次 trade-off。既然问题的根源在于 Git 会将所有历史信息下载到本地，若是我们能舍弃一些过早的历史信息，只下载较近的历史，就能够绕过这个问题。为此，我们需要：</p><ul><li><code>rm -rf &lt;local repo&gt;</code>：删掉已经「失真」的本地仓库。</li><li><code>mkdir &lt;local repo&gt;</code>：建立一个空的目录。</li><li><code>cd &lt;local repo&gt;</code>：进入刚创立的目录。</li><li><code>git svn init -s &lt;uri of svn repository&gt;</code>：以 <code>git svn</code> 初始化该仓库，但不立即 <code>clone</code>。</li><li><code>git svn fetch -r &lt;revision&gt;</code>：从 <code>&lt;revision&gt;</code> 开始，拉取仓库版本信息；即舍弃从 <code>r1</code> 开始到 <code>&lt;revision&gt;</code> 结束的所有历史信息。</li></ul><p>唯独需要注意的是，如果涉及到分支操作，你必须保证你会用到的分支，都在上述 <code>&lt;revision&gt;</code> 之后创建。</p><p>如此一来，只要 <code>&lt;revision&gt;</code> 选得好，代码开始写的早。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 &lt;code&gt;git clone&lt;/code&gt; 会消耗很长时间。使用 &lt;code&gt;git svn&lt;/code&gt; 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 &lt;code&gt;git svn fetch&lt;/code&gt; 会花费很长时间（可能超过 24 hours）。&lt;/p&gt;
&lt;p&gt;如果你觉得，&lt;code&gt;git svn fetch&lt;/code&gt; 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="SVN" scheme="https://liam.page/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>解决 Git 2.24.1 与 OpenSSL 1.1.1b 的冲突</title>
    <link href="https://liam.page/2020/01/07/fix-incompatiblities-between-git-2-24-1-and-openssl-1-1-1b/"/>
    <id>https://liam.page/2020/01/07/fix-incompatiblities-between-git-2-24-1-and-openssl-1-1-1b/</id>
    <published>2020-01-07T08:58:52.000Z</published>
    <updated>2020-01-07T09:42:36.232Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为工作需要处理一些 SVN 仓库，但我还是偏好 Git。早些年就知道 Git 提供了 <code>git svn</code> 可以桥接 SVN。但今天发现公司开发机上的 Git 没有把 <code>git svn</code> 编译进来，也就是会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git svn</span><br><span class="line">git: <span class="string">'svn'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.</span><br><span class="line"></span><br><span class="line">Did you mean one of these?</span><br><span class="line">        fsck</span><br><span class="line">        mv</span><br><span class="line">        show</span><br><span class="line">        spop</span><br><span class="line">        st</span><br></pre></td></tr></table></figure><p>又因为开发机上我没有 <code>root</code> 权限，所以不得已只能自己从源码编译安装 Git。</p><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>首先是下载、解包、<code>configure</code>、<code>make</code> 一波流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.1.tar.gz</span><br><span class="line">$ tar zvxf git-2.24.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> git-2.24.1</span><br><span class="line">$ ./configure --prefix=~/.<span class="built_in">local</span> --with-libpcre1 --with-curl --with-openssl=~/.<span class="built_in">local</span>/include</span><br><span class="line">$ make -j32</span><br></pre></td></tr></table></figure><p>但在链接阶段报错，提示 <code>SSLv23_method</code>, <code>SSL_library_init</code>, <code>SSL_load_error_strings</code>, <code>sk_num</code>, <code>sk_value</code>, <code>sk_pop_free</code> 等符号不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imap-send.o: In function `verify_hostname&apos;:</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:252: undefined reference to `sk_num&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:254: undefined reference to `sk_value&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:260: undefined reference to `sk_pop_free&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:260: undefined reference to `sk_pop_free&apos;</span><br><span class="line">imap-send.o: In function `ssl_socket_connect&apos;:</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:287: undefined reference to `SSL_library_init&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:288: undefined reference to `SSL_load_error_strings&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:290: undefined reference to `SSLv23_method&apos;</span><br><span class="line">collect2: ld returned 1 exit status</span><br><span class="line">make: *** [git-imap-send] Error 1</span><br></pre></td></tr></table></figure><p>我第一反应是 OpenSSL 没安装，或是没有正确配置。但随即发现，早先在安装别的工具的时候，已经安装了 OpenSSL 1.1.1b；并且已经修改了 <code>LD_PATH</code> 和 <code>LD_LIBRARY_PATH</code> 两个环境变量，确保链接器能够正确找到相应的共享对象（动态链接库）。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>在确定 OpenSSL 已安装且能够被编译器、链接器正确找到之后，就只能去检查一下相应符号在共享对象中是否存在了。</p><p><code>SSLv23_method</code>, <code>SSL_library_init</code> 和 <code>SSL_load_error_strings</code> 显然属于 OpenSSL 当中的 <code>libssl.so</code>。于是执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nm libssl.so | grep SSL_library_init</span><br><span class="line">$ nm libssl.so | grep SSL_load_error_strings</span><br><span class="line">$ nm libssl.so | grep SSLv23_method</span><br></pre></td></tr></table></figure><p>返现返回均为空。这说明在 <code>libssl.so</code> 当中确实不存在这三个符号。<code>sk_num</code>, <code>sk_value</code> 和 <code>sk_pop_free</code> 应当位于 <code>libcrypto.so</code> 当中，检查也有同样结果。</p><p>这就令人「满头大汉」了。难道是我下载 OpenSSL 的姿势不对？经过一番检索，在一个与 Git 无关的版本库的 commit log 中，发现了这么一段话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># https://cbi-dev.igbmc.fr/niveale/tap-formatter/commit/b67a118e7a438009e5d44d0701c21d030c92aa94</span><br><span class="line">Fix: OpenSSL 1.1.0 renamed some symbols</span><br><span class="line"></span><br><span class="line">- sk_free =&gt; OPENSSL_sk_free</span><br><span class="line">- sk_num =&gt; OPENSSL_sk_num</span><br><span class="line">- sk_pop_free =&gt; OPENSSL_sk_pop_free</span><br><span class="line">- sk_value =&gt; OPENSSL_sk_value</span><br><span class="line">- evp_md_ctx_create =&gt; evp_md_ctx_new</span><br><span class="line">- evp_md_ctx_destroy =&gt; evp_md_ctx_free</span><br></pre></td></tr></table></figure><p>原来，OpenSSL 自 1.1.0 开始，修改了部分 API 的名称，导致部分符号名发生了变化。此时，大胆猜想：<code>SSL_*</code> 等三个未定义的符号也是因为类似原因导致的。小心求证如下：</p><ul><li>首先，在 <code>libssl.so</code> 当中检索含有 <code>init</code> 的符号，发现有名为 <code>OPENSSL_init_ssl</code> 的符号。看名字，其作用应该与 <code>SSL_library_init</code> 相近。</li><li>而后，在 Google 上检索 <code>SSL_library_init OPENSSL_init_ssl</code>，发现果然，也是在 1.1.0 版本中，该 API 发生了修改；并且 <code>OPENSSL_init_ssl</code> 包括了原先 <code>SSL_library_init</code> 和 <code>SSL_load_error_strings</code> 二者的功能。</li><li>最后，需要确定 <code>SSLv23_method</code> 的对应是什么。在 Google 上检索 <code>SSLv23_method deprecated</code>，发现在 <a href="https://www.openssl.org/docs/man1.1.0/man3/SSLv23_method.html" target="_blank" rel="noopener">OpenSSL 官方文档</a>有提到，它已为 <code>TLS_method</code> 所代替。</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是检索 Git 代码中所有用到这些过时符号的代码，将他们分别修改为对应的新版本。之后编译、链接正常。最后，再顺手提交<a href="https://github.com/gitgitgadget/git/pull/516" target="_blank" rel="noopener">一个 patch</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为工作需要处理一些 SVN 仓库，但我还是偏好 Git。早些年就知道 Git 提供了 &lt;code&gt;git svn&lt;/code&gt; 可以桥接 SVN。但今天发现公司开发机上的 Git 没有把 &lt;code&gt;git svn&lt;/code&gt; 编译进来，也就是会报错：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git svn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git: &lt;span class=&quot;string&quot;&gt;&#39;svn&#39;&lt;/span&gt; is not a git &lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;. See &lt;span class=&quot;string&quot;&gt;&#39;git --help&#39;&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Did you mean one of these?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fsck&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        show&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        spop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;又因为开发机上我没有 &lt;code&gt;root&lt;/code&gt; 权限，所以不得已只能自己从源码编译安装 Git。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="OpenSSL" scheme="https://liam.page/tags/OpenSSL/"/>
    
      <category term="Imcompatibilities" scheme="https://liam.page/tags/Imcompatibilities/"/>
    
      <category term="Symbol" scheme="https://liam.page/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 记录键盘事件</title>
    <link href="https://liam.page/2019/12/06/record-keyboard-events-by-python/"/>
    <id>https://liam.page/2019/12/06/record-keyboard-events-by-python/</id>
    <published>2019-12-06T09:25:10.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天也不知道是想了什么，突然就想要试试看我有效击键时的手速到底有多快。为此，需要记录下来击键的记录。于是找到了 Python 的 <code>keyboard</code> 库。</p><a id="more"></a><p>安装非常简单，只需执行 <code>pip install keyboard</code> 即可。而后保存并执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyboard</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">keyboard.hook(<span class="keyword">lambda</span> e: print(e, time.clock()))</span><br><span class="line">keyboard.wait(<span class="string">'Ctrl'</span>)</span><br></pre></td></tr></table></figure><p>这里，我们利用 <code>keyboard.hook</code> 为每个键盘事件下钩子，并且执行其中的 <code>lambda</code> 函数。<code>keyboard.wait()</code> 的作用是阻塞进程，直到按下 <code>Ctrl</code> 键。</p><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">KeyboardEvent(g down) 4.450576466</span><br><span class="line">KeyboardEvent(g up) 4.505627652</span><br><span class="line">KeyboardEvent(i down) 4.510628277</span><br><span class="line">KeyboardEvent(t down) 4.570555791</span><br><span class="line">KeyboardEvent(i up) 4.580582066</span><br><span class="line">KeyboardEvent(space down) 4.581583136</span><br><span class="line">KeyboardEvent(p down) 4.630656009</span><br><span class="line">KeyboardEvent(t up) 4.671189791</span><br><span class="line">KeyboardEvent(space up) 4.693182730</span><br><span class="line">KeyboardEvent(p up) 4.705543556</span><br><span class="line">KeyboardEvent(u down) 4.705867633</span><br><span class="line">KeyboardEvent(s down) 4.730623806</span><br><span class="line">KeyboardEvent(u up) 4.750832241</span><br><span class="line">KeyboardEvent(s up) 4.795770594</span><br><span class="line">KeyboardEvent(h down) 4.810543976</span><br><span class="line">KeyboardEvent(h up) 4.86056459</span><br><span class="line">KeyboardEvent(enter down) 4.920739469</span><br><span class="line">KeyboardEvent(enter up) 4.930514276</span><br><span class="line">KeyboardEvent(ctrl down) 7.030813124</span><br></pre></td></tr></table></figure><p>从中可见，在敲下 <code>git push&lt;enter&gt;</code> 这条命令的过程中，发生了多次击键交错的现象（即上一个按键还未完全弹起，下一个按键就已经触发）。这是在高速击键时很常见的现象。此外，输入到执行这条命令，总共花费了不到 <code>0.5 s</code> 的时间，不愧曾经单身多年 <code>←_←</code>。</p><blockquote><p>你的手速如何呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天也不知道是想了什么，突然就想要试试看我有效击键时的手速到底有多快。为此，需要记录下来击键的记录。于是找到了 Python 的 &lt;code&gt;keyboard&lt;/code&gt; 库。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="Keyboard" scheme="https://liam.page/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>二分类的评价指标</title>
    <link href="https://liam.page/2019/12/05/evaluation-of-binary-classification/"/>
    <id>https://liam.page/2019/12/05/evaluation-of-binary-classification/</id>
    <published>2019-12-05T12:34:14.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。</p><a id="more"></a><h2 id="混淆矩阵（confusion-matrix）"><a href="#混淆矩阵（confusion-matrix）" class="headerlink" title="混淆矩阵（confusion matrix）"></a>混淆矩阵（confusion matrix）</h2><p>二分类模型的基本工作是这样的：</p><ul><li>将样本 <code>$\{\vec x, y\}$</code> 输入二分类模型 <code>$\mathcal C$</code>，得到模型输出得分 <code>$s$</code>；</li><li>将模型输出得分 <code>$s$</code> 映射为最终结果 <code>$\hat y = M(s)$</code>。</li></ul><p>对于给定的模型 <code>$\mathcal C$</code> 和映射函数 <code>$M(\cdot)$</code>，根据样本真实分类 <code>$y$</code> 和模型预测分类 <code>$\hat y$</code> 的组合，定义如下四种情况：</p><ul><li>真阳性（True Positive，简称：TP）：表示样本是阳性 <code>$y = 1$</code>，并且模型也预测为阳性 <code>$\hat y = 1$</code>。</li><li>假阳性（False Positive，简称：FP）：表示样本是阴性 <code>$y = 0$</code>，但模型预测为阳性 <code>$\hat y = 1$</code>。</li><li>真阴性（True Negative，简称：TN）：表示样本是阴性 <code>$y = 0$</code>，并且模型也预测为阴性 <code>$\hat y = 0$</code>。</li><li>假阴性（False Negative，简称：FN）：表示样本是阳性 <code>$y = 1$</code>，但模型预测为阴性 <code>$\hat y = 0$</code>。</li></ul><p>又根据样本真实分类 <code>$y$</code> 和模型预测分类 <code>$\hat y$</code> 的实际情况，定义如下四个变量：</p><ul><li><code>$P = TP + FN$</code>：表示所有真实分类为阳性的样本的数量。</li><li><code>$N = FP + TN$</code>：表示所有真实分类为阴性的样本的数量。</li><li><code>$P&#39; = TP + FP$</code>：表示所有预测分类为阳性的样本的数量。</li><li><code>$N&#39; = TN + FN$</code>：表示所有预测分类为阴性的样本的数量。</li></ul><p>于是可绘制如下混淆矩阵：</p><table align="center"><tbody><tr><th colspan="2" rowspan="2">&nbsp;</th><th colspan="2" align="center">真实值</th><th rowspan="2">总<br>数</th></tr><tr><th><i>1</i></th><th><i>0</i></th></tr><tr><th rowspan="2" valign="middle">预<br>测<br>输<br>出</th><th valign="middle" style="padding:0.5em;"><i>1</i></th><th style="padding:0.5em;">真阳性<br>(TP)</th><th style="padding:0.5em;">假阳性<br>(FP)</th><th style="padding:0.5em;">P'</th></tr><tr><th valign="middle" style="padding:0.5em;"><i>0</i></th><th style="padding: 0.5em;">假阴性<br>(FN)</th><th style="padding:0.5em;">真阴性<br>(TN)</th><th style="padding:0.5em;">N'</th></tr><tr><th colspan="2" style="padding:0.5em;">总数</th><th align="center">P</th><th align="center">N</th><th></th></tr></tbody></table><h2 id="由混淆矩阵衍生的指标"><a href="#由混淆矩阵衍生的指标" class="headerlink" title="由混淆矩阵衍生的指标"></a>由混淆矩阵衍生的指标</h2><p>混淆矩阵是二分类模型与其数据相互作用得到的最基本的结果。建立在混淆矩阵之上，我们可以定义出一系列的指标，来衡量二分类模型的性能。这里对常见的指标及需要关注的要点罗列如下。</p><ul><li><strong>真阳性率</strong>（true positive rate，TPR）/<strong>敏感度</strong>（sensitivity）/<strong>召回率</strong>（recall rate）：在二分类问题中，真阳性率、敏感度和召回率三个名词对应着同一个概念；它表示正样本中被预测为正样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$TPR = TP / P = TP / (TP + FN).$</code></li><li><strong>真阴性率</strong>（true negative rate，TNR）/<strong>特异度</strong>（specificity）：在二分类问题中，真阴性率和特异度对应着同一个概念；它表示负样本中被预测为负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$TNR = TN / N = TN / (TN + FP).$</code></li><li><strong>假阳性率</strong>（false positive rate，FPR）：它表示负样本中被错误地预测为正样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FPR = FP / N = FP / (TN + FP) = 1 - TNR.$</code></li><li><strong>假阴性率</strong>（false negative rate，FNR）：它表示正样本中被错误滴预测为负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FNR = FN / P = FN / (TP + FN) = 1 - TPR.$</code></li><li><strong>阳性预测值</strong>（positive predictive value，PPV）/<strong>精确率</strong>（percision）：它表示被预测为正的样本中正样本的占比。在二分类问题中，阳性预测值和精确率对应着同一个概念；一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$PPV = TP / (TP + FP) = TP / P&#39;.$</code></li><li><strong>阴性预测值</strong>（negative predictive value，NPV）：它表示被预测为负的样本中负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$NPV = TN / (TN + FN) = TN / N&#39;.$</code></li><li><strong>假发现率</strong>（false detective rate，FDR）：它表示被预测为正的样本中负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FDR = FP / (TP + FP) = FP / P&#39; = 1 - PPV.$</code></li><li><strong>准确率</strong>（accuracy，ACC）：它表示全体样本中预测正确的样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$ACC = (TP + TN) / (P + N).$</code></li><li><strong>F1 值</strong>（F1-score）：它是召回率（真阳性率）和精确率（阳性预测值）的调和平均。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$F1 = 2TP / (P + P&#39;).$</code></li><li><strong>约登指数</strong>（Youden&#39;s J statistic）：一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$J = TPR + TNR - 1.$</code></li></ul><h3 id="准确率悖论（Accuracy-Paradox）"><a href="#准确率悖论（Accuracy-Paradox）" class="headerlink" title="准确率悖论（Accuracy Paradox）"></a>准确率悖论（Accuracy Paradox）</h3><p>准确率表示全体样本中，模型预测正确的样本之占比。这是一个非常 intuitive 的指标，和我们一般的认知很相符。但准确率有一个很大的问题：当正负例极不平衡时，即当 <code>$P \gg N$</code> 或 <code>$N \gg P$</code> 时，准确率会被样本量占优的类别主导从而失真。一般我们认为正例是重要的，于是这个问题在负例数量远多于正例数量时，显得尤为严重。欺诈检测、癌症检测等场合，均属于这种情况。</p><p>举个栗子。假设验证集中共有 100 个样本，其中有 95 个负例和 5 个正例。若模型对所有输入都认定为负例，则这种情况下有 <code>$ACC = (TP + TN) / (P + N) = (0 + 95) / (5 +95) = 0.95$</code>。看起来准确率很高，但这个模型一个正例都分辨不出来，没有实际价值。</p><p>单独用 TPR、TNR、FPR、FNR、PPV、NPV、FDR 这些指标，也会遇到类似的困难。</p><h3 id="召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值"><a href="#召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值" class="headerlink" title="召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值"></a>召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值</h3><p>计算召回率和精确率时的分子都是 TP，不同在于分母。召回率的分母是 <code>$P$</code>，而精确率的分母是 <code>$P&#39;$</code>。这也就是说，召回率是相对真实样本而言的，精确率是相对模型预测为正例的样本而言的。</p><p>举个栗子。</p><ul><li>假设验证集当中有 100 个正例，你的模型将这 100 个正例中的 40 个预测为正例，则你的模型的召回率是 40%。</li><li>假设你的模型一共预测了 50 个正例，其中 40 个确实是正例（还有 10 个是负例，即 FP 的情形），则你的模型精确率是 80%。</li></ul><p>显然，若要提高召回率，则模型会变得「贪婪」，于是犯错的可能性就会变大，也就是精确率下降；若要提高精确率，则模型会变得「保守」，此时模型能够覆盖的正例就少，于是召回率下降。考虑到召回率和精确率之间「跷跷板」的关系，人们发明了 F1 值这个指标，并将其定义为召回率和精确率的调和平均数，从而能够比较容易地在召回率和精确率方面取得平衡：</p><p><code>$$F1 = \frac{2}{\frac{1}{TPR} + \frac{1}{PPV}} = \frac{2TP}{P + P&#39;}.$$</code></p><h3 id="敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数"><a href="#敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数" class="headerlink" title="敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数"></a>敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数</h3><p>从数学上将，召回率和精确率之间跷跷板一般的关系来自于精确率计算的分母是 <code>$P&#39;$</code> 而非 <code>$P$</code>。因为当模型发生变化的时候，<code>$P&#39;$</code> 就会发生变化。所以你无法在提升召回率的时候，保证精确率不变；反之亦然。</p><p>既然如此，我们寻找分母为 <code>$P$</code> 或 <code>$N$</code> 的指标，是否就能解决这个问题了呢？按照这个思路，人们定义了敏感度和特异度的概念。</p><ul><li>敏感度就是召回率，它是真阳性率的有一个马甲。</li><li>特异度是模型在负例上的召回率，因此它是真阴性率的马甲。</li></ul><p>因为敏感度和特异度分别是以验证集中正例数量和负例数量为分母的，所以它们：</p><ul><li>不存在必然的跷跷板关系；</li><li>不受不平衡数据的影响。</li></ul><p>这就「很<del>理中客</del>」了嘛。为了统一考量模型的敏感度和特异度，即为了统一考量模型在正负例上的召回率，人们又定义了约登指数。</p><p><code>$$J = TPR + TNR - 1.$$</code></p><h2 id="曲线及其-AUC（Area-under-Curve，曲线下面积）"><a href="#曲线及其-AUC（Area-under-Curve，曲线下面积）" class="headerlink" title="曲线及其 AUC（Area under Curve，曲线下面积）"></a>曲线及其 AUC（Area under Curve，曲线下面积）</h2><p>上面的讨论都基于一个假设，即映射函数 <code>$M(\cdot)$</code> 是确定的。如果映射函数发生变化，模型对样本的最终预测 <code>$\hat y$</code> 就会发生变化，进而影响到混淆矩阵，最终影响到各个评价指标。因此，在这个意义下，对于确定的模型，各个指标将是映射函数的函数。</p><p>一般来说，对于二分类问题，映射函数是一个简单的分段函数。于是，各个指标将是分段阈值 <code>$t$</code> 的函数。</p><p><code>$$M(s) = \begin{cases} 1 &amp; s &gt; t, \\ 0 &amp; \text{otherwise}. \end{cases}$$</code></p><p>对于需要取舍的指标对，我们可以做如下操作，得到一条曲线（折线）：</p><ul><li>逐渐改变阈值 <code>$t$</code>，得到序列 <code>$\bigl\{\bigl(A(t), B(t)\bigr)\bigr\}$</code>。</li><li>将指标 A 和指标 B 分别作为平面直角坐标系的横轴和纵轴。</li><li>将序列对应的点，绘制在平面直角坐标系中。</li><li>顺序连接这些点。</li></ul><p>对于真阳性率（敏感度，召回率）和假阳性率（1 - 特异度），这条曲线是接收者操作特征曲线（receiver operating characteristic curve）。对于召回率和精确率，这条曲线是精确率-召回率曲线（PR-Curve）。</p><h3 id="接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）"><a href="#接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）" class="headerlink" title="接收者操作特征曲线（receiver operating characteristic curve, ROC）"></a>接收者操作特征曲线（receiver operating characteristic curve, ROC）</h3><p>一条典型的 ROC 如下图所示。</p><p><img alt="ROC" data-src="/uploads/images/MachineLearning/roc.png"></p><p>这里，横坐标代表假阳性率 FPR，它是阈值 <code>$t$</code> 的函数，我们记作 <code>$F(t)$</code>；纵坐标代表真阳性率 TPR，它也是阈值 <code>$t$</code> 的函数，我们记作 <code>$T(t)$</code>。从图中很明显能看出 FPR 和 TPR 之间「鱼和熊掌不可兼得」的关系。曲线下面积（AUC）越大，也就是曲线约接近左上角，说明模型就越理想。那么 ROC 的 AUC 是什么含义呢？</p><p>我们将 FPR 看做是一个累积分布函数，即</p><p><code>$$F(t) = P(\hat y \geqslant t \mid y = 0),$$</code></p><p>因此 FPR 相对 <code>$t$</code> 的偏导数应当是一个概率密度函数，即</p><p><code>$$\frac{\partial F(t)}{\partial t} = P(\hat y = t \mid y = 0).$$</code></p><p>我们将 TPR 看做是 FPR 的函数，即 <code>$T(t) = T(F) = T(F^{-1}(F(t)))$</code>。因此有</p><p><code>$$\begin{aligned}\text{AUC} = {}&amp; \int_{0}^{1} T(F)\,\mathop{}\mathrm{d}F \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \mid y = 1)\cdot\frac{\partial F(t)}{\partial t}\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \mid y = 1)\cdot P(\hat y&#39; = t \mid y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \wedge \hat y&#39; = t \mid y = 1 \wedge y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; \hat y&#39; \wedge \hat y&#39; = t \mid y = 1 \wedge y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; P(\hat y &gt; \hat y&#39; \mid y = 1 \wedge y&#39; = 0). \\\end{aligned}$$</code></p><p>于是我们知道，ROC 的 AUC 表示任选正负例对 <code>$\bigl((\vec x_1, y_1 = 1), (\vec x_2, y_2 = 0)\bigr)$</code>，模型输出得分中，正例得分大于负例得分的概率 <code>$P\bigl(\mathcal C(\vec x_1) &gt; \mathcal C(\vec x_2)\bigr)$</code>。换言之，ROC 的 AUC 反映了模型的排序能力。这在 CTR 预估排序的场景下，非常有用。</p><blockquote><p>关于这一点，<a href="https://madrury.github.io/jekyll/update/statistics/2017/06/21/auc-proof.html" target="_blank" rel="noopener">这里</a>有一个有趣的集合解释。<br>另外，值得一提的是，一般默认的 AUC 指的是 AUC of ROC。</p></blockquote><h3 id="精确率-召回率曲线（precision-recall-curve-PR-Curve）"><a href="#精确率-召回率曲线（precision-recall-curve-PR-Curve）" class="headerlink" title="精确率-召回率曲线（precision-recall curve, PR-Curve）"></a>精确率-召回率曲线（precision-recall curve, PR-Curve）</h3><p>一条典型的 PR-Curve 如下图所示。</p><p><img alt="PR-Curve" data-src="/uploads/images/MachineLearning/pr-curve.jpg"></p><p>从中很明显能看出来之前说的「跷跷板」关系。曲线下面积（AUC）越大，也就是曲线约接近右上角，说明模型就越理想。但这种情况，在实际工作中基本是不可能出现的。因此我们需要根据实际问题进行取舍（确定一个合适的 <code>$t$</code>）。</p><p>对于正例显著少于负例的情况，人们往往追求尽可能高的召回率。因此，可以预先设定一个精确率下限，然后在这个下限之上，寻找召回率最高的点。比如在上图中，若设定可接受的最低精确率是 0.8，则召回率最高大约是 0.55；若设定可接受的最低精确率是 0.6，则召回率最高大约是 0.92。对于正例显著多于负例的情况，人们往往追求尽可能高的精确率。此时可以反向操作，选取合适的 <code>$t$</code>。</p><p>同样的问题：那么 PR-Curve 的 AUC 是什么含义呢？利用类似的思路可得：PR-Curve 的 AUC 表示任选一个正例 <code>$(\vec x_1, y_1 = 1)$</code>，而后任选一个满足 <code>$\mathcal C(\vec x_2) &gt; \mathcal C(\vec x_1)$</code> 的样本 <code>$(\vec x_2, y_2)$</code>，该样本为正样本的概率 <code>$P\bigl(y_2 = 1 \mid y_1 = 1 \wedge \mathcal C(\vec x_2) &gt; \mathcal C(\vec x_1)\bigr)$</code>。</p><h3 id="ROC-与-PR-Curve-的比较"><a href="#ROC-与-PR-Curve-的比较" class="headerlink" title="ROC 与 PR-Curve 的比较"></a>ROC 与 PR-Curve 的比较</h3><p><img alt="ROC in skewed datasets" data-src="/uploads/images/MachineLearning/roc-imbalanced.webp"></p><p>由于 ROC 的横纵坐标分别表示 FPR 和 TPR，二者的分母完全隔开，从而使得 AUC of ROC 不受正负样本比例的影响（如上图所示）。这看起来是个好事，因为它在倾斜的数据集上依然保持了稳定的物理意义（类似准确率）。但是，另一方面，这说明在负例数量远大于正例数量的极度倾斜的数据集上，AUC of ROC 可能失真。在这种情况下，PR-Curve 能够更好地反映出模型的性能。</p><h2 id="点击率预估模型中的-AUC-与-gAUC（grouped-AUC）"><a href="#点击率预估模型中的-AUC-与-gAUC（grouped-AUC）" class="headerlink" title="点击率预估模型中的 AUC 与 gAUC（grouped AUC）"></a>点击率预估模型中的 AUC 与 gAUC（grouped AUC）</h2><p>在个性化推荐、广告中，用作 rank 的模型，通常是点击率预估模型。此类模型将问题抽象为一个二分类问题，用模型预测用户是否会点击一个物品（推荐的内容或者广告）。由于该场景的目标是对物品进行排序，所以天然适合使用 AUC 作为评价指标。</p><p>但这有一个问题，我们通过例子来说明。</p><p>假设样本集中有 A 和 B 两个用户，分别都有 10 个物品。在这分别的 10 个物品当中，又分别有 5 个正例和 5 个负例。我们将这些正例和负例记为 A+/B+/A-/B-。假设将点击率预估模型的输出从高到低排序，结果是 A+/A-/B+/B-。此时，将两个用户的正负例混合起来看，AUC 不会很高。因为模型将部分负例（A-）排在了部分正例（B+）之前。但是，对于 A 和 B 分别来说，他们能观察到的正例均排在负例之前。也就是说，此时 AUC 不高，但实际效果很好。</p><p>这个问题可以这样解释：在模型预测分数越集中的区域，用户之间的细微差异导致的正负样本差异的影响就越大。因此，AUC 在这些区域可能会失真。此时，引入分组 AUC（grouped AUC, gAUC）可以缓解这一问题。</p><p><code>$$\text{gAUC} := \frac{\sum_{i = 1}^{n}(\omega_{i}\cdot\text{AUC}_{i})}{\sum_{i = 1}^{n}\omega_{i}}.$$</code></p><p>这里，<code>$\text{AUC}_{i}$</code> 表示第 <code>$i$</code> 个分组内的 AUC；<code>$\omega_{i}$</code> 则表示该组权重。对于点击率预估的场景，每个用户对应一个分组，该用户的权重可设为该用户在样本集当中可见的曝光数量。即有</p><p><code>$$\text{gAUC} := \frac{\sum_{i = 1}^{n}(\#\text{impression}_{i}\cdot\text{AUC}_{i})}{\sum_{i = 1}^{n}\#\text{impression}_{i}}.$$</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Classification" scheme="https://liam.page/tags/Classification/"/>
    
      <category term="Binary" scheme="https://liam.page/tags/Binary/"/>
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>Alias Method: 在常数时间复杂度内非均匀地随机抽取元素</title>
    <link href="https://liam.page/2019/12/02/non-uniform-random-choice-in-constant-time-complexity/"/>
    <id>https://liam.page/2019/12/02/non-uniform-random-choice-in-constant-time-complexity/</id>
    <published>2019-12-02T04:54:56.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章要讨论的问题很简单：给定一个集合，要你在常数时间复杂度内，从中以给定的概率分布随机抽取其中的元素。</p><a id="more"></a><h2 id="问题的抽象"><a href="#问题的抽象" class="headerlink" title="问题的抽象"></a>问题的抽象</h2><p>这里我们以 C++ 语言描述，我们需要实现这样一个可调用的类模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values_;</span><br><span class="line">  <span class="comment">// other internal assets</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob);</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，构造函数完成初始化工作，函数调用运算符完成随机抽取元素的工作。</p><h2 id="Trival-版本"><a href="#Trival-版本" class="headerlink" title="Trival 版本"></a>Trival 版本</h2><p>最平凡的想法可以是：</p><ol><li>根据概率分布计算累积分布，将 $[0, 1]$ 分成若干段；</li><li>然后通过一个 $[0, 1]$ 之间的均匀随机生成器，随机生成一个 $[0, 1]$ 之间的浮点数；</li><li>最后通过<strong>判断</strong>随机数落在哪一个分段中，输出相应的元素。</li></ol><p>这里的 (1) 和 (2) 都可以在常数时间内完成，(3) 最快可以用二分或者二叉搜索树的方法在对数时间内完成。这里实现一版利用二分查找的方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;         values_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;    cumulative_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::random_device   rd_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mt19937         gen_&#123;rd_()&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; dis_&#123;<span class="number">0.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob) :</span><br><span class="line">      values_(val), cumulative_(generate_cumulative(prob)) &#123;</span><br><span class="line">    assert(val.size() == prob.size());</span><br><span class="line">    assert(<span class="built_in">std</span>::<span class="built_in">fabs</span>(<span class="number">1.0</span> - cumulative_.back()) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon());  <span class="comment">// *</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> rand = dis_(gen_);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> idx  = bsearch_last_not_greater_than(cumulative_.begin(), cumulative_.end(), rand);</span><br><span class="line">    assert(idx &lt; values_.size());</span><br><span class="line">    <span class="keyword">return</span> values_[idx];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; generate_cumulative(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; cumulative;</span><br><span class="line">    cumulative.reserve(prob.size() + <span class="number">1</span>);</span><br><span class="line">    cumulative.emplace_back(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::transform(prob.begin(), prob.end(), <span class="built_in">std</span>::back_inserter(cumulative),</span><br><span class="line">        [&amp;](<span class="keyword">const</span> <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> p + cumulative.back(); &#125; );</span><br><span class="line">    <span class="keyword">return</span> cumulative;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">iter_t</span>,</span><br><span class="line">            <span class="keyword">typename</span> <span class="keyword">value_t</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;<span class="keyword">iter_t</span>&gt;::value_type,</span><br><span class="line">            <span class="keyword">typename</span> <span class="keyword">binpred_t</span> = <span class="built_in">std</span>::less&lt;<span class="keyword">value_t</span>&gt;&gt;</span><br><span class="line">  <span class="keyword">size_t</span> bsearch_last_not_greater_than(<span class="keyword">const</span> <span class="keyword">iter_t</span> begin,</span><br><span class="line">                                       <span class="keyword">const</span> <span class="keyword">iter_t</span> end,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="keyword">value_t</span> target,</span><br><span class="line">                                          <span class="keyword">binpred_t</span> binpred = <span class="keyword">binpred_t</span>()) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">iter_t</span> first = begin, last = end;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      <span class="keyword">iter_t</span> mid = first + <span class="built_in">std</span>::distance(first, last) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">not</span>(binpred(target, *mid)) <span class="keyword">and</span></span><br><span class="line">            (<span class="built_in">std</span>::next(mid) == last <span class="keyword">or</span> binpred(target, *(<span class="built_in">std</span>::next(mid))))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::distance(begin, mid);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binpred(target, *mid)) &#123;</span><br><span class="line">        last = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first = <span class="built_in">std</span>::next(mid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probs&#123;<span class="number">0.05</span>, <span class="number">0.25</span>, <span class="number">0.35</span>, <span class="number">0.35</span>&#125;;</span><br><span class="line"></span><br><span class="line">  discrete_random_variable&lt;<span class="keyword">int</span>&gt; drv&#123;values, probs&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">400000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = drv();</span><br><span class="line">    assert(<span class="built_in">std</span>::find(values.begin(), values.end(), x) != values.end());</span><br><span class="line">    ++counter[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> pair : counter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">"["</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">": \t"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != pair.second / <span class="number">2500</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Walker-Vose-Alias-Method"><a href="#Walker-Vose-Alias-Method" class="headerlink" title="Walker-Vose Alias Method"></a>Walker-Vose Alias Method</h2><p>平凡的解法，效率最高也只能做到对数时间复杂度。不过，既然目标很明确，希望能在「常数时间」内完成任务；那我们就思考一下，有什么类似的场景，可以在常数时间内解决的。显而易见，在标准库设施 <code>std::uniform_int_distribution</code> 的帮助下，对于均匀随机采样，我们可以在常数时间内完成任务。因此，若能在常数时间内，完成均匀和到非均匀的映射，我们就可以借助它来完成任务。</p><p>回过头来看「效率最高也只能做到对数时间复杂度」这句话。在目前用到的信息的条件下，这句话是正确的。也就是，在第 (3) 步在没有其他辅助的情况下，对数时间复杂度已经是最优解。因此，若想要继续优化，就必须「找其他辅助」。</p><p>我们注意用 <code>*</code> 标注出来的断言。在平凡的解法中，概率分布加和为 1 这一性质，我们只是用来验证概率分布合法，而没有用到它来辅助计算。为了用到这一性质，我们需要注意到以下一些事实：</p><ul><li>虽然非均匀分布的平凡解法最好能做到对数时间复杂度，但对于非均匀的伯努利实验（随机变量可能取值只有 2 种），我们仍能在<strong>常数时间</strong>内解决问题。</li><li>若随机变量的取值可能有 $k$ 个，那必然有部分取值的概率小于 $\frac{1}{k}$，同时有另一些不小于 $\frac{1}{k}$。</li><li>我们可以通过<strong>拆借</strong>的方法，把概率大于 $\frac{1}{k}$ 的部分借给概率小于 $\frac{1}{k}$ 的部分，使得所有取值上的概率都恰好等于 $\frac{1}{k}$；从而使非均匀采样问题变成均匀采样问题。</li></ul><p>经过上网查询，这个算法已经被发明过了，它叫做 <a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">Walker-Vose Alias Method</a>。下面给出它的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; alias_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::random_device   rd_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mt19937         gen_&#123;rd_()&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; real_dis_&#123;<span class="number">0.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">size_t</span>&gt;  int_dis_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; vals, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; probs) :</span><br><span class="line">      values_(vals), alias_(generate_alias_table(probs)), int_dis_(<span class="number">0</span>, probs.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    assert(vals.size() == probs.size());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> sum = <span class="built_in">std</span>::accumulate(probs.begin(), probs.end(), <span class="number">0.0</span>);</span><br><span class="line">    assert(<span class="built_in">std</span>::<span class="built_in">fabs</span>(<span class="number">1.0</span> - sum) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> idx  = int_dis_(gen_);</span><br><span class="line">    <span class="keyword">if</span> (real_dis_(gen_) &gt;= alias_[idx].first <span class="keyword">and</span></span><br><span class="line">          alias_[idx].second != <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max()) &#123;</span><br><span class="line">      <span class="keyword">return</span> values_[alias_[idx].second];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> values_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; generate_alias_table(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; probs) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> sz = probs.size();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; alias(sz, &#123;<span class="number">0.0</span>, <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max()&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">size_t</span>&gt;  small, large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != sz; ++i) &#123;</span><br><span class="line">      alias[i].first = sz * probs[i];</span><br><span class="line">      <span class="keyword">if</span> (alias[i].first &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        small.push(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span>(small.empty()) <span class="keyword">and</span> <span class="keyword">not</span>(large.empty())) &#123;</span><br><span class="line">      <span class="keyword">auto</span> s = small.front(), l = large.front();</span><br><span class="line">      small.pop(), large.pop();</span><br><span class="line">      alias[s].second = l;</span><br><span class="line">      alias[l].first -= (<span class="number">1.0</span> - alias[s].first);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (alias[l].first &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        small.push(l);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large.push(l);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> alias;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probs&#123;<span class="number">0.05</span>, <span class="number">0.25</span>, <span class="number">0.35</span>, <span class="number">0.35</span>&#125;;</span><br><span class="line"></span><br><span class="line">  discrete_random_variable&lt;<span class="keyword">int</span>&gt; drv&#123;values, probs&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">400000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = drv();</span><br><span class="line">    assert(<span class="built_in">std</span>::find(values.begin(), values.end(), x) != values.end());</span><br><span class="line">    ++counter[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> pair : counter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">"["</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">": \t"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != pair.second / <span class="number">2500</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章要讨论的问题很简单：给定一个集合，要你在常数时间复杂度内，从中以给定的概率分布随机抽取其中的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Random" scheme="https://liam.page/tags/Random/"/>
    
      <category term="Choice" scheme="https://liam.page/tags/Choice/"/>
    
  </entry>
  
  <entry>
    <title>期权和风险对冲</title>
    <link href="https://liam.page/2019/11/24/option-and-hedge/"/>
    <id>https://liam.page/2019/11/24/option-and-hedge/</id>
    <published>2019-11-24T07:49:36.000Z</published>
    <updated>2019-11-28T10:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在<a href="https://www.youtube.com/channel/UC5RtC9dKUJ9noJ4C6N4XnmQ" target="_blank" rel="noopener">跟我一起来谈钱</a>这个频道里学了不少知识，特别感谢薇姐姐在繁忙工作之余还给我们科普金融经济基本常识，让我受益良多。</p><p>这里把学习到的关于期权和对冲的知识记录下来。</p><a id="more"></a><h2 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h2><p>期权（option）是一种金融衍生品。其英文 option 的意思就是「选择」，于是，顾名思义期权是一种选择交易与否的权利。期权分为两大类，买权（call option；又称：看涨期权、认购期权）和卖权（put option；又称：看空期权、认沽期权）。对期权的买卖分别称之为 long 和 short。例如，买入卖权称之为 long a put option；卖出买权称之为 short a call option。</p><p>期权的核心要素有以下一些：</p><ul><li>标的物（underlying）：即选择是否交易的东西。通常是有价证券（security；例如：股票）。</li><li>行权价（exercise price / strike price）：即交易标的物时的价格。</li><li>履约日期（maturity date / expiration date）：即指定的交易日期（European Option）或指定的期权失效日期（American Option）。对于欧式期权来说，交易只能选择发生在履约日；对于美式期权来说，交易可以发生在不晚于履约日的任何一天。</li></ul><p>以买权为例。假设你看好一只股票（现价 100），认为该股票在未来一段时间内会涨。那么你可以：</p><ul><li>买入该股票，待涨后（比如涨到 110）卖出（净赚 10）；</li><li>买入该股票的期权（花费 3，行权价 110），当股票在履约日之前（针对美式期权）超过 break-even price（113）之后买入该股票（净赚 <code>price - 103</code>）。</li></ul><p>那么现在问题来了。既然你看好一只股票，那为什么不直接买，还要多此一举先买期权再购入呢？最常见的就是为了对冲（hedge，接下来要讲）而不是为了拥有（exposure）。另外，对于资金有限制、有合规及避税方面的需求等情形，购买期权而非直接购买也是有利的。</p><p>对于资金有限制的情况，比如你手头只有 300 美元，立即买入只能买入 3 股；但能够买入 100 股的期权（行权价 110）。当股价涨到 120 时，立即买入的收益率是 20%；而买入期权的做法，只需再借入 10,000 美元（可能要为此承担借款利息）买入 100 股并立即卖出，收益率可达 230%。这时，long call 成为杠杆投机的工具。——当然，若股价没有超过 break-even price，则会产生亏损。</p><h2 id="对冲"><a href="#对冲" class="headerlink" title="对冲"></a>对冲</h2><p>对冲（hedge）的本质是损失一定利益或者付出一定成本，来控制风险的手段。英文 hedge 的原意是「栅栏」，相当于 barrier，引申义是保护或防御的手段。</p><p>举个栗子来说。</p><p>如果一只股票现价 100，你看好这只股票将来的表现，因此买入股票。为了获取股票将来可能的涨幅带来的收益，你就必须承担股价下跌的风险。这种风险最大可以是 100% 的本金，即在极端情况下，股价跌至接近零。显然，你是不想承担这种风险的。于是你可以选择买入卖权。比如，你花费 3 元，买入在未来某一时间段内以 100 元卖出该股票的卖权（long a put option）。此时，你持有该股票的成本变成了 103 元。</p><p>如果股价未来上涨，超过 103 元，卖出股票你就能获利。但如果股价下跌，比如跌到了 90 元甚至 50 元、20 元，你可以选择行权，以 100 元的价格将股票卖出。在后一种情况下，你只亏损了 3 元，有效地控制了风险。</p><p>卖权的定价一般和以下一些因素有关：</p><ul><li>标的物当前价格和行权价。行权价相对标的物价格越高，卖权价格越高。</li><li>履约日期限。履约日距今时间越长，卖权价格越高。</li><li>标的物价格的波动幅度。波动幅度越大，卖权价格越高。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在&lt;a href=&quot;https://www.youtube.com/channel/UC5RtC9dKUJ9noJ4C6N4XnmQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跟我一起来谈钱&lt;/a&gt;这个频道里学了不少知识，特别感谢薇姐姐在繁忙工作之余还给我们科普金融经济基本常识，让我受益良多。&lt;/p&gt;
&lt;p&gt;这里把学习到的关于期权和对冲的知识记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Hedge" scheme="https://liam.page/tags/Hedge/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上跨版本更新 TeX Live</title>
    <link href="https://liam.page/2019/11/11/cross-release-update-TeX-Live-on-macOS/"/>
    <id>https://liam.page/2019/11/11/cross-release-update-TeX-Live-on-macOS/</id>
    <published>2019-11-11T11:24:38.000Z</published>
    <updated>2019-11-11T11:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写 LaTeX 了。嗯……原因是因为我很久没用 LaTeX 了。</p><p>因为很久没用 LaTeX，所以 Mac 上的 macTeX 也很久没更新。这不，目前版本还是 macTeX 2018，而 macTeX 2019 都出来很久了。另一方面，因为系统版本有升级，导致与 macTeX 2018 有些不兼容。于是，升级到 2019 版本变得势在必行。</p><a id="more"></a><h2 id="升级-macTeX-还是升级-TeX-Live"><a href="#升级-macTeX-还是升级-TeX-Live" class="headerlink" title="升级 macTeX 还是升级 TeX Live"></a>升级 macTeX 还是升级 TeX Live</h2><p>本质上 macTeX 是对 TeX Live 的打包封装。里面当中实际执行的，还是 TeX Live。因此，升级 TeX Live 而不升级 macTeX 可以避免下载巨大的 <code>macTeX.pkg</code>。</p><h2 id="update-tlmgr-latest"><a href="#update-tlmgr-latest" class="headerlink" title="update-tlmgr-latest"></a><code>update-tlmgr-latest</code></h2><p>一般升级，用到的命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tlmgr update --self --all --reinstall-forcibly-removed</span><br></pre></td></tr></table></figure><p>但是，跨版本升级时，它会报错。不过，它会有提示，让你下载 <code>update-tlmgr-latest</code> 来将 <code>tlmgr</code> 更新到最新版本，从而可以跨版本更新。于是我们有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh</span><br><span class="line">bash update-tlmgr-latest.sh</span><br><span class="line">tlmgr update --self --all --reinstall-forcibly-removed</span><br></pre></td></tr></table></figure><h2 id="更新语言配置"><a href="#更新语言配置" class="headerlink" title="更新语言配置"></a>更新语言配置</h2><p>上述 <code>tlmgr update</code> 在执行到最后，构建 <code>fmt</code> 文件时会报错。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I can&apos;t find file `dehypht-x-2018-03-31.tex`!</span><br></pre></td></tr></table></figure><p>检查发现，构建 <code>fmt</code> 文件时，会读取 <code>/usr/local/texlive/2018/texmf-var/tex/generic/config/language.def</code> 文件，它提到了：<code>\addlanguage{german-x-latest}{dehypht-x-2018-03-30.tex}{}{2}{2}</code>。</p><p>上网检查发现，可以用 <code>tlmgr generate language</code> 更新语言定义文件。遂执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tlmgr generate language</span><br><span class="line">fmtutil -sys --all</span><br></pre></td></tr></table></figure><p>至此，万事 OK~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没写 LaTeX 了。嗯……原因是因为我很久没用 LaTeX 了。&lt;/p&gt;
&lt;p&gt;因为很久没用 LaTeX，所以 Mac 上的 macTeX 也很久没更新。这不，目前版本还是 macTeX 2018，而 macTeX 2019 都出来很久了。另一方面，因为系统版本有升级，导致与 macTeX 2018 有些不兼容。于是，升级到 2019 版本变得势在必行。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="TeX Live" scheme="https://liam.page/tags/TeX-Live/"/>
    
  </entry>
  
  <entry>
    <title>踩坑：value to great for base</title>
    <link href="https://liam.page/2019/11/11/value-too-great-for-base-in-shell/"/>
    <id>https://liam.page/2019/11/11/value-too-great-for-base-in-shell/</id>
    <published>2019-11-11T01:57:34.000Z</published>
    <updated>2019-11-11T11:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天启动的定时任务，有几个实例挂掉了。报错提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value too great for base (error token is "08")</span><br></pre></td></tr></table></figure><a id="more"></a><p>出错的相关代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $(($&#123;hour_s&#125; + $&#123;hour_diff&#125;)) -gt 23 ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> foo bar</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这里 <code>${hour_s}</code> 是当前标定时间的小时数。形如 <code>00</code>, <code>01</code>, <code>02</code>, ..., <code>08</code>, <code>09</code>, ..., <code>23</code>。<code>${hour_diff}</code> 是需要向后处理的小时数。这段代码的意图，是判断二者相加是否大于 <code>23</code>。若大于 <code>23</code>，则需要在日期上 <code>+1</code>，否则只需要操作小时即可限定数据范围。</p><p>关键就在于 <code>08</code> 和 <code>09</code> 的意思。这里 <code>08</code> 是上午八点的意思，为了保持格式一致，在 <code>8</code> 的前面填充了 <code>0</code>。但 Shell 把它当成是八进制（base is 8）。这样一来，怪不得 Shell 认为 <code>08</code> 是不合法的八进制数。为解决这个问题，我们需要告知 Shell 这是个前面填充了 0 的十进制数。于是我们需要改成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $((10#$&#123;hour_s&#125; + $&#123;hour_diff&#125;)) -gt 23 ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> foo bar</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天启动的定时任务，有几个实例挂掉了。报错提示：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;value too great for base (error token is &quot;08&quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="Integer" scheme="https://liam.page/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>梨花又开放</title>
    <link href="https://liam.page/2019/11/07/another-blossom-of-pear-flower/"/>
    <id>https://liam.page/2019/11/07/another-blossom-of-pear-flower/</id>
    <published>2019-11-07T06:16:53.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天说点不一样的，聊聊「梨花又开放」这首歌的歌词。</p><a id="more"></a><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>「梨花又开放」是周峰根据谭咏麟的经典粤语歌曲「迟来的春天」重新填词而作，谭咏麟的「迟来的春天」则根据因幡晃的「夏にありがとう」重新填词。</p><p>另有香港已故巨星张国荣英文版本「Good Morning Sorrow」，收录于1978年发行的专辑「Daydreaming」中。</p><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><blockquote><p>梨花又开放<br>原唱：周峰<br>作词：丁小齐<br>作曲：因幡晃（日）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=175391&auto=1&height=32"></iframe><p>忘不了故乡 年年梨花放<br>染白了山岗 我的小村庄<br>妈妈坐在梨树下 纺车嗡嗡响<br>我爬上梨树枝 闻那梨花香<br>摇摇啊洁白的树枝 花雨漫天飞扬<br>落在妈妈头上 飘在纺车上<br>给我幸福的故乡 永生难忘<br>永生永世我不能忘</p><p>重返了故乡 梨花又开放<br>找到了我的梦 我一腔衷肠<br>小村一切都依然 树下空荡荡<br>开满梨花的树下 纺车不再响<br>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p><p>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p><p>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p></blockquote><h2 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h2><p>梨花又开放的歌词，可以说是纸短情长的典范。</p><p>歌词共分上下两阙，上阙是回忆歌者的童年，下阙则是重返故乡的所见所想。上下两阙共同出现的意象是：梨花（梨树）、村庄（故乡、山岗）；只在上阙中出现的意象是：妈妈、纺车。共同出现的意象是触景生情的基础，只在回忆中出现的意象则是触景生情的情感寄托所在。</p><p>两阙中 A 段的故乡、梨树一切都依然，甚至梨花开得都一样茂盛。这勾起了「我」的回忆，从而构成了触景深情的基础。但是梨树下空荡荡、纺车不再响。为什么纺车不再响了？因为妈妈已经走了。由纺车作为牵线：纺车不再了，也就是妈妈不在了。哀而不伤的情绪，由此喷薄而出。</p><p>B 段里，「我」摇动梨树枝，花雨同样的漫天飞扬。但不同的是，回忆中梨花飘在妈妈头上和纺车上，现在却只有我一个人孤零零呆立树下。回忆中的妈妈操作纺车会是什么神情？想必是问题又宠溺的表情，看着调皮的「我」吧！然而，妈妈走了，不再了。如今还能摇动梨树的我，只能任凭梨花飘落，想要见妈妈，却只能在想象当中。妈妈已经不在，能够寄托思绪的，就只能是依然还在的故乡、村庄。此时，故乡村庄已经变成了妈妈的化身——妈妈给我幸福、给我血肉，那我当然永生难忘！永生难忘的，不是明面上的故乡，而是妈妈。</p><p>全歌词只说难忘，不说想念；只说故乡，不说已经离去的母亲。但是，对母亲的想念思念却跃然纸上，让人动容。此等的触景生情，只在归有光的「项脊轩志」中见到过：庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。后人评价项脊轩志，讲「此意境人人所有，此笔妙人人所无」，又讲「盖古今来事无巨细，唯此可歌可涕之精神，长留天壤」。想来把这些用在评价这首歌词中，也是恰如其分的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天说点不一样的，聊聊「梨花又开放」这首歌的歌词。&lt;/p&gt;
    
    </summary>
    
      <category term="Music" scheme="https://liam.page/categories/Music/"/>
    
    
      <category term="Lyrics" scheme="https://liam.page/tags/Lyrics/"/>
    
  </entry>
  
  <entry>
    <title>利用穷人乐理论撰写精准营销类文章</title>
    <link href="https://liam.page/2019/11/06/writing-marketing-articles-based-on-the-theory-of-poor-but-happy/"/>
    <id>https://liam.page/2019/11/06/writing-marketing-articles-based-on-the-theory-of-poor-but-happy/</id>
    <published>2019-11-06T09:47:12.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>中国互联网历史中，要论最成功的精准营销类文章写手，咪蒙必在其中无疑。咪蒙本名马凌，说起来还是我山东大学的校友。2015 年时，马凌注册了名为咪蒙的微信公众号。该微信公众号以发表精准定位现代女性的营销类文章而出名，一度有超过千万的关注量和阅读量。</p><p>时至今日，<a href="https://www.zhihu.com/question/318167756" target="_blank" rel="noopener">咪蒙已经「毕业」</a>，但互联网江湖上一直流传着咪蒙的传说。大家乐此不疲地讨论和思考，咪蒙为什么会成功？咪蒙的文章为什么会有这种奇怪的魔力，让无数具有良好教育的现代女性为之着魔。</p><p>此篇讲一讲我的一些思考。</p><a id="more"></a><h2 id="人穷但快乐"><a href="#人穷但快乐" class="headerlink" title="人穷但快乐"></a>人穷但快乐</h2><p>世界上有一种奇怪的现象。</p><p>有一些人，生活水平和物质基础低于平均水平，我们称之为穷人。在追逐更高生活水平和物质基础的过程中，穷人往往会凭着自己的想象，设想出心目中富人的样子。这些穷人为了平衡自己落后的物质基础，会认为富人的精神世界是单调的、空洞的、乏味的。也就是说：这部分穷人承认自己穷，但是认为自己活得开心快乐；认为富人虽然富，但是富人精神空虚。</p><p>我们说，在这个过程中，这些穷人不仅会表现出物质上的穷，还会表现了精神世界层面的穷。我们把这种现象称之为「人穷但快乐」，简称「穷人乐」。</p><h2 id="分裂的人性"><a href="#分裂的人性" class="headerlink" title="分裂的人性"></a>分裂的人性</h2><p>读完上面这一段，如果你很穷，你大概会很生气；如果你比较富裕，你大概心里长处一口气。但别着急，读完这一段，可能不论你穷困还是富裕，你可能都会胸有愤愤。</p><p>上面这一段说的穷人，主要说的是经济实力上问题。但实际上，这种穷，可以扩展到很多方面。穷人的穷，实际上说的是经济实力上的「不如人意」。于是，我们可以把这种现象，扩展到任何层面上的不如人意上。</p><p>比如：</p><ul><li>谢顶者可能会心想：你虽然头发浓密，但是你肯定学习不用功。</li><li>学习差者可能会心想：你虽然学习好，但你将来也就是个打工者。</li><li>打工者可能会心想：你虽然当老板，但是你老婆肯定会背叛你。</li><li>夫妻不和睦的人可能会心想：你虽然家庭幸福，但你肯定每天精疲力尽。（<code>←_←</code>）</li></ul><p>看！多么分裂的人性！</p><p>顺着这个思路往下走，你猜给下面这些文章点赞的人，是处于什么感情状态：</p><ul><li>我一个人活得好好的，为什么要结婚？</li><li>女人好好打扮就是为了取悦男人？瞎扯！</li><li>对不起，你的病，爱情治不了</li></ul><h2 id="精准营销"><a href="#精准营销" class="headerlink" title="精准营销"></a>精准营销</h2><p>好了，所以你大概已经想明白了。如果你要瞄准一个在某方面过得不如意的人，撰写一篇精准营销文章应该怎么写呢？</p><p>首先，你得有一个抓住这些人眼球的标题。怎样才能抓住这些人的眼球呢？答案很简单：如果这个人在某方面过得不如意，就批判贬低这方面过得如意的人，或者力挺这方面过得不如意的人。</p><p>比如对于在感情中受过伤，再也不相信爱情的女性：</p><ul><li>我一个人活得好好的，为什么要结婚？——力挺在感情中不如意的人</li><li>女人好好打扮就是为了取悦男人？瞎扯！——批判感情中如意的人（有男人可取悦）</li><li>有一种礼物，叫男朋友送的礼物——男朋友送的礼物肯定都是狗屁不通的呗，这是在贬低有男朋友的女的也收不到什么像样的礼物</li></ul><p>还有其他一些例子：</p><ul><li>我，一个矮子的史诗——你看，都「史诗」了，这不就是力挺矮子么</li><li>如何把大牌穿成地摊货？——你看，那些有钱人居然能把大牌穿成地摊货，这不就是批判有钱人么</li></ul><p>而后，你得编造一个故事，核心还是：批判如意者，发现不如意者其他方面的闪光点。总而言之，一大碗毒鸡汤就这么狠狠灌下去。</p><p>最后，如果你要营销带货，最好在文章的末尾来一个反转。比如，对于「我，一个矮子的史诗」这篇文章，如果要带货卖增高鞋垫，我会在大篇幅批判那些高个子人之后来这么一句：</p><blockquote><p>后来，我才知道，XX 看起来高，实际上只不过是在鞋子中悄悄放了一块 XX 品牌 3cm 的增高鞋垫罢了。</p></blockquote><p>你看，情绪上还是对高个子人的嘲讽鄙视，但不经意间，一个反转，点出了需要营销的东西。</p><p><code>o(*￣︶￣*)o</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国互联网历史中，要论最成功的精准营销类文章写手，咪蒙必在其中无疑。咪蒙本名马凌，说起来还是我山东大学的校友。2015 年时，马凌注册了名为咪蒙的微信公众号。该微信公众号以发表精准定位现代女性的营销类文章而出名，一度有超过千万的关注量和阅读量。&lt;/p&gt;
&lt;p&gt;时至今日，&lt;a href=&quot;https://www.zhihu.com/question/318167756&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咪蒙已经「毕业」&lt;/a&gt;，但互联网江湖上一直流传着咪蒙的传说。大家乐此不疲地讨论和思考，咪蒙为什么会成功？咪蒙的文章为什么会有这种奇怪的魔力，让无数具有良好教育的现代女性为之着魔。&lt;/p&gt;
&lt;p&gt;此篇讲一讲我的一些思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Writing" scheme="https://liam.page/tags/Writing/"/>
    
      <category term="Marketing Articles" scheme="https://liam.page/tags/Marketing-Articles/"/>
    
      <category term="Poor but Happy" scheme="https://liam.page/tags/Poor-but-Happy/"/>
    
  </entry>
  
  <entry>
    <title>一种基于 Beta 分布的推荐方法示例</title>
    <link href="https://liam.page/2019/11/06/a-Beta-Distribution-based-recommendation-realia-method/"/>
    <id>https://liam.page/2019/11/06/a-Beta-Distribution-based-recommendation-realia-method/</id>
    <published>2019-11-06T08:05:19.000Z</published>
    <updated>2019-11-12T16:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为一直在做推荐系统和点击率预估排序相关工作，所以一直想用一种粗糙但直观的方式来做一个推荐系统的示例，如果能有一定的工程实现价值就更好。最近突然有了这样一个基于 Beta 分布的想法，所以记录下来。当然，这个想法可能不是我的专利，可能已经有人想到过了。</p><a id="more"></a><h2 id="Beta-分布的直观理解"><a href="#Beta-分布的直观理解" class="headerlink" title="Beta 分布的直观理解"></a>Beta 分布的直观理解</h2><p><a href="https://zh.wikipedia.org/wiki/%CE%92%E5%88%86%E5%B8%83" target="_blank" rel="noopener">Beta 分布</a> 是一组定义在 $(0, 1)$ 之间的连续概率分布，有两个参数 <code>$\alpha, \beta &gt; 0$</code>。随机变量 <code>$X$</code> 服从参数为 <code>$\alpha$</code>, <code>$\beta$</code> 的 Beta 分布通常记作 <code>$X \sim \text{Be}(\alpha, \beta)$</code>。</p><p>在理解 Beta 分布之前，我们先回顾一下二项分布。</p><p>二项分布说的是 $n$ 个 i.i.d 的二项伯努利试验中成功次数的离散概率分布。根据二项分布，我们可以用似然的办法，通过有限次的实验，推断伯努利实验成功的概率。比如有一枚多少有些不均匀的硬币，我们多次抛硬币，将硬币呈现正面记为成功，要求成功的概率，就可以用似然的办法结合二项分布来求解。现在的问题是，在只有很少次数的实验时，利用二项分布估计的概率可能会很不准。一个极端的例子，如果我们只做了一次实验，硬币落下后呈现正面。那么根据二项分布估计出来的概率将会是 <code>$P = 1$</code>。这显然是不对的。</p><p>这时候，Beta 分布就该出场了。Beta 分布可以看做是二项分布概率的概率分布。怎么理解呢？我们来继续看抛硬币的例子。</p><p>我们知道，虽然每一枚硬币都多少有些不均匀，但是总体上，硬币落下呈现正面的概率是 <code>$0.5$</code> 左右。因此，不论如何，一枚多少有些不均匀的硬币，抛硬币得到正面的概率应该和 <code>$0.5$</code> 相去不远。具体到多次 i.i.d 的二项伯努利试验上，就是当 <code>$N$</code> 足够大时，<code>$2N$</code> 次二项伯努利试验中，得到正面的次数应该接近 <code>$N$</code>。我们假设 <code>$N = 1000$</code>，这意味着，在 <code>$2000$</code> 次二项伯努利试验中，大约会获得 <code>$A = 1000$</code> 次正面和 <code>$B = 1000$</code> 次反面。于是，我们初始化 Beta 分布 <code>$\text{Be}(A, B) = \text{Be}(1000, 1000)$</code>。接着，我们用这枚多少有些不均匀的硬币开始若干次二项伯努利试验，比如说 50 次。在 50 次试验中，我们得到了 <code>$a = 19$</code> 次正面，<code>$b = 31$</code> 次反面。于是我们更新 Beta 分布的参数 <code>$\alpha \gets A + a$</code> 以及 <code>$\beta \gets B + b$</code>，于是得到新的 Beta 分布 <code>$\text{Be}(1019, 1031)$</code>。该 Beta 分布的均值是</p><p><code>$$ \frac{\alpha}{\alpha + \beta} = \frac{1019}{1019 + 1031} = \frac{1019}{2050} \approx 0.497. $$</code></p><p>于是我们说，这枚多少有些不均匀的硬币在二项伯努利试验中得到正面的概率是 <code>$P = 0.497$</code>；与此同时，就这 50 次试验，根据二项分布推算出来的概率是 <code>$P = 0.38$</code>。显然，根据 Beta 分布均值推算出来的概率相对根据二项分布推算出来的概率要显著接近 <code>$P = 0.5$</code> 的先验值。</p><p>总结一下，Beta 分布可以看做是二项分布概率的概率分布。当我们对二项分布概率已经有一个相对比较靠谱的先验知识的时候，我们可以据此设定 Beta 的参数，然后在后续 i.i.d 的二项伯努利试验过程中，依赖 Beta 分布共轭先验的特性，对 Beta 分布的参数进行更新，最后以 Beta 分布均值作为二项分布概率的估计。</p><h2 id="基于-Beta-分布的用户画像"><a href="#基于-Beta-分布的用户画像" class="headerlink" title="基于 Beta 分布的用户画像"></a>基于 Beta 分布的用户画像</h2><p>推荐系统的一侧是用户，描述用户的方法是用户画像。我们可以用 Beta 用户来做基于 Tag 的用户画像。在这里，对于某个用户来说：</p><ul><li>Beta 分布中的 <code>$\alpha_i$</code> 是用户在编号为 <code>$i$</code> 的 Tag 下的点击次数的反映；</li><li>相应地，<code>$\beta_i$</code> 则是用户在编号为 <code>$i$</code> 的 Tag 下展示未点击次数的反应。</li></ul><p>于是，用户画像的策略可以简单叙述如下：</p><ul><li>对于某个用户，使用先验知识（比如，全体用户的平均兴趣），对 <code>$\{(\alpha_i, \beta_i)\}$</code> 序列进行初始化。</li><li>根据用户的行为（展示和点击），更新该序列<ul><li>用户点击了具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> Tag 的物品进行了点击，则对 <code>$\alpha_i$</code>, <code>$\alpha_j$</code>, <code>$\alpha_k$</code> 分别自增 1；</li><li>用户展示未点击具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> Tag 的物品进行了点击，则对 <code>$\beta_i$</code>, <code>$\beta_j$</code>, <code>$\beta_k$</code> 分别自增 1。</li></ul></li></ul><h2 id="基于-Beta-分布的点击率预估"><a href="#基于-Beta-分布的点击率预估" class="headerlink" title="基于 Beta 分布的点击率预估"></a>基于 Beta 分布的点击率预估</h2><p>对于具有画像 <code>$\{(\alpha_i, \beta_i)\}$</code> 的用户进行推荐时，我们要对待推荐的物品进行点击率预估。假设某物品同时具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> 的 Tag，假设各个 Tag 对点击行为的贡献都相同——这是一个很强的假设，但对于示例方案来说无关紧要，则用户对该物品的点击概率可以预估为：</p><p><code>$$P_{\text{click}} = 1 - \frac{\beta_i}{\alpha_i + \beta_i} \times \frac{\beta_j}{\alpha_j + \beta_j} \times \frac{\beta_k}{\alpha_k + \beta_k}.$$</code></p><p>而后，我们可以根据各个物品的预估点击率对物品进行排序，然后推荐给用户。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个近乎「儿戏」的推荐方案，但在实践上并非完全无用。说它儿戏，是因为它只考虑了单个用户的历史行为，而没有考虑其他所有对推荐有帮助的因素——比如其他用户的行为（可做协同过滤），比如推荐结果多样性。但是，在没有这些其他因素的情况下，这种方案可以起到过渡方案的作用。对，我说的就是在新用户、新物品冷启动的时候，这种方案简单易实现，值得一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直在做推荐系统和点击率预估排序相关工作，所以一直想用一种粗糙但直观的方式来做一个推荐系统的示例，如果能有一定的工程实现价值就更好。最近突然有了这样一个基于 Beta 分布的想法，所以记录下来。当然，这个想法可能不是我的专利，可能已经有人想到过了。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Beta Distribution" scheme="https://liam.page/tags/Beta-Distribution/"/>
    
      <category term="Recommendation System" scheme="https://liam.page/tags/Recommendation-System/"/>
    
      <category term="Realia" scheme="https://liam.page/tags/Realia/"/>
    
  </entry>
  
  <entry>
    <title>一篇关于大公司病的魔幻现实主义文章的读后感</title>
    <link href="https://liam.page/2019/11/05/thoughts-on-the-low-efficiency-of-large-companies/"/>
    <id>https://liam.page/2019/11/05/thoughts-on-the-low-efficiency-of-large-companies/</id>
    <published>2019-11-05T02:13:24.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在知乎上读到一篇<a href="https://www.zhihu.com/question/26111395/answer/138128420" target="_blank" rel="noopener">魔幻现实主义的文章</a>。<a href="https://www.zhihu.com/people/sun-bin-12-58" target="_blank" rel="noopener">作者</a>用一个实体的「塑料标牌」隐喻了在大公司中无形的身份、头衔和自我满足感，然后通过这一实体的塑料标牌，讲述了职场的，特别是大公司中的一些现象。</p><p>总体上来说，文章特别有意思，显得回味无穷。因此作此篇读后感。</p><a id="more"></a><h2 id="初入江湖"><a href="#初入江湖" class="headerlink" title="初入江湖"></a>初入江湖</h2><p>原文的第一段，写的是主人公「陆枫」刚入职时候的故事。</p><p>刚入职的陆枫发现周围很多同事都戴着标有数字的塑料标牌：有的人戴着多，有的人戴着少。戴着多的人，走起路来，塑料牌互相碰撞，还会<strong>哗啦啦</strong>响。陆枫感到很奇怪，但查遍「员工手册」，都没找到相应说明——既没有说明是否必须佩戴，也没有说明标牌的含义。不过在他入职时候，随附了一个标着「001」的标牌。</p><p>陆枫去问老员工，却被老员工当成<strong>不懂事的小孩子</strong>。但老员工还是给陆枫做了一些解释：</p><ul><li>这标牌戴不戴全凭个人意愿，没有规定，也不会强迫；</li><li>每周五可以主动要求领取更大编号的标牌，将在下周一发放；</li><li>（神秘地）戴上了，<strong>可能就摘不下来了</strong>。</li></ul><p>前面提到，文中的塑料标牌，隐喻的是在大公司中无形的身份、头衔和自我满足感。陆枫初入职场，看见别人有标牌，说的就是职场老人的身份、头衔等无形东西的外化。也就是说，职场老人因为在日常相处过程中，慢慢有了一些不可言明的身份头衔。这些身份头衔会影响身在职场中的人，从而外化表现在职场人的言行举止上，进而能被他人感知到。身份头衔和自我满足感高而多的人，这种外化的表现就更加明显，以至于「哗啦啦」地作响，让人想不注意到都不行。但另一方面，这种无形的东西是不能言明的，它往往是在多重因素下生根发芽萌发出来的潜规则。因此，在入职培训或者员工手册当中，陆枫当然就找不到相关说明了。</p><p>陆枫作为初入江湖的「愣头青」，把不能言明的东西主动说出来去询问老员工，当然要遭到老员工的「白眼」，被认为是「不懂事的小孩子」。从老员工的解释当中可以看出来，这种无形的东西具有的特征：</p><ul><li>全凭个人意愿，不会强迫——潜规则的东西，不能白纸黑字写出来，当然名义上是「不会强迫」的了；</li><li>身份头衔和个人满足感，随着时间的延长，会缓慢而自然地增加；</li><li>这些不能言明的虚的身份头衔，一旦陷入其中，甚至体会到它们带来的好处，就会难以自拔「摘不掉了」。</li></ul><h2 id="进入圈子"><a href="#进入圈子" class="headerlink" title="进入圈子"></a>进入圈子</h2><p>原文的第二段，写的是主人公陆枫逐渐进入圈子的故事。</p><p>既然「不强迫」，懵懂的陆枫也就选择不佩戴标牌和「升级」标牌了。但如此一来，陆枫逐渐感觉到了周围的诡异气氛——虽然大家在言语上并不会明面说什么，但是在实际行动上对陆枫有所排斥。如此一来，陆枫显得格格不入。忍受了一段时间之后，陆枫看到和他同期入职的「小陈」戴上了标牌。于是陆枫「保险起见」地也戴上了标牌。</p><p>神奇的事情出现了。随着陆枫戴上标牌并且每周开始获取新的标牌，陆枫周围那种诡异气氛慢慢不见了。大家不再「躲着」陆枫说话，开始和陆枫有说有笑起来。只是……关于这块标牌本身，大家仍然缄口不言。</p><p>戴上标牌并且获取新标牌实际上喻示着陆枫开始「融入圈子」。之所以陆枫一开始会感到诡异的气氛，是因为戴标牌的老员工们自发地形成了一个圈子。陆枫不戴标牌，无疑表示陆枫不是圈内人。人类群体对群体外的个体会有天然的排斥。在无约束的环境中，这种排斥甚至会上升到暴力。但在有约束的职场环境中，因为明面规则的限制，这种排斥最基本的表现方式就是「回避」。陆枫戴起标牌并每周更新实际上向外传达了一种态度——尽管这种态度可能并非陆枫本意，甚至这种态度的传达都是在陆枫本人无意识的情况下进行的——感受到这种态度的圈子，就逐渐接纳了陆枫。之所以说这种态度的传达可能是无意识的，是因为人的行为往往会受到所在群体的潜移默化的影响。中国的老祖宗们创造了不少成语来描述这种现象，比如：和光同尘、同流合污。</p><p>当然，在这个阶段，陆枫暂时不会也没办法体会到「进入圈子」带来的实际的好处。</p><h2 id="深入试探"><a href="#深入试探" class="headerlink" title="深入试探"></a>深入试探</h2><p>原文的第三段，讲的是主人公陆枫逐渐习惯戴标牌、领标牌的过程中发生的事情。</p><p>随着时间的推移，陆枫脖子上已经挂了 024 块标牌。在这个过程中，陆枫习惯甚至开始享受这种戴着标牌的状态。但人生总有意外。这一周的周五，陆枫太忙了，以至于没有去主动要求更新标牌。周末在家的陆枫辗转反侧惴惴不安；周一一大早，陆枫就赶到公司想要处理标牌的事情。但不出意料，陆枫的桌上没有标号为 025 的新标牌。少了 025 的标牌，标牌的「更新」无疑就要慢一个星期。陆枫感到很郁闷，但他随即想到，小陈应该会有标号为 025 的标牌。于是趁着自己来得早大家都还没到公司，陆枫悄悄地拿走了本属于小陈的 025 号标牌。</p><p>心亏的陆枫战战兢兢地度过了一周。但周围所有人都仿若不知的样子，并且陆枫用本不属于自己的 025 号标牌申领 026 号标牌也通过了。陆枫心里的石头终于落地，而后他发现：这东西是可以偷的，所以自己要小心不要被别人偷了自己的标牌，同时以后不要忘记申领新的标牌。</p><p>第一次读到这一段的时候，我心里乐哈哈的。这个陆枫，是在「危险」边缘试探啊。甚至我认为，这是原文最出彩的一段。这一段最有味道的地方在于陆枫心里石头落地的过程。按说标牌这个东西是具有实体的实实在在的东西——大家都看着呢！那为什么陆枫偷了小陈的标牌，大家都毫无所觉，并且陆枫用不属于自己的标牌申领新标牌也毫无阻碍地通过了呢？其实作者就是通过这一段，用这种方式隐晦地告诉大家：标牌只是虚幻在显示中的投影，它模模糊糊朦朦胧胧，看似有，但又看不真切。也是从这里，读者应该慢慢能体会到标牌背后的隐喻：身份、头衔和虚无的心里满足感。</p><p>但是，作者没有交代的另一个问题在于：其他人不知道也就罢了，被偷标牌的小陈，他能不知道吗？</p><h2 id="虚拟荣耀"><a href="#虚拟荣耀" class="headerlink" title="虚拟荣耀"></a>虚拟荣耀</h2><p>原文的第四段，讲的是主人公陆枫所在单位业绩不好，用标牌代替年终奖的事情。</p><p>时间继续推移，年底的时候陆枫脖子上已经挂了 42 块标牌。陆枫期待年终奖已久，终于等到领导请他去办公室沟通。不期而遇的意外又发生了。领导先是肯定了陆枫的工作，但随即告诉陆枫，公司今年业绩不好，发不出多少年终奖了。陆枫正失落，领导从抽屉里拿出了 043 -- 052 号共 10 个标牌给了陆枫，作为补偿。</p><p>五味陈杂的陆枫走出领导的办公室，却发现周围人用一种「你得到了很大好处」的羡慕眼神看着陆枫。慢慢地，在这种目光的注视下，陆枫说服了自己——我年轻，我不吃亏谁吃亏，再说这也是领导的心意嘛。</p><p>这一段我是最佩服作者笔力的了。我们分角色来看。</p><p>首先是领导。领导很自然地用标牌作为奖金不足的补偿，代替年终奖。这说明领导深谙职场潜规则，在心里早已将虚幻的身份头衔当成了财富的一种。然后是同事们。同事们见到领导的「奖励」很是羡慕。可见同事们也受职场潜规则的影响颇深，这才会羡慕陆枫获得了「好处」。最后是陆枫。陆枫一开始因为奖金没拿够而失落，可见陆枫的「修为」还不够，比领导那种「把虚幻当财富」的境界差远了。后来，在同事们「羡慕」的目光下，陆枫的<strong>心态发生了转变</strong>。从把标牌当成是「领导的心意」开始，陆枫也慢慢把虚幻的身份头衔和心理满足感当成了实际的财富。</p><p>作者用寥寥几笔，通过三个（类）角色的行为，写出了三个（类）角色的心态，从而表现了在「潜规则」这个游戏里人们越陷越深的趋势和进程。明明写的是一个事件、一个状态，越陷越深的进程却清晰可见。仅凭这一段，作者可称得上是「笔力雄浑」。</p><h2 id="机锋隐现"><a href="#机锋隐现" class="headerlink" title="机锋隐现"></a>机锋隐现</h2><p>原文的第五段可谓是机锋初现、隐而不发。</p><p>前面提到，陆枫偷拿了小陈的 025 号标牌，导致陆枫标牌始终领先小陈一块。这一天，当陆枫拿到了 061 号标牌的时候，小陈找到了陆枫，<strong>隐晦地</strong>告诉陆枫自己因为「一些原因」落后于陆枫了。陆枫心里一紧，这说的不就是我偷标牌的事情吗？小陈却马上摆摆手表示不在意，同时表示有秘密要告诉陆枫。</p><p>趁着陆枫注意力在秘密上，小陈一把抓住陆枫的 060 号标牌，扔出了窗外。然后拿起自己的 060 号标牌，笑嘻嘻地跟陆枫说：你看啊，把「060」颠倒过来就变成了「090」。只要我拿着「090」去申请标牌，下周我就能拿到「091」了。陆枫目瞪口呆，突然想到：如果拿「069」倒过来变成「690」，下周岂不是可以拿到「691」了？小陈却嘲笑陆枫傻，小陈说：「『060』变成『090』，增加 30 块，一时半会儿<strong>看不出来</strong>。但是『069』变成『690』，增加 600 多块。脖子上挂着这么大的数字，却只有几十块标牌，<strong>谁都知道你作弊了</strong>。我研究过了，在新人阶段，就这一次机会。」</p><p>陆枫傻了，<strong>不敢置信</strong>。小陈却继续暴击，说：「<strong>全公司都这么干</strong>，只有你一个人傻乎乎的」。并且威胁说：「如果你拿『059』去领『060』，再当做『090』去领『091』，我就<strong>揭发你</strong>，<strong>让全公司都知道你偷了我的『025』</strong>！说到底，你偷我一块，我扔你一块，咱俩扯平了。」</p><p>看过这一段，可谓是心潮汹涌。我们逐一来看。</p><p>为什么小陈找到陆枫的时候，明明自己占理，却只是隐晦地告诉陆枫自己知道它偷拿了自己的标牌呢？这是因为，在这个潜规则下，「作弊是允许的」。被偷走标牌，只能说是自己不小心，怪不了别人，所以不能拿到明面上来说。这也与第三段相呼应。作弊是允许的，那岂不是要乱套了？不然！因为在这个潜规则下，你可以作弊，但关键在于「你不能让人看出来」。具体的例子就是，你可以从 060 作弊到 090，但是不能太过分太明显，从 069 作弊到 690。不然，大家都知道你作弊了，就会鄙视你、唾弃你、让你抬不起头。「年轻」的陆枫犹自不觉，但「全公司」都深谙潜规则，都这么干了。反过来，小陈又利用「作弊是允许的，<strong>但不能让别人知道</strong>」来威胁陆枫，让陆枫无法再通过 059 领 060，进而去作弊。</p><p>哇！这可谓是入木三分！在潜规则下，对于名声、地位、身份、头衔，你可以偏、偷、抢，可以作弊，可以巧取豪夺；可以作弊，但唯独不能让别人知道。</p><h2 id="高潮低谷"><a href="#高潮低谷" class="headerlink" title="高潮低谷"></a>高潮低谷</h2><p>原文的第六段毫无征兆地突然掀开所有的伏笔，可谓高潮突至，但又突然跌入低谷。</p><p>陆枫拿着 061 号标牌领取了 062 号标牌，也迎接了周围同事们若有若无的嘲笑。是啊，所有人都跳过了 60 -- 90 这个阶段，只有陆枫「傻乎乎」地一块一块往前爬。陆枫心里苦啊——不是宝宝不想跳，而是宝宝的 060 被小陈那个杀千刀的丢了啊！终于，当陆枫拿到 069 的时候，他终于忍不住了。陆枫用颠倒的「069」领取了「691」号标牌。毫不意外地，更加猛烈的嘲笑向陆枫扑面而至。甚至，这种嘲笑已经脱离了若有若无的范畴。比如有同事哈哈笑着来到陆枫面前，拍着他的肩膀对大家说：「大家快别闲聊了，<strong>大领导</strong>来视察了啊！」</p><p>自己的 691 已经被大家看到，想要再用 069 去换 070 已经不现实——那无疑告诉大家「<strong>我上周作弊了</strong>」。于是陆枫只能硬着头皮，继续兑换 692，693。但终于，所谓积毁销骨，在舆论的压力下，陆枫终于无法忍受，辞职走了。</p><p>读完这一段后，心里空落落的，似乎意犹未尽。</p><p>是啊，跳跃几百号的作弊被大家嘲笑，这显而易见——第五段刚说了嘛。是啊，无法退回也显而易见——不能明摆着告诉大家作弊了嘛！似乎高潮到来，但又索然无味。</p><h2 id="真正高潮"><a href="#真正高潮" class="headerlink" title="真正高潮"></a>真正高潮</h2><p>原文的第七段才是真正的高潮。</p><p>陆枫离职后半年左右，偶遇小陈。两人一起吃饭，陆枫得知小陈已经有 332 号的标牌，大吃一惊，以为小陈花钱去买标牌了。小陈无不得意地解释说，那样太低端了。然后将「高端」的作弊方式娓娓道来：</p><ul><li>当我有 115 号的时候，我找到有 147 号标牌的人</li><li>他将 144 号标牌给我，我将 106 -- 115 的标牌给他</li><li>我获得了更大号码的标牌，他填补了作弊过程中留下的「空虚」，互惠互利</li></ul><p>陆枫目瞪口呆。小陈继续介绍更高端的作弊方法：</p><ul><li>一群人形成链条</li><li>下一级为上一级填补空虚，上一级给更大号的标牌给下一级</li><li>最下一级将 069 翻转成 690 交给最上一级</li><li>所有人都得利</li></ul><p>陆枫目瞪口呆 * 2。小陈继续说：「塑料片能当钱做奖励吗？（当年领导）拿出 10 块白给你，意思就是要你下次拿出更多还给他，这是拉你进入交易圈的暗示啊！人家这么明显的信号放给你，你不接茬，你啊，真不适合这个游戏。」</p><p>陆枫目瞪口呆 * 3，不解地问小陈，为什么这么个不值钱的东西，出了公司就没用的东西，引得大家斗来斗去乐此不疲呢？小陈嘲讽道：「你问这个问题就还是幼稚。像我们这样的公司，家家都有这样的标牌。你戴上了，就摘不掉，它什么都不代表，却又代表了一切。只不过我们公司的标牌戴在脖子上，别的公司的标牌戴在人心里。戴在心里的标牌，更难猜，也更难摘。」</p><p>陆枫哇的一口吐了一地，就此昏了过去。</p><p>看完这段，我是无言又佩服，作者是真的高手。</p><p>时至今日，两种「高端作弊」方式揭示的意义已是昭然若揭，但在作者说明之前却又如在窗户纸背后，常人不得要领。所有人在追逐虚无的时候，都会作弊。作弊就会留下空洞，就会需要后人来填补。在这个基础上，领先者和落后者就有了合作的基础。反过来，因为领先者有空洞，所以他们有动力拉新人进入这个圈子，与他们「同流合污」。而当新人无法领会弦外之音的时候，或者体会不到这个「游戏」的真意的时候，就会被放弃，就会再一次被排挤，最后离开这个体系。</p><p>让文章上升到新的高度的是「它什么都不代表，却又代表了一切」这一句。虚无的东西终归是虚无，当要拿出实际业绩的时候，它什么都不代表。但是，哪有那么多时间要拿出真的业绩呢？在这些「大多数」的时候，这些虚无的东西，就又代表了一切，主宰了利益的分配。而在现实中，「标牌」不是戴在脖子上，而是戴在「人心里」。</p><h2 id="回味不绝"><a href="#回味不绝" class="headerlink" title="回味不绝"></a>回味不绝</h2><p>原文的故事到这里就结束了，但是留下的回味却绕梁不绝。</p><p>作者的故事虽然没有回答原问题（大公司效率低最根本的原因是什么？应该如何应对？），但从一个角度解释了大公司内某种内耗的内在机制。人们在不追求实际业绩时，转而追求虚无缥缈的身份地位头衔时，隐形的利益交换消耗了本可以发展实际业务的时间、精力、金钱等各个成本。在这个意义上，这种内耗降低了公司的整体效率。</p><p>让我们一起，咂摸咂摸嘴，继续回味这个故事。</p><blockquote><p>收到「标牌小说原作者的『开心打赏』10 元」。<code>٩( &#39;ω&#39; )و get！</code><br>开心 * 10086~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在知乎上读到一篇&lt;a href=&quot;https://www.zhihu.com/question/26111395/answer/138128420&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;魔幻现实主义的文章&lt;/a&gt;。&lt;a href=&quot;https://www.zhihu.com/people/sun-bin-12-58&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作者&lt;/a&gt;用一个实体的「塑料标牌」隐喻了在大公司中无形的身份、头衔和自我满足感，然后通过这一实体的塑料标牌，讲述了职场的，特别是大公司中的一些现象。&lt;/p&gt;
&lt;p&gt;总体上来说，文章特别有意思，显得回味无穷。因此作此篇读后感。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Efficiency" scheme="https://liam.page/tags/Efficiency/"/>
    
      <category term="Magical Realist" scheme="https://liam.page/tags/Magical-Realist/"/>
    
  </entry>
  
  <entry>
    <title>将 HDFS 上的目录作为 Hive 外表分区同时避免数据拷贝</title>
    <link href="https://liam.page/2019/11/05/connect-HDFS-data-into-Hive-external-table-without-redundant-movement/"/>
    <id>https://liam.page/2019/11/05/connect-HDFS-data-into-Hive-external-table-without-redundant-movement/</id>
    <published>2019-11-04T23:38:07.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hive 是个好东西，它能够把 SQL 查询自动转化为一系列 Map-Reduce 任务。但显然，如何将数据引入 Hive 也会是个问题。一个典型的场景是：你通过某种方式，生成了大量结构化的数据，保存在 HDFS 上。现在你希望 Hive 能够基于这些数据，建立数据库，从而能够使用 SQL 语句进行数据库操作。但与此同时，因为数据量十分庞大，你不希望产生数据拷贝、搬移，以免消耗无谓的存储资源和计算资源。</p><p>此篇介绍我近期的一个实践方案。</p><a id="more"></a><h2 id="数据产出"><a href="#数据产出" class="headerlink" title="数据产出"></a>数据产出</h2><p>首先，你需要将数据以特定的格式产出到 HDFS 上。</p><p>例如，这里我以 Spark Streaming 任务将制表符分隔的 4 列数据，以 GZip 的格式，输出到 HDFS 位置：<code>hdfs://namenode/path/to/data/&lt;date&gt;/&lt;hour&gt;/&lt;dstreamid&gt;</code>。其中 <code>&lt;date&gt;</code> 是数据产出的日期，<code>&lt;hour&gt;</code> 是数据产出的小时，<code>&lt;dstreamid&gt;</code> 是数据产出时，对应 Spark Streaming 的 Direct Stream 的 ID。于是有类似这样的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/_SUCCESS</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00000.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00001.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00002.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00003.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00004.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00005.gz</span><br></pre></td></tr></table></figure><h2 id="建立-Hive-表"><a href="#建立-Hive-表" class="headerlink" title="建立 Hive 表"></a>建立 Hive 表</h2><p>有了数据之后，我们需要建立与数据格式相对应的 Hive 表。注意，由于我们不希望对数据进行额外的搬移操作，所以这里需要建立一张外表（EXTERNAL TABLE）。例如，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> (</span><br><span class="line">  <span class="string">`field_1`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_2`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_3`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_4`</span> <span class="keyword">string</span>)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  <span class="string">`date`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`hour`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`dstreamid`</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE</span><br><span class="line">  <span class="string">'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (</span><br><span class="line">  <span class="string">'field.delim'</span>=<span class="string">'\t'</span>,</span><br><span class="line">  <span class="string">'serialization.format'</span>=<span class="string">'\t'</span>)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">'org.apache.hadoop.mapred.TextInputFormat'</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">'hdfs://namenode/path/to/data/'</span>;</span><br></pre></td></tr></table></figure><p>这里，</p><ul><li>数据共有 4 个域，名字分别是 <code>field_1</code> 至 <code>field_4</code>（你可以根据实际情况设置恰当的域名字）。</li><li>分区字段有三个，分别是 <code>date</code>/<code>hour</code>/<code>dstreamid</code>，与数据保存时的子路径名保持一致。</li><li>域分隔符是 <code>\t</code>，即制表符。</li><li>输入格式是 <code>org.apache.hadoop.mapred.TextInputFormat</code>，即文本输入。</li><li>数据位于 <code>hdfs://namenode/path/to/data/</code>，这是我们所有数据的完整路径。</li><li>表名字是 <code>table_name</code>，你可以根据实际情况设置恰当的表名字。</li></ul><h2 id="将数据接入-Hive-表"><a href="#将数据接入-Hive-表" class="headerlink" title="将数据接入 Hive 表"></a>将数据接入 Hive 表</h2><p>有了数据并创建好 Hive 表之后，我们就可以将数据接入 Hive 表了。这里，我们需要用到 <code>ALTER TABLE</code> 语句。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">  table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">PARTITION</span></span><br><span class="line">  (dt=<span class="string">'2019-11-01'</span>, <span class="keyword">hour</span>=<span class="string">'13'</span>, dstreamid=<span class="string">'123456'</span>)</span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">'hdfs://namenode/path/to/data/2019-11-01/13/123456'</span>;</span><br></pre></td></tr></table></figure><p>这个语句表示：</p><ul><li>更改名为 <code>table_name</code> 的表；</li><li>具体的动作是 <code>ADD IF NOT EXISTS PARTITION</code>，即当表中不存在相应分区时，添加该分区；</li><li>添加的数据来自的路径是 <code>hdfs://namenode/path/to/data/2019-11-01/13/123456</code>。</li></ul><p>执行成功之后，即可在不进行数据搬移的前提下，将 HDFS 上目录中的数据作为 Hive 外表的分区了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive 是个好东西，它能够把 SQL 查询自动转化为一系列 Map-Reduce 任务。但显然，如何将数据引入 Hive 也会是个问题。一个典型的场景是：你通过某种方式，生成了大量结构化的数据，保存在 HDFS 上。现在你希望 Hive 能够基于这些数据，建立数据库，从而能够使用 SQL 语句进行数据库操作。但与此同时，因为数据量十分庞大，你不希望产生数据拷贝、搬移，以免消耗无谓的存储资源和计算资源。&lt;/p&gt;
&lt;p&gt;此篇介绍我近期的一个实践方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="HDFS" scheme="https://liam.page/tags/HDFS/"/>
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上对单个文件取消「来自互联网的应用」之限制</title>
    <link href="https://liam.page/2019/10/29/How-to-fix-This-is-an-application-downloaded-from-the-Internet/"/>
    <id>https://liam.page/2019/10/29/How-to-fix-This-is-an-application-downloaded-from-the-Internet/</id>
    <published>2019-10-29T09:35:07.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 上有对未正确签名的应用程序进行<a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">隔离</a>的设定。具体来说，如果用户下载了一个来自互联网的应用，但该应用没有使用 Apple 认可的签名，则 Apple 会在用户尝试执行应用程序时提示「应用程序来自互联网」，要求用户确认后才能执行。</p><p>中文网络上对这种情况的解决办法，一般都是进入系统偏好设置，在安全性设置中允许来自任意位置的应用。这其实是取消了 macOS 的隔离功能，无疑会降低系统安全性。特别地，对于某些特定的程序，我们确切知道它是无害的，于是我们希望 macOS 对它打开绿灯，但对其它来自互联网的应用程序仍保持必要的隔离措施。这时，整个儿取消 macOS 的隔离功能就不合适了。</p><a id="more"></a><p>为解决这一问题，我们需要使用命令行工具 <code>xattr</code>。这是一个 macOS 下用来展示和修改文件（包括目录、符号链接）扩展属性的功能。「是否隔离」正是 macOS 的一项文件扩展属性。其用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Syntax</span><br><span class="line">   List attributes</span><br><span class="line">      xattr [-lrsvx] file ...</span><br><span class="line"></span><br><span class="line">   Print the value associated with the given attribute:</span><br><span class="line">      xattr -p [-lrsvx] attr_name file ...</span><br><span class="line"></span><br><span class="line">   Write a given attribute name with a value:</span><br><span class="line">      xattr -w [-rsx] attr_name attr_value file ...</span><br><span class="line"></span><br><span class="line">   Delete the given attribute from file:</span><br><span class="line">      xattr -d [-rsv] attr_name file ...</span><br><span class="line"></span><br><span class="line">   Clear all attributes including their associated values:</span><br><span class="line">      xattr -c [-rsv] file ...</span><br><span class="line"></span><br><span class="line">   Display help:</span><br><span class="line">      xattr -h | --help</span><br><span class="line"></span><br><span class="line">Key</span><br><span class="line">   -c  CLear all Atrributes.</span><br><span class="line"></span><br><span class="line">   -d  Delete the given attribute.</span><br><span class="line"></span><br><span class="line">   -h  Help.</span><br><span class="line"></span><br><span class="line">   -l  By default, the first two command forms either display just the attribute names or</span><br><span class="line">       values, respectively. The -l option causes both the attribute names and corresponding</span><br><span class="line">       values to be displayed. For hex display of values, the output is preceeded with the hex</span><br><span class="line">       offset values and followed by ASCII display, enclosed by &apos;|&apos;.</span><br><span class="line"></span><br><span class="line">   -p  Print the value associated with the given attribute.</span><br><span class="line"></span><br><span class="line">   -r  If a file argument is a directory, act as if the entire contents of the directory</span><br><span class="line">       recursively were also specified (so that every file in the directory tree is acted upon).</span><br><span class="line"></span><br><span class="line">   -s  If a file argument is a symbolic link, act on the symbolic link itself, rather than</span><br><span class="line">       the file that the symbolic link points at.</span><br><span class="line"></span><br><span class="line">   -v  Force the the file name to be displayed, even for a single file.</span><br><span class="line"></span><br><span class="line">   -w  Write a given attribute name with a value.</span><br><span class="line"></span><br><span class="line">   -x  Force the attribute value to be displayed in the hexadecimal representation.</span><br></pre></td></tr></table></figure><p>这里，我们需要在终端里，执行 <code>xattr -d com.apple.quarantine /path/to/quarantined/file</code> 来移除加在 <code>/path/to/quarantined/file</code> 上的隔离属性。而后在执行相应应用程序，就不会被 macOS 的隔离机制限制了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;macOS 上有对未正确签名的应用程序进行&lt;a href=&quot;https://support.apple.com/zh-cn/HT202491&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;隔离&lt;/a&gt;的设定。具体来说，如果用户下载了一个来自互联网的应用，但该应用没有使用 Apple 认可的签名，则 Apple 会在用户尝试执行应用程序时提示「应用程序来自互联网」，要求用户确认后才能执行。&lt;/p&gt;
&lt;p&gt;中文网络上对这种情况的解决办法，一般都是进入系统偏好设置，在安全性设置中允许来自任意位置的应用。这其实是取消了 macOS 的隔离功能，无疑会降低系统安全性。特别地，对于某些特定的程序，我们确切知道它是无害的，于是我们希望 macOS 对它打开绿灯，但对其它来自互联网的应用程序仍保持必要的隔离措施。这时，整个儿取消 macOS 的隔离功能就不合适了。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="xattr" scheme="https://liam.page/tags/xattr/"/>
    
      <category term="quarantine" scheme="https://liam.page/tags/quarantine/"/>
    
  </entry>
  
  <entry>
    <title>Scala 中下划线的一些魔法</title>
    <link href="https://liam.page/2019/10/24/underscore-magic-in-Scala/"/>
    <id>https://liam.page/2019/10/24/underscore-magic-in-Scala/</id>
    <published>2019-10-24T02:42:27.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间开始学习使用 Scala。和大多数初学者一样，面对 Scala 的各种符号，我也是一脸懵哔。尤其是 Scala 中的下划线 <code>_</code> 在不同场合有不同含义，简直慌。适应一段时间之后，这里总结记录一下我遇见的下划线的含义。</p><a id="more"></a><h2 id="导入模块包"><a href="#导入模块包" class="headerlink" title="导入模块包"></a>导入模块包</h2><p>在 Scala 导入模块包时，<code>_</code> 的作用类似于 Java 导入模块包时的 <code>*</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 matching 包中的所有类</span></span><br><span class="line"><span class="keyword">import</span> scala.util.matching._</span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员（相当于 Java 中的 static import）</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>._</span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员，但将 `Foo` 改名为 `Bar`（相当于 Python 中的 `import Foo from com.test.Fun as Bar`）</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; <span class="type">Bar</span> , _ &#125;</span><br><span class="line"><span class="comment">// imports all the members except Foo. To exclude a member rename it to _</span></span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员，但通过将 `Foo` 改名为 `_` 而忽略。</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; _ , _ &#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><a href="https://docs.scala-lang.org/tour/pattern-matching.html" target="_blank" rel="noopener">Scala 中的模式匹配</a>和 C/C++ 或者 Java 中的 <code>switch</code> - <code>case</code> 语句类似。在 Scala 中的模式匹配中，下划线 <code>_</code> 是匹配任意内容的通配符。最基本的用法时，<code>_</code> 相当于 C/C++ 中的 <code>default</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x: <span class="type">Int</span> = <span class="type">Random</span>.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="string">"zero"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"other"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更高阶的用法中，<code>_</code> 可以嵌套使用，这时候就远超出 <code>default</code> case 的作用了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _, _) =&gt; <span class="string">" a list with three element and the first element is 1 "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(_*)  =&gt; <span class="string">" a list with zero or more elements "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>[_, _] =&gt; <span class="string">" matches a map with any key type and any value type "</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">" others "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h2><p>Scala 和 Python、C++ 等语言一样，也有匿名函数的设定。下划线 <code>_</code> 可用作是匿名函数的参数的占位符，但对于每一个参数，只能用下划线占位一次。例如，在 Scala 中 <code>2 * _</code> 相当于 Python 中的 <code>lambda x: 2 * x</code> 或者 C++ 中的 <code>[](auto x) { return 2 * x; }</code>；但对于 Python 中的 <code>lambda x: x * x</code> 不能写成 Scala 中的 <code>_ * _</code>——因为在 Scala 中，<code>_ * _</code> 表示匿名函数接受 2 个参数，函数返回值是两个参数的乘积。又例如，下列 Scala 代码中的 <code>print(_)</code> 相当于 <code>x =&gt; print(x)</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).foreach(print(_))</span><br></pre></td></tr></table></figure><p>下列 Scala 代码中的 <code>_ + _</code> 相当于 <code>(x, y) =&gt; x + y</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduceLeft(_ + _)</span><br></pre></td></tr></table></figure><h2 id="阻止函数意外调用"><a href="#阻止函数意外调用" class="headerlink" title="阻止函数意外调用"></a>阻止函数意外调用</h2><p>众所周知，Scala 是函数式语言。在 Scala 中，函数是一等公民，和普通变量一样可以赋值。但由于在 Scala 中函数调用时可省略括号，如果你打算将一个函数赋值给一个新的变量，则函数可能会被意外地调用而后将函数的返回值赋值。这种时候，我们需要在函数名之后加上 <code>_</code> 来阻止函数调用——类似 TeX 中的 <code>\relax</code> 阻止继续执行的作用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> bar = foo _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区分-getter-和-setter"><a href="#区分-getter-和-setter" class="headerlink" title="区分 getter 和 setter"></a>区分 getter 和 setter</h2><p>在 Scala 中，对象中的非私有成员会自动生成一对 getter 和 setter。对于私有成员，程序员也可以自己实现 getter 和 setter。这时候，我们需要在 setter 后加上下划线 <code>_</code> 来实现类似 C++ 中函数重载的效果。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= a</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age_</span> </span>= (n:<span class="type">Int</span>) = &#123;</span><br><span class="line">    require(n &gt; <span class="number">0</span>)</span><br><span class="line">    a = n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t = <span class="keyword">new</span> <span class="type">Test</span></span><br><span class="line">t.age = <span class="number">5</span></span><br><span class="line">println(t.age)</span><br></pre></td></tr></table></figure><p>相当于 C++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">age</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a_)</span> </span>&#123;</span><br><span class="line">    a = a_;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line">t.age(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.age() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间开始学习使用 Scala。和大多数初学者一样，面对 Scala 的各种符号，我也是一脸懵哔。尤其是 Scala 中的下划线 &lt;code&gt;_&lt;/code&gt; 在不同场合有不同含义，简直慌。适应一段时间之后，这里总结记录一下我遇见的下划线的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Scala" scheme="https://liam.page/tags/Scala/"/>
    
      <category term="Underscore" scheme="https://liam.page/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>解决公司 Win7 更新时的 0x80092004 错误</title>
    <link href="https://liam.page/2019/10/18/0x80092004-error-on-Windows-7/"/>
    <id>https://liam.page/2019/10/18/0x80092004-error-on-Windows-7/</id>
    <published>2019-10-18T07:57:06.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>从大概 8 月份开始，公司配发的电脑（Windows 7 系统）就总是提示有更新，但每次更新都安装失败。不断提示更新很打扰工作思路，于是下决心解决。</p><a id="more"></a><p>经检查，问题出在 KB4512506/KB4516065（Windows 7 月安全质量汇总更新）上，尝试安装该更新时，系统会提示 <code>0x80092004</code> 错误。上网检查后确认，该错误代码与 <code>CRYPT_E_NOT_FOUND</code> 有关。也就是说，Windows Update 发现更新文件的散列值不匹配，于是拒绝安装。</p><p><img alt="`0x80092004` 错误" data-src="/uploads/images/computer-skills/kb4516065.png"></p><p>进一步检查发现，微软在给 Windows 7 和 Windows Server 2008 R2 的更新中修改了散列值签名方式，而 19 年 8 月发布的 7 月安全质量汇总更新，正是新签名方式第一次生效的时候。具体来说，原先会使用 SHA-1 和 SHA-2 同时签名；但因为众所周知的安全问题，微软放弃了 SHA-1 签名转而仅使用 SHA-2 签名。但如果 Windows 7 上的 Windows Update 依旧检查 SHA-1 签名，则会发现更新文件的散列值不匹配，于是拒绝安装，并报错 <code>0x80092004</code>。</p><p>为解决这一问题，微软先期发布了两个相关更新：</p><ul><li><a href="https://support.microsoft.com/en-us/help/4474419/sha-2-code-signing-support-update" target="_blank" rel="noopener">KB4474419</a>：用于在 Windows 7 等系统上支持 SHA-2 签名。</li><li><a href="https://support.microsoft.com/en-us/help/4490628/servicing-stack-update-for-windows-7-sp1-and-windows-server-2008-r2" target="_blank" rel="noopener">KB4490628</a>：服务堆栈更新，解决了安装仅使用 SHA-2 哈希算法签名的更新时服务堆栈中的问题。</li></ul><p>安装 KB4512506 前，系统必须安装好这两个前置依赖，否则就会因签名问题报错 <code>0x80092004</code>。</p><p>经检查，我的系统里安装了 KB4474419，但是没有安装 KB4490628。那么这就是导致问题的直接原因了。</p><p>那么根本原因在哪里呢？答案是：公司电脑的组策略配置决定了 Windows Update 由公司 IT 管理员来管理。公司 IT 可能没有正确配置安装 KB4490628，于是有后续问题。更加无奈的是，因为组策略配置的限制，我无法在 Windows Update 中搜索安装 KB4490628。幸运的是，我在<a href="http://catalog.update.microsoft.com/v7/site/search.aspx?q=4490628" target="_blank" rel="noopener">微软 Update Catalog</a> 当中找到了 KB4490628 的独立安装包。下载安装 KB4490628 的过程一切顺利。</p><p>安装完 KB4490628 之后，再次打开 Windows Update，尝试安装 KB4516065 则一切顺利。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从大概 8 月份开始，公司配发的电脑（Windows 7 系统）就总是提示有更新，但每次更新都安装失败。不断提示更新很打扰工作思路，于是下决心解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows 7" scheme="https://liam.page/tags/Windows-7/"/>
    
      <category term="Windows Update" scheme="https://liam.page/tags/Windows-Update/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 中抹除磁盘上所有已删除文件的痕迹</title>
    <link href="https://liam.page/2019/09/16/safe-clean-all-data-on-disks-in-Windows/"/>
    <id>https://liam.page/2019/09/16/safe-clean-all-data-on-disks-in-Windows/</id>
    <published>2019-09-16T09:59:24.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在电脑上删除文件时，并不会真的删除数据，而仅仅是在文件系统中将相应文件的索引删除。哪怕是格式化，在「快速格式化」的情况下，也不会删除磁盘上的数据。这种删除/格式化的操作，有歹心的人是有可能恢复数据的。</p><p>因此，在某些情况下——例如归还借用的电脑时——我们会希望能够真正地「粉碎」文件，避免被人恢复敏感数据。</p><p>市面上有不少「粉碎文件」的工具。但：</p><ul><li>为了信息安全这件事情，专门安装第三方工具，这件事情本身就很吊诡；</li><li>如果要粉碎大量文件，同时保证全盘没有遗漏，这些第三方工具往往不可靠。</li></ul><p>这篇介绍用 Windows 自带的工具解决这个问题。</p><a id="more"></a><h2 id="CIPHER"><a href="#CIPHER" class="headerlink" title="CIPHER"></a><code>CIPHER</code></h2><p>Windows 自带有名为 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cipher" target="_blank" rel="noopener"><code>CIPHER</code></a> 的工具。这个工具本身是用来在 NTFS 格式的磁盘上加密磁盘或磁盘上的文件的。不过，我们这里要用到它的 <code>/w</code> 参数。以下是这个参数的作用：</p><blockquote><p>Removes data from available unused disk space on the entire volume. If you use the /w parameter, all other parameters are ignored. The directory specified can be located anywhere in a local volume. If it is a mount point or points to a directory in another volume, the data on that volume is removed.</p></blockquote><p>翻译：<code>cipher /w:&lt;directory&gt;</code> 移除卷上所有未使用的空间并忽略所有其他参数。这里，<code>&lt;directory&gt;</code> 可以是卷上的任意目录。如果该目录是其他卷的挂载点，则 <code>cipher</code> 将会移除被挂载的卷上的数据。</p><p>这个介绍有一点没介绍明白：具体怎样移除卷上的所有空间呢？作为一个用于加密的工具，「移除」的方法当然是很安全的啦。实际上，<code>cipher /w:&lt;directory&gt;</code> 会在磁盘上所有可用空间上，先全部写入 <code>0x00</code>，再全部写入 <code>0xFF</code>，再全部写入随机值。如此一来，磁盘上空闲空间里的内容，就变得难以恢复了。</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>今天写了一个 Windows 批处理脚本，利用 <code>cipher /w</code> 在所有磁盘的空闲空间上抹除数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">for %%i in (A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z) do (</span><br><span class="line">  if exist %%i:\ (</span><br><span class="line">    echo &quot;will start to cipher %%i&quot;</span><br><span class="line">    cipher /w:%%i:\</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在桌面上新建一个文本文件 <code>cipher_disks.txt</code>，将这些内容粘贴上去，而后修改后缀名为 <code>.bat</code>，即改名为 <code>cipher_disks.bat</code>。如此一来，只需双击该批处理脚本，即可抹除所有磁盘上的空闲空间中的数据了。</p><p>于是，在归还电脑时，只需先将个人数据/敏感文件全部删除，然后执行该批处理脚本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在电脑上删除文件时，并不会真的删除数据，而仅仅是在文件系统中将相应文件的索引删除。哪怕是格式化，在「快速格式化」的情况下，也不会删除磁盘上的数据。这种删除/格式化的操作，有歹心的人是有可能恢复数据的。&lt;/p&gt;
&lt;p&gt;因此，在某些情况下——例如归还借用的电脑时——我们会希望能够真正地「粉碎」文件，避免被人恢复敏感数据。&lt;/p&gt;
&lt;p&gt;市面上有不少「粉碎文件」的工具。但：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了信息安全这件事情，专门安装第三方工具，这件事情本身就很吊诡；&lt;/li&gt;
&lt;li&gt;如果要粉碎大量文件，同时保证全盘没有遗漏，这些第三方工具往往不可靠。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇介绍用 Windows 自带的工具解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows" scheme="https://liam.page/tags/Windows/"/>
    
      <category term="Disks" scheme="https://liam.page/tags/Disks/"/>
    
      <category term="Cipher" scheme="https://liam.page/tags/Cipher/"/>
    
  </entry>
  
  <entry>
    <title>FTRL 不太简短之介绍</title>
    <link href="https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/"/>
    <id>https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/</id>
    <published>2019-08-31T12:01:23.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 <code>$L_1$</code> 正则化的<a href="/2018/10/10/logistic-regression/">逻辑回归</a>类模型时，效果非常出色：能够得到性能较好的稀疏解。</p><p>中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我看来，已有的关于 FTRL 的介绍，都或多或少有些值得调整和改进的地方。这促成了这篇文章。</p><p>这篇文章讲 FTRL 的理论部分，大致会按照这样的路径来阐述：</p><ul><li>我们想要解决什么问题？</li><li>FTRL 的前辈们是怎么尝试解决问题的？</li><li>前辈们之间是什么关系？又留下了哪些尚未解决的问题？FTRL 是如何解决这些遗留问题的？</li></ul><p>而后，在下一篇工程部分的文章中，我们会讨论一下 FTRL 的工程实现有哪些值得谈一谈的问题。</p><a id="more"></a><h2 id="我们面临的问题"><a href="#我们面临的问题" class="headerlink" title="我们面临的问题"></a>我们面临的问题</h2><p>传统的运用机器学习解决实际问题的步骤如下：</p><ul><li>数据融合，获取数据样本的标签。</li><li>特征工程及其 ETL，获取每个样本的特征。</li><li>样本处理，处理正负样本比例、无效或作弊样本等问题，输出用于训练、验证、测试的样本集。</li><li>构建模型，根据业务特点和数据特点，选取恰当的模型；比如 LR、FM、GBDT、DNN 等。</li><li>训练模型，在训练集上训练模型，在验证集上调参。</li><li>模型评估，在测试机上评估模型。</li><li>在线预测，将有效模型上线，进行在线预测。</li></ul><p>这样的流程能够解决很多问题，但存在至少两方面的瓶颈：</p><ol><li>整套流程在样本维度是「批量」的，在特征高维数据大量的情况下，这导致模型更新周期较长。在工程能力强的团队手上，模型的更新周期最好能做到小时级别；在工程能力差的团队手上，这个周期可能是天级甚至是周级别的。</li><li>模型的复杂度和线上预测性能之间难以权衡：模型复杂度低，线上预测效果差；模型复杂度高，线上预测效果好，但需要的存储、时间资源也随之升高，无法保证 RT 和 QPS。</li></ol><p>为了解决这里的问题 (1)，在线学习（Online Learning）逐渐兴起；为了解决问题 (2)，人们从各种正则、剪枝开始，尝试用各种手段，在保证模型精度的前提下，尽可能获得稀疏的模型。</p><h3 id="在线学习的兴起"><a href="#在线学习的兴起" class="headerlink" title="在线学习的兴起"></a>在线学习的兴起</h3><p>我曾经在多个场合谈到，机器学习模型的三要素是：</p><ul><li>模型结构；</li><li>优化目标；</li><li>求解方法。</li></ul><p>在这里，模型结构通常会需要根据实际问题的特点进行调整。例如，对于具有稠密特征样本的分类问题，GBDT 类的树模型往往效果良好。又例如，对于具有高维稀疏特征的大规模样本，<a href="/2018/10/10/logistic-regression/">逻辑回归</a>和<a href="https://liam.page/2019/03/25/Factorization-Machine/">因子分解机</a>（及其<a href="https://liam.page/2019/06/28/variants-of-FM/">变体</a>）就会是不错的选择。</p><p>优化目标往往会以目标函数这一数学形式来表达。目标函数中的损失函数，则是用来描述「模型对经验数据拟合程度好坏」的方法。目标函数（或损失函数）的选择，通常也是和实际问题的特点相关的。例如对于回归问题和分类问题，通常就会选择不同的损失函数。</p><blockquote><p>对于样本集合 <code>$\mathcal{D}$</code> 中编号为 <code>$i$</code> 的样本 <code>$\{\vec x_i, y_i\}$</code> 来说，在确定好模型结构 <code>$h(\cdot; \vec\omega)$</code> 的基础上，损失函数记为<br><code>$$\ell\bigl(h(\vec x_i; \vec\omega), y_i\bigr).$$</code></p></blockquote><p>求解方法则是解决如何在有限的时间内，求得一个既简单（模型复杂度低，不易过拟合）性能又好（对经验数据拟合程度较高）的模型。在模型结构确定的基础上，机器学习模型的学习，往往会化归为带参数目标函数的最优化求解问题。如何解决这些最优化问题，或者说，采用何种求解方法，往往要根据问题特点、模型结构、目标函数等等各种因素的不同，综合考虑。</p><h4 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h4><p>在机器学习兴起的早期，由于数据规模较小，计算性能较低与求解复杂度较高的矛盾尚不明显，人们很自然地选择与直觉相符合的批量求解方式来优化模型。具体来说，人们通常会随机给定模型参数 <code>$\vec\omega$</code> 的初值 <code>$\vec\omega_0$</code>，通过迭代，不断更新来调整 <code>$\vec\omega$</code> 的取值，使得目标函数在样本集合 <code>$\mathcal{D}$</code> 上的加和取得或接近最小值：</p><p><code>$$\begin{aligned}  L(\vec\omega\mid \mathcal{D}) &amp;{} = \sum_{\{\vec x_i, y_i\} \in \mathcal{D}}\ell\bigl(h(\vec x_i; \vec\omega), y_i\bigr) \\  \vec\omega^{*} &amp;{} = \mathop{\arg\,\min}_{\vec\omega} L(\vec\omega\mid \mathcal{D})\end{aligned}$$</code></p><p>对于这种解法，典型的方式是梯度下降（Gradient Descend）和牛顿法、拟牛顿法等。以梯度下降法为例，其 <code>$t$</code> 轮迭代的更新如下所示：</p><p><code>$$\vec\omega^{(t + 1)} \gets \vec\omega^{(t)} - \eta^{(t)}\cdot\nabla_{\vec\omega^{(t)}}L(\vec\omega^{(t)}\mid \mathcal{D}).$$</code></p><p>在这种做法当中，每一次迭代，都需要扫描整个样本集合 <code>$\mathcal{D}$</code> 以计算全局损失 <code>$L$</code>，而后才能更新参数 <code>$\vec\omega$</code>。对于数据规模较小的情况，这样做的好处是能够准确计算每一次迭代时的梯度，避免「跑偏」。但对于随着数据规模的增大，每一次计算全局梯度的代价变得过高，完成训练的时间就会变得很长。为了解决这个问题，人们引入了随机（小批量）的解法。</p><h4 id="随机小批量"><a href="#随机小批量" class="headerlink" title="随机小批量"></a>随机小批量</h4><p>我在<a href="/2019/06/18/OCD-needs-stochastic-gradient-descent/">强迫症患者也需要随机梯度下降</a>一文中介绍了随机（小批量）梯度下降（Stochastic Gradient Descend）的方法和它的好处。按照本文的记号约定，随机梯度下降第 <code>$t$</code> 轮迭代的更新如下所示：</p><p><code>$$\vec\omega^{(t + 1)} \gets \vec\omega^{(t)} - \eta^{(t)}\cdot\nabla_{\vec\omega^{(t)}}L(\vec\omega^{(t)}\mid \mathcal{D}^{(t)}).$$</code></p><p>这里描述的是随机小批量梯度下降。其中 <code>$\mathcal{D}^{(t)}$</code> 是当前轮次的迭代从全部样本集 <code>$\mathcal{D}$</code> 中随机选取的子集。当子集 <code>$\mathcal{D}^{(t)}$</code> 当中只有 1 个元素时，算法退化为纯粹的随机梯度下降。</p><p>在这种做法当中，每一次迭代，无需扫描整个样本集合 <code>$\mathcal{D}$</code> 以计算全局损失 <code>$L$</code>。取而代之的是，计算一个随机选取的小集合 <code>$\mathcal{D}^{(t)}$</code> 中的局部损失，即可更新参数 <code>$\vec\omega$</code>。对于数据规模较大的情况，这样的做法节省了每次迭代的计算量，虽然代价是需要迭代更多轮次，但是总体来说极大地降低了整体的训练时间；与此同时，如<a href="/2019/06/18/OCD-needs-stochastic-gradient-descent/">强迫症患者也需要随机梯度下降</a>一文中介绍的那样，随机梯度下降还能带来其它一些好处。</p><h4 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h4><p>随机（小批量）的优化方法解决了一部分问题，但做到极限，模型的更新周期也只能缩短到小时级。因此，在线学习逐渐走上了舞台。</p><p>和前辈们相比，在线学习最大的特点（或者说需求）有两个：</p><ul><li>每次只处理少数几个样本，甚至每次只处理一个样本；</li><li>处理过的样本对于优化过程来说会被「丢弃」，再也看不到了，因此在线学习需要一种「不吃后悔药」的优化方法。</li></ul><p>回过头来看随机（小批量）梯度下降，我们发现它恰好能满足在线学习的这两方面需求。对于第一个需求来说，这是显然的。对于第二个需求来说，在线接收的样本某种意义上就可以理解为是一种随机，只要这些随机送到优化器的样本的梯度在统计期望上与总体样本是一致的（而这是在线学习的基本假设），那就适用随机（小批量）梯度下降。</p><p>事情看起来很美妙，只需要把随机（小批量）梯度下降整合进在线学习的工程框架当中就可以了。但是事情没有那么美妙，因为这依然无法解决我们面临的第二个问题——对模型稀疏性的追求。</p><h3 id="对模型稀疏性的追求"><a href="#对模型稀疏性的追求" class="headerlink" title="对模型稀疏性的追求"></a>对模型稀疏性的追求</h3><h4 id="模型稀疏的好处"><a href="#模型稀疏的好处" class="headerlink" title="模型稀疏的好处"></a>模型稀疏的好处</h4><p>模型稀疏的好处有几个方面。</p><p>一是能解决之前提到的「模型复杂度低，线上预测效果差；模型复杂度高，线上预测效果好，但需要的存储、时间资源也随之升高，无法保证 RT 和 QPS」之问题。这是比较显然的。稀疏的模型会大大减少预测时的内存和复杂度。以 LR 为例，若已知输入向量的维度是 <code>$d$</code> 而 LR 中不为 0 的参数的数量是 <code>$w$</code>，若 <code>$d \gg w$</code>，那么绝大多数特征甚至不需要去采集。这样一来，从特征采集到预测运算整个步骤都能省下很多内存和计算复杂度。</p><p>二是模型的稀疏与 <code>$L_1$</code> 正则化不谋而合（见<a href="/2017/03/30/L1-and-L2-regularizer/">谈谈 L1 与 L2-正则项</a>一文），这意味着运用 <code>$L_1$</code> 正则化一方面可以使得模型变得稀疏，另一方面还能够降低模型过拟合的风险。</p><p>三是稀疏性较好的模型，相对来说可解释性更好。这对于我们来说，特别是在实际应用当中，是很有好处的。以那个经典的例子来解释，假设你现在需要训练一个模型，解释人的某些特征和罹患某种疾病之间的关系。如果模型稀疏，那么意味着，罹患某种疾病只与少数一些特征有关。这种模型，对于医生来说，是很友好的。因为当医生拿到一个人的指标数据（特征），他就能根据模型，很容易地告诉来访的就医者说：「你的 XX 指标比较高，而 YY 指标比较低，这是罹患 ZZ 疾病的高危因素。因此你需要在日常生活中注意某些方面，同时定期进行身体检查。」</p><h4 id="在批量梯度下降中，追求模型稀疏性"><a href="#在批量梯度下降中，追求模型稀疏性" class="headerlink" title="在批量梯度下降中，追求模型稀疏性"></a>在批量梯度下降中，追求模型稀疏性</h4><p>我们从最基本的批量梯度下降开始，逐步探寻如何解得一个稀疏的模型。</p><p>如<a href="/2017/03/30/L1-and-L2-regularizer/">谈谈 L1 与 L2-正则项</a>一文所说的那样，我们只需将 <code>$L_1$</code> 范数引入模型求解过程中的目标函数，即可获得相对稀疏的模型。注意，由于我们的终极目标是「稀疏」，这意味着要有尽可能多的权重项为 0。这样看起来，使用 <code>$L_0$</code> 范数可能更好（向量 <code>$\vec x$</code> 的 <code>$L_0$</code> 范数 <code>$\lVert \vec x\rVert_0$</code> 是向量 <code>$\vec x$</code> 各维度中不为 0 的维度的数量）。但由于 <code>$L_0$</code> 范数是非凸的，在求解优化上比较困难，故而采用 <code>$L_0$</code> 范数的最紧凸放松，即 <code>$L_1$</code> 范数作为替代。</p><p>这样一来，模型优化时需要最小化的目标函数变更为如下形式：</p><p><code>$$\text{Obj}(\vec\omega\mid \mathcal{D}) = L(\vec\omega\mid \mathcal{D}) + \lambda_1\frac{\lVert \vec\omega\rVert_1}{n}, \quad\lambda_1 &gt; 0.$$</code></p><p>这里，等式右边的第一项表示模型在训练集 <code>$\mathcal{D}$</code> 上经验损失，第二项则表示模型的 <code>$L_1$</code> 正则项。其中 <code>$\lVert \vec\omega\rVert_1$</code> 表示向量 <code>$\vec\omega$</code> 的 <code>$L_1$</code> 范数，<code>$n$</code> 表示向量 <code>$\vec\omega$</code> 的维度。</p><p>那么为什么加入 <code>$L_1$</code> 正则项，有助于产出稀疏解呢？</p><p>我们假设对于某个 <code>$i \in \{1, 2, \ldots, n\}$</code> 来说，<code>$\omega_i = 0$</code>。然后，在接下来的迭代中，<code>$\omega_i$</code> 被更新为 <code>$\omega_i \gets 0 - \eta\frac{\partial \text{Obj}}{\partial \omega_i}$</code> 而其它参数保持不变。这意味着，对于 <code>$L_1$</code> 正则项来说，在这一轮迭代中增加了 <code>$\Delta\Omega = \eta\frac{\lambda_1}{n}\Bigl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\Bigr\rvert$</code>；对于损失函数来说，在这一轮迭代中大约下降了 <code>$\Delta L = \eta\Bigl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\Bigr\rvert\Bigl\lvert \frac{\partial L}{\partial \omega_i}\Bigr\rvert$</code>。而如果 <code>$\Delta L &lt; \Delta\Omega$</code>，即 <code>$\Bigl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\Bigr\rvert &lt; \frac{\lambda_1}{n}$</code>，那么目标函数整体是变大了（而不是变小了）。因此，对于这种情况，优化器会拒绝更新 <code>$\omega_i$</code>，也就是拒绝将 <code>$\omega_i$</code> 更新为非 0 值。由此就得到了相对稀疏的模型。</p><h4 id="L-1-正则在-SGD-中"><a href="#L-1-正则在-SGD-中" class="headerlink" title="$L_1$ 正则在 SGD 中"></a><code>$L_1$</code> 正则在 SGD 中</h4><p>注意，在批量梯度下降中，<code>$L_1$</code> 正则项能有效的原因在于下式的成立：</p><p><code>$$\biggl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\biggr\rvert &lt; \frac{\lambda_1}{n}.$$</code></p><p>但是，SGD 的假设（随机梯度的期望等于全局梯度）并不能保证在全局梯度满足上式的情况下，随机梯度总能使上式成立。这意味着，在 SGD 的场景中，使用 <code>$L_1$</code> 正则化有助于提升模型的稀疏性，但并不能很好地保证有在批量梯度下降中的那种稀疏化效果。</p><p>那么问题就来了：按之前的说法，在线学习中，我们必然要依赖类似 SGD 的算法；但 <code>$L_1$</code> 正则化并不能在 SGD 中确保模型是足够稀疏的。于是，<strong>我们迫切需要找到一种能够满足在线学习的需要，同时又能保证模型稀疏性的优化方法</strong>。</p><h2 id="FTRL-的前辈们"><a href="#FTRL-的前辈们" class="headerlink" title="FTRL 的前辈们"></a>FTRL 的前辈们</h2><p>前面提到，加入 <code>$L_1$</code> 正则项，是获得稀疏模型的主要手段；但由于 SGD 的原因，<code>$L_1$</code> 正则项又很难发挥作用。因此，我们需要新的手段——或者在 <code>$L_1$</code> 正则化的基础上改进，或者有全新的手段——来解决模型稀疏化的问题。完全创新总是比较困难的。事实上，目前也没有发现完全独立于 <code>$L_1$</code> 范数同时又十分有效的稀疏化方法。因此，人们的目光还是更多地会聚焦在，如何基于 <code>$L_1$</code> 正则项进行改进之上。</p><p>一个粗暴有简单的想法是：基于 <code>$L_1$</code> 正则项，对模型参数进行截断。具体是这样做的，以 <code>$k$</code> 轮迭代为一组：</p><ul><li>按带 <code>$L_1$</code> 正则项的 SGD 的方法训练 <code>$k - 1$</code> 轮</li><li>在第 <code>$k$</code> 轮迭代中，先按通常的 SGD 进行更新，得到 <code>$\vec\omega^{(k&#39;)}$</code>，然后对所有参数进行考察，以超参数 <code>$\theta$</code> 进行截断置零：</li></ul><p><code>$$\omega_i^{(k)} \gets \begin{cases}0 &amp; \text{if $\Bigl\lvert\omega_{i}^{(k&#39;)}\Bigr\rvert &lt; \theta$,} \\\omega_{i}^{(k&#39;)} &amp; \text{otherwise.}\end{cases}$$</code></p><p>显然，这种做法太过粗暴，存在很多问题；但它是所有类似方法的祖师爷，反映的是「不等式约束下的凸优化」的思路。在这种思路下，求到的梯度 <code>$g^{(t)} = \frac{\partial \text{Obj}}{\partial \omega_i}$</code> 被视作是次梯度（subgradient）。根据次梯度更新的结果，可能落在不等式约束的范围之外。此时，就要取该梯度在不等式约束范围内的投影作为真正的迭代结果。</p><p>简单截断法采取的投影方式，是直接截断。接下来，我们看看 FTRL 的其他前辈们是怎么做的。</p><h3 id="Truncated-Gradient"><a href="#Truncated-Gradient" class="headerlink" title="Truncated Gradient"></a>Truncated Gradient</h3><p>既然简单地截断过于粗暴，那么我们就让截断温和一点。这就是 09 年提出的截断梯度法。</p><ul><li>按带 <code>$L_1$</code> 正则项的 SGD 的方法训练 <code>$k - 1$</code> 轮</li><li>在第 <code>$k$</code> 轮迭代中，先按通常的 SGD 进行更新，得到 <code>$\vec\omega^{(k&#39;)}$</code>，然后对所有参数进行考察，以超参数 <code>$\theta$</code> 和 <code>$\alpha$</code> 进行截断：</li></ul><p><code>$$\omega_i^{(k)} \gets \begin{cases}0&amp; \text{if $\Bigl\lvert\omega_{i}^{(k&#39;)}\Bigr\rvert \leqslant \alpha$,} \\\omega_{i}^{(k&#39;)} - \alpha\,\text{sgn}\Bigl(\omega_{i}^{(k&#39;)}\Bigr) &amp; \text{if $\alpha &lt; \Bigl\lvert\omega_{i}^{(k&#39;)}\Bigr\rvert \leqslant \theta$,} \\\omega_{i}^{(k&#39;)} &amp; \text{otherwise.}\end{cases}$$</code></p><p>这里 <code>$\alpha$</code> 通常取学习率 <code>$\eta^{(k)}$</code> 的倍数，例如 <code>$\alpha^{(k)} = \eta^{(k)}\lambda$</code>。截断梯度法采用的投影方式，是以分段函数的方式，对参数进行截断。</p><p>显然，<code>$\alpha$</code> 或 <code>$\theta$</code> 越大，模型越容易求得稀疏解。当 <code>$\alpha = \theta$</code>，TG 退化为简单截断法；当 <code>$\theta = \infty$</code> 且 <code>$k = 1$</code>，在截断区域之外，TG 继续退化为 SGD-<code>$L_1$</code>，此时 <code>$\omega_i$</code> 的更新是：</p><p><code>$$\omega_{i}^{(t + 1)} \gets \omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} - \eta^{(t)}\lambda\,\text{sgn}\Bigl(\omega_{i}^{(t)}\Bigr).$$</code></p><h3 id="FOBOS-Forward-Backward-Splitting"><a href="#FOBOS-Forward-Backward-Splitting" class="headerlink" title="FOBOS (Forward-Backward Splitting)"></a>FOBOS (Forward-Backward Splitting)</h3><p>FOBOS 最开始的名字叫做 Forward Looking Subgradients，简写叫做 FOLOS；后来改名叫做 Forward-Backward Splitting，按说应该简写成 FOBAS。但作者为了减少可能的困扰，就只修改了一个字母，变成了 FOBOS。</p><blockquote><p>吐槽：但实际上，变得更加困惑了好不好……</p></blockquote><p>FOBOS 可以看做是 TG 的改进。</p><p>首先，FOBOS 将 <code>$k$</code> 设置为 1。如此一来，每一轮迭代都一样了：先根据次梯度做梯度下降，再做一步投影操作。</p><p>其次，FOBOS 将投影操作改进如下：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{2}\Bigl\lVert\vec\omega - \vec\omega^{t&#39;}\Bigr\rVert^{2} + \eta^{(t&#39;)}\Omega(\vec\omega)\biggr\}.$$</code></p><p>这里，优化符号中的第一项保证了投影之后的结果距离梯度下降的结果不太远，第二项是正则项，用于产生稀疏性。我们将它转换为无约束优化的形式：</p><p><code>$$\begin{aligned}\vec\omega^{(t + 1)} \gets{}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{2}\Bigl\lVert\vec\omega - \vec\omega^{(t)} + \eta^{(t)}\nabla\text{Obj}(\vec\omega^{(t)})\Bigr\rVert^{2} + \eta^{(t&#39;)}\Omega(\vec\omega)\biggr\},  \\={}&amp; \vec\omega^{(t)} - \eta^{(t)}\nabla\text{Obj}(\vec\omega^{(t)}) - \eta^{(t&#39;)}\nabla\Omega(\vec\omega^{(t + 1)}).\end{aligned}$$</code></p><p>可见，更新结果不仅与上一轮迭代的结果有关（梯度下降），还与迭代之后的状态有关（正则约束），这就是所谓的 Forward-Backword Splitting。</p><p>当 <code>$\Omega(\cdot) = \eta^{(t&#39;)}\lambda\lVert\cdot\rVert_1 = \tilde\lambda\lVert\cdot\rVert_1$</code> 时，我们将向量形式再化简到具体某一维度的更新：</p><p><code>$$\begin{aligned}\omega_{i}^{(t + 1)} \gets{}&amp; \text{sgn}\bigl(\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}\bigr)\cdot\max\Bigl\{0, \bigl\lvert \omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} \bigr\rvert - \tilde\lambda\Bigr\}, \\={}&amp; \begin{cases}0 &amp; \text{if $\lvert\omega_{i}^{(t&#39;)}\rvert &lt; \tilde\lambda$,} \\\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} - \tilde\lambda\,\text{sgn}\Bigl(\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}\Bigr) &amp; \text{otherwise.}\end{cases}\end{aligned}$$</code></p><p>不难发现，它与 TG 的形式非常接近。当 TG 中的 <code>$\theta = \infty$</code>, <code>$\alpha = \tilde\lambda$</code>, <code>$k = 1$</code> 时，TG 与 FOBOS 的唯一差别就在于惩罚项上。TG 是惩罚在迭代前的项上，FOBOS 是惩罚在经过次梯度迭代后的项上。</p><h3 id="RDA-Regularized-Dual-Averaging"><a href="#RDA-Regularized-Dual-Averaging" class="headerlink" title="RDA (Regularized Dual Averaging)"></a>RDA (Regularized Dual Averaging)</h3><p>RDA 是微软 10 年发表的研究成果，其权重更新策略如下：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{t}\sum_{r = 1}^{t}\Bigl\langle \nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr), \vec\omega\Bigr\rangle + \Omega(\vec\omega) + \frac{\beta^{(t)}}{t}h(\vec\omega)\biggr\}.$$</code></p><p>这里，</p><ul><li><code>$\Bigl\langle \nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr), \vec\omega\Bigr\rangle$</code> 表示梯度 <code>$\nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr)$</code> 对参数 <code>$\vec\omega$</code> 的积分中值，即：第 <code>$r$</code> 轮迭代中的梯度对参数 <code>$\vec\omega$</code> 产生的变动在所有样本上产生的平均影响。</li><li><code>$\frac{1}{t}\sum_{r = 1}^{t}\Bigl\langle \nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr), \vec\omega\Bigr\rangle$</code> 则是前 <code>$r$</code> 轮迭代上述平均影响的平均值（Dual Average）。</li><li><code>$\Omega(\vec\omega)$</code> 是正则项。</li><li><code>$\frac{\beta^{(t)}}{t}h(\vec\omega)$</code> 是额外的正则项。<ul><li><code>$\bigl\{\beta^{(t)}\mid t \geqslant 1\bigr\}$</code> 是一个非负的非降序列。</li><li><code>$h(\vec\omega)$</code> 是一个严格的凸函数。</li></ul></li></ul><p>除开正则项的变化，和 FOBOS 及之前的截断方法比较，RDA 最大的差别在于丢弃了梯度下降的那一项，换成了梯度的二次平均值。接下来，我们取</p><ul><li><code>$\Omega(\vec\omega) = \lambda\lVert\vec\omega\rVert_1$</code>，其中 <code>$\lambda &gt; 0$</code>；</li><li><code>$h(\vec\omega) = \frac{1}{2}\lVert\vec\omega\rVert_2^2$</code>；</li><li><code>$\beta^{(t)} = \gamma\sqrt{t}$</code>，其中 <code>$\gamma &gt; 0$</code>。</li></ul><p>记 <code>$g_i^{(1:t)} = \frac{1}{t}\sum_{r = 1}^{t} g_i^{(r)}$</code>，于是得到第 <code>$i$</code> 维权重的更新：</p><p><code>$$\omega_{i}^{(t + 1)} \gets \begin{cases}0&amp; \text{if $\bigl\lvert g_i^{(1:t)}\bigr\rvert &lt; \lambda$,} \\-\frac{\sqrt{t}}{\gamma}\Bigl(g_i^{(1:t)} - \lambda\,\text{sgn}\bigl(g_i^{(1:t)}\bigr)\Bigr) &amp; \text{otherwise.}\end{cases}$$</code></p><p>可见，当某一维度参数的二次平均梯度小于阈值 <code>$\lambda$</code> 时，这一维度被截断，产生稀疏性。</p><h2 id="FTRL-Follow-The-Regularized-Leader"><a href="#FTRL-Follow-The-Regularized-Leader" class="headerlink" title="FTRL (Follow The Regularized Leader)"></a>FTRL (Follow The Regularized Leader)</h2><p>接下来介绍 FTRL。</p><h3 id="FOBOS-和-RDA-的区别"><a href="#FOBOS-和-RDA-的区别" class="headerlink" title="FOBOS 和 RDA 的区别"></a>FOBOS 和 RDA 的区别</h3><p>为便于比较，这里把 FOBOS 和 RDA 在单一维度上的更新策略再次抄录如下。</p><p><code>\begin{equation}\omega_{i}^{(t + 1)} \gets \begin{cases}0 &amp; \text{if $\lvert\omega_{i}^{(t&#39;)}\rvert &lt; \tilde\lambda$,} \\\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} - \tilde\lambda\,\text{sgn}\Bigl(\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}\Bigr) &amp; \text{otherwise.}\end{cases}\tag{FOBOS}\label{eq:FOBOS}\end{equation}</code></p><p><code>\begin{equation}\omega_{i}^{(t + 1)} \gets \begin{cases}0&amp; \text{if $\bigl\lvert g_i^{(1:t)}\bigr\rvert &lt; \lambda$,} \\-\frac{\sqrt{t}}{\gamma}\Bigl(g_i^{(1:t)} - \lambda\,\text{sgn}\bigl(g_i^{(1:t)}\bigr)\Bigr) &amp; \text{otherwise.}\end{cases}\tag{RDA}\label{eq:RDA}\end{equation}</code></p><p>首先我们看 FOBOS 和 RDA 的截断部分的差异。</p><p>FOBOS 的截断判断取的是单次梯度下降的结果，而 RDA 的截断判断取的是往期所有梯度的二次平均。考虑到我们面临的是「在线学习」，样本在局部抖动的几率比较大。因此 FOBOS 的做法容易因为某些异常、离群样本的出现而错误地截断；RDA 的做法则稳妥许多，参考了过去所有样本的梯度结果。</p><p>FOBOS 的截断阈值是 <code>$\tilde\lambda = \eta^{(t&#39;)}\lambda$</code>。考虑到学习率 <code>$\eta^{(t&#39;)}$</code> 往往会随着 <code>$t$</code> 的增加而减小。故而 FOBOS 的截断阈值是不断减小的；与之相对，RDA 的截断阈值是固定的 <code>$\lambda$</code>。这说明，随着训练的进程，FOBOS 对截断的要求越放越松，因而 RDA 相对更容易得到稀疏解。</p><p>接下来我们看 FOBOS 和 RDA 截断之外部分的差异。</p><p>FOBOS 的取值主体是 <code>$\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}$</code>，即梯度下降的结果，在此基础上做微调——向 0 的方向微调 <code>$\tilde\lambda$</code> 步长。按「下山」的比喻，FOBOS 的取值，是在梯度反方向上下山，每次做一定的微调。RDA 的取值，主体是往期所有梯度的二次平均的缩放（<code>$-\frac{\sqrt{t}}{\gamma}$</code>），在此基础上做微调——向 0 的方向微调 <code>$\lambda$</code>。按同样的比喻，RDA 的取值，是在山顶上试探很多步，平均之后只走出一小步。从感性的认知来说，FOBOS 的准确度显然会更高一些。</p><p>这也就是说，FOBOS 的精度较高，但解的稀疏性相对较差；RDA 的解的稀疏性好，但精度较差。于是，很自然地，我们会问：<strong>是否有办法，将二者的优点合在一起呢</strong>？</p><h3 id="统一-FOBOS-和-RDA-的形式"><a href="#统一-FOBOS-和-RDA-的形式" class="headerlink" title="统一 FOBOS 和 RDA 的形式"></a>统一 FOBOS 和 RDA 的形式</h3><p>想要取长补短，就要想办法将 FOBOS 和 RDA 的形式统一起来。这样才方便拆墙补墙。</p><p>首先看 FOBOS 的无约束优化形式：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{2}\Bigl\lVert\vec\omega - \vec\omega^{(t)} + \eta^{(t)}\vec g^{(t)}\Bigr\rVert^{2} + \eta^{(t)}\lambda\lVert\vec\omega\rVert_1\biggr\}.$$</code></p><p>注意，这里 <code>$\vec g^{(t)} = \nabla\text{Obj}(\vec\omega^{(t)})$</code>，并且令 <code>$\eta^{(t&#39;)} = \eta^{(t)} = \frac{\gamma}{\sqrt{t}}$</code>。我们将之按维度拆开：</p><p><code>$$\begin{aligned}&amp; \min_{\omega_i\in\mathbb{R}}\biggl\{\frac{1}{2}\Bigl\lVert\omega_i - \omega_i^{(t)} + \eta^{(t)}g_i^{(t)}\Bigr\rVert^{2} + \eta^{(t)}\lambda\lvert\omega_i\rvert\biggr\} \\={}&amp; \min_{\omega_i\in\mathbb{R}}\biggl\{\omega_ig_i^{(t)} + \lambda\lvert\omega_i\rvert + \frac{1}{2\eta^{(t)}}\bigl(\omega_i - \omega_i^{(t)}\bigr)_2^2 + \biggl[ \frac{\eta^{(t)}}{2}\bigl(g_i^{(t)}\bigr)_2^2 + \omega_i^{(t)}g_i^{(t)} \biggr]\biggr\} \\={}&amp; \min_{\omega_i\in\mathbb{R}}\biggl\{\omega_ig_i^{(t)} + \lambda\lvert\omega_i\rvert + \frac{1}{2\eta^{(t)}}\bigl(\omega_i - \omega_i^{(t)}\bigr)_2^2\biggr\}.\end{aligned}$$</code></p><p>再合并起来有，</p><p><code>$$\begin{aligned}\vec\omega^{(t + 1)} \gets&amp;{} \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec g^{(t)}\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac{1}{2\eta^{(t)}}\bigl\lVert\vec\omega - \vec\omega^{(t)}\bigr\rVert_2^2\biggr\} \\=&amp;{} \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec g^{(t)}\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac{1}{2}\sigma^{(1:t)}\bigl\lVert\vec\omega - \vec\omega^{(t)}\bigr\rVert_2^2\biggr\}.\end{aligned}$$</code></p><p>其中 <code>$\sigma^{(t)} = \frac{1}{\eta^{(t)}} - \frac{1}{\eta^{(t - 1)}}$</code>，以及 <code>$\sigma^{(1:t)} = \sum_{r = 1}^{t}\sigma^{(r)} = \frac{1}{\eta^{(t)}}$</code>（注意与 <code>$\vec g^{(1:t)}$</code> 不同，<code>$\sigma^{(1:t)}$</code> 在求和符号外没有 <code>$\frac{1}{t}$</code>）。类似地，对于 RDA 有：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + t\lambda\lVert\vec\omega\rVert_1 + \frac{1}{2}\sigma^{(1:t)}\bigl\lVert\vec\omega - \vec 0\bigr\rVert_2^2\biggr\}.$$</code></p><p>这里 <code>$\vec G^{(t)} = \vec g^{(t)}$</code>，而 <code>$\vec G^{(1:t)} = \sum_{r = 1}^{t}\vec G^{(t)} = t\cdot\vec g^{(1:t)}$</code>。</p><h3 id="拆墙补墙得到-FTRL"><a href="#拆墙补墙得到-FTRL" class="headerlink" title="拆墙补墙得到 FTRL"></a>拆墙补墙得到 FTRL</h3><p>统一了 FOBOS 和 RDA 的形式之后，我们就可以将它们各自的优点拿出来了。</p><p>对于 FOBOS，它的优点体现在 <code>$ \frac{1}{2}\sigma^{(1:t)}\bigl\lVert\vec\omega - \vec\omega^{(t)}\bigr\rVert_2^2$</code> 这一项上；对于 RDA，它的优点体现在 <code>$\vec G^{(1:t)}\cdot\vec\omega$</code> 这一项上。于是，我们将这两项组合起来，得到的就是标准的 FTRL 了（11 年的论文中的原始版本）：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\}.$$</code></p><p>注意这里式中第 3 项与 FOBOS 的第三项稍有区别。我们还可以为它加上 <code>$L_2$</code> 正则项，变成：</p><p><code>\begin{equation}\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\lambda_2\lVert\vec\omega\rVert_2^2 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\}.\tag{FTRL}\label{eq:FTRL}\end{equation}</code></p><h3 id="FTRL-更新公式的推导"><a href="#FTRL-更新公式的推导" class="headerlink" title="FTRL 更新公式的推导"></a>FTRL 更新公式的推导</h3><p>我们将 \ref{eq:FTRL} 展开，得到</p><p><code>$$\begin{aligned}\vec\omega^{(t + 1)} \gets{}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\lambda_2\lVert\vec\omega\rVert_2^2 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\} \\={}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec z^{(1:t)}\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\Bigl(\lambda_2 + \sum_{r = 1}^{t}\sigma^{(r)}\Bigr)\lVert\vec\omega\rVert_2^2 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\lVert\vec\omega^{(r)}\rVert_2^2\biggr\} \\={}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec z^{(1:t)}\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\Bigl(\lambda_2 + \sum_{r = 1}^{t}\sigma^{(r)}\Bigr)\lVert\vec\omega\rVert_2^2\biggr\}.\end{aligned}$$</code></p><p>其中 <code>$\vec z^{(t)} = \vec g^{(t)} - \sigma^{(t)}\cdot\vec\omega^{(t)}$</code>，而 <code>$\vec z^{(1:t)} = \sum_{r = 1}^{t}\vec z^{(r)}$</code>。我们将之按维度拆开，有</p><p><code>\begin{equation}\min_{\omega_{i}\in\mathbb{R}}\biggl\{z_i^{(t)}\omega_{i} + \lambda_1\lvert\omega_i\rvert + \frac{1}{2}\Bigl(\lambda_2 + \sigma^{(1:t)}\Bigr)\omega_{i}^{2}\biggr\}.\label{eq:ftrl-one-dim}\end{equation}</code></p><p>式 \ref{eq:ftrl-one-dim} 是一个无约束的非平滑参数优化问题，其中第二项 <code>$\lambda_1\lvert\omega_i\rvert$</code> 在 <code>$\omega_i = 0$</code> 处不可导。假设 <code>$\omega_i^*$</code> 是使式 \ref{eq:ftrl-one-dim} 得到最优解的 <code>$\omega_i$</code> 的取值；定义 <code>$\xi\in\partial\lvert\omega_i^*\rvert$</code> 是 <code>$\lvert\omega_i\rvert$</code> 在 <code>$\omega_i^*$</code> 处的次导数，于是有</p><p><code>\begin{equation}\partial\lvert\omega_i^*\rvert = \begin{cases}1  &amp; \text{if $\omega_i^* &gt; 0$}, \\{-1 &lt; \xi &lt; 1} &amp; \text{if $\omega_i^* = 0$}, \\-1 &amp; \text{if $\omega_i^* &lt; 0$}.\end{cases}\label{eq:ftrl-subgradient}\end{equation}</code></p><p>根据式 \ref{eq:ftrl-subgradient} 定义的次导数，对式 \ref{eq:ftrl-one-dim} 待优化的部分求导，令其为零，得到方程：</p><p><code>\begin{equation}z_i^{(t)} + \lambda_1\cdot\xi + \bigl(\lambda_2 + \sigma^{(1:t)}\bigr)\omega_{i}^* = 0.\label{eq:ftrl-equation}\end{equation}</code></p><p>式 \ref{eq:ftrl-equation} 中，<code>$\lambda_1 &gt; 0$</code> 且 <code>$\bigl(\lambda_2 + \sigma^{(1:t)}\bigr) &gt; 0$</code>。对 <code>$z_i^{(t)}$</code> 的取值进行分类讨论：</p><ul><li>当 <code>$\bigl\lvert z_i^{(t)}\bigr\rvert &lt; \lambda_1$</code> 时，有 <code>$\omega_i^{*} = 0$</code>。因为若不然：<ul><li>当 <code>$\omega_i^{*} &lt; 0$</code>，有 <code>$\xi = -1$</code>。式 \ref{eq:ftrl-equation} 左边有 <code>$z_i^{(t)} - \lambda_1 + \bigl(\lambda_2 + \sigma^{(1:t)}\bigr)\omega_{i}^* &lt; z_i^{(t)} - \lambda_1 &lt; 0$</code>，与式 \ref{eq:ftrl-equation} 矛盾。</li><li>当 <code>$\omega_i^{*} &gt; 0$</code>，有 <code>$\xi = 1$</code>。式 \ref{eq:ftrl-equation} 左边有 <code>$z_i^{(t)} + \lambda_1 + \bigl(\lambda_2 + \sigma^{(1:t)}\bigr)\omega_{i}^* &gt; z_i^{(t)} + \lambda_1 &gt; 0$</code>，与式 \ref{eq:ftrl-equation} 矛盾。</li></ul></li><li>当 <code>$z_i^{(t)} &gt; \lambda_1$</code> 时，有 <code>$\omega_i^{*} = -\frac{1}{\lambda_2 + \sigma^{(1:t)}}\bigl(z_i^{(t)} - \lambda_1\bigr) &lt; 0$</code>。因为若不然：<ul><li>当 <code>$\omega_i^{*} = 0$</code>，由式 \ref{eq:ftrl-equation} 知 <code>$\xi = -\frac{z_i^{(t)}}{\lambda_1} &lt; -1$</code>，与式 \ref{eq:ftrl-subgradient} 矛盾。</li><li>当 <code>$\omega_i^{*} &gt; 0$</code>，与 <code>$\bigl\lvert z_i^{(t)}\bigr\rvert &lt; \lambda_1$</code> 的情况类似，与式 \ref{eq:ftrl-equation} 矛盾。</li></ul></li><li>当 <code>$z_i^{(t)} &lt; -\lambda_1$</code>，类似分析，有 <code>$\omega_i^{*} = -\frac{1}{\lambda_2 + \sigma^{(1:t)}}\bigl(z_i^{(t)} + \lambda_1\bigr) &gt; 0$</code>。</li></ul><p>如此一来，我们得到 FTRL 的更新公式：</p><p><code>\begin{equation}\omega_i^{(t + 1)} = \begin{cases}0 &amp; \text{if $\lvert z_i^{(t)}\rvert &lt; \lambda_1$}, \\-\frac{1}{\lambda_2 + \sigma^{(1:t)}}\bigl(z_i^{(t)} - \text{sgn}(z_i^{(t)})\lambda_1\bigr) &amp; \text{otherwise}.\end{cases}\label{eq:ftrl-updates}\end{equation}</code></p><p>从式 \ref{eq:ftrl-updates} 来看，加入 <code>$L_2$</code> 正则，没有影响模型的稀疏性，而只是使得参数的取值趋向零。</p><h3 id="FTRL-为什么是有效的"><a href="#FTRL-为什么是有效的" class="headerlink" title="FTRL 为什么是有效的"></a>FTRL 为什么是有效的</h3><p>我们引出 FTRL 是按「稀疏性」的路径，从 FOBOS 和 RDA 拆借出来的。从上面的推导，我们能看出 FTRL 能够较好地获得稀疏解。但是，我们仍未能说明，FTRL 能够获得较好的稀疏解。（大家来找茬，笑）这一小节里，我们来说明 FTRL 是有效的。</p><p>首先回顾一下 SGD 的更新公式：</p><p><code>\begin{equation}\vec\omega_i^{(t + 1)} \gets \vec\omega_i^{(t)} - \eta^{(t)}\vec g^{(t)}.\label{eq:sgd}\end{equation}</code></p><p>我们丢掉式 \ref{eq:FTRL} 中有关 <code>$L_1$</code> 和 <code>$L_2$</code> 正则相关的部分，有</p><p><code>\begin{equation}\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\}.\label{eq:ftrl-pure}\end{equation}</code></p><p>记式 \ref{eq:ftrl-pure} 中待优化的部分为 <code>$f(\vec\omega)$</code>。对其求导，有：</p><p><code>\begin{equation}\frac{\partial f(\vec\omega)}{\partial\vec\omega} = \vec G^{(1:t)} + \sum_{r = 1}^{t}\sigma^{(r)}\bigl(\vec\omega - \vec\omega^{(r)}\bigr).\label{eq:ftrl-pure-gradient}\end{equation}</code></p><p>当式 \ref{eq:ftrl-pure-gradient} 为 0 时的 <code>$\vec\omega$</code>，式 \ref{eq:ftrl-pure} 取得极值。此即有</p><p><code>\begin{equation}\begin{aligned}\vec G^{(1:t)} + \sum_{r = 1}^{t}\sigma^{(r)}\bigl(\vec\omega^{(t + 1)} - \vec\omega^{(r)}\bigr) ={}&amp; 0 \\\sigma^{(1:t)} \vec\omega^{(t + 1)} ={}&amp; \sum_{r = 1}^{t}\sigma^{(r)} \vec\omega^{(r)} - \vec G^{(1:t)}\end{aligned}\label{eq:ftrl-pure-gradient-equation}\end{equation}</code></p><p>在式 \ref{eq:ftrl-pure-gradient-equation} 中，以 <code>$t - 1$</code> 替换 <code>$t$</code>，得到</p><p><code>\begin{equation}\sigma^{(1:t - 1)} \vec\omega^{(t)} = \sum_{r = 1}^{t - 1}\sigma^{(r)} \vec\omega^{(r)} - \vec G^{(1:t - 1)}\label{eq:ftrl-pure-gradient-equation-minus}\end{equation}</code></p><p>用式 \ref{eq:ftrl-pure-gradient-equation} 减去式 \ref{eq:ftrl-pure-gradient-equation-minus} 得到</p><p><code>\begin{equation}\begin{aligned}\sigma^{(1:t)} \vec\omega^{(t + 1)} - \sigma^{(1:t - 1)} \vec\omega^{(t)} ={}&amp; \sigma^{(t)}\vec\omega^{(t)} - \vec g^{(t)} \\\sigma^{(1:t)} \vec\omega^{(t + 1)} ={}&amp; \sigma^{(1:t)} \vec\omega^{(t)} - \vec g^{(t)}\end{aligned}\label{eq:ftrl-sgd-equiv}\end{equation}</code></p><p>考虑 <code>$\sigma^{(1:t)} = \frac{1}{\eta^{(t)}}$</code>，化简式 \ref{eq:ftrl-sgd-equiv} 即得到式 \ref{eq:sgd}。这也就是说，FTRL 去掉 <code>$L_1$</code> 和 <code>$L_2$</code> 部分后，和 SGD 是等价的。这说明 FTRL 能够较好地获得稀疏解并且能够获得较好的稀疏解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 &lt;code&gt;$L_1$&lt;/code&gt; 正则化的&lt;a href=&quot;/2018/10/10/logistic-regression/&quot;&gt;逻辑回归&lt;/a&gt;类模型时，效果非常出色：能够得到性能较好的稀疏解。&lt;/p&gt;
&lt;p&gt;中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我看来，已有的关于 FTRL 的介绍，都或多或少有些值得调整和改进的地方。这促成了这篇文章。&lt;/p&gt;
&lt;p&gt;这篇文章讲 FTRL 的理论部分，大致会按照这样的路径来阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们想要解决什么问题？&lt;/li&gt;
&lt;li&gt;FTRL 的前辈们是怎么尝试解决问题的？&lt;/li&gt;
&lt;li&gt;前辈们之间是什么关系？又留下了哪些尚未解决的问题？FTRL 是如何解决这些遗留问题的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而后，在下一篇工程部分的文章中，我们会讨论一下 FTRL 的工程实现有哪些值得谈一谈的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Logistic Regression" scheme="https://liam.page/tags/Logistic-Regression/"/>
    
      <category term="FTRL" scheme="https://liam.page/tags/FTRL/"/>
    
      <category term="Online Optimization" scheme="https://liam.page/tags/Online-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>从前序遍历结果中重建二叉搜索树</title>
    <link href="https://liam.page/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/"/>
    <id>https://liam.page/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/</id>
    <published>2019-08-29T06:38:23.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个有趣的问题：已知有一个无重复元素的二叉搜索树的前序遍历结果，要求重建该二叉搜索树。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>首先回顾一下前序遍历和二叉搜索树的概念。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>二叉树的前序遍历指得是：对于任意的节点及其左右子节点，在遍历结果中出现的顺序总是「父节点 -&gt; 左子树（如果有） -&gt; 右子树（如果有）」；由于二叉树的自相似结构，这种描述唯一确定的遍历顺序即是前序遍历。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是一种特殊的二叉树，它要求：对于任意的节点及其左右子节点作为根节点形成的左右子树，满足：左子树的所有节点的值小于父节点的值，右子树的所有节点的值大于父节点的值。</p><blockquote><p>显然，二叉搜索树的中序遍历是从小到大排序的。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><p>首先要考虑，一个无重复元素的二叉搜索树的前序遍历结果能否唯一确定一个二叉搜索树？答案是可以的，简要证明如下：</p><ul><li>已知二叉搜索树的前序遍历结果，即知晓二叉搜索树中所有元素；</li><li>对二叉搜索树中所有元素进行从小到大排序，根据二叉搜索树的性质，即得到该二叉搜索树的中序遍历结果；</li><li>已知二叉树的前序遍历结果和中序遍历结果，可以唯一地确定一个二叉树，即该二叉搜索树。</li></ul><p>由此可知，一个无重复元素的二叉搜索树的前序遍历结果，确实能够唯一地确定一个二叉搜索树。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>重建二叉搜索树必然要获知该二叉搜索树中的全部结果。因此，时间复杂度必然不小于 <code>$O(n)$</code>，由此我们得到一个下界。</p><p>又从上述唯一性证明的过程中可知一种重建方法，分析该方法的复杂度可得到一个上界。现在我们简单分析一下该方法的时间复杂度。</p><blockquote><p>一种恢复二叉搜索树的方法：</p><ol><li>对结果进行从小到大排序，得到中序遍历结果。</li><li>根据前序遍历结果和中序遍历结果，重建二叉树。</li></ol></blockquote><p>该方法的时间复杂度是两步之和，其中第 (1) 步的时间复杂度为 <code>$O(n\log(n))$</code>；关键要求得第 (2) 步的时间复杂度。</p><blockquote><p>根据前序遍历结果和中序遍历结果，重建二叉树的方法：</p><ol><li>根据前序遍历结果，确定树根</li><li>根据中序遍历结果，确定树根位置</li><li>根据中序遍历结果，确定左子树（如果有）元素数量</li><li>根据 (3) 的结果，在前序遍历结果中，确定左右子树（如果有）的树根位置</li><li>如此分治递归</li></ol></blockquote><p>若使用支持随机访问的数组存储前序、中序遍历结果，这里的 (1), (3), (4) 步的复杂度均是常数 <code>$O(1)$</code>。对于 (2)，若中序遍历是有序结果（二叉搜索树的情况），可用二分搜索确定树根位置，这一步的复杂度是 <code>$O(\log(n))$</code>，否则只能逐一遍历，复杂度是 <code>$O(n)$</code>。根据「主定理」，这种重建二叉树的方法的时间复杂度不超过 <code>$O(n\log(n))$</code>。</p><p>由此可知，根据前序遍历结果重建二叉搜索树的方法，其时间复杂度下界是 <code>$O(n)$</code>，上界是 <code>$O(n\log(n))$</code>。</p><h2 id="向-Theta-n-进发"><a href="#向-Theta-n-进发" class="headerlink" title="向 $\Theta(n)$ 进发"></a>向 <code>$\Theta(n)$</code> 进发</h2><p>回顾借助中序遍历结果重建二叉树的步骤，我们发现，中序遍历结果的核心作用是通过确定左子树（如果有）元素的数量，在前序遍历中确定左右子树的根节点。考虑到，在前序遍历中，左子树的根节点的位置是平凡的——如果存在左子树，左子树根节点就是整棵树根节点的在前序遍历中的下一个元素。所以关键是要想办法确定右子树（如果有）根节点的位置。</p><p>好消息是，我们现在需要重建的二叉树是二叉搜索树。因此，树根的右孩子，就是前序遍历中第一个比根节点大的那个元素。这样一来，我们就能确定根节点的左右孩子的位置了，如此一来，只需要递归就能解决问题。</p><p>于是，遗留的问题变成了：如何在常数时间内找到第一个比根节点大的元素的位置。</p><p>讲道理，单就查找元素的问题而言，我们是做不到的。最快的二分的复杂度也有 <code>$\Theta(\log(n))$</code>，何况它还有额外要求。但是，我们已知：根节点到根节点右孩子（如果有）之间的所有元素，都是根节点左子树（如果有）的元素（假设其个数是 <code>$k$</code>）。如果我们有办法在寻找右孩子的过程中，把左子树构建出来，我们就能把寻找右孩子的复杂度 <code>$\Theta(k)$</code> 均摊到这 <code>$k$</code> 个左子树的元素上去，复杂度就变成了常数。要做到这一点，依赖于实现。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rebuildBST</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">int</span> bound = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::max())</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (preorder.size() == i <span class="keyword">or</span> preorder[i] &gt; bound) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">  ++i;</span><br><span class="line">  node-&gt;left = rebuildBST(preorder, node-&gt;val);</span><br><span class="line">  node-&gt;right = rebuildBST(preorder, bound);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，所有递归调用都共享同一个下标 <code>i</code>，它从 <code>0</code> 开始自增到 <code>preorder.size()</code> 后，所有递归退出。在每次递归调用中，除开构建节点的开销，都只有常数项的操作：至多两次比较，一次变量自增。因此，复杂度是 <code>$\Theta(n)$</code>。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>再多一点挑战：有没有办法用非递归的方式去实现这一算法呢？</p><p>既然会问出来，那答案肯定是「有」。</p><p>我们分析一下递归版本的代码。</p><ul><li>函数的默认参数 <code>std::numeric_limits&lt;int&gt;::max()</code> 实际上是为了简化代码实现，而引入的「哨兵」。</li><li>变量 <code>i</code> 在所有递归调用中共享，从 <code>0</code> 开始自增到 <code>preorder.size()</code> 后，所有递归退出，实际上起到了循环的作用。</li><li>每次递归调用中，<code>preorder</code> 是不变的，变化的只有 <code>bound</code>；它保证了在处理右子树之前，先处理完左子树的所有节点。</li></ul><p>因此，若要非递归地实现这一算法，我们需要：</p><ul><li>用某种方式，重新引入哨兵 <code>std::numeric_limits&lt;int&gt;::max()</code>；</li><li>循环，从 <code>0 -&gt; preorder.size()</code>；</li><li>提供一个栈，直接或间接地保存这里的 <code>bound</code>。</li></ul><p>于是有实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rebuildBST</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">  TreeNode* dummy = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::max());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">  s.push(dummy);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x : preorder) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(x);</span><br><span class="line">    TreeNode* wk = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (; s.top()-&gt;val &lt; x; wk = s.top(), s.pop()) &#123; ; &#125;</span><br><span class="line">    <span class="keyword">if</span> (wk == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      s.top()-&gt;left = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wk-&gt;right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode* res = dummy-&gt;left;</span><br><span class="line">  dummy-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">delete</span> dummy;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>dummy</code> 起到了哨兵的作用；<code>for (:)</code> 是上述提到的循环；<code>for (;;)</code> 里每一次弹栈，都意味着遇到了右孩子，对应递归版本中的 <code>return nullptr;</code>。</p><p>从非递归的版本中看时间复杂度是很明显的。<code>for (:)</code> 之外的内容只有常数复杂度，<code>for (:)</code> 循环之内的内容要重点分析 <code>for (;;)</code> 循环。<code>for (;;)</code> 循环每执行一次，都有一次 <code>s.pop()</code> 操作，它与 <code>s.push(node)</code> 一一对应。因此，有多少次 <code>s.push(node)</code> 就有多少次 <code>s.pop()</code>（不算 <code>s.push(dummy)</code>）。于是，均摊到每次 <code>for (:)</code> 循环中去，<code>for (;;)</code> 恰好只执行一次 <code>wk = s.top()</code> 和 <code>s.pop()</code>。于是 <code>for (:)</code> 之内的内容也只有常数复杂度。于是，这个实现的复杂度为 <code>$\Theta(n)$</code>。</p><p>这里非递归的实现，是从递归实现中变形出来的。但实际上，非递归的实现，也有其自身的含义。</p><p>首先看「栈」。由于是「前序遍历」，所以一个节点的祖辈节点一定在父辈节点之前。考虑到任何一个节点，都只和父亲节点直接建立联系，因此从前往后遍历 <code>preorder</code> 时，必然要用到栈结构，保存历代祖先。（捶桌笑）</p><p>然后看弹栈的循环。这实际上透露的是一种自底向上的思路：如果我遇到了一个节点，它是某个节点的左孩子，那么一定是刚才入栈的节点；如果它是某个节点的右孩子，这意味着这个节点的左子树都已经处理完了，就要依次弹栈。通过这样的方式，我们能找到每一个「孩子」的「父亲」是谁。与之对应，递归版本的实现，则是一种自顶向下的思路：我现在有一个节点，它的左孩子在哪里，你给我找出来（递归调用），找到之后再继续找它的右孩子（递归调用）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到这个问题，我们的分析从确定唯一性开始。运用二叉搜索树中序遍历元素有序的特点，我们借助「前序中序唯一确定二叉树」的定理，很快确定了唯一性。（这要感谢 <code>@linjie</code>）</p><p>顺着唯一性出发，我们马上确定了一种重建二叉树的方法，从而确定了一个时间复杂度上界。</p><p>在确定上界之后，我们会希望继续降低算法的时间复杂度。自然而然地，我们从已有的方法出发，寻找可能的改进点。由于我们手头只有前序遍历结果，自然地，我们就会去想中序遍历在已有算法中起到的作用是什么，并寻找其替代。</p><p>如此，我们自顶向下地，很容易地找到了上述递归实现。在转递归为非递归的过成功中，我们又发现了自底向上的解法。这促使我们在将来的日子里，在符合常规思维的「自顶向下」中，多去找找「自底向上」的解法，可能会有奇效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到一个有趣的问题：已知有一个无重复元素的二叉搜索树的前序遍历结果，要求重建该二叉搜索树。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="BST" scheme="https://liam.page/tags/BST/"/>
    
      <category term="Preorder Traversal" scheme="https://liam.page/tags/Preorder-Traversal/"/>
    
  </entry>
  
</feed>
