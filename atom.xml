<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2020-01-19T03:49:03.024Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>USB 3.0 射频噪声对 2.4GHz 无线设备的干扰</title>
    <link href="https://liam.page/2020/01/19/USB-3-0-Radio-Frequency-Interference-Impact-on-2-4-GHz-Wireless-Devices/"/>
    <id>https://liam.page/2020/01/19/USB-3-0-Radio-Frequency-Interference-Impact-on-2-4-GHz-Wireless-Devices/</id>
    <published>2020-01-19T02:34:48.000Z</published>
    <updated>2020-01-19T03:49:03.024Z</updated>
    
    <content type="html"><![CDATA[<p>早些年，第一次使用 USB 3.0 硬盘的时候，我就发现了它对 Wi-Fi 网络信号的影响。为了解决这个问题，当时投资几百块，换了 NetGear 的路由器，并启用其 5GHz 的 Wi-Fi 信号。最近，在结合 rMBP 使用无线鼠标时，我发现鼠标经常出现跳帧的现象。因为距离上一次踩坑的时间已经过去六七年的时间，一时完全没想到可能是 USB 3.0 带来的问题。在经历了一系列折腾之后，才突然想起这个坑。特此记录。</p><a id="more"></a><h2 id="向外辐射的电磁波"><a href="#向外辐射的电磁波" class="headerlink" title="向外辐射的电磁波"></a>向外辐射的电磁波</h2><p>有高中物理电磁知识的人都应该知道一个基本事实：任何未经完全屏蔽的非直流电流，都会向外辐射电磁波。在高中物理中，它的基本形式就是 <a href="https://zh.wikipedia.org/wiki/LC%E7%94%B5%E8%B7%AF" target="_blank" rel="noopener">LC 谐振电路</a>。但另一方面，向外辐射电磁波的另一个条件是电路开路。也就是说，在连续的电路中，一般来说很难产生足以干扰其他设备的射频信号。此外，线缆通常也会考虑屏蔽电磁辐射。因此，一般来说，产生电磁射频噪声的干扰源，通常是电路的连接点，例如接头、引脚处。</p><h2 id="USB-3-0-的射频噪声"><a href="#USB-3-0-的射频噪声" class="headerlink" title="USB 3.0 的射频噪声"></a>USB 3.0 的射频噪声</h2><p>根据 Intel 于 2012 年发布的<a href="https://usb.org/sites/default/files/327216.pdf" target="_blank" rel="noopener">白皮书</a>，从 USB 3.0 的 <a href="https://zh.wikipedia.org/wiki/Sinc%E5%87%BD%E6%95%B0" target="_blank" rel="noopener"><code>sinc</code> 函数</a>来看，USB 3.0 的频谱很宽，从直流一直到 5GHz 都有所涉及。</p><p><img alt data-src="/uploads/images/computer-skills/usb3-sinc.jpg"></p><p>直接在笔记本上测量 USB 3.0 线对（transmit-pair）上的频谱则有如下分布。</p><p><img alt data-src="/uploads/images/computer-skills/usb3-noise-power-over-frequence.jpg"></p><p>于是，不难想见，USB 3.0 的接头处，在非常广的频谱上，都会向外辐射无线电干扰。那么射频干扰主要集中在什么频段呢？Intel 以实验说话，发现射频干扰主要集中在 2.4GHz -- 2.5GHz 之间。</p><p><img alt data-src="/uploads/images/computer-skills/usb3-noise-HDD.jpg"></p><h2 id="信噪比与干扰"><a href="#信噪比与干扰" class="headerlink" title="信噪比与干扰"></a>信噪比与干扰</h2><p>无线信号接收器是否能够正确解析无线信号，不仅取决于无线信号的强度，还取决于接收器所处环境的无线噪声强度。并不是说无线信号强度大，就一定能正确解析无线信号。假设有一个 -20 dBm（分贝毫瓦，对数能量单位）的信号，已经算很强了；但若环境中有一个 -20dBm 的同频率干扰信号，则原信号依然是不可辨别的。</p><p>因此，人们定义了信噪比（Signal-to-Noise ratio）这个概念。信噪比的单位也是分贝（dB）。</p><p>$$\text{SNR} = 10 \log_{10}\Bigl(\frac{P_{\text{signal}}}{P_{\text{noise}}}\Bigr).$$</p><p>为了能够正确解调无线信号，无线信号接收器都会有一个最低限度的信噪比要求。当无线信号过于衰弱，或是无线噪声过于强大时，信噪比就可能低于无线信号接收器所需的最低信噪比。如此一来，无线信号接收器就无法正常工作了。</p><h2 id="2-4GHz"><a href="#2-4GHz" class="headerlink" title="2.4GHz"></a>2.4GHz</h2><p>无线电信号频段是有限的资源。在大多数主要国家，都有相应的法律法规，来约束和限制无线电信号频段的使用。2.4GHz 是国际通用的不受约束的频段（当然，这里的不受约束，指的是你可以使用，但功率不能太大）。因此，大多数无线设备，都在这一频段工作。常见的有 Wi-Fi、无线鼠标、无线键盘、蓝牙等外设。</p><p>不巧的是，USB 3.0 的射频干扰主要集中在 2.4GHz 和 2.5GHz 之间，正好与这一通用频段重合。于是，USB 3.0 设备干扰 Wi-Fi、无线鼠标等，也就不奇怪了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法很简单。</p><ol><li>屏蔽：使用金属箔纸，将 USB 3.0 的连接处和电缆包裹起来，起到无线屏蔽的作用。当然，这对动手能力要求很高。</li><li>远离：由于无线信号强度随着信号源的距离的增加而快速衰减（平方衰减），因此，使用 USB 2.0 延长线，将无线信号接收器（如果有）远离 USB 3.0 的设备和借口，即可避免这一问题。</li><li>换频：由于 USB 3.0 的射频干扰主要集中在 2.4GHz 至 2.5GHz 之间，那么换成不在 2.4GHz 频段工作的设备即可。例如，可以更换成 5(.8) GHz 的设备。</li><li>有线：开历史倒车，从无线设备切换回到有线设备，彻底绕开无线干扰这个问题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早些年，第一次使用 USB 3.0 硬盘的时候，我就发现了它对 Wi-Fi 网络信号的影响。为了解决这个问题，当时投资几百块，换了 NetGear 的路由器，并启用其 5GHz 的 Wi-Fi 信号。最近，在结合 rMBP 使用无线鼠标时，我发现鼠标经常出现跳帧的现象。因为距离上一次踩坑的时间已经过去六七年的时间，一时完全没想到可能是 USB 3.0 带来的问题。在经历了一系列折腾之后，才突然想起这个坑。特此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="USB" scheme="https://liam.page/tags/USB/"/>
    
      <category term="USB3.0" scheme="https://liam.page/tags/USB3-0/"/>
    
      <category term="Wireless" scheme="https://liam.page/tags/Wireless/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑨）：Linux 系统里的进程状态</title>
    <link href="https://liam.page/2020/01/10/the-states-of-processes-on-Linux/"/>
    <id>https://liam.page/2020/01/10/the-states-of-processes-on-Linux/</id>
    <published>2020-01-10T07:22:34.000Z</published>
    <updated>2020-01-10T09:53:55.449Z</updated>
    
    <content type="html"><![CDATA[<p>今天有同事问到 <code>top</code> 命令里的 <code>running</code>, <code>sleep</code>, <code>stop</code>, <code>zombie</code> 等进程状态分别是什么意思。于是借这个机会写一下 Linux 系统里的进程状态。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>进程（Process）即当前正在运行的计算机程序之实例。每个进程都有一些属性变量，这些变量决定了进程所能使用的计算机资源。进程执行过程中，会处在不同状态；正如人会处在不同的人生状态一样。</p><p>和人一样，进程也是进程它妈生的。进程从其父进程当中 <em>fork</em> 出来。而后，程在执行（running）的过程中，会用到一些可用的资源；这一点，和人也是一样的。如果把精力当成是一种资源，那么人睡觉就是等待精力这一资源的过程；进程也是一样，当进程执行所需的资源暂时不可用时，进程就会进入睡眠（sleeping）状态。当然，和人一样，进程也会死。一个进程可能会正常结束，相当于人的寿终正寝；也可能被杀死（kill a process）。</p><h2 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h2><p>Linux 系统里有几种不同类型的进程：用户进程（User processes）、守护进程（Deamon processes）和内核进程（Kernel processes）。</p><h3 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h3><p>系统里大多数进程都是用户进程。用户进程由通常的用户账户启动，并在用户空间（user space）当中执行。在没有获得额外许可的情况下，通常用户进程无法对处理器进行特殊访问，或是访问启动进程的用户无权访问的文件。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程通常是后台程序，它们往往由一些持续运行的服务来管理。守护进程可以用来监听请求，而后访问某些服务。举例来说，<code>httpd</code> 这一守护进程监听访问网络页面的请求。守护进程也可以用来自行启动一些任务。例如，<code>crond</code> 这一守护进程会在预设的时间点启动计划任务。</p><p>尽管用于管理守护进程的服务通常是 <code>root</code> 用户启动的，但守护进程本身往往以非 <code>root</code> 用户启动。这种启动方式，符合「只赋予进程运行所必须的权限」之要求，因而能使系统免于一些攻击。举例来说，若是黑客骇入了 <code>httpd</code> 这一由 <code>Apache</code> 用户启动的守护进程，黑客仍然无法访问包括 <code>root</code> 用户在内的其他用户的文件，或是影响其他用户启动的守护进程。</p><p>守护进程通常由系统在启动时拉起，而后一直运行到系统关闭。当然，守护进程也可以按需启动和终止，以及让守护进程在特定的系统运行级别上执行，或是在运行过程中触发重新加载配置信息。</p><h3 id="内核进程"><a href="#内核进程" class="headerlink" title="内核进程"></a>内核进程</h3><p>内核进程仅在内核空间（kernel space）当中执行。内核进程与守护进程有些相似；它们之间主要的不同在于：内核进程对内核数据结构拥有完全的访问权限。此外，内核进程不如守护进程灵活：修改配置文件并触发重载即可修改守护进程的行为；但对于内核进程来说，修改行为则需要重新编译内核本身。</p><h2 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h2><p>系统在进程启动时会赋予其状态。进程的状态由该进程的状态描述符来描述。设置进程状态，通常对应了一个简单的赋值操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><p>这里，<code>p</code> 代表进程，<code>state</code> 是其状态标识，<code>TASK_RUNNING</code> 表示该进程正在运行或可以执行。</p><p>进程通常处于以下两种状态之一：</p><ul><li>在 CPU 上执行（此时，进程正在运行）</li><li>不在 CPU 上执行（此时，进程未在运行）</li></ul><p>同一时间同一 CPU 上只能运行一个进程，其他进程就只能等待，或处于其他状态。也就是说，未在运行的进程可能处于不同状态：</p><ul><li>可运行状态</li><li>可中断之睡眠状态</li><li>不可中断之睡眠状态</li><li>僵死状态</li></ul><p>接下来，详细说说不同状态。</p><h3 id="P-之初（人之初）"><a href="#P-之初（人之初）" class="headerlink" title="P 之初（人之初）"></a>P 之初（人之初）</h3><p>按 <code>fork(2)</code> 的手册页（执行 <code>man 2 fork</code> 可打开），<code>fork</code> 这一系统调用创建一个与调用 <code>fork</code> 的进程几乎完全相同的进程。这里，前者称为父进程，后者称为子进程。子进程与父进程几乎完全相同，但有以下一些差别：</p><ul><li>子进程拥有全局唯一的进程 ID（见 <code>setpgid(2)</code> 的手册页）</li><li>子进程的父进程 ID 是父进程的进程 ID</li><li>子进程不继承父进程的内存锁（见 <code>mlock(2)</code> 和 <code>mlockall(2)</code> 的手册页）</li><li>子进程的资源使用计数及 CPU 时间计数（见 <code>getrusage(2)</code> 和 <code>times(2)</code> 的手册页）重置为零</li><li>子进程未处理的信号队列重置为空（见 <code>sigpending(2)</code> 的手册页）</li><li>子进程不继承父进程的信号量修正（见 <code>semop(2)</code> 的手册页）</li><li>子进程不继承父进程的文件区域锁（record lock / file-region lock，见 <code>fcntl(2)</code> 的手册页）</li><li>子进程不继承父进程的计时器（见 <code>setitimer(2)</code>, <code>alarm(2)</code> 和 <code>timer_create(2)</code> 的手册页）</li><li>子进程不继承父进程未完成的异步输入输出操作（outstanding asynchronous I/O operations）（见 <code>aio_read(3)</code> 和 <code>aio_write(3)</code> 的手册页）</li><li>子进程不继承父进程的异步输入输出上下文（asynchronous I/O contexts）（见 <code>io_setup(2)</code> 的手册页）</li></ul><h3 id="正在运行状态"><a href="#正在运行状态" class="headerlink" title="正在运行状态"></a>正在运行状态</h3><p>系统中最珍贵的资源是 CPU。正使用 CPU 的进程处于「正在运行状态」。在 <code>ps</code> 或是 <code>top</code> 中，状态标识为 <code>R</code> 的进程，即处于正在运行状态。</p><p>接下来，我们看看进程是怎么进入「正在运行状态」的。比方说，你在 Shell（以 <code>bash</code> 为例）中执行 <code>ls</code> 命令时，Shell 会在环境变量 <code>PATH</code> 记录的搜索路径里寻找 <code>ls</code> 命令对应的可执行文件。找到后，Shell 使用 <code>fork</code> 克隆自身进程，而后在子进程中，使用 <code>ls</code> 的可执行文件替换虚存空间中 Shell 的内容。</p><p>此时，系统会设置子进程的运行状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><p>CPU 即可在内核模式运行，又可在用户模式运行。当用户初始化一个进程，进程在用户空间运行，对应 CPU 在用户模式运行。在用户空间运行的进程无权访问内核数据结构和算法。各型号的 CPU 都会提供一些特定的指令，以便在内核模式和用户模式之间切换。如果一个用户级的进程需要访问内核数据结构或算法，则它需要使用系统调用来与文件子系统或是进程控制子系统之间进行交互。部分系统调用罗列如下：</p><ul><li>文件子系统对应的系统调用：<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>chmod()</code> 以及 <code>chown()</code></li><li>进程控制子系统对应的系统调用：<code>fork()</code>, <code>exec()</code>, <code>exit()</code>, <code>wait()</code>, <code>brk()</code> 以及 <code>signal()</code></li></ul><p>当内核开始处理来自用户级进程的请求，相应进程就进入了内核空间，对应 CPU 就在内核模式运行。<code>/proc/&lt;pid&gt;/stat</code> 中的第 14 和 15 项，分别记录了进程在用户空间和内核空间执行的时间。摘录部分 <code>proc(5)</code> 的手册页内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">utime %lu</span><br><span class="line">  Amount of time that this process has been scheduled in user mode,</span><br><span class="line">  measured in clock ticks (divide by sysconf(_SC_CLK_TCK). This</span><br><span class="line">  includes guest time, guest_time (time spent running a virtual CPU, see</span><br><span class="line">  below), so that applications that are not aware of the guest time field do</span><br><span class="line">  not lose that time from their calculations.</span><br><span class="line"></span><br><span class="line">stime %lu</span><br><span class="line">  Amount of time that this process has been scheduled in kernel mode,</span><br><span class="line">  measured in clock ticks (divide by sysconf(_SC_CLK_TCK).</span><br></pre></td></tr></table></figure><p><code>top</code> 命令的 CPU 统计行，则展示了 CPU 位于用户模式和内核模式的时间占比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top - 12:27:25 up 2:51, 4 users, load average: 4.37, 3.64, 3.44</span><br><span class="line">Tasks: 194 total, 2 running, 192 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 57.0%us, 1.3%sy, 0.0%ni, 41.1%id, 0.0%wa, 0.4%hi, 0.1%si, 0.0%st</span><br></pre></td></tr></table></figure><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>进程获取了所有所需资源，正等待 CPU 时，就会进入可运行状态。处于可运行状态的进程在 <code>ps</code> 的输出中，也已 <code>R</code> 标识。</p><p>举例来说，一个正在 I/O 的进程并不立即需要 CPU。当进程完成 I/O 操作后，就会触发一个信号，通知 CPU 和调度器将该进程置于运行队列（由内核维护的可运行进程的列表）。当 CPU 可用时，该进程就会进入正在运行状态。</p><p>和正在运行状态一样，进程的状态被设置为 <code>TASK_RUNNING</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><h3 id="睡眠状态"><a href="#睡眠状态" class="headerlink" title="睡眠状态"></a>睡眠状态</h3><p>当进程所需的资源暂不可用时，就会进入睡眠状态。此时，进程要么主动进入睡眠状态，要么被内核置于睡眠状态（不管你想不想睡，反正内核会让你睡；因此，后者又称为「进程被内核睡了」）。进入睡眠状态的进程，会立即交出 CPU 的使用权。</p><p>当进程所需的资源可用时，CPU 会收到一个信号。于是，当调度器下次调度该进程时，会将它置为正在运行或可以运行状态。</p><p>以 login shell 进程为例，它</p><ul><li>在你键入命令时进入睡眠状态，同时等待一个特定的事件（取决与你键入执行的命令）；</li><li>Shell 进程睡眠时，会进入一个特定的等待通道（<code>WCHAN</code>, wait channel，同样取决于你键入执行的命令）；</li><li>当 Shell 进程等待的事件发生时（例如，收到一个来自键盘的中断 <code>^C</code>），在该等待通道的所有进程都会苏醒。</li></ul><p>执行 <code>ps -l</code> 可看到与当前 shell 关联的进程，执行 <code>ps -el</code> 则可看到系统上所有进程。如果进程处于睡眠状态，<code>ps</code> 输出中的 <code>WCHAN</code> 字段会显示进程在等待什么系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -l | more</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R   867 12085 27779  0  80   0 - 27029 -      pts/480  00:00:00 ps</span><br><span class="line">0 S   867 12086 27779  0  80   0 - 25779 pipe_w pts/480  00:00:00 more</span><br><span class="line">0 S   867 27779 35146  0  80   0 - 27721 do_wai pts/480  00:00:01 bash</span><br></pre></td></tr></table></figure><p>例如，在这里，我们执行了 <code>ps -l | more</code> 这个命令。输出中，<code>more</code> 和 <code>bash</code> 都处于睡眠状态。前者是在等待管道输入，即 <code>pipe_wait</code>，因为 <code>ps</code> 输出时，<code>more</code> 还没有接到内容。后者是在 等待 <code>ps -l | more</code> 执行完毕，即等待 <code>do_wait</code> 系统调用。</p><p>除了等待资源之外，进程也可以主动进入睡眠状态并持续一段时间。例如，<code>sleep()</code> 函数接收一个时间长度（以秒为单位，比如 10 秒）的参数，然后调用该函数的进程就会进入睡眠状态，并持续 10 秒。当睡眠时间结束后，调度器再次调度到该进程时，会将其设置为可运行状态。之后，当 CPU 空闲时，进程会重新进入正在运行状态。</p><blockquote><p>由此可见，<code>sleep(10)</code> 并不能保证「恰好」睡眠 10 秒，它只保证睡眠时间不少于 10 秒。</p></blockquote><p>部分进程永远不会终止，而是不断地在睡眠、唤醒干活的状态中循环。每次循环开始时，进程进入睡眠状态，然后等待某个特定的事件。当事件发生时，进程被唤醒（进入正在运行或者可以运行状态），然后处理任务。</p><p>睡眠状态也分可中断之睡眠状态和不可中断之睡眠状态。</p><h4 id="可中断之睡眠状态"><a href="#可中断之睡眠状态" class="headerlink" title="可中断之睡眠状态"></a>可中断之睡眠状态</h4><p>可中断之睡眠状态表示进程在等待时间片段或者某个特定的事件。一旦事件发生，进程会从可中断之睡眠状态中退出。<code>ps</code> 命令的输出中，可中断之睡眠状态标识为 <code>S</code>。</p><p>系统会为可中断之睡眠状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_INTERRUPTABLE;</span><br></pre></td></tr></table></figure><h4 id="不可中断之睡眠状态"><a href="#不可中断之睡眠状态" class="headerlink" title="不可中断之睡眠状态"></a>不可中断之睡眠状态</h4><p>不可中断之睡眠状态的进程不会处理任何信号，而仅在其等待的资源可用或超时时退出（前提是设置了超时时间）。</p><p>不可中断之睡眠状态通常和设备驱动等待磁盘或网络 I/O 有关。在内核源码 <code>fs/proc/array.c</code> 中，其文字定义为 <code>&quot;D (disk sleep)&quot;, /* 2 */</code>。当进程进入不可中断之睡眠状态时，进程不会处理信号，而是将信号都积累起来，等进程唤醒之后再处理。在 Linux 中，<code>ps</code> 命令使用 <code>D</code> 来标识处于不可中断之睡眠状态的进程。</p><p>系统会为不可中断之睡眠状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_UNINTERRUPTABLE;</span><br></pre></td></tr></table></figure><p>由于处于不可中断之睡眠状态的进程不会处理任何信号，所以 <code>kill -9</code> 也杀不掉它。解决此类进程的办法只有两个:</p><ul><li>对于怨妇，你还能怎么办，只能满足它啊：搞定不可中断之睡眠状态进程所等待的资源，使资源可用。</li><li>如果满足不了它，那就只能 kill the world——重启系统。</li></ul><h3 id="进程的终止和僵尸状态"><a href="#进程的终止和僵尸状态" class="headerlink" title="进程的终止和僵尸状态"></a>进程的终止和僵尸状态</h3><p>进程可以主动调用 <code>exit</code> 系统调用来终止，或者接受信号来由信号处理函数来调用 <code>exit</code> 系统调用来终止。</p><p>当进程执行 <code>exit</code> 系统调用后，进程会释放相应的数据结构；此时，进程本身已经终止。不过，此时操作系统还没有释放进程表中该进程的槽位（可以形象地理解为，「父进程还没有替子进程收尸」）；为解决这个问题，终止前，进程会向父进程发送 <code>SIGCHLD</code> 信号，通知父进程来释放子进程在操作系统进程表中的槽位。这个设计是为了让父进程知道子进程退出时所处的状态。</p><p>子进程终止后到父进程释放进程表中子进程所占槽位的过程，子进程进入僵尸状态（zombie state）。如果在父进程因为各种原因，在释放子进程槽位之前就挂掉了，也就是，父进程来不及为子进程收尸。那么，子进程就会一直处于僵尸状态。而考虑到，处于僵尸状态的进程本身已经终止，无法再处理任何信号，所以它就只能是孤魂野鬼，飘在操作系统进程表里，直到系统重启。</p><p>在 <code>ps</code> 命令的输出中，僵尸状态的进程标识为 <code>Z</code>。系统会为僵尸状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_ZOMBIE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有同事问到 &lt;code&gt;top&lt;/code&gt; 命令里的 &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;zombie&lt;/code&gt; 等进程状态分别是什么意思。于是借这个机会写一下 Linux 系统里的进程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
      <category term="Process" scheme="https://liam.page/tags/Process/"/>
    
  </entry>
  
  <entry>
    <title>向 non-bare 仓库的检出分支推送提交</title>
    <link href="https://liam.page/2020/01/09/git-push-to-a-non-bare-repository-with-checked-out-branch/"/>
    <id>https://liam.page/2020/01/09/git-push-to-a-non-bare-repository-with-checked-out-branch/</id>
    <published>2020-01-09T12:59:13.000Z</published>
    <updated>2020-01-10T07:11:06.810Z</updated>
    
    <content type="html"><![CDATA[<p>假设有本地 Git 仓库 A，而后在本地自 A 克隆仓库 B（即，在 B 的视角，A 是远程仓库，只不过物理位置在本机）。若从 B 向 A 推送提交，则 Git 可能会报错。这是因为，A 默认是 non-bare 的仓库，粗略理解即是工作区不为空；此时，从 B 向 A 推送的话，A 仓库中的内容可能和 A 工作区内容不一致。</p><a id="more"></a><p>解决该问题的办法之一，是将 A 设置为 bare 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line">mv .git ../repo.git <span class="comment"># renaming just for clarity</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -fr repo</span><br><span class="line"><span class="built_in">cd</span> repo.git</span><br><span class="line">git config --bool core.bare <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但若 A 是 <code>git svn</code> 桥接的仓库，则 Git 不允许我们将其设置为 bare 仓库。此时，应在仓库 A 执行下列代码，告知 Git 在仓库 A 接受检出分支推送时，同步修改工作区的内容。不过这样的话，我们要保证仓库 A 的工作区没有未提交的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config receive.denyCurrentBranch updateInstead</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有本地 Git 仓库 A，而后在本地自 A 克隆仓库 B（即，在 B 的视角，A 是远程仓库，只不过物理位置在本机）。若从 B 向 A 推送提交，则 Git 可能会报错。这是因为，A 默认是 non-bare 的仓库，粗略理解即是工作区不为空；此时，从 B 向 A 推送的话，A 仓库中的内容可能和 A 工作区内容不一致。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="SVN" scheme="https://liam.page/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>跳过冗余 revisions 以加速 git svn fetch</title>
    <link href="https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/"/>
    <id>https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/</id>
    <published>2020-01-09T11:41:55.000Z</published>
    <updated>2020-01-09T11:58:41.950Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 <code>git clone</code> 会消耗很长时间。使用 <code>git svn</code> 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 <code>git svn fetch</code> 会花费很长时间（可能超过 24 hours）。</p><p>如果你觉得，<code>git svn fetch</code> 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。</p><a id="more"></a><p>SVN 相较 Git 的一个优势在于它可以针对仓库里的各个子路径进行权限设置。于是，我们可以假设这样一种场景：</p><ul><li>SVN 仓库中，有例如 100,000 次修订。</li><li>你使用 <code>git svn clone -s &lt;uri of svn repository&gt;</code> 将这 10 万次修订都下载到本地，行程了一个 Git 本地仓库。</li><li>在开发的过程中，你发现你缺少某些子路径的权限，于是你找到 SVN 管理员，为你授权了这些子路径。</li><li>而后，你会使用 <code>git svn fetch</code> 来更新你的本地仓库。这时，你会发现报错 <code>&lt;file&gt; was not found in commit &lt;hash&gt;</code>。其原因在于，由于之前你的权限缺失，导致前次 <code>git svn clone</code> 以及历次 <code>git svn fetch</code> 的过程中，这些路径在 <code>git-svn</code> 看来是「空的」；但在这次 <code>git svn fetch</code> 时，这些路径突然有了东西，但是缺少相应的历史。</li><li>为了修正这个问题，有以下一些解决办法：<ul><li>干掉整个本地仓库，从头再 <code>git svn clone -s &lt;uri of svn repository&gt;</code> 一次。这相当于从 <code>r1</code> 开始重新 <code>git svn fetch</code> 一次。</li><li>使用 <code>git svn reset -p &lt;revision&gt;</code> 将本地仓库回退到一个早先的版本，然后从该版本 <code>git svn fetch</code>。需要注意的是，涉及到权限缺失的路径，必须在该 <code>&lt;revision&gt;</code> 之后创建。定位这个 <code>&lt;revision&gt;</code> 本身就很困难，更不用说若是这些路径有过移动的话，又会有一系列的问题。因此，虽然该方案相当于从 <code>&lt;revision&gt;</code> 开始重新 <code>git svn fetch</code>；能省下 <code>r1 -- &lt;revision&gt;</code> 之间的修订，但仍然十分麻烦。</li></ul></li></ul><p>在这种情况下，从头再来，似乎是唯一的选择了。而后，你终于不得不承认曾经的自己「太年轻」。</p><p>为了解决这个困局，我们不得不做一次 trade-off。既然问题的根源在于 Git 会将所有历史信息下载到本地，若是我们能舍弃一些过早的历史信息，只下载较近的历史，就能够绕过这个问题。为此，我们需要：</p><ul><li><code>rm -rf &lt;local repo&gt;</code>：删掉已经「失真」的本地仓库。</li><li><code>mkdir &lt;local repo&gt;</code>：建立一个空的目录。</li><li><code>cd &lt;local repo&gt;</code>：进入刚创立的目录。</li><li><code>git svn init -s &lt;uri of svn repository&gt;</code>：以 <code>git svn</code> 初始化该仓库，但不立即 <code>clone</code>。</li><li><code>git svn fetch -r &lt;revision&gt;</code>：从 <code>&lt;revision&gt;</code> 开始，拉取仓库版本信息；即舍弃从 <code>r1</code> 开始到 <code>&lt;revision&gt;</code> 结束的所有历史信息。</li></ul><p>唯独需要注意的是，如果涉及到分支操作，你必须保证你会用到的分支，都在上述 <code>&lt;revision&gt;</code> 之后创建。</p><p>如此一来，只要 <code>&lt;revision&gt;</code> 选得好，代码开始写的早。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 &lt;code&gt;git clone&lt;/code&gt; 会消耗很长时间。使用 &lt;code&gt;git svn&lt;/code&gt; 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 &lt;code&gt;git svn fetch&lt;/code&gt; 会花费很长时间（可能超过 24 hours）。&lt;/p&gt;
&lt;p&gt;如果你觉得，&lt;code&gt;git svn fetch&lt;/code&gt; 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="SVN" scheme="https://liam.page/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>解决 Git 2.24.1 与 OpenSSL 1.1.1b 的冲突</title>
    <link href="https://liam.page/2020/01/07/fix-incompatiblities-between-git-2-24-1-and-openssl-1-1-1b/"/>
    <id>https://liam.page/2020/01/07/fix-incompatiblities-between-git-2-24-1-and-openssl-1-1-1b/</id>
    <published>2020-01-07T08:58:52.000Z</published>
    <updated>2020-01-07T09:42:36.232Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为工作需要处理一些 SVN 仓库，但我还是偏好 Git。早些年就知道 Git 提供了 <code>git svn</code> 可以桥接 SVN。但今天发现公司开发机上的 Git 没有把 <code>git svn</code> 编译进来，也就是会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git svn</span><br><span class="line">git: <span class="string">'svn'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.</span><br><span class="line"></span><br><span class="line">Did you mean one of these?</span><br><span class="line">        fsck</span><br><span class="line">        mv</span><br><span class="line">        show</span><br><span class="line">        spop</span><br><span class="line">        st</span><br></pre></td></tr></table></figure><p>又因为开发机上我没有 <code>root</code> 权限，所以不得已只能自己从源码编译安装 Git。</p><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>首先是下载、解包、<code>configure</code>、<code>make</code> 一波流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.1.tar.gz</span><br><span class="line">$ tar zvxf git-2.24.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> git-2.24.1</span><br><span class="line">$ ./configure --prefix=~/.<span class="built_in">local</span> --with-libpcre1 --with-curl --with-openssl=~/.<span class="built_in">local</span>/include</span><br><span class="line">$ make -j32</span><br></pre></td></tr></table></figure><p>但在链接阶段报错，提示 <code>SSLv23_method</code>, <code>SSL_library_init</code>, <code>SSL_load_error_strings</code>, <code>sk_num</code>, <code>sk_value</code>, <code>sk_pop_free</code> 等符号不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imap-send.o: In function `verify_hostname&apos;:</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:252: undefined reference to `sk_num&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:254: undefined reference to `sk_value&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:260: undefined reference to `sk_pop_free&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:260: undefined reference to `sk_pop_free&apos;</span><br><span class="line">imap-send.o: In function `ssl_socket_connect&apos;:</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:287: undefined reference to `SSL_library_init&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:288: undefined reference to `SSL_load_error_strings&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:290: undefined reference to `SSLv23_method&apos;</span><br><span class="line">collect2: ld returned 1 exit status</span><br><span class="line">make: *** [git-imap-send] Error 1</span><br></pre></td></tr></table></figure><p>我第一反应是 OpenSSL 没安装，或是没有正确配置。但随即发现，早先在安装别的工具的时候，已经安装了 OpenSSL 1.1.1b；并且已经修改了 <code>LD_PATH</code> 和 <code>LD_LIBRARY_PATH</code> 两个环境变量，确保链接器能够正确找到相应的共享对象（动态链接库）。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>在确定 OpenSSL 已安装且能够被编译器、链接器正确找到之后，就只能去检查一下相应符号在共享对象中是否存在了。</p><p><code>SSLv23_method</code>, <code>SSL_library_init</code> 和 <code>SSL_load_error_strings</code> 显然属于 OpenSSL 当中的 <code>libssl.so</code>。于是执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nm libssl.so | grep SSL_library_init</span><br><span class="line">$ nm libssl.so | grep SSL_load_error_strings</span><br><span class="line">$ nm libssl.so | grep SSLv23_method</span><br></pre></td></tr></table></figure><p>返现返回均为空。这说明在 <code>libssl.so</code> 当中确实不存在这三个符号。<code>sk_num</code>, <code>sk_value</code> 和 <code>sk_pop_free</code> 应当位于 <code>libcrypto.so</code> 当中，检查也有同样结果。</p><p>这就令人「满头大汉」了。难道是我下载 OpenSSL 的姿势不对？经过一番检索，在一个与 Git 无关的版本库的 commit log 中，发现了这么一段话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># https://cbi-dev.igbmc.fr/niveale/tap-formatter/commit/b67a118e7a438009e5d44d0701c21d030c92aa94</span><br><span class="line">Fix: OpenSSL 1.1.0 renamed some symbols</span><br><span class="line"></span><br><span class="line">- sk_free =&gt; OPENSSL_sk_free</span><br><span class="line">- sk_num =&gt; OPENSSL_sk_num</span><br><span class="line">- sk_pop_free =&gt; OPENSSL_sk_pop_free</span><br><span class="line">- sk_value =&gt; OPENSSL_sk_value</span><br><span class="line">- evp_md_ctx_create =&gt; evp_md_ctx_new</span><br><span class="line">- evp_md_ctx_destroy =&gt; evp_md_ctx_free</span><br></pre></td></tr></table></figure><p>原来，OpenSSL 自 1.1.0 开始，修改了部分 API 的名称，导致部分符号名发生了变化。此时，大胆猜想：<code>SSL_*</code> 等三个未定义的符号也是因为类似原因导致的。小心求证如下：</p><ul><li>首先，在 <code>libssl.so</code> 当中检索含有 <code>init</code> 的符号，发现有名为 <code>OPENSSL_init_ssl</code> 的符号。看名字，其作用应该与 <code>SSL_library_init</code> 相近。</li><li>而后，在 Google 上检索 <code>SSL_library_init OPENSSL_init_ssl</code>，发现果然，也是在 1.1.0 版本中，该 API 发生了修改；并且 <code>OPENSSL_init_ssl</code> 包括了原先 <code>SSL_library_init</code> 和 <code>SSL_load_error_strings</code> 二者的功能。</li><li>最后，需要确定 <code>SSLv23_method</code> 的对应是什么。在 Google 上检索 <code>SSLv23_method deprecated</code>，发现在 <a href="https://www.openssl.org/docs/man1.1.0/man3/SSLv23_method.html" target="_blank" rel="noopener">OpenSSL 官方文档</a>有提到，它已为 <code>TLS_method</code> 所代替。</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是检索 Git 代码中所有用到这些过时符号的代码，将他们分别修改为对应的新版本。之后编译、链接正常。最后，再顺手提交<a href="https://github.com/gitgitgadget/git/pull/516" target="_blank" rel="noopener">一个 patch</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为工作需要处理一些 SVN 仓库，但我还是偏好 Git。早些年就知道 Git 提供了 &lt;code&gt;git svn&lt;/code&gt; 可以桥接 SVN。但今天发现公司开发机上的 Git 没有把 &lt;code&gt;git svn&lt;/code&gt; 编译进来，也就是会报错：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git svn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git: &lt;span class=&quot;string&quot;&gt;&#39;svn&#39;&lt;/span&gt; is not a git &lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;. See &lt;span class=&quot;string&quot;&gt;&#39;git --help&#39;&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Did you mean one of these?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fsck&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        show&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        spop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;又因为开发机上我没有 &lt;code&gt;root&lt;/code&gt; 权限，所以不得已只能自己从源码编译安装 Git。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="OpenSSL" scheme="https://liam.page/tags/OpenSSL/"/>
    
      <category term="Imcompatibilities" scheme="https://liam.page/tags/Imcompatibilities/"/>
    
      <category term="Symbol" scheme="https://liam.page/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 记录键盘事件</title>
    <link href="https://liam.page/2019/12/06/record-keyboard-events-by-python/"/>
    <id>https://liam.page/2019/12/06/record-keyboard-events-by-python/</id>
    <published>2019-12-06T09:25:10.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天也不知道是想了什么，突然就想要试试看我有效击键时的手速到底有多快。为此，需要记录下来击键的记录。于是找到了 Python 的 <code>keyboard</code> 库。</p><a id="more"></a><p>安装非常简单，只需执行 <code>pip install keyboard</code> 即可。而后保存并执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyboard</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">keyboard.hook(<span class="keyword">lambda</span> e: print(e, time.clock()))</span><br><span class="line">keyboard.wait(<span class="string">'Ctrl'</span>)</span><br></pre></td></tr></table></figure><p>这里，我们利用 <code>keyboard.hook</code> 为每个键盘事件下钩子，并且执行其中的 <code>lambda</code> 函数。<code>keyboard.wait()</code> 的作用是阻塞进程，直到按下 <code>Ctrl</code> 键。</p><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">KeyboardEvent(g down) 4.450576466</span><br><span class="line">KeyboardEvent(g up) 4.505627652</span><br><span class="line">KeyboardEvent(i down) 4.510628277</span><br><span class="line">KeyboardEvent(t down) 4.570555791</span><br><span class="line">KeyboardEvent(i up) 4.580582066</span><br><span class="line">KeyboardEvent(space down) 4.581583136</span><br><span class="line">KeyboardEvent(p down) 4.630656009</span><br><span class="line">KeyboardEvent(t up) 4.671189791</span><br><span class="line">KeyboardEvent(space up) 4.693182730</span><br><span class="line">KeyboardEvent(p up) 4.705543556</span><br><span class="line">KeyboardEvent(u down) 4.705867633</span><br><span class="line">KeyboardEvent(s down) 4.730623806</span><br><span class="line">KeyboardEvent(u up) 4.750832241</span><br><span class="line">KeyboardEvent(s up) 4.795770594</span><br><span class="line">KeyboardEvent(h down) 4.810543976</span><br><span class="line">KeyboardEvent(h up) 4.86056459</span><br><span class="line">KeyboardEvent(enter down) 4.920739469</span><br><span class="line">KeyboardEvent(enter up) 4.930514276</span><br><span class="line">KeyboardEvent(ctrl down) 7.030813124</span><br></pre></td></tr></table></figure><p>从中可见，在敲下 <code>git push&lt;enter&gt;</code> 这条命令的过程中，发生了多次击键交错的现象（即上一个按键还未完全弹起，下一个按键就已经触发）。这是在高速击键时很常见的现象。此外，输入到执行这条命令，总共花费了不到 <code>0.5 s</code> 的时间，不愧曾经单身多年 <code>←_←</code>。</p><blockquote><p>你的手速如何呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天也不知道是想了什么，突然就想要试试看我有效击键时的手速到底有多快。为此，需要记录下来击键的记录。于是找到了 Python 的 &lt;code&gt;keyboard&lt;/code&gt; 库。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="Keyboard" scheme="https://liam.page/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>二分类的评价指标</title>
    <link href="https://liam.page/2019/12/05/evaluation-of-binary-classification/"/>
    <id>https://liam.page/2019/12/05/evaluation-of-binary-classification/</id>
    <published>2019-12-05T12:34:14.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。</p><a id="more"></a><h2 id="混淆矩阵（confusion-matrix）"><a href="#混淆矩阵（confusion-matrix）" class="headerlink" title="混淆矩阵（confusion matrix）"></a>混淆矩阵（confusion matrix）</h2><p>二分类模型的基本工作是这样的：</p><ul><li>将样本 <code>$\{\vec x, y\}$</code> 输入二分类模型 <code>$\mathcal C$</code>，得到模型输出得分 <code>$s$</code>；</li><li>将模型输出得分 <code>$s$</code> 映射为最终结果 <code>$\hat y = M(s)$</code>。</li></ul><p>对于给定的模型 <code>$\mathcal C$</code> 和映射函数 <code>$M(\cdot)$</code>，根据样本真实分类 <code>$y$</code> 和模型预测分类 <code>$\hat y$</code> 的组合，定义如下四种情况：</p><ul><li>真阳性（True Positive，简称：TP）：表示样本是阳性 <code>$y = 1$</code>，并且模型也预测为阳性 <code>$\hat y = 1$</code>。</li><li>假阳性（False Positive，简称：FP）：表示样本是阴性 <code>$y = 0$</code>，但模型预测为阳性 <code>$\hat y = 1$</code>。</li><li>真阴性（True Negative，简称：TN）：表示样本是阴性 <code>$y = 0$</code>，并且模型也预测为阴性 <code>$\hat y = 0$</code>。</li><li>假阴性（False Negative，简称：FN）：表示样本是阳性 <code>$y = 1$</code>，但模型预测为阴性 <code>$\hat y = 0$</code>。</li></ul><p>又根据样本真实分类 <code>$y$</code> 和模型预测分类 <code>$\hat y$</code> 的实际情况，定义如下四个变量：</p><ul><li><code>$P = TP + FN$</code>：表示所有真实分类为阳性的样本的数量。</li><li><code>$N = FP + TN$</code>：表示所有真实分类为阴性的样本的数量。</li><li><code>$P&#39; = TP + FP$</code>：表示所有预测分类为阳性的样本的数量。</li><li><code>$N&#39; = TN + FN$</code>：表示所有预测分类为阴性的样本的数量。</li></ul><p>于是可绘制如下混淆矩阵：</p><table align="center"><tbody><tr><th colspan="2" rowspan="2">&nbsp;</th><th colspan="2" align="center">真实值</th><th rowspan="2">总<br>数</th></tr><tr><th><i>1</i></th><th><i>0</i></th></tr><tr><th rowspan="2" valign="middle">预<br>测<br>输<br>出</th><th valign="middle" style="padding:0.5em;"><i>1</i></th><th style="padding:0.5em;">真阳性<br>(TP)</th><th style="padding:0.5em;">假阳性<br>(FP)</th><th style="padding:0.5em;">P'</th></tr><tr><th valign="middle" style="padding:0.5em;"><i>0</i></th><th style="padding: 0.5em;">假阴性<br>(FN)</th><th style="padding:0.5em;">真阴性<br>(TN)</th><th style="padding:0.5em;">N'</th></tr><tr><th colspan="2" style="padding:0.5em;">总数</th><th align="center">P</th><th align="center">N</th><th></th></tr></tbody></table><h2 id="由混淆矩阵衍生的指标"><a href="#由混淆矩阵衍生的指标" class="headerlink" title="由混淆矩阵衍生的指标"></a>由混淆矩阵衍生的指标</h2><p>混淆矩阵是二分类模型与其数据相互作用得到的最基本的结果。建立在混淆矩阵之上，我们可以定义出一系列的指标，来衡量二分类模型的性能。这里对常见的指标及需要关注的要点罗列如下。</p><ul><li><strong>真阳性率</strong>（true positive rate，TPR）/<strong>敏感度</strong>（sensitivity）/<strong>召回率</strong>（recall rate）：在二分类问题中，真阳性率、敏感度和召回率三个名词对应着同一个概念；它表示正样本中被预测为正样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$TPR = TP / P = TP / (TP + FN).$</code></li><li><strong>真阴性率</strong>（true negative rate，TNR）/<strong>特异度</strong>（specificity）：在二分类问题中，真阴性率和特异度对应着同一个概念；它表示负样本中被预测为负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$TNR = TN / N = TN / (TN + FP).$</code></li><li><strong>假阳性率</strong>（false positive rate，FPR）：它表示负样本中被错误地预测为正样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FPR = FP / N = FP / (TN + FP) = 1 - TNR.$</code></li><li><strong>假阴性率</strong>（false negative rate，FNR）：它表示正样本中被错误滴预测为负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FNR = FN / P = FN / (TP + FN) = 1 - TPR.$</code></li><li><strong>阳性预测值</strong>（positive predictive value，PPV）/<strong>精确率</strong>（percision）：它表示被预测为正的样本中正样本的占比。在二分类问题中，阳性预测值和精确率对应着同一个概念；一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$PPV = TP / (TP + FP) = TP / P&#39;.$</code></li><li><strong>阴性预测值</strong>（negative predictive value，NPV）：它表示被预测为负的样本中负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$NPV = TN / (TN + FN) = TN / N&#39;.$</code></li><li><strong>假发现率</strong>（false detective rate，FDR）：它表示被预测为正的样本中负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FDR = FP / (TP + FP) = FP / P&#39; = 1 - PPV.$</code></li><li><strong>准确率</strong>（accuracy，ACC）：它表示全体样本中预测正确的样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$ACC = (TP + TN) / (P + N).$</code></li><li><strong>F1 值</strong>（F1-score）：它是召回率（真阳性率）和精确率（阳性预测值）的调和平均。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$F1 = 2TP / (P + P&#39;).$</code></li><li><strong>约登指数</strong>（Youden&#39;s J statistic）：一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$J = TPR + TNR - 1.$</code></li></ul><h3 id="准确率悖论（Accuracy-Paradox）"><a href="#准确率悖论（Accuracy-Paradox）" class="headerlink" title="准确率悖论（Accuracy Paradox）"></a>准确率悖论（Accuracy Paradox）</h3><p>准确率表示全体样本中，模型预测正确的样本之占比。这是一个非常 intuitive 的指标，和我们一般的认知很相符。但准确率有一个很大的问题：当正负例极不平衡时，即当 <code>$P \gg N$</code> 或 <code>$N \gg P$</code> 时，准确率会被样本量占优的类别主导从而失真。一般我们认为正例是重要的，于是这个问题在负例数量远多于正例数量时，显得尤为严重。欺诈检测、癌症检测等场合，均属于这种情况。</p><p>举个栗子。假设验证集中共有 100 个样本，其中有 95 个负例和 5 个正例。若模型对所有输入都认定为负例，则这种情况下有 <code>$ACC = (TP + TN) / (P + N) = (0 + 95) / (5 +95) = 0.95$</code>。看起来准确率很高，但这个模型一个正例都分辨不出来，没有实际价值。</p><p>单独用 TPR、TNR、FPR、FNR、PPV、NPV、FDR 这些指标，也会遇到类似的困难。</p><h3 id="召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值"><a href="#召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值" class="headerlink" title="召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值"></a>召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值</h3><p>计算召回率和精确率时的分子都是 TP，不同在于分母。召回率的分母是 <code>$P$</code>，而精确率的分母是 <code>$P&#39;$</code>。这也就是说，召回率是相对真实样本而言的，精确率是相对模型预测为正例的样本而言的。</p><p>举个栗子。</p><ul><li>假设验证集当中有 100 个正例，你的模型将这 100 个正例中的 40 个预测为正例，则你的模型的召回率是 40%。</li><li>假设你的模型一共预测了 50 个正例，其中 40 个确实是正例（还有 10 个是负例，即 FP 的情形），则你的模型精确率是 80%。</li></ul><p>显然，若要提高召回率，则模型会变得「贪婪」，于是犯错的可能性就会变大，也就是精确率下降；若要提高精确率，则模型会变得「保守」，此时模型能够覆盖的正例就少，于是召回率下降。考虑到召回率和精确率之间「跷跷板」的关系，人们发明了 F1 值这个指标，并将其定义为召回率和精确率的调和平均数，从而能够比较容易地在召回率和精确率方面取得平衡：</p><p><code>$$F1 = \frac{2}{\frac{1}{TPR} + \frac{1}{PPV}} = \frac{2TP}{P + P&#39;}.$$</code></p><h3 id="敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数"><a href="#敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数" class="headerlink" title="敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数"></a>敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数</h3><p>从数学上将，召回率和精确率之间跷跷板一般的关系来自于精确率计算的分母是 <code>$P&#39;$</code> 而非 <code>$P$</code>。因为当模型发生变化的时候，<code>$P&#39;$</code> 就会发生变化。所以你无法在提升召回率的时候，保证精确率不变；反之亦然。</p><p>既然如此，我们寻找分母为 <code>$P$</code> 或 <code>$N$</code> 的指标，是否就能解决这个问题了呢？按照这个思路，人们定义了敏感度和特异度的概念。</p><ul><li>敏感度就是召回率，它是真阳性率的有一个马甲。</li><li>特异度是模型在负例上的召回率，因此它是真阴性率的马甲。</li></ul><p>因为敏感度和特异度分别是以验证集中正例数量和负例数量为分母的，所以它们：</p><ul><li>不存在必然的跷跷板关系；</li><li>不受不平衡数据的影响。</li></ul><p>这就「很<del>理中客</del>」了嘛。为了统一考量模型的敏感度和特异度，即为了统一考量模型在正负例上的召回率，人们又定义了约登指数。</p><p><code>$$J = TPR + TNR - 1.$$</code></p><h2 id="曲线及其-AUC（Area-under-Curve，曲线下面积）"><a href="#曲线及其-AUC（Area-under-Curve，曲线下面积）" class="headerlink" title="曲线及其 AUC（Area under Curve，曲线下面积）"></a>曲线及其 AUC（Area under Curve，曲线下面积）</h2><p>上面的讨论都基于一个假设，即映射函数 <code>$M(\cdot)$</code> 是确定的。如果映射函数发生变化，模型对样本的最终预测 <code>$\hat y$</code> 就会发生变化，进而影响到混淆矩阵，最终影响到各个评价指标。因此，在这个意义下，对于确定的模型，各个指标将是映射函数的函数。</p><p>一般来说，对于二分类问题，映射函数是一个简单的分段函数。于是，各个指标将是分段阈值 <code>$t$</code> 的函数。</p><p><code>$$M(s) = \begin{cases} 1 &amp; s &gt; t, \\ 0 &amp; \text{otherwise}. \end{cases}$$</code></p><p>对于需要取舍的指标对，我们可以做如下操作，得到一条曲线（折线）：</p><ul><li>逐渐改变阈值 <code>$t$</code>，得到序列 <code>$\bigl\{\bigl(A(t), B(t)\bigr)\bigr\}$</code>。</li><li>将指标 A 和指标 B 分别作为平面直角坐标系的横轴和纵轴。</li><li>将序列对应的点，绘制在平面直角坐标系中。</li><li>顺序连接这些点。</li></ul><p>对于真阳性率（敏感度，召回率）和假阳性率（1 - 特异度），这条曲线是接收者操作特征曲线（receiver operating characteristic curve）。对于召回率和精确率，这条曲线是精确率-召回率曲线（PR-Curve）。</p><h3 id="接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）"><a href="#接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）" class="headerlink" title="接收者操作特征曲线（receiver operating characteristic curve, ROC）"></a>接收者操作特征曲线（receiver operating characteristic curve, ROC）</h3><p>一条典型的 ROC 如下图所示。</p><p><img alt="ROC" data-src="/uploads/images/MachineLearning/roc.png"></p><p>这里，横坐标代表假阳性率 FPR，它是阈值 <code>$t$</code> 的函数，我们记作 <code>$F(t)$</code>；纵坐标代表真阳性率 TPR，它也是阈值 <code>$t$</code> 的函数，我们记作 <code>$T(t)$</code>。从图中很明显能看出 FPR 和 TPR 之间「鱼和熊掌不可兼得」的关系。曲线下面积（AUC）越大，也就是曲线约接近左上角，说明模型就越理想。那么 ROC 的 AUC 是什么含义呢？</p><p>我们将 FPR 看做是一个累积分布函数，即</p><p><code>$$F(t) = P(\hat y \geqslant t \mid y = 0),$$</code></p><p>因此 FPR 相对 <code>$t$</code> 的偏导数应当是一个概率密度函数，即</p><p><code>$$\frac{\partial F(t)}{\partial t} = P(\hat y = t \mid y = 0).$$</code></p><p>我们将 TPR 看做是 FPR 的函数，即 <code>$T(t) = T(F) = T(F^{-1}(F(t)))$</code>。因此有</p><p><code>$$\begin{aligned}\text{AUC} = {}&amp; \int_{0}^{1} T(F)\,\mathop{}\mathrm{d}F \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \mid y = 1)\cdot\frac{\partial F(t)}{\partial t}\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \mid y = 1)\cdot P(\hat y&#39; = t \mid y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \wedge \hat y&#39; = t \mid y = 1 \wedge y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; \hat y&#39; \wedge \hat y&#39; = t \mid y = 1 \wedge y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; P(\hat y &gt; \hat y&#39; \mid y = 1 \wedge y&#39; = 0). \\\end{aligned}$$</code></p><p>于是我们知道，ROC 的 AUC 表示任选正负例对 <code>$\bigl((\vec x_1, y_1 = 1), (\vec x_2, y_2 = 0)\bigr)$</code>，模型输出得分中，正例得分大于负例得分的概率 <code>$P\bigl(\mathcal C(\vec x_1) &gt; \mathcal C(\vec x_2)\bigr)$</code>。换言之，ROC 的 AUC 反映了模型的排序能力。这在 CTR 预估排序的场景下，非常有用。</p><blockquote><p>关于这一点，<a href="https://madrury.github.io/jekyll/update/statistics/2017/06/21/auc-proof.html" target="_blank" rel="noopener">这里</a>有一个有趣的集合解释。<br>另外，值得一提的是，一般默认的 AUC 指的是 AUC of ROC。</p></blockquote><h3 id="精确率-召回率曲线（precision-recall-curve-PR-Curve）"><a href="#精确率-召回率曲线（precision-recall-curve-PR-Curve）" class="headerlink" title="精确率-召回率曲线（precision-recall curve, PR-Curve）"></a>精确率-召回率曲线（precision-recall curve, PR-Curve）</h3><p>一条典型的 PR-Curve 如下图所示。</p><p><img alt="PR-Curve" data-src="/uploads/images/MachineLearning/pr-curve.jpg"></p><p>从中很明显能看出来之前说的「跷跷板」关系。曲线下面积（AUC）越大，也就是曲线约接近右上角，说明模型就越理想。但这种情况，在实际工作中基本是不可能出现的。因此我们需要根据实际问题进行取舍（确定一个合适的 <code>$t$</code>）。</p><p>对于正例显著少于负例的情况，人们往往追求尽可能高的召回率。因此，可以预先设定一个精确率下限，然后在这个下限之上，寻找召回率最高的点。比如在上图中，若设定可接受的最低精确率是 0.8，则召回率最高大约是 0.55；若设定可接受的最低精确率是 0.6，则召回率最高大约是 0.92。对于正例显著多于负例的情况，人们往往追求尽可能高的精确率。此时可以反向操作，选取合适的 <code>$t$</code>。</p><p>同样的问题：那么 PR-Curve 的 AUC 是什么含义呢？利用类似的思路可得：PR-Curve 的 AUC 表示任选一个正例 <code>$(\vec x_1, y_1 = 1)$</code>，而后任选一个满足 <code>$\mathcal C(\vec x_2) &gt; \mathcal C(\vec x_1)$</code> 的样本 <code>$(\vec x_2, y_2)$</code>，该样本为正样本的概率 <code>$P\bigl(y_2 = 1 \mid y_1 = 1 \wedge \mathcal C(\vec x_2) &gt; \mathcal C(\vec x_1)\bigr)$</code>。</p><h3 id="ROC-与-PR-Curve-的比较"><a href="#ROC-与-PR-Curve-的比较" class="headerlink" title="ROC 与 PR-Curve 的比较"></a>ROC 与 PR-Curve 的比较</h3><p><img alt="ROC in skewed datasets" data-src="/uploads/images/MachineLearning/roc-imbalanced.webp"></p><p>由于 ROC 的横纵坐标分别表示 FPR 和 TPR，二者的分母完全隔开，从而使得 AUC of ROC 不受正负样本比例的影响（如上图所示）。这看起来是个好事，因为它在倾斜的数据集上依然保持了稳定的物理意义（类似准确率）。但是，另一方面，这说明在负例数量远大于正例数量的极度倾斜的数据集上，AUC of ROC 可能失真。在这种情况下，PR-Curve 能够更好地反映出模型的性能。</p><h2 id="点击率预估模型中的-AUC-与-gAUC（grouped-AUC）"><a href="#点击率预估模型中的-AUC-与-gAUC（grouped-AUC）" class="headerlink" title="点击率预估模型中的 AUC 与 gAUC（grouped AUC）"></a>点击率预估模型中的 AUC 与 gAUC（grouped AUC）</h2><p>在个性化推荐、广告中，用作 rank 的模型，通常是点击率预估模型。此类模型将问题抽象为一个二分类问题，用模型预测用户是否会点击一个物品（推荐的内容或者广告）。由于该场景的目标是对物品进行排序，所以天然适合使用 AUC 作为评价指标。</p><p>但这有一个问题，我们通过例子来说明。</p><p>假设样本集中有 A 和 B 两个用户，分别都有 10 个物品。在这分别的 10 个物品当中，又分别有 5 个正例和 5 个负例。我们将这些正例和负例记为 A+/B+/A-/B-。假设将点击率预估模型的输出从高到低排序，结果是 A+/A-/B+/B-。此时，将两个用户的正负例混合起来看，AUC 不会很高。因为模型将部分负例（A-）排在了部分正例（B+）之前。但是，对于 A 和 B 分别来说，他们能观察到的正例均排在负例之前。也就是说，此时 AUC 不高，但实际效果很好。</p><p>这个问题可以这样解释：在模型预测分数越集中的区域，用户之间的细微差异导致的正负样本差异的影响就越大。因此，AUC 在这些区域可能会失真。此时，引入分组 AUC（grouped AUC, gAUC）可以缓解这一问题。</p><p><code>$$\text{gAUC} := \frac{\sum_{i = 1}^{n}(\omega_{i}\cdot\text{AUC}_{i})}{\sum_{i = 1}^{n}\omega_{i}}.$$</code></p><p>这里，<code>$\text{AUC}_{i}$</code> 表示第 <code>$i$</code> 个分组内的 AUC；<code>$\omega_{i}$</code> 则表示该组权重。对于点击率预估的场景，每个用户对应一个分组，该用户的权重可设为该用户在样本集当中可见的曝光数量。即有</p><p><code>$$\text{gAUC} := \frac{\sum_{i = 1}^{n}(\#\text{impression}_{i}\cdot\text{AUC}_{i})}{\sum_{i = 1}^{n}\#\text{impression}_{i}}.$$</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Classification" scheme="https://liam.page/tags/Classification/"/>
    
      <category term="Binary" scheme="https://liam.page/tags/Binary/"/>
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>Alias Method: 在常数时间复杂度内非均匀地随机抽取元素</title>
    <link href="https://liam.page/2019/12/02/non-uniform-random-choice-in-constant-time-complexity/"/>
    <id>https://liam.page/2019/12/02/non-uniform-random-choice-in-constant-time-complexity/</id>
    <published>2019-12-02T04:54:56.000Z</published>
    <updated>2019-12-24T11:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章要讨论的问题很简单：给定一个集合，要你在常数时间复杂度内，从中以给定的概率分布随机抽取其中的元素。</p><a id="more"></a><h2 id="问题的抽象"><a href="#问题的抽象" class="headerlink" title="问题的抽象"></a>问题的抽象</h2><p>这里我们以 C++ 语言描述，我们需要实现这样一个可调用的类模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values_;</span><br><span class="line">  <span class="comment">// other internal assets</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob);</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，构造函数完成初始化工作，函数调用运算符完成随机抽取元素的工作。</p><h2 id="Trival-版本"><a href="#Trival-版本" class="headerlink" title="Trival 版本"></a>Trival 版本</h2><p>最平凡的想法可以是：</p><ol><li>根据概率分布计算累积分布，将 $[0, 1]$ 分成若干段；</li><li>然后通过一个 $[0, 1]$ 之间的均匀随机生成器，随机生成一个 $[0, 1]$ 之间的浮点数；</li><li>最后通过<strong>判断</strong>随机数落在哪一个分段中，输出相应的元素。</li></ol><p>这里的 (1) 和 (2) 都可以在常数时间内完成，(3) 最快可以用二分或者二叉搜索树的方法在对数时间内完成。这里实现一版利用二分查找的方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;         values_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;    cumulative_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::random_device   rd_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mt19937         gen_&#123;rd_()&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; dis_&#123;<span class="number">0.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob) :</span><br><span class="line">      values_(val), cumulative_(generate_cumulative(prob)) &#123;</span><br><span class="line">    assert(val.size() == prob.size());</span><br><span class="line">    assert(<span class="built_in">std</span>::<span class="built_in">fabs</span>(<span class="number">1.0</span> - cumulative_.back()) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon());  <span class="comment">// *</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> rand = dis_(gen_);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> idx  = bsearch_last_not_greater_than(cumulative_.begin(), cumulative_.end(), rand);</span><br><span class="line">    assert(idx &lt; values_.size());</span><br><span class="line">    <span class="keyword">return</span> values_[idx];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; generate_cumulative(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; cumulative;</span><br><span class="line">    cumulative.reserve(prob.size() + <span class="number">1</span>);</span><br><span class="line">    cumulative.emplace_back(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::transform(prob.begin(), prob.end(), <span class="built_in">std</span>::back_inserter(cumulative),</span><br><span class="line">        [&amp;](<span class="keyword">const</span> <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> p + cumulative.back(); &#125; );</span><br><span class="line">    <span class="keyword">return</span> cumulative;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">iter_t</span>,</span><br><span class="line">            <span class="keyword">typename</span> <span class="keyword">value_t</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;<span class="keyword">iter_t</span>&gt;::value_type,</span><br><span class="line">            <span class="keyword">typename</span> <span class="keyword">binpred_t</span> = <span class="built_in">std</span>::less&lt;<span class="keyword">value_t</span>&gt;&gt;</span><br><span class="line">  <span class="keyword">size_t</span> bsearch_last_not_greater_than(<span class="keyword">const</span> <span class="keyword">iter_t</span> begin,</span><br><span class="line">                                       <span class="keyword">const</span> <span class="keyword">iter_t</span> end,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="keyword">value_t</span> target,</span><br><span class="line">                                          <span class="keyword">binpred_t</span> binpred = <span class="keyword">binpred_t</span>()) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">iter_t</span> first = begin, last = end;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      <span class="keyword">iter_t</span> mid = first + <span class="built_in">std</span>::distance(first, last) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">not</span>(binpred(target, *mid)) <span class="keyword">and</span></span><br><span class="line">            (<span class="built_in">std</span>::next(mid) == last <span class="keyword">or</span> binpred(target, *(<span class="built_in">std</span>::next(mid))))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::distance(begin, mid);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binpred(target, *mid)) &#123;</span><br><span class="line">        last = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first = <span class="built_in">std</span>::next(mid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probs&#123;<span class="number">0.05</span>, <span class="number">0.25</span>, <span class="number">0.35</span>, <span class="number">0.35</span>&#125;;</span><br><span class="line"></span><br><span class="line">  discrete_random_variable&lt;<span class="keyword">int</span>&gt; drv&#123;values, probs&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">400000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = drv();</span><br><span class="line">    assert(<span class="built_in">std</span>::find(values.begin(), values.end(), x) != values.end());</span><br><span class="line">    ++counter[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> pair : counter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">"["</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">": \t"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != pair.second / <span class="number">2500</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Walker-Vose-Alias-Method"><a href="#Walker-Vose-Alias-Method" class="headerlink" title="Walker-Vose Alias Method"></a>Walker-Vose Alias Method</h2><p>平凡的解法，效率最高也只能做到对数时间复杂度。不过，既然目标很明确，希望能在「常数时间」内完成任务；那我们就思考一下，有什么类似的场景，可以在常数时间内解决的。显而易见，在标准库设施 <code>std::uniform_int_distribution</code> 的帮助下，对于均匀随机采样，我们可以在常数时间内完成任务。因此，若能在常数时间内，完成均匀和到非均匀的映射，我们就可以借助它来完成任务。</p><p>回过头来看「效率最高也只能做到对数时间复杂度」这句话。在目前用到的信息的条件下，这句话是正确的。也就是，在第 (3) 步在没有其他辅助的情况下，对数时间复杂度已经是最优解。因此，若想要继续优化，就必须「找其他辅助」。</p><p>我们注意用 <code>*</code> 标注出来的断言。在平凡的解法中，概率分布加和为 1 这一性质，我们只是用来验证概率分布合法，而没有用到它来辅助计算。为了用到这一性质，我们需要注意到以下一些事实：</p><ul><li>虽然非均匀分布的平凡解法最好能做到对数时间复杂度，但对于非均匀的伯努利实验（随机变量可能取值只有 2 种），我们仍能在<strong>常数时间</strong>内解决问题。</li><li>若随机变量的取值可能有 $k$ 个，那必然有部分取值的概率小于 $\frac{1}{k}$，同时有另一些不小于 $\frac{1}{k}$。</li><li>我们可以通过<strong>拆借</strong>的方法，把概率大于 $\frac{1}{k}$ 的部分借给概率小于 $\frac{1}{k}$ 的部分，使得所有取值上的概率都恰好等于 $\frac{1}{k}$；从而使非均匀采样问题变成均匀采样问题。</li></ul><p>经过上网查询，这个算法已经被发明过了，它叫做 <a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">Walker-Vose Alias Method</a>。下面给出它的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; alias_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::random_device   rd_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mt19937         gen_&#123;rd_()&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; real_dis_&#123;<span class="number">0.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">size_t</span>&gt;  int_dis_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; vals, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; probs) :</span><br><span class="line">      values_(vals), alias_(generate_alias_table(probs)), int_dis_(<span class="number">0</span>, probs.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    assert(vals.size() == probs.size());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> sum = <span class="built_in">std</span>::accumulate(probs.begin(), probs.end(), <span class="number">0.0</span>);</span><br><span class="line">    assert(<span class="built_in">std</span>::<span class="built_in">fabs</span>(<span class="number">1.0</span> - sum) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> idx  = int_dis_(gen_);</span><br><span class="line">    <span class="keyword">if</span> (real_dis_(gen_) &gt;= alias_[idx].first <span class="keyword">and</span></span><br><span class="line">          alias_[idx].second != <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max()) &#123;</span><br><span class="line">      <span class="keyword">return</span> values_[alias_[idx].second];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> values_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; generate_alias_table(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; probs) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> sz = probs.size();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; alias(sz, &#123;<span class="number">0.0</span>, <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max()&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">size_t</span>&gt;  small, large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != sz; ++i) &#123;</span><br><span class="line">      alias[i].first = sz * probs[i];</span><br><span class="line">      <span class="keyword">if</span> (alias[i].first &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        small.push(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span>(small.empty()) <span class="keyword">and</span> <span class="keyword">not</span>(large.empty())) &#123;</span><br><span class="line">      <span class="keyword">auto</span> s = small.front(), l = large.front();</span><br><span class="line">      small.pop(), large.pop();</span><br><span class="line">      alias[s].second = l;</span><br><span class="line">      alias[l].first -= (<span class="number">1.0</span> - alias[s].first);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (alias[l].first &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        small.push(l);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large.push(l);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> alias;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probs&#123;<span class="number">0.05</span>, <span class="number">0.25</span>, <span class="number">0.35</span>, <span class="number">0.35</span>&#125;;</span><br><span class="line"></span><br><span class="line">  discrete_random_variable&lt;<span class="keyword">int</span>&gt; drv&#123;values, probs&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">400000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = drv();</span><br><span class="line">    assert(<span class="built_in">std</span>::find(values.begin(), values.end(), x) != values.end());</span><br><span class="line">    ++counter[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> pair : counter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">"["</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">": \t"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != pair.second / <span class="number">2500</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章要讨论的问题很简单：给定一个集合，要你在常数时间复杂度内，从中以给定的概率分布随机抽取其中的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Random" scheme="https://liam.page/tags/Random/"/>
    
      <category term="Choice" scheme="https://liam.page/tags/Choice/"/>
    
  </entry>
  
  <entry>
    <title>期权和风险对冲</title>
    <link href="https://liam.page/2019/11/24/option-and-hedge/"/>
    <id>https://liam.page/2019/11/24/option-and-hedge/</id>
    <published>2019-11-24T07:49:36.000Z</published>
    <updated>2019-11-28T10:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在<a href="https://www.youtube.com/channel/UC5RtC9dKUJ9noJ4C6N4XnmQ" target="_blank" rel="noopener">跟我一起来谈钱</a>这个频道里学了不少知识，特别感谢薇姐姐在繁忙工作之余还给我们科普金融经济基本常识，让我受益良多。</p><p>这里把学习到的关于期权和对冲的知识记录下来。</p><a id="more"></a><h2 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h2><p>期权（option）是一种金融衍生品。其英文 option 的意思就是「选择」，于是，顾名思义期权是一种选择交易与否的权利。期权分为两大类，买权（call option；又称：看涨期权、认购期权）和卖权（put option；又称：看空期权、认沽期权）。对期权的买卖分别称之为 long 和 short。例如，买入卖权称之为 long a put option；卖出买权称之为 short a call option。</p><p>期权的核心要素有以下一些：</p><ul><li>标的物（underlying）：即选择是否交易的东西。通常是有价证券（security；例如：股票）。</li><li>行权价（exercise price / strike price）：即交易标的物时的价格。</li><li>履约日期（maturity date / expiration date）：即指定的交易日期（European Option）或指定的期权失效日期（American Option）。对于欧式期权来说，交易只能选择发生在履约日；对于美式期权来说，交易可以发生在不晚于履约日的任何一天。</li></ul><p>以买权为例。假设你看好一只股票（现价 100），认为该股票在未来一段时间内会涨。那么你可以：</p><ul><li>买入该股票，待涨后（比如涨到 110）卖出（净赚 10）；</li><li>买入该股票的期权（花费 3，行权价 110），当股票在履约日之前（针对美式期权）超过 break-even price（113）之后买入该股票（净赚 <code>price - 103</code>）。</li></ul><p>那么现在问题来了。既然你看好一只股票，那为什么不直接买，还要多此一举先买期权再购入呢？最常见的就是为了对冲（hedge，接下来要讲）而不是为了拥有（exposure）。另外，对于资金有限制、有合规及避税方面的需求等情形，购买期权而非直接购买也是有利的。</p><p>对于资金有限制的情况，比如你手头只有 300 美元，立即买入只能买入 3 股；但能够买入 100 股的期权（行权价 110）。当股价涨到 120 时，立即买入的收益率是 20%；而买入期权的做法，只需再借入 10,000 美元（可能要为此承担借款利息）买入 100 股并立即卖出，收益率可达 230%。这时，long call 成为杠杆投机的工具。——当然，若股价没有超过 break-even price，则会产生亏损。</p><h2 id="对冲"><a href="#对冲" class="headerlink" title="对冲"></a>对冲</h2><p>对冲（hedge）的本质是损失一定利益或者付出一定成本，来控制风险的手段。英文 hedge 的原意是「栅栏」，相当于 barrier，引申义是保护或防御的手段。</p><p>举个栗子来说。</p><p>如果一只股票现价 100，你看好这只股票将来的表现，因此买入股票。为了获取股票将来可能的涨幅带来的收益，你就必须承担股价下跌的风险。这种风险最大可以是 100% 的本金，即在极端情况下，股价跌至接近零。显然，你是不想承担这种风险的。于是你可以选择买入卖权。比如，你花费 3 元，买入在未来某一时间段内以 100 元卖出该股票的卖权（long a put option）。此时，你持有该股票的成本变成了 103 元。</p><p>如果股价未来上涨，超过 103 元，卖出股票你就能获利。但如果股价下跌，比如跌到了 90 元甚至 50 元、20 元，你可以选择行权，以 100 元的价格将股票卖出。在后一种情况下，你只亏损了 3 元，有效地控制了风险。</p><p>卖权的定价一般和以下一些因素有关：</p><ul><li>标的物当前价格和行权价。行权价相对标的物价格越高，卖权价格越高。</li><li>履约日期限。履约日距今时间越长，卖权价格越高。</li><li>标的物价格的波动幅度。波动幅度越大，卖权价格越高。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在&lt;a href=&quot;https://www.youtube.com/channel/UC5RtC9dKUJ9noJ4C6N4XnmQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跟我一起来谈钱&lt;/a&gt;这个频道里学了不少知识，特别感谢薇姐姐在繁忙工作之余还给我们科普金融经济基本常识，让我受益良多。&lt;/p&gt;
&lt;p&gt;这里把学习到的关于期权和对冲的知识记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Hedge" scheme="https://liam.page/tags/Hedge/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上跨版本更新 TeX Live</title>
    <link href="https://liam.page/2019/11/11/cross-release-update-TeX-Live-on-macOS/"/>
    <id>https://liam.page/2019/11/11/cross-release-update-TeX-Live-on-macOS/</id>
    <published>2019-11-11T11:24:38.000Z</published>
    <updated>2019-11-11T11:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写 LaTeX 了。嗯……原因是因为我很久没用 LaTeX 了。</p><p>因为很久没用 LaTeX，所以 Mac 上的 macTeX 也很久没更新。这不，目前版本还是 macTeX 2018，而 macTeX 2019 都出来很久了。另一方面，因为系统版本有升级，导致与 macTeX 2018 有些不兼容。于是，升级到 2019 版本变得势在必行。</p><a id="more"></a><h2 id="升级-macTeX-还是升级-TeX-Live"><a href="#升级-macTeX-还是升级-TeX-Live" class="headerlink" title="升级 macTeX 还是升级 TeX Live"></a>升级 macTeX 还是升级 TeX Live</h2><p>本质上 macTeX 是对 TeX Live 的打包封装。里面当中实际执行的，还是 TeX Live。因此，升级 TeX Live 而不升级 macTeX 可以避免下载巨大的 <code>macTeX.pkg</code>。</p><h2 id="update-tlmgr-latest"><a href="#update-tlmgr-latest" class="headerlink" title="update-tlmgr-latest"></a><code>update-tlmgr-latest</code></h2><p>一般升级，用到的命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tlmgr update --self --all --reinstall-forcibly-removed</span><br></pre></td></tr></table></figure><p>但是，跨版本升级时，它会报错。不过，它会有提示，让你下载 <code>update-tlmgr-latest</code> 来将 <code>tlmgr</code> 更新到最新版本，从而可以跨版本更新。于是我们有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh</span><br><span class="line">bash update-tlmgr-latest.sh</span><br><span class="line">tlmgr update --self --all --reinstall-forcibly-removed</span><br></pre></td></tr></table></figure><h2 id="更新语言配置"><a href="#更新语言配置" class="headerlink" title="更新语言配置"></a>更新语言配置</h2><p>上述 <code>tlmgr update</code> 在执行到最后，构建 <code>fmt</code> 文件时会报错。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I can&apos;t find file `dehypht-x-2018-03-31.tex`!</span><br></pre></td></tr></table></figure><p>检查发现，构建 <code>fmt</code> 文件时，会读取 <code>/usr/local/texlive/2018/texmf-var/tex/generic/config/language.def</code> 文件，它提到了：<code>\addlanguage{german-x-latest}{dehypht-x-2018-03-30.tex}{}{2}{2}</code>。</p><p>上网检查发现，可以用 <code>tlmgr generate language</code> 更新语言定义文件。遂执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tlmgr generate language</span><br><span class="line">fmtutil -sys --all</span><br></pre></td></tr></table></figure><p>至此，万事 OK~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没写 LaTeX 了。嗯……原因是因为我很久没用 LaTeX 了。&lt;/p&gt;
&lt;p&gt;因为很久没用 LaTeX，所以 Mac 上的 macTeX 也很久没更新。这不，目前版本还是 macTeX 2018，而 macTeX 2019 都出来很久了。另一方面，因为系统版本有升级，导致与 macTeX 2018 有些不兼容。于是，升级到 2019 版本变得势在必行。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="TeX Live" scheme="https://liam.page/tags/TeX-Live/"/>
    
  </entry>
  
  <entry>
    <title>踩坑：value to great for base</title>
    <link href="https://liam.page/2019/11/11/value-too-great-for-base-in-shell/"/>
    <id>https://liam.page/2019/11/11/value-too-great-for-base-in-shell/</id>
    <published>2019-11-11T01:57:34.000Z</published>
    <updated>2019-11-11T11:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天启动的定时任务，有几个实例挂掉了。报错提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value too great for base (error token is "08")</span><br></pre></td></tr></table></figure><a id="more"></a><p>出错的相关代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $(($&#123;hour_s&#125; + $&#123;hour_diff&#125;)) -gt 23 ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> foo bar</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这里 <code>${hour_s}</code> 是当前标定时间的小时数。形如 <code>00</code>, <code>01</code>, <code>02</code>, ..., <code>08</code>, <code>09</code>, ..., <code>23</code>。<code>${hour_diff}</code> 是需要向后处理的小时数。这段代码的意图，是判断二者相加是否大于 <code>23</code>。若大于 <code>23</code>，则需要在日期上 <code>+1</code>，否则只需要操作小时即可限定数据范围。</p><p>关键就在于 <code>08</code> 和 <code>09</code> 的意思。这里 <code>08</code> 是上午八点的意思，为了保持格式一致，在 <code>8</code> 的前面填充了 <code>0</code>。但 Shell 把它当成是八进制（base is 8）。这样一来，怪不得 Shell 认为 <code>08</code> 是不合法的八进制数。为解决这个问题，我们需要告知 Shell 这是个前面填充了 0 的十进制数。于是我们需要改成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $((10#$&#123;hour_s&#125; + $&#123;hour_diff&#125;)) -gt 23 ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> foo bar</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天启动的定时任务，有几个实例挂掉了。报错提示：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;value too great for base (error token is &quot;08&quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="Integer" scheme="https://liam.page/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>梨花又开放</title>
    <link href="https://liam.page/2019/11/07/another-blossom-of-pear-flower/"/>
    <id>https://liam.page/2019/11/07/another-blossom-of-pear-flower/</id>
    <published>2019-11-07T06:16:53.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天说点不一样的，聊聊「梨花又开放」这首歌的歌词。</p><a id="more"></a><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>「梨花又开放」是周峰根据谭咏麟的经典粤语歌曲「迟来的春天」重新填词而作，谭咏麟的「迟来的春天」则根据因幡晃的「夏にありがとう」重新填词。</p><p>另有香港已故巨星张国荣英文版本「Good Morning Sorrow」，收录于1978年发行的专辑「Daydreaming」中。</p><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><blockquote><p>梨花又开放<br>原唱：周峰<br>作词：丁小齐<br>作曲：因幡晃（日）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=175391&auto=1&height=32"></iframe><p>忘不了故乡 年年梨花放<br>染白了山岗 我的小村庄<br>妈妈坐在梨树下 纺车嗡嗡响<br>我爬上梨树枝 闻那梨花香<br>摇摇啊洁白的树枝 花雨漫天飞扬<br>落在妈妈头上 飘在纺车上<br>给我幸福的故乡 永生难忘<br>永生永世我不能忘</p><p>重返了故乡 梨花又开放<br>找到了我的梦 我一腔衷肠<br>小村一切都依然 树下空荡荡<br>开满梨花的树下 纺车不再响<br>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p><p>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p><p>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p></blockquote><h2 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h2><p>梨花又开放的歌词，可以说是纸短情长的典范。</p><p>歌词共分上下两阙，上阙是回忆歌者的童年，下阙则是重返故乡的所见所想。上下两阙共同出现的意象是：梨花（梨树）、村庄（故乡、山岗）；只在上阙中出现的意象是：妈妈、纺车。共同出现的意象是触景生情的基础，只在回忆中出现的意象则是触景生情的情感寄托所在。</p><p>两阙中 A 段的故乡、梨树一切都依然，甚至梨花开得都一样茂盛。这勾起了「我」的回忆，从而构成了触景深情的基础。但是梨树下空荡荡、纺车不再响。为什么纺车不再响了？因为妈妈已经走了。由纺车作为牵线：纺车不再了，也就是妈妈不在了。哀而不伤的情绪，由此喷薄而出。</p><p>B 段里，「我」摇动梨树枝，花雨同样的漫天飞扬。但不同的是，回忆中梨花飘在妈妈头上和纺车上，现在却只有我一个人孤零零呆立树下。回忆中的妈妈操作纺车会是什么神情？想必是问题又宠溺的表情，看着调皮的「我」吧！然而，妈妈走了，不再了。如今还能摇动梨树的我，只能任凭梨花飘落，想要见妈妈，却只能在想象当中。妈妈已经不在，能够寄托思绪的，就只能是依然还在的故乡、村庄。此时，故乡村庄已经变成了妈妈的化身——妈妈给我幸福、给我血肉，那我当然永生难忘！永生难忘的，不是明面上的故乡，而是妈妈。</p><p>全歌词只说难忘，不说想念；只说故乡，不说已经离去的母亲。但是，对母亲的想念思念却跃然纸上，让人动容。此等的触景生情，只在归有光的「项脊轩志」中见到过：庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。后人评价项脊轩志，讲「此意境人人所有，此笔妙人人所无」，又讲「盖古今来事无巨细，唯此可歌可涕之精神，长留天壤」。想来把这些用在评价这首歌词中，也是恰如其分的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天说点不一样的，聊聊「梨花又开放」这首歌的歌词。&lt;/p&gt;
    
    </summary>
    
      <category term="Music" scheme="https://liam.page/categories/Music/"/>
    
    
      <category term="Lyrics" scheme="https://liam.page/tags/Lyrics/"/>
    
  </entry>
  
  <entry>
    <title>利用穷人乐理论撰写精准营销类文章</title>
    <link href="https://liam.page/2019/11/06/writing-marketing-articles-based-on-the-theory-of-poor-but-happy/"/>
    <id>https://liam.page/2019/11/06/writing-marketing-articles-based-on-the-theory-of-poor-but-happy/</id>
    <published>2019-11-06T09:47:12.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>中国互联网历史中，要论最成功的精准营销类文章写手，咪蒙必在其中无疑。咪蒙本名马凌，说起来还是我山东大学的校友。2015 年时，马凌注册了名为咪蒙的微信公众号。该微信公众号以发表精准定位现代女性的营销类文章而出名，一度有超过千万的关注量和阅读量。</p><p>时至今日，<a href="https://www.zhihu.com/question/318167756" target="_blank" rel="noopener">咪蒙已经「毕业」</a>，但互联网江湖上一直流传着咪蒙的传说。大家乐此不疲地讨论和思考，咪蒙为什么会成功？咪蒙的文章为什么会有这种奇怪的魔力，让无数具有良好教育的现代女性为之着魔。</p><p>此篇讲一讲我的一些思考。</p><a id="more"></a><h2 id="人穷但快乐"><a href="#人穷但快乐" class="headerlink" title="人穷但快乐"></a>人穷但快乐</h2><p>世界上有一种奇怪的现象。</p><p>有一些人，生活水平和物质基础低于平均水平，我们称之为穷人。在追逐更高生活水平和物质基础的过程中，穷人往往会凭着自己的想象，设想出心目中富人的样子。这些穷人为了平衡自己落后的物质基础，会认为富人的精神世界是单调的、空洞的、乏味的。也就是说：这部分穷人承认自己穷，但是认为自己活得开心快乐；认为富人虽然富，但是富人精神空虚。</p><p>我们说，在这个过程中，这些穷人不仅会表现出物质上的穷，还会表现了精神世界层面的穷。我们把这种现象称之为「人穷但快乐」，简称「穷人乐」。</p><h2 id="分裂的人性"><a href="#分裂的人性" class="headerlink" title="分裂的人性"></a>分裂的人性</h2><p>读完上面这一段，如果你很穷，你大概会很生气；如果你比较富裕，你大概心里长处一口气。但别着急，读完这一段，可能不论你穷困还是富裕，你可能都会胸有愤愤。</p><p>上面这一段说的穷人，主要说的是经济实力上问题。但实际上，这种穷，可以扩展到很多方面。穷人的穷，实际上说的是经济实力上的「不如人意」。于是，我们可以把这种现象，扩展到任何层面上的不如人意上。</p><p>比如：</p><ul><li>谢顶者可能会心想：你虽然头发浓密，但是你肯定学习不用功。</li><li>学习差者可能会心想：你虽然学习好，但你将来也就是个打工者。</li><li>打工者可能会心想：你虽然当老板，但是你老婆肯定会背叛你。</li><li>夫妻不和睦的人可能会心想：你虽然家庭幸福，但你肯定每天精疲力尽。（<code>←_←</code>）</li></ul><p>看！多么分裂的人性！</p><p>顺着这个思路往下走，你猜给下面这些文章点赞的人，是处于什么感情状态：</p><ul><li>我一个人活得好好的，为什么要结婚？</li><li>女人好好打扮就是为了取悦男人？瞎扯！</li><li>对不起，你的病，爱情治不了</li></ul><h2 id="精准营销"><a href="#精准营销" class="headerlink" title="精准营销"></a>精准营销</h2><p>好了，所以你大概已经想明白了。如果你要瞄准一个在某方面过得不如意的人，撰写一篇精准营销文章应该怎么写呢？</p><p>首先，你得有一个抓住这些人眼球的标题。怎样才能抓住这些人的眼球呢？答案很简单：如果这个人在某方面过得不如意，就批判贬低这方面过得如意的人，或者力挺这方面过得不如意的人。</p><p>比如对于在感情中受过伤，再也不相信爱情的女性：</p><ul><li>我一个人活得好好的，为什么要结婚？——力挺在感情中不如意的人</li><li>女人好好打扮就是为了取悦男人？瞎扯！——批判感情中如意的人（有男人可取悦）</li><li>有一种礼物，叫男朋友送的礼物——男朋友送的礼物肯定都是狗屁不通的呗，这是在贬低有男朋友的女的也收不到什么像样的礼物</li></ul><p>还有其他一些例子：</p><ul><li>我，一个矮子的史诗——你看，都「史诗」了，这不就是力挺矮子么</li><li>如何把大牌穿成地摊货？——你看，那些有钱人居然能把大牌穿成地摊货，这不就是批判有钱人么</li></ul><p>而后，你得编造一个故事，核心还是：批判如意者，发现不如意者其他方面的闪光点。总而言之，一大碗毒鸡汤就这么狠狠灌下去。</p><p>最后，如果你要营销带货，最好在文章的末尾来一个反转。比如，对于「我，一个矮子的史诗」这篇文章，如果要带货卖增高鞋垫，我会在大篇幅批判那些高个子人之后来这么一句：</p><blockquote><p>后来，我才知道，XX 看起来高，实际上只不过是在鞋子中悄悄放了一块 XX 品牌 3cm 的增高鞋垫罢了。</p></blockquote><p>你看，情绪上还是对高个子人的嘲讽鄙视，但不经意间，一个反转，点出了需要营销的东西。</p><p><code>o(*￣︶￣*)o</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国互联网历史中，要论最成功的精准营销类文章写手，咪蒙必在其中无疑。咪蒙本名马凌，说起来还是我山东大学的校友。2015 年时，马凌注册了名为咪蒙的微信公众号。该微信公众号以发表精准定位现代女性的营销类文章而出名，一度有超过千万的关注量和阅读量。&lt;/p&gt;
&lt;p&gt;时至今日，&lt;a href=&quot;https://www.zhihu.com/question/318167756&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咪蒙已经「毕业」&lt;/a&gt;，但互联网江湖上一直流传着咪蒙的传说。大家乐此不疲地讨论和思考，咪蒙为什么会成功？咪蒙的文章为什么会有这种奇怪的魔力，让无数具有良好教育的现代女性为之着魔。&lt;/p&gt;
&lt;p&gt;此篇讲一讲我的一些思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Writing" scheme="https://liam.page/tags/Writing/"/>
    
      <category term="Marketing Articles" scheme="https://liam.page/tags/Marketing-Articles/"/>
    
      <category term="Poor but Happy" scheme="https://liam.page/tags/Poor-but-Happy/"/>
    
  </entry>
  
  <entry>
    <title>一种基于 Beta 分布的推荐方法示例</title>
    <link href="https://liam.page/2019/11/06/a-Beta-Distribution-based-recommendation-realia-method/"/>
    <id>https://liam.page/2019/11/06/a-Beta-Distribution-based-recommendation-realia-method/</id>
    <published>2019-11-06T08:05:19.000Z</published>
    <updated>2019-11-12T16:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为一直在做推荐系统和点击率预估排序相关工作，所以一直想用一种粗糙但直观的方式来做一个推荐系统的示例，如果能有一定的工程实现价值就更好。最近突然有了这样一个基于 Beta 分布的想法，所以记录下来。当然，这个想法可能不是我的专利，可能已经有人想到过了。</p><a id="more"></a><h2 id="Beta-分布的直观理解"><a href="#Beta-分布的直观理解" class="headerlink" title="Beta 分布的直观理解"></a>Beta 分布的直观理解</h2><p><a href="https://zh.wikipedia.org/wiki/%CE%92%E5%88%86%E5%B8%83" target="_blank" rel="noopener">Beta 分布</a> 是一组定义在 $(0, 1)$ 之间的连续概率分布，有两个参数 <code>$\alpha, \beta &gt; 0$</code>。随机变量 <code>$X$</code> 服从参数为 <code>$\alpha$</code>, <code>$\beta$</code> 的 Beta 分布通常记作 <code>$X \sim \text{Be}(\alpha, \beta)$</code>。</p><p>在理解 Beta 分布之前，我们先回顾一下二项分布。</p><p>二项分布说的是 $n$ 个 i.i.d 的二项伯努利试验中成功次数的离散概率分布。根据二项分布，我们可以用似然的办法，通过有限次的实验，推断伯努利实验成功的概率。比如有一枚多少有些不均匀的硬币，我们多次抛硬币，将硬币呈现正面记为成功，要求成功的概率，就可以用似然的办法结合二项分布来求解。现在的问题是，在只有很少次数的实验时，利用二项分布估计的概率可能会很不准。一个极端的例子，如果我们只做了一次实验，硬币落下后呈现正面。那么根据二项分布估计出来的概率将会是 <code>$P = 1$</code>。这显然是不对的。</p><p>这时候，Beta 分布就该出场了。Beta 分布可以看做是二项分布概率的概率分布。怎么理解呢？我们来继续看抛硬币的例子。</p><p>我们知道，虽然每一枚硬币都多少有些不均匀，但是总体上，硬币落下呈现正面的概率是 <code>$0.5$</code> 左右。因此，不论如何，一枚多少有些不均匀的硬币，抛硬币得到正面的概率应该和 <code>$0.5$</code> 相去不远。具体到多次 i.i.d 的二项伯努利试验上，就是当 <code>$N$</code> 足够大时，<code>$2N$</code> 次二项伯努利试验中，得到正面的次数应该接近 <code>$N$</code>。我们假设 <code>$N = 1000$</code>，这意味着，在 <code>$2000$</code> 次二项伯努利试验中，大约会获得 <code>$A = 1000$</code> 次正面和 <code>$B = 1000$</code> 次反面。于是，我们初始化 Beta 分布 <code>$\text{Be}(A, B) = \text{Be}(1000, 1000)$</code>。接着，我们用这枚多少有些不均匀的硬币开始若干次二项伯努利试验，比如说 50 次。在 50 次试验中，我们得到了 <code>$a = 19$</code> 次正面，<code>$b = 31$</code> 次反面。于是我们更新 Beta 分布的参数 <code>$\alpha \gets A + a$</code> 以及 <code>$\beta \gets B + b$</code>，于是得到新的 Beta 分布 <code>$\text{Be}(1019, 1031)$</code>。该 Beta 分布的均值是</p><p><code>$$ \frac{\alpha}{\alpha + \beta} = \frac{1019}{1019 + 1031} = \frac{1019}{2050} \approx 0.497. $$</code></p><p>于是我们说，这枚多少有些不均匀的硬币在二项伯努利试验中得到正面的概率是 <code>$P = 0.497$</code>；与此同时，就这 50 次试验，根据二项分布推算出来的概率是 <code>$P = 0.38$</code>。显然，根据 Beta 分布均值推算出来的概率相对根据二项分布推算出来的概率要显著接近 <code>$P = 0.5$</code> 的先验值。</p><p>总结一下，Beta 分布可以看做是二项分布概率的概率分布。当我们对二项分布概率已经有一个相对比较靠谱的先验知识的时候，我们可以据此设定 Beta 的参数，然后在后续 i.i.d 的二项伯努利试验过程中，依赖 Beta 分布共轭先验的特性，对 Beta 分布的参数进行更新，最后以 Beta 分布均值作为二项分布概率的估计。</p><h2 id="基于-Beta-分布的用户画像"><a href="#基于-Beta-分布的用户画像" class="headerlink" title="基于 Beta 分布的用户画像"></a>基于 Beta 分布的用户画像</h2><p>推荐系统的一侧是用户，描述用户的方法是用户画像。我们可以用 Beta 用户来做基于 Tag 的用户画像。在这里，对于某个用户来说：</p><ul><li>Beta 分布中的 <code>$\alpha_i$</code> 是用户在编号为 <code>$i$</code> 的 Tag 下的点击次数的反映；</li><li>相应地，<code>$\beta_i$</code> 则是用户在编号为 <code>$i$</code> 的 Tag 下展示未点击次数的反应。</li></ul><p>于是，用户画像的策略可以简单叙述如下：</p><ul><li>对于某个用户，使用先验知识（比如，全体用户的平均兴趣），对 <code>$\{(\alpha_i, \beta_i)\}$</code> 序列进行初始化。</li><li>根据用户的行为（展示和点击），更新该序列<ul><li>用户点击了具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> Tag 的物品进行了点击，则对 <code>$\alpha_i$</code>, <code>$\alpha_j$</code>, <code>$\alpha_k$</code> 分别自增 1；</li><li>用户展示未点击具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> Tag 的物品进行了点击，则对 <code>$\beta_i$</code>, <code>$\beta_j$</code>, <code>$\beta_k$</code> 分别自增 1。</li></ul></li></ul><h2 id="基于-Beta-分布的点击率预估"><a href="#基于-Beta-分布的点击率预估" class="headerlink" title="基于 Beta 分布的点击率预估"></a>基于 Beta 分布的点击率预估</h2><p>对于具有画像 <code>$\{(\alpha_i, \beta_i)\}$</code> 的用户进行推荐时，我们要对待推荐的物品进行点击率预估。假设某物品同时具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> 的 Tag，假设各个 Tag 对点击行为的贡献都相同——这是一个很强的假设，但对于示例方案来说无关紧要，则用户对该物品的点击概率可以预估为：</p><p><code>$$P_{\text{click}} = 1 - \frac{\beta_i}{\alpha_i + \beta_i} \times \frac{\beta_j}{\alpha_j + \beta_j} \times \frac{\beta_k}{\alpha_k + \beta_k}.$$</code></p><p>而后，我们可以根据各个物品的预估点击率对物品进行排序，然后推荐给用户。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个近乎「儿戏」的推荐方案，但在实践上并非完全无用。说它儿戏，是因为它只考虑了单个用户的历史行为，而没有考虑其他所有对推荐有帮助的因素——比如其他用户的行为（可做协同过滤），比如推荐结果多样性。但是，在没有这些其他因素的情况下，这种方案可以起到过渡方案的作用。对，我说的就是在新用户、新物品冷启动的时候，这种方案简单易实现，值得一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直在做推荐系统和点击率预估排序相关工作，所以一直想用一种粗糙但直观的方式来做一个推荐系统的示例，如果能有一定的工程实现价值就更好。最近突然有了这样一个基于 Beta 分布的想法，所以记录下来。当然，这个想法可能不是我的专利，可能已经有人想到过了。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Beta Distribution" scheme="https://liam.page/tags/Beta-Distribution/"/>
    
      <category term="Recommendation System" scheme="https://liam.page/tags/Recommendation-System/"/>
    
      <category term="Realia" scheme="https://liam.page/tags/Realia/"/>
    
  </entry>
  
  <entry>
    <title>一篇关于大公司病的魔幻现实主义文章的读后感</title>
    <link href="https://liam.page/2019/11/05/thoughts-on-the-low-efficiency-of-large-companies/"/>
    <id>https://liam.page/2019/11/05/thoughts-on-the-low-efficiency-of-large-companies/</id>
    <published>2019-11-05T02:13:24.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在知乎上读到一篇<a href="https://www.zhihu.com/question/26111395/answer/138128420" target="_blank" rel="noopener">魔幻现实主义的文章</a>。<a href="https://www.zhihu.com/people/sun-bin-12-58" target="_blank" rel="noopener">作者</a>用一个实体的「塑料标牌」隐喻了在大公司中无形的身份、头衔和自我满足感，然后通过这一实体的塑料标牌，讲述了职场的，特别是大公司中的一些现象。</p><p>总体上来说，文章特别有意思，显得回味无穷。因此作此篇读后感。</p><a id="more"></a><h2 id="初入江湖"><a href="#初入江湖" class="headerlink" title="初入江湖"></a>初入江湖</h2><p>原文的第一段，写的是主人公「陆枫」刚入职时候的故事。</p><p>刚入职的陆枫发现周围很多同事都戴着标有数字的塑料标牌：有的人戴着多，有的人戴着少。戴着多的人，走起路来，塑料牌互相碰撞，还会<strong>哗啦啦</strong>响。陆枫感到很奇怪，但查遍「员工手册」，都没找到相应说明——既没有说明是否必须佩戴，也没有说明标牌的含义。不过在他入职时候，随附了一个标着「001」的标牌。</p><p>陆枫去问老员工，却被老员工当成<strong>不懂事的小孩子</strong>。但老员工还是给陆枫做了一些解释：</p><ul><li>这标牌戴不戴全凭个人意愿，没有规定，也不会强迫；</li><li>每周五可以主动要求领取更大编号的标牌，将在下周一发放；</li><li>（神秘地）戴上了，<strong>可能就摘不下来了</strong>。</li></ul><p>前面提到，文中的塑料标牌，隐喻的是在大公司中无形的身份、头衔和自我满足感。陆枫初入职场，看见别人有标牌，说的就是职场老人的身份、头衔等无形东西的外化。也就是说，职场老人因为在日常相处过程中，慢慢有了一些不可言明的身份头衔。这些身份头衔会影响身在职场中的人，从而外化表现在职场人的言行举止上，进而能被他人感知到。身份头衔和自我满足感高而多的人，这种外化的表现就更加明显，以至于「哗啦啦」地作响，让人想不注意到都不行。但另一方面，这种无形的东西是不能言明的，它往往是在多重因素下生根发芽萌发出来的潜规则。因此，在入职培训或者员工手册当中，陆枫当然就找不到相关说明了。</p><p>陆枫作为初入江湖的「愣头青」，把不能言明的东西主动说出来去询问老员工，当然要遭到老员工的「白眼」，被认为是「不懂事的小孩子」。从老员工的解释当中可以看出来，这种无形的东西具有的特征：</p><ul><li>全凭个人意愿，不会强迫——潜规则的东西，不能白纸黑字写出来，当然名义上是「不会强迫」的了；</li><li>身份头衔和个人满足感，随着时间的延长，会缓慢而自然地增加；</li><li>这些不能言明的虚的身份头衔，一旦陷入其中，甚至体会到它们带来的好处，就会难以自拔「摘不掉了」。</li></ul><h2 id="进入圈子"><a href="#进入圈子" class="headerlink" title="进入圈子"></a>进入圈子</h2><p>原文的第二段，写的是主人公陆枫逐渐进入圈子的故事。</p><p>既然「不强迫」，懵懂的陆枫也就选择不佩戴标牌和「升级」标牌了。但如此一来，陆枫逐渐感觉到了周围的诡异气氛——虽然大家在言语上并不会明面说什么，但是在实际行动上对陆枫有所排斥。如此一来，陆枫显得格格不入。忍受了一段时间之后，陆枫看到和他同期入职的「小陈」戴上了标牌。于是陆枫「保险起见」地也戴上了标牌。</p><p>神奇的事情出现了。随着陆枫戴上标牌并且每周开始获取新的标牌，陆枫周围那种诡异气氛慢慢不见了。大家不再「躲着」陆枫说话，开始和陆枫有说有笑起来。只是……关于这块标牌本身，大家仍然缄口不言。</p><p>戴上标牌并且获取新标牌实际上喻示着陆枫开始「融入圈子」。之所以陆枫一开始会感到诡异的气氛，是因为戴标牌的老员工们自发地形成了一个圈子。陆枫不戴标牌，无疑表示陆枫不是圈内人。人类群体对群体外的个体会有天然的排斥。在无约束的环境中，这种排斥甚至会上升到暴力。但在有约束的职场环境中，因为明面规则的限制，这种排斥最基本的表现方式就是「回避」。陆枫戴起标牌并每周更新实际上向外传达了一种态度——尽管这种态度可能并非陆枫本意，甚至这种态度的传达都是在陆枫本人无意识的情况下进行的——感受到这种态度的圈子，就逐渐接纳了陆枫。之所以说这种态度的传达可能是无意识的，是因为人的行为往往会受到所在群体的潜移默化的影响。中国的老祖宗们创造了不少成语来描述这种现象，比如：和光同尘、同流合污。</p><p>当然，在这个阶段，陆枫暂时不会也没办法体会到「进入圈子」带来的实际的好处。</p><h2 id="深入试探"><a href="#深入试探" class="headerlink" title="深入试探"></a>深入试探</h2><p>原文的第三段，讲的是主人公陆枫逐渐习惯戴标牌、领标牌的过程中发生的事情。</p><p>随着时间的推移，陆枫脖子上已经挂了 024 块标牌。在这个过程中，陆枫习惯甚至开始享受这种戴着标牌的状态。但人生总有意外。这一周的周五，陆枫太忙了，以至于没有去主动要求更新标牌。周末在家的陆枫辗转反侧惴惴不安；周一一大早，陆枫就赶到公司想要处理标牌的事情。但不出意料，陆枫的桌上没有标号为 025 的新标牌。少了 025 的标牌，标牌的「更新」无疑就要慢一个星期。陆枫感到很郁闷，但他随即想到，小陈应该会有标号为 025 的标牌。于是趁着自己来得早大家都还没到公司，陆枫悄悄地拿走了本属于小陈的 025 号标牌。</p><p>心亏的陆枫战战兢兢地度过了一周。但周围所有人都仿若不知的样子，并且陆枫用本不属于自己的 025 号标牌申领 026 号标牌也通过了。陆枫心里的石头终于落地，而后他发现：这东西是可以偷的，所以自己要小心不要被别人偷了自己的标牌，同时以后不要忘记申领新的标牌。</p><p>第一次读到这一段的时候，我心里乐哈哈的。这个陆枫，是在「危险」边缘试探啊。甚至我认为，这是原文最出彩的一段。这一段最有味道的地方在于陆枫心里石头落地的过程。按说标牌这个东西是具有实体的实实在在的东西——大家都看着呢！那为什么陆枫偷了小陈的标牌，大家都毫无所觉，并且陆枫用不属于自己的标牌申领新标牌也毫无阻碍地通过了呢？其实作者就是通过这一段，用这种方式隐晦地告诉大家：标牌只是虚幻在显示中的投影，它模模糊糊朦朦胧胧，看似有，但又看不真切。也是从这里，读者应该慢慢能体会到标牌背后的隐喻：身份、头衔和虚无的心里满足感。</p><p>但是，作者没有交代的另一个问题在于：其他人不知道也就罢了，被偷标牌的小陈，他能不知道吗？</p><h2 id="虚拟荣耀"><a href="#虚拟荣耀" class="headerlink" title="虚拟荣耀"></a>虚拟荣耀</h2><p>原文的第四段，讲的是主人公陆枫所在单位业绩不好，用标牌代替年终奖的事情。</p><p>时间继续推移，年底的时候陆枫脖子上已经挂了 42 块标牌。陆枫期待年终奖已久，终于等到领导请他去办公室沟通。不期而遇的意外又发生了。领导先是肯定了陆枫的工作，但随即告诉陆枫，公司今年业绩不好，发不出多少年终奖了。陆枫正失落，领导从抽屉里拿出了 043 -- 052 号共 10 个标牌给了陆枫，作为补偿。</p><p>五味陈杂的陆枫走出领导的办公室，却发现周围人用一种「你得到了很大好处」的羡慕眼神看着陆枫。慢慢地，在这种目光的注视下，陆枫说服了自己——我年轻，我不吃亏谁吃亏，再说这也是领导的心意嘛。</p><p>这一段我是最佩服作者笔力的了。我们分角色来看。</p><p>首先是领导。领导很自然地用标牌作为奖金不足的补偿，代替年终奖。这说明领导深谙职场潜规则，在心里早已将虚幻的身份头衔当成了财富的一种。然后是同事们。同事们见到领导的「奖励」很是羡慕。可见同事们也受职场潜规则的影响颇深，这才会羡慕陆枫获得了「好处」。最后是陆枫。陆枫一开始因为奖金没拿够而失落，可见陆枫的「修为」还不够，比领导那种「把虚幻当财富」的境界差远了。后来，在同事们「羡慕」的目光下，陆枫的<strong>心态发生了转变</strong>。从把标牌当成是「领导的心意」开始，陆枫也慢慢把虚幻的身份头衔和心理满足感当成了实际的财富。</p><p>作者用寥寥几笔，通过三个（类）角色的行为，写出了三个（类）角色的心态，从而表现了在「潜规则」这个游戏里人们越陷越深的趋势和进程。明明写的是一个事件、一个状态，越陷越深的进程却清晰可见。仅凭这一段，作者可称得上是「笔力雄浑」。</p><h2 id="机锋隐现"><a href="#机锋隐现" class="headerlink" title="机锋隐现"></a>机锋隐现</h2><p>原文的第五段可谓是机锋初现、隐而不发。</p><p>前面提到，陆枫偷拿了小陈的 025 号标牌，导致陆枫标牌始终领先小陈一块。这一天，当陆枫拿到了 061 号标牌的时候，小陈找到了陆枫，<strong>隐晦地</strong>告诉陆枫自己因为「一些原因」落后于陆枫了。陆枫心里一紧，这说的不就是我偷标牌的事情吗？小陈却马上摆摆手表示不在意，同时表示有秘密要告诉陆枫。</p><p>趁着陆枫注意力在秘密上，小陈一把抓住陆枫的 060 号标牌，扔出了窗外。然后拿起自己的 060 号标牌，笑嘻嘻地跟陆枫说：你看啊，把「060」颠倒过来就变成了「090」。只要我拿着「090」去申请标牌，下周我就能拿到「091」了。陆枫目瞪口呆，突然想到：如果拿「069」倒过来变成「690」，下周岂不是可以拿到「691」了？小陈却嘲笑陆枫傻，小陈说：「『060』变成『090』，增加 30 块，一时半会儿<strong>看不出来</strong>。但是『069』变成『690』，增加 600 多块。脖子上挂着这么大的数字，却只有几十块标牌，<strong>谁都知道你作弊了</strong>。我研究过了，在新人阶段，就这一次机会。」</p><p>陆枫傻了，<strong>不敢置信</strong>。小陈却继续暴击，说：「<strong>全公司都这么干</strong>，只有你一个人傻乎乎的」。并且威胁说：「如果你拿『059』去领『060』，再当做『090』去领『091』，我就<strong>揭发你</strong>，<strong>让全公司都知道你偷了我的『025』</strong>！说到底，你偷我一块，我扔你一块，咱俩扯平了。」</p><p>看过这一段，可谓是心潮汹涌。我们逐一来看。</p><p>为什么小陈找到陆枫的时候，明明自己占理，却只是隐晦地告诉陆枫自己知道它偷拿了自己的标牌呢？这是因为，在这个潜规则下，「作弊是允许的」。被偷走标牌，只能说是自己不小心，怪不了别人，所以不能拿到明面上来说。这也与第三段相呼应。作弊是允许的，那岂不是要乱套了？不然！因为在这个潜规则下，你可以作弊，但关键在于「你不能让人看出来」。具体的例子就是，你可以从 060 作弊到 090，但是不能太过分太明显，从 069 作弊到 690。不然，大家都知道你作弊了，就会鄙视你、唾弃你、让你抬不起头。「年轻」的陆枫犹自不觉，但「全公司」都深谙潜规则，都这么干了。反过来，小陈又利用「作弊是允许的，<strong>但不能让别人知道</strong>」来威胁陆枫，让陆枫无法再通过 059 领 060，进而去作弊。</p><p>哇！这可谓是入木三分！在潜规则下，对于名声、地位、身份、头衔，你可以偏、偷、抢，可以作弊，可以巧取豪夺；可以作弊，但唯独不能让别人知道。</p><h2 id="高潮低谷"><a href="#高潮低谷" class="headerlink" title="高潮低谷"></a>高潮低谷</h2><p>原文的第六段毫无征兆地突然掀开所有的伏笔，可谓高潮突至，但又突然跌入低谷。</p><p>陆枫拿着 061 号标牌领取了 062 号标牌，也迎接了周围同事们若有若无的嘲笑。是啊，所有人都跳过了 60 -- 90 这个阶段，只有陆枫「傻乎乎」地一块一块往前爬。陆枫心里苦啊——不是宝宝不想跳，而是宝宝的 060 被小陈那个杀千刀的丢了啊！终于，当陆枫拿到 069 的时候，他终于忍不住了。陆枫用颠倒的「069」领取了「691」号标牌。毫不意外地，更加猛烈的嘲笑向陆枫扑面而至。甚至，这种嘲笑已经脱离了若有若无的范畴。比如有同事哈哈笑着来到陆枫面前，拍着他的肩膀对大家说：「大家快别闲聊了，<strong>大领导</strong>来视察了啊！」</p><p>自己的 691 已经被大家看到，想要再用 069 去换 070 已经不现实——那无疑告诉大家「<strong>我上周作弊了</strong>」。于是陆枫只能硬着头皮，继续兑换 692，693。但终于，所谓积毁销骨，在舆论的压力下，陆枫终于无法忍受，辞职走了。</p><p>读完这一段后，心里空落落的，似乎意犹未尽。</p><p>是啊，跳跃几百号的作弊被大家嘲笑，这显而易见——第五段刚说了嘛。是啊，无法退回也显而易见——不能明摆着告诉大家作弊了嘛！似乎高潮到来，但又索然无味。</p><h2 id="真正高潮"><a href="#真正高潮" class="headerlink" title="真正高潮"></a>真正高潮</h2><p>原文的第七段才是真正的高潮。</p><p>陆枫离职后半年左右，偶遇小陈。两人一起吃饭，陆枫得知小陈已经有 332 号的标牌，大吃一惊，以为小陈花钱去买标牌了。小陈无不得意地解释说，那样太低端了。然后将「高端」的作弊方式娓娓道来：</p><ul><li>当我有 115 号的时候，我找到有 147 号标牌的人</li><li>他将 144 号标牌给我，我将 106 -- 115 的标牌给他</li><li>我获得了更大号码的标牌，他填补了作弊过程中留下的「空虚」，互惠互利</li></ul><p>陆枫目瞪口呆。小陈继续介绍更高端的作弊方法：</p><ul><li>一群人形成链条</li><li>下一级为上一级填补空虚，上一级给更大号的标牌给下一级</li><li>最下一级将 069 翻转成 690 交给最上一级</li><li>所有人都得利</li></ul><p>陆枫目瞪口呆 * 2。小陈继续说：「塑料片能当钱做奖励吗？（当年领导）拿出 10 块白给你，意思就是要你下次拿出更多还给他，这是拉你进入交易圈的暗示啊！人家这么明显的信号放给你，你不接茬，你啊，真不适合这个游戏。」</p><p>陆枫目瞪口呆 * 3，不解地问小陈，为什么这么个不值钱的东西，出了公司就没用的东西，引得大家斗来斗去乐此不疲呢？小陈嘲讽道：「你问这个问题就还是幼稚。像我们这样的公司，家家都有这样的标牌。你戴上了，就摘不掉，它什么都不代表，却又代表了一切。只不过我们公司的标牌戴在脖子上，别的公司的标牌戴在人心里。戴在心里的标牌，更难猜，也更难摘。」</p><p>陆枫哇的一口吐了一地，就此昏了过去。</p><p>看完这段，我是无言又佩服，作者是真的高手。</p><p>时至今日，两种「高端作弊」方式揭示的意义已是昭然若揭，但在作者说明之前却又如在窗户纸背后，常人不得要领。所有人在追逐虚无的时候，都会作弊。作弊就会留下空洞，就会需要后人来填补。在这个基础上，领先者和落后者就有了合作的基础。反过来，因为领先者有空洞，所以他们有动力拉新人进入这个圈子，与他们「同流合污」。而当新人无法领会弦外之音的时候，或者体会不到这个「游戏」的真意的时候，就会被放弃，就会再一次被排挤，最后离开这个体系。</p><p>让文章上升到新的高度的是「它什么都不代表，却又代表了一切」这一句。虚无的东西终归是虚无，当要拿出实际业绩的时候，它什么都不代表。但是，哪有那么多时间要拿出真的业绩呢？在这些「大多数」的时候，这些虚无的东西，就又代表了一切，主宰了利益的分配。而在现实中，「标牌」不是戴在脖子上，而是戴在「人心里」。</p><h2 id="回味不绝"><a href="#回味不绝" class="headerlink" title="回味不绝"></a>回味不绝</h2><p>原文的故事到这里就结束了，但是留下的回味却绕梁不绝。</p><p>作者的故事虽然没有回答原问题（大公司效率低最根本的原因是什么？应该如何应对？），但从一个角度解释了大公司内某种内耗的内在机制。人们在不追求实际业绩时，转而追求虚无缥缈的身份地位头衔时，隐形的利益交换消耗了本可以发展实际业务的时间、精力、金钱等各个成本。在这个意义上，这种内耗降低了公司的整体效率。</p><p>让我们一起，咂摸咂摸嘴，继续回味这个故事。</p><blockquote><p>收到「标牌小说原作者的『开心打赏』10 元」。<code>٩( &#39;ω&#39; )و get！</code><br>开心 * 10086~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在知乎上读到一篇&lt;a href=&quot;https://www.zhihu.com/question/26111395/answer/138128420&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;魔幻现实主义的文章&lt;/a&gt;。&lt;a href=&quot;https://www.zhihu.com/people/sun-bin-12-58&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作者&lt;/a&gt;用一个实体的「塑料标牌」隐喻了在大公司中无形的身份、头衔和自我满足感，然后通过这一实体的塑料标牌，讲述了职场的，特别是大公司中的一些现象。&lt;/p&gt;
&lt;p&gt;总体上来说，文章特别有意思，显得回味无穷。因此作此篇读后感。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Efficiency" scheme="https://liam.page/tags/Efficiency/"/>
    
      <category term="Magical Realist" scheme="https://liam.page/tags/Magical-Realist/"/>
    
  </entry>
  
  <entry>
    <title>将 HDFS 上的目录作为 Hive 外表分区同时避免数据拷贝</title>
    <link href="https://liam.page/2019/11/05/connect-HDFS-data-into-Hive-external-table-without-redundant-movement/"/>
    <id>https://liam.page/2019/11/05/connect-HDFS-data-into-Hive-external-table-without-redundant-movement/</id>
    <published>2019-11-04T23:38:07.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hive 是个好东西，它能够把 SQL 查询自动转化为一系列 Map-Reduce 任务。但显然，如何将数据引入 Hive 也会是个问题。一个典型的场景是：你通过某种方式，生成了大量结构化的数据，保存在 HDFS 上。现在你希望 Hive 能够基于这些数据，建立数据库，从而能够使用 SQL 语句进行数据库操作。但与此同时，因为数据量十分庞大，你不希望产生数据拷贝、搬移，以免消耗无谓的存储资源和计算资源。</p><p>此篇介绍我近期的一个实践方案。</p><a id="more"></a><h2 id="数据产出"><a href="#数据产出" class="headerlink" title="数据产出"></a>数据产出</h2><p>首先，你需要将数据以特定的格式产出到 HDFS 上。</p><p>例如，这里我以 Spark Streaming 任务将制表符分隔的 4 列数据，以 GZip 的格式，输出到 HDFS 位置：<code>hdfs://namenode/path/to/data/&lt;date&gt;/&lt;hour&gt;/&lt;dstreamid&gt;</code>。其中 <code>&lt;date&gt;</code> 是数据产出的日期，<code>&lt;hour&gt;</code> 是数据产出的小时，<code>&lt;dstreamid&gt;</code> 是数据产出时，对应 Spark Streaming 的 Direct Stream 的 ID。于是有类似这样的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/_SUCCESS</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00000.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00001.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00002.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00003.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00004.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00005.gz</span><br></pre></td></tr></table></figure><h2 id="建立-Hive-表"><a href="#建立-Hive-表" class="headerlink" title="建立 Hive 表"></a>建立 Hive 表</h2><p>有了数据之后，我们需要建立与数据格式相对应的 Hive 表。注意，由于我们不希望对数据进行额外的搬移操作，所以这里需要建立一张外表（EXTERNAL TABLE）。例如，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> (</span><br><span class="line">  <span class="string">`field_1`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_2`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_3`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_4`</span> <span class="keyword">string</span>)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  <span class="string">`date`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`hour`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`dstreamid`</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE</span><br><span class="line">  <span class="string">'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (</span><br><span class="line">  <span class="string">'field.delim'</span>=<span class="string">'\t'</span>,</span><br><span class="line">  <span class="string">'serialization.format'</span>=<span class="string">'\t'</span>)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">'org.apache.hadoop.mapred.TextInputFormat'</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">'hdfs://namenode/path/to/data/'</span>;</span><br></pre></td></tr></table></figure><p>这里，</p><ul><li>数据共有 4 个域，名字分别是 <code>field_1</code> 至 <code>field_4</code>（你可以根据实际情况设置恰当的域名字）。</li><li>分区字段有三个，分别是 <code>date</code>/<code>hour</code>/<code>dstreamid</code>，与数据保存时的子路径名保持一致。</li><li>域分隔符是 <code>\t</code>，即制表符。</li><li>输入格式是 <code>org.apache.hadoop.mapred.TextInputFormat</code>，即文本输入。</li><li>数据位于 <code>hdfs://namenode/path/to/data/</code>，这是我们所有数据的完整路径。</li><li>表名字是 <code>table_name</code>，你可以根据实际情况设置恰当的表名字。</li></ul><h2 id="将数据接入-Hive-表"><a href="#将数据接入-Hive-表" class="headerlink" title="将数据接入 Hive 表"></a>将数据接入 Hive 表</h2><p>有了数据并创建好 Hive 表之后，我们就可以将数据接入 Hive 表了。这里，我们需要用到 <code>ALTER TABLE</code> 语句。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">  table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">PARTITION</span></span><br><span class="line">  (dt=<span class="string">'2019-11-01'</span>, <span class="keyword">hour</span>=<span class="string">'13'</span>, dstreamid=<span class="string">'123456'</span>)</span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">'hdfs://namenode/path/to/data/2019-11-01/13/123456'</span>;</span><br></pre></td></tr></table></figure><p>这个语句表示：</p><ul><li>更改名为 <code>table_name</code> 的表；</li><li>具体的动作是 <code>ADD IF NOT EXISTS PARTITION</code>，即当表中不存在相应分区时，添加该分区；</li><li>添加的数据来自的路径是 <code>hdfs://namenode/path/to/data/2019-11-01/13/123456</code>。</li></ul><p>执行成功之后，即可在不进行数据搬移的前提下，将 HDFS 上目录中的数据作为 Hive 外表的分区了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive 是个好东西，它能够把 SQL 查询自动转化为一系列 Map-Reduce 任务。但显然，如何将数据引入 Hive 也会是个问题。一个典型的场景是：你通过某种方式，生成了大量结构化的数据，保存在 HDFS 上。现在你希望 Hive 能够基于这些数据，建立数据库，从而能够使用 SQL 语句进行数据库操作。但与此同时，因为数据量十分庞大，你不希望产生数据拷贝、搬移，以免消耗无谓的存储资源和计算资源。&lt;/p&gt;
&lt;p&gt;此篇介绍我近期的一个实践方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="HDFS" scheme="https://liam.page/tags/HDFS/"/>
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上对单个文件取消「来自互联网的应用」之限制</title>
    <link href="https://liam.page/2019/10/29/How-to-fix-This-is-an-application-downloaded-from-the-Internet/"/>
    <id>https://liam.page/2019/10/29/How-to-fix-This-is-an-application-downloaded-from-the-Internet/</id>
    <published>2019-10-29T09:35:07.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 上有对未正确签名的应用程序进行<a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">隔离</a>的设定。具体来说，如果用户下载了一个来自互联网的应用，但该应用没有使用 Apple 认可的签名，则 Apple 会在用户尝试执行应用程序时提示「应用程序来自互联网」，要求用户确认后才能执行。</p><p>中文网络上对这种情况的解决办法，一般都是进入系统偏好设置，在安全性设置中允许来自任意位置的应用。这其实是取消了 macOS 的隔离功能，无疑会降低系统安全性。特别地，对于某些特定的程序，我们确切知道它是无害的，于是我们希望 macOS 对它打开绿灯，但对其它来自互联网的应用程序仍保持必要的隔离措施。这时，整个儿取消 macOS 的隔离功能就不合适了。</p><a id="more"></a><p>为解决这一问题，我们需要使用命令行工具 <code>xattr</code>。这是一个 macOS 下用来展示和修改文件（包括目录、符号链接）扩展属性的功能。「是否隔离」正是 macOS 的一项文件扩展属性。其用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Syntax</span><br><span class="line">   List attributes</span><br><span class="line">      xattr [-lrsvx] file ...</span><br><span class="line"></span><br><span class="line">   Print the value associated with the given attribute:</span><br><span class="line">      xattr -p [-lrsvx] attr_name file ...</span><br><span class="line"></span><br><span class="line">   Write a given attribute name with a value:</span><br><span class="line">      xattr -w [-rsx] attr_name attr_value file ...</span><br><span class="line"></span><br><span class="line">   Delete the given attribute from file:</span><br><span class="line">      xattr -d [-rsv] attr_name file ...</span><br><span class="line"></span><br><span class="line">   Clear all attributes including their associated values:</span><br><span class="line">      xattr -c [-rsv] file ...</span><br><span class="line"></span><br><span class="line">   Display help:</span><br><span class="line">      xattr -h | --help</span><br><span class="line"></span><br><span class="line">Key</span><br><span class="line">   -c  CLear all Atrributes.</span><br><span class="line"></span><br><span class="line">   -d  Delete the given attribute.</span><br><span class="line"></span><br><span class="line">   -h  Help.</span><br><span class="line"></span><br><span class="line">   -l  By default, the first two command forms either display just the attribute names or</span><br><span class="line">       values, respectively. The -l option causes both the attribute names and corresponding</span><br><span class="line">       values to be displayed. For hex display of values, the output is preceeded with the hex</span><br><span class="line">       offset values and followed by ASCII display, enclosed by &apos;|&apos;.</span><br><span class="line"></span><br><span class="line">   -p  Print the value associated with the given attribute.</span><br><span class="line"></span><br><span class="line">   -r  If a file argument is a directory, act as if the entire contents of the directory</span><br><span class="line">       recursively were also specified (so that every file in the directory tree is acted upon).</span><br><span class="line"></span><br><span class="line">   -s  If a file argument is a symbolic link, act on the symbolic link itself, rather than</span><br><span class="line">       the file that the symbolic link points at.</span><br><span class="line"></span><br><span class="line">   -v  Force the the file name to be displayed, even for a single file.</span><br><span class="line"></span><br><span class="line">   -w  Write a given attribute name with a value.</span><br><span class="line"></span><br><span class="line">   -x  Force the attribute value to be displayed in the hexadecimal representation.</span><br></pre></td></tr></table></figure><p>这里，我们需要在终端里，执行 <code>xattr -d com.apple.quarantine /path/to/quarantined/file</code> 来移除加在 <code>/path/to/quarantined/file</code> 上的隔离属性。而后在执行相应应用程序，就不会被 macOS 的隔离机制限制了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;macOS 上有对未正确签名的应用程序进行&lt;a href=&quot;https://support.apple.com/zh-cn/HT202491&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;隔离&lt;/a&gt;的设定。具体来说，如果用户下载了一个来自互联网的应用，但该应用没有使用 Apple 认可的签名，则 Apple 会在用户尝试执行应用程序时提示「应用程序来自互联网」，要求用户确认后才能执行。&lt;/p&gt;
&lt;p&gt;中文网络上对这种情况的解决办法，一般都是进入系统偏好设置，在安全性设置中允许来自任意位置的应用。这其实是取消了 macOS 的隔离功能，无疑会降低系统安全性。特别地，对于某些特定的程序，我们确切知道它是无害的，于是我们希望 macOS 对它打开绿灯，但对其它来自互联网的应用程序仍保持必要的隔离措施。这时，整个儿取消 macOS 的隔离功能就不合适了。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="xattr" scheme="https://liam.page/tags/xattr/"/>
    
      <category term="quarantine" scheme="https://liam.page/tags/quarantine/"/>
    
  </entry>
  
  <entry>
    <title>Scala 中下划线的一些魔法</title>
    <link href="https://liam.page/2019/10/24/underscore-magic-in-Scala/"/>
    <id>https://liam.page/2019/10/24/underscore-magic-in-Scala/</id>
    <published>2019-10-24T02:42:27.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间开始学习使用 Scala。和大多数初学者一样，面对 Scala 的各种符号，我也是一脸懵哔。尤其是 Scala 中的下划线 <code>_</code> 在不同场合有不同含义，简直慌。适应一段时间之后，这里总结记录一下我遇见的下划线的含义。</p><a id="more"></a><h2 id="导入模块包"><a href="#导入模块包" class="headerlink" title="导入模块包"></a>导入模块包</h2><p>在 Scala 导入模块包时，<code>_</code> 的作用类似于 Java 导入模块包时的 <code>*</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 matching 包中的所有类</span></span><br><span class="line"><span class="keyword">import</span> scala.util.matching._</span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员（相当于 Java 中的 static import）</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>._</span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员，但将 `Foo` 改名为 `Bar`（相当于 Python 中的 `import Foo from com.test.Fun as Bar`）</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; <span class="type">Bar</span> , _ &#125;</span><br><span class="line"><span class="comment">// imports all the members except Foo. To exclude a member rename it to _</span></span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员，但通过将 `Foo` 改名为 `_` 而忽略。</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; _ , _ &#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><a href="https://docs.scala-lang.org/tour/pattern-matching.html" target="_blank" rel="noopener">Scala 中的模式匹配</a>和 C/C++ 或者 Java 中的 <code>switch</code> - <code>case</code> 语句类似。在 Scala 中的模式匹配中，下划线 <code>_</code> 是匹配任意内容的通配符。最基本的用法时，<code>_</code> 相当于 C/C++ 中的 <code>default</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x: <span class="type">Int</span> = <span class="type">Random</span>.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="string">"zero"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"other"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更高阶的用法中，<code>_</code> 可以嵌套使用，这时候就远超出 <code>default</code> case 的作用了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _, _) =&gt; <span class="string">" a list with three element and the first element is 1 "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(_*)  =&gt; <span class="string">" a list with zero or more elements "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>[_, _] =&gt; <span class="string">" matches a map with any key type and any value type "</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">" others "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h2><p>Scala 和 Python、C++ 等语言一样，也有匿名函数的设定。下划线 <code>_</code> 可用作是匿名函数的参数的占位符，但对于每一个参数，只能用下划线占位一次。例如，在 Scala 中 <code>2 * _</code> 相当于 Python 中的 <code>lambda x: 2 * x</code> 或者 C++ 中的 <code>[](auto x) { return 2 * x; }</code>；但对于 Python 中的 <code>lambda x: x * x</code> 不能写成 Scala 中的 <code>_ * _</code>——因为在 Scala 中，<code>_ * _</code> 表示匿名函数接受 2 个参数，函数返回值是两个参数的乘积。又例如，下列 Scala 代码中的 <code>print(_)</code> 相当于 <code>x =&gt; print(x)</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).foreach(print(_))</span><br></pre></td></tr></table></figure><p>下列 Scala 代码中的 <code>_ + _</code> 相当于 <code>(x, y) =&gt; x + y</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduceLeft(_ + _)</span><br></pre></td></tr></table></figure><h2 id="阻止函数意外调用"><a href="#阻止函数意外调用" class="headerlink" title="阻止函数意外调用"></a>阻止函数意外调用</h2><p>众所周知，Scala 是函数式语言。在 Scala 中，函数是一等公民，和普通变量一样可以赋值。但由于在 Scala 中函数调用时可省略括号，如果你打算将一个函数赋值给一个新的变量，则函数可能会被意外地调用而后将函数的返回值赋值。这种时候，我们需要在函数名之后加上 <code>_</code> 来阻止函数调用——类似 TeX 中的 <code>\relax</code> 阻止继续执行的作用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> bar = foo _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区分-getter-和-setter"><a href="#区分-getter-和-setter" class="headerlink" title="区分 getter 和 setter"></a>区分 getter 和 setter</h2><p>在 Scala 中，对象中的非私有成员会自动生成一对 getter 和 setter。对于私有成员，程序员也可以自己实现 getter 和 setter。这时候，我们需要在 setter 后加上下划线 <code>_</code> 来实现类似 C++ 中函数重载的效果。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= a</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age_</span> </span>= (n:<span class="type">Int</span>) = &#123;</span><br><span class="line">    require(n &gt; <span class="number">0</span>)</span><br><span class="line">    a = n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t = <span class="keyword">new</span> <span class="type">Test</span></span><br><span class="line">t.age = <span class="number">5</span></span><br><span class="line">println(t.age)</span><br></pre></td></tr></table></figure><p>相当于 C++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">age</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a_)</span> </span>&#123;</span><br><span class="line">    a = a_;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line">t.age(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.age() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间开始学习使用 Scala。和大多数初学者一样，面对 Scala 的各种符号，我也是一脸懵哔。尤其是 Scala 中的下划线 &lt;code&gt;_&lt;/code&gt; 在不同场合有不同含义，简直慌。适应一段时间之后，这里总结记录一下我遇见的下划线的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Scala" scheme="https://liam.page/tags/Scala/"/>
    
      <category term="Underscore" scheme="https://liam.page/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>解决公司 Win7 更新时的 0x80092004 错误</title>
    <link href="https://liam.page/2019/10/18/0x80092004-error-on-Windows-7/"/>
    <id>https://liam.page/2019/10/18/0x80092004-error-on-Windows-7/</id>
    <published>2019-10-18T07:57:06.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>从大概 8 月份开始，公司配发的电脑（Windows 7 系统）就总是提示有更新，但每次更新都安装失败。不断提示更新很打扰工作思路，于是下决心解决。</p><a id="more"></a><p>经检查，问题出在 KB4512506/KB4516065（Windows 7 月安全质量汇总更新）上，尝试安装该更新时，系统会提示 <code>0x80092004</code> 错误。上网检查后确认，该错误代码与 <code>CRYPT_E_NOT_FOUND</code> 有关。也就是说，Windows Update 发现更新文件的散列值不匹配，于是拒绝安装。</p><p><img alt="`0x80092004` 错误" data-src="/uploads/images/computer-skills/kb4516065.png"></p><p>进一步检查发现，微软在给 Windows 7 和 Windows Server 2008 R2 的更新中修改了散列值签名方式，而 19 年 8 月发布的 7 月安全质量汇总更新，正是新签名方式第一次生效的时候。具体来说，原先会使用 SHA-1 和 SHA-2 同时签名；但因为众所周知的安全问题，微软放弃了 SHA-1 签名转而仅使用 SHA-2 签名。但如果 Windows 7 上的 Windows Update 依旧检查 SHA-1 签名，则会发现更新文件的散列值不匹配，于是拒绝安装，并报错 <code>0x80092004</code>。</p><p>为解决这一问题，微软先期发布了两个相关更新：</p><ul><li><a href="https://support.microsoft.com/en-us/help/4474419/sha-2-code-signing-support-update" target="_blank" rel="noopener">KB4474419</a>：用于在 Windows 7 等系统上支持 SHA-2 签名。</li><li><a href="https://support.microsoft.com/en-us/help/4490628/servicing-stack-update-for-windows-7-sp1-and-windows-server-2008-r2" target="_blank" rel="noopener">KB4490628</a>：服务堆栈更新，解决了安装仅使用 SHA-2 哈希算法签名的更新时服务堆栈中的问题。</li></ul><p>安装 KB4512506 前，系统必须安装好这两个前置依赖，否则就会因签名问题报错 <code>0x80092004</code>。</p><p>经检查，我的系统里安装了 KB4474419，但是没有安装 KB4490628。那么这就是导致问题的直接原因了。</p><p>那么根本原因在哪里呢？答案是：公司电脑的组策略配置决定了 Windows Update 由公司 IT 管理员来管理。公司 IT 可能没有正确配置安装 KB4490628，于是有后续问题。更加无奈的是，因为组策略配置的限制，我无法在 Windows Update 中搜索安装 KB4490628。幸运的是，我在<a href="http://catalog.update.microsoft.com/v7/site/search.aspx?q=4490628" target="_blank" rel="noopener">微软 Update Catalog</a> 当中找到了 KB4490628 的独立安装包。下载安装 KB4490628 的过程一切顺利。</p><p>安装完 KB4490628 之后，再次打开 Windows Update，尝试安装 KB4516065 则一切顺利。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从大概 8 月份开始，公司配发的电脑（Windows 7 系统）就总是提示有更新，但每次更新都安装失败。不断提示更新很打扰工作思路，于是下决心解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows 7" scheme="https://liam.page/tags/Windows-7/"/>
    
      <category term="Windows Update" scheme="https://liam.page/tags/Windows-Update/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 中抹除磁盘上所有已删除文件的痕迹</title>
    <link href="https://liam.page/2019/09/16/safe-clean-all-data-on-disks-in-Windows/"/>
    <id>https://liam.page/2019/09/16/safe-clean-all-data-on-disks-in-Windows/</id>
    <published>2019-09-16T09:59:24.000Z</published>
    <updated>2019-11-10T10:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在电脑上删除文件时，并不会真的删除数据，而仅仅是在文件系统中将相应文件的索引删除。哪怕是格式化，在「快速格式化」的情况下，也不会删除磁盘上的数据。这种删除/格式化的操作，有歹心的人是有可能恢复数据的。</p><p>因此，在某些情况下——例如归还借用的电脑时——我们会希望能够真正地「粉碎」文件，避免被人恢复敏感数据。</p><p>市面上有不少「粉碎文件」的工具。但：</p><ul><li>为了信息安全这件事情，专门安装第三方工具，这件事情本身就很吊诡；</li><li>如果要粉碎大量文件，同时保证全盘没有遗漏，这些第三方工具往往不可靠。</li></ul><p>这篇介绍用 Windows 自带的工具解决这个问题。</p><a id="more"></a><h2 id="CIPHER"><a href="#CIPHER" class="headerlink" title="CIPHER"></a><code>CIPHER</code></h2><p>Windows 自带有名为 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cipher" target="_blank" rel="noopener"><code>CIPHER</code></a> 的工具。这个工具本身是用来在 NTFS 格式的磁盘上加密磁盘或磁盘上的文件的。不过，我们这里要用到它的 <code>/w</code> 参数。以下是这个参数的作用：</p><blockquote><p>Removes data from available unused disk space on the entire volume. If you use the /w parameter, all other parameters are ignored. The directory specified can be located anywhere in a local volume. If it is a mount point or points to a directory in another volume, the data on that volume is removed.</p></blockquote><p>翻译：<code>cipher /w:&lt;directory&gt;</code> 移除卷上所有未使用的空间并忽略所有其他参数。这里，<code>&lt;directory&gt;</code> 可以是卷上的任意目录。如果该目录是其他卷的挂载点，则 <code>cipher</code> 将会移除被挂载的卷上的数据。</p><p>这个介绍有一点没介绍明白：具体怎样移除卷上的所有空间呢？作为一个用于加密的工具，「移除」的方法当然是很安全的啦。实际上，<code>cipher /w:&lt;directory&gt;</code> 会在磁盘上所有可用空间上，先全部写入 <code>0x00</code>，再全部写入 <code>0xFF</code>，再全部写入随机值。如此一来，磁盘上空闲空间里的内容，就变得难以恢复了。</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>今天写了一个 Windows 批处理脚本，利用 <code>cipher /w</code> 在所有磁盘的空闲空间上抹除数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">for %%i in (A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z) do (</span><br><span class="line">  if exist %%i:\ (</span><br><span class="line">    echo &quot;will start to cipher %%i&quot;</span><br><span class="line">    cipher /w:%%i:\</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在桌面上新建一个文本文件 <code>cipher_disks.txt</code>，将这些内容粘贴上去，而后修改后缀名为 <code>.bat</code>，即改名为 <code>cipher_disks.bat</code>。如此一来，只需双击该批处理脚本，即可抹除所有磁盘上的空闲空间中的数据了。</p><p>于是，在归还电脑时，只需先将个人数据/敏感文件全部删除，然后执行该批处理脚本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在电脑上删除文件时，并不会真的删除数据，而仅仅是在文件系统中将相应文件的索引删除。哪怕是格式化，在「快速格式化」的情况下，也不会删除磁盘上的数据。这种删除/格式化的操作，有歹心的人是有可能恢复数据的。&lt;/p&gt;
&lt;p&gt;因此，在某些情况下——例如归还借用的电脑时——我们会希望能够真正地「粉碎」文件，避免被人恢复敏感数据。&lt;/p&gt;
&lt;p&gt;市面上有不少「粉碎文件」的工具。但：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了信息安全这件事情，专门安装第三方工具，这件事情本身就很吊诡；&lt;/li&gt;
&lt;li&gt;如果要粉碎大量文件，同时保证全盘没有遗漏，这些第三方工具往往不可靠。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇介绍用 Windows 自带的工具解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows" scheme="https://liam.page/tags/Windows/"/>
    
      <category term="Disks" scheme="https://liam.page/tags/Disks/"/>
    
      <category term="Cipher" scheme="https://liam.page/tags/Cipher/"/>
    
  </entry>
  
</feed>
