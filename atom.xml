<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2019-11-05T03:32:43.647Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将 HDFS 上的目录作为 Hive 外表分区同时避免数据拷贝</title>
    <link href="https://liam.page/2019/11/05/connect-HDFS-data-into-Hive-external-table-without-redundant-movement/"/>
    <id>https://liam.page/2019/11/05/connect-HDFS-data-into-Hive-external-table-without-redundant-movement/</id>
    <published>2019-11-04T23:38:07.000Z</published>
    <updated>2019-11-05T03:32:43.647Z</updated>
    
    <content type="html"><![CDATA[<p>Hive 是个好东西，它能够把 SQL 查询自动转化为一系列 Map-Reduce 任务。但显然，如何将数据引入 Hive 也会是个问题。一个典型的场景是：你通过某种方式，生成了大量结构化的数据，保存在 HDFS 上。现在你希望 Hive 能够基于这些数据，建立数据库，从而能够使用 SQL 语句进行数据库操作。但与此同时，因为数据量十分庞大，你不希望产生数据拷贝、搬移，以免消耗无谓的存储资源和计算资源。</p><p>这篇来讲一下我最近的一个实践方案。</p><a id="more"></a><h2 id="数据产出"><a href="#数据产出" class="headerlink" title="数据产出"></a>数据产出</h2><p>首先，你需要将数据以特定的格式产出到 HDFS 上。</p><p>例如，这里我以 Spark Streaming 任务将制表符分隔的 4 列数据，以 GZip 的格式，输出到 HDFS 位置：<code>hdfs://namenode/path/to/data/&lt;date&gt;/&lt;hour&gt;/&lt;dstreamid&gt;</code>。其中 <code>&lt;date&gt;</code> 是数据产出的日期，<code>&lt;hour&gt;</code> 是数据产出的小时，<code>&lt;dstreamid&gt;</code> 是数据产出时，对应 Spark Streaming 的 Direct Stream 的 ID。于是有类似这样的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/_SUCCESS</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00000.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00001.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00002.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00003.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00004.gz</span><br><span class="line">hdfs://namenode/path/to/data/2019-11-01/13/123456/part-00005.gz</span><br></pre></td></tr></table></figure><h2 id="建立-Hive-表"><a href="#建立-Hive-表" class="headerlink" title="建立 Hive 表"></a>建立 Hive 表</h2><p>有了数据之后，我们需要建立与数据格式相对应的 Hive 表。注意，由于我们不希望对数据进行额外的搬移操作，所以这里需要建立一张外表（EXTERNAL TABLE）。例如，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> (</span><br><span class="line">  <span class="string">`field_1`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_2`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_3`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`field_4`</span> <span class="keyword">string</span>)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  <span class="string">`date`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`hour`</span> <span class="keyword">string</span>,</span><br><span class="line">  <span class="string">`dstreamid`</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE</span><br><span class="line">  <span class="string">'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (</span><br><span class="line">  <span class="string">'field.delim'</span>=<span class="string">'\t'</span>,</span><br><span class="line">  <span class="string">'serialization.format'</span>=<span class="string">'\t'</span>)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">'org.apache.hadoop.mapred.TextInputFormat'</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">'hdfs://namenode/path/to/data/'</span>;</span><br></pre></td></tr></table></figure><p>这里，</p><ul><li>数据共有 4 个域，名字分别是 <code>field_1</code> 至 <code>field_4</code>（你可以根据实际情况设置恰当的域名字）。</li><li>分区字段有三个，分别是 <code>date</code>/<code>hour</code>/<code>dstreamid</code>，与数据保存时的子路径名保持一致。</li><li>域分隔符是 <code>\t</code>，即制表符。</li><li>输入格式是 <code>org.apache.hadoop.mapred.TextInputFormat</code>，即文本输入。</li><li>数据位于 <code>hdfs://namenode/path/to/data/</code>，这是我们所有数据的完整路径。</li><li>表名字是 <code>table_name</code>，你可以根据实际情况设置恰当的表名字。</li></ul><h2 id="将数据接入-Hive-表"><a href="#将数据接入-Hive-表" class="headerlink" title="将数据接入 Hive 表"></a>将数据接入 Hive 表</h2><p>有了数据并创建好 Hive 表之后，我们就可以将数据接入 Hive 表了。这里，我们需要用到 <code>ALTER TABLE</code> 语句。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">  table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">PARTITION</span></span><br><span class="line">  (dt=<span class="string">'2019-11-01'</span>, <span class="keyword">hour</span>=<span class="string">'13'</span>, dstreamid=<span class="string">'123456'</span>)</span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">'hdfs://namenode/path/to/data/2019-11-01/13/123456'</span>;</span><br></pre></td></tr></table></figure><p>这个语句表示：</p><ul><li>更改名为 <code>table_name</code> 的表；</li><li>具体的动作是 <code>ADD IF NOT EXISTS PARTITION</code>，即当表中不存在相应分区时，添加该分区；</li><li>添加的数据来自的路径是 <code>hdfs://namenode/path/to/data/2019-11-01/13/123456</code>。</li></ul><p>执行成功之后，即可在不进行数据搬移的前提下，将 HDFS 上目录中的数据作为 Hive 外表的分区了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive 是个好东西，它能够把 SQL 查询自动转化为一系列 Map-Reduce 任务。但显然，如何将数据引入 Hive 也会是个问题。一个典型的场景是：你通过某种方式，生成了大量结构化的数据，保存在 HDFS 上。现在你希望 Hive 能够基于这些数据，建立数据库，从而能够使用 SQL 语句进行数据库操作。但与此同时，因为数据量十分庞大，你不希望产生数据拷贝、搬移，以免消耗无谓的存储资源和计算资源。&lt;/p&gt;
&lt;p&gt;这篇来讲一下我最近的一个实践方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://liam.page/categories/Big-Data/"/>
    
    
      <category term="HDFS" scheme="https://liam.page/tags/HDFS/"/>
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上对单个文件取消「来自互联网的应用」之限制</title>
    <link href="https://liam.page/2019/10/29/How-to-fix-This-is-an-application-downloaded-from-the-Internet/"/>
    <id>https://liam.page/2019/10/29/How-to-fix-This-is-an-application-downloaded-from-the-Internet/</id>
    <published>2019-10-29T09:35:07.000Z</published>
    <updated>2019-10-29T09:44:59.808Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 上有对未正确签名的应用程序进行<a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">隔离</a>的设定。具体来说，如果用户下载了一个来自互联网的应用，但该应用没有使用 Apple 认可的签名，则 Apple 会在用户尝试执行应用程序时提示「应用程序来自互联网」，要求用户确认后才能执行。</p><p>中文网络上对这种情况的解决办法，一般都是进入系统偏好设置，在安全性设置中允许来自任意位置的应用。这其实是取消了 macOS 的隔离功能，无疑会降低系统安全性。特别地，对于某些特定的程序，我们确切知道它是无害的，于是我们希望 macOS 对它打开绿灯，但对其它来自互联网的应用程序仍保持必要的隔离措施。这时，整个儿取消 macOS 的隔离功能就不合适了。</p><a id="more"></a><p>为解决这一问题，我们需要使用命令行工具 <code>xattr</code>。这是一个 macOS 下用来展示和修改文件（包括目录、符号链接）扩展属性的功能。「是否隔离」正是 macOS 的一项文件扩展属性。其用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Syntax</span><br><span class="line">   List attributes</span><br><span class="line">      xattr [-lrsvx] file ...</span><br><span class="line"></span><br><span class="line">   Print the value associated with the given attribute:</span><br><span class="line">      xattr -p [-lrsvx] attr_name file ...</span><br><span class="line"></span><br><span class="line">   Write a given attribute name with a value:</span><br><span class="line">      xattr -w [-rsx] attr_name attr_value file ...</span><br><span class="line"></span><br><span class="line">   Delete the given attribute from file:</span><br><span class="line">      xattr -d [-rsv] attr_name file ...</span><br><span class="line"></span><br><span class="line">   Clear all attributes including their associated values:</span><br><span class="line">      xattr -c [-rsv] file ...</span><br><span class="line"></span><br><span class="line">   Display help:</span><br><span class="line">      xattr -h | --help</span><br><span class="line"></span><br><span class="line">Key</span><br><span class="line">   -c  CLear all Atrributes.</span><br><span class="line"></span><br><span class="line">   -d  Delete the given attribute.</span><br><span class="line"></span><br><span class="line">   -h  Help.</span><br><span class="line"></span><br><span class="line">   -l  By default, the first two command forms either display just the attribute names or</span><br><span class="line">       values, respectively. The -l option causes both the attribute names and corresponding</span><br><span class="line">       values to be displayed. For hex display of values, the output is preceeded with the hex</span><br><span class="line">       offset values and followed by ASCII display, enclosed by &apos;|&apos;.</span><br><span class="line"></span><br><span class="line">   -p  Print the value associated with the given attribute.</span><br><span class="line"></span><br><span class="line">   -r  If a file argument is a directory, act as if the entire contents of the directory</span><br><span class="line">       recursively were also specified (so that every file in the directory tree is acted upon).</span><br><span class="line"></span><br><span class="line">   -s  If a file argument is a symbolic link, act on the symbolic link itself, rather than</span><br><span class="line">       the file that the symbolic link points at.</span><br><span class="line"></span><br><span class="line">   -v  Force the the file name to be displayed, even for a single file.</span><br><span class="line"></span><br><span class="line">   -w  Write a given attribute name with a value.</span><br><span class="line"></span><br><span class="line">   -x  Force the attribute value to be displayed in the hexadecimal representation.</span><br></pre></td></tr></table></figure><p>这里，我们需要在终端里，执行 <code>xattr -d com.apple.quarantine /path/to/quarantined/file</code> 来移除加在 <code>/path/to/quarantined/file</code> 上的隔离属性。而后在执行相应应用程序，就不会被 macOS 的隔离机制限制了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;macOS 上有对未正确签名的应用程序进行&lt;a href=&quot;https://support.apple.com/zh-cn/HT202491&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;隔离&lt;/a&gt;的设定。具体来说，如果用户下载了一个来自互联网的应用，但该应用没有使用 Apple 认可的签名，则 Apple 会在用户尝试执行应用程序时提示「应用程序来自互联网」，要求用户确认后才能执行。&lt;/p&gt;
&lt;p&gt;中文网络上对这种情况的解决办法，一般都是进入系统偏好设置，在安全性设置中允许来自任意位置的应用。这其实是取消了 macOS 的隔离功能，无疑会降低系统安全性。特别地，对于某些特定的程序，我们确切知道它是无害的，于是我们希望 macOS 对它打开绿灯，但对其它来自互联网的应用程序仍保持必要的隔离措施。这时，整个儿取消 macOS 的隔离功能就不合适了。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="xattr" scheme="https://liam.page/tags/xattr/"/>
    
      <category term="quarantine" scheme="https://liam.page/tags/quarantine/"/>
    
  </entry>
  
  <entry>
    <title>Scala 中下划线的一些魔法</title>
    <link href="https://liam.page/2019/10/24/underscore-magic-in-Scala/"/>
    <id>https://liam.page/2019/10/24/underscore-magic-in-Scala/</id>
    <published>2019-10-24T02:42:27.000Z</published>
    <updated>2019-10-24T03:50:53.642Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间开始学习使用 Scala。和大多数初学者一样，面对 Scala 的各种符号，我也是一脸懵哔。尤其是 Scala 中的下划线 <code>_</code> 在不同场合有不同含义，简直慌。适应一段时间之后，这里总结记录一下我遇见的下划线的含义。</p><a id="more"></a><h2 id="导入模块包"><a href="#导入模块包" class="headerlink" title="导入模块包"></a>导入模块包</h2><p>在 Scala 导入模块包时，<code>_</code> 的作用类似于 Java 导入模块包时的 <code>*</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 matching 包中的所有类</span></span><br><span class="line"><span class="keyword">import</span> scala.util.matching._</span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员（相当于 Java 中的 static import）</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>._</span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员，但将 `Foo` 改名为 `Bar`（相当于 Python 中的 `import Foo from com.test.Fun as Bar`）</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; <span class="type">Bar</span> , _ &#125;</span><br><span class="line"><span class="comment">// imports all the members except Foo. To exclude a member rename it to _</span></span><br><span class="line"><span class="comment">// 引入对象 Fun 中的所有成员，但通过将 `Foo` 改名为 `_` 而忽略。</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; _ , _ &#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><a href="https://docs.scala-lang.org/tour/pattern-matching.html" target="_blank" rel="noopener">Scala 中的模式匹配</a>和 C/C++ 或者 Java 中的 <code>switch</code> - <code>case</code> 语句类似。在 Scala 中的模式匹配中，下划线 <code>_</code> 是匹配任意内容的通配符。最基本的用法时，<code>_</code> 相当于 C/C++ 中的 <code>default</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x: <span class="type">Int</span> = <span class="type">Random</span>.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="string">"zero"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"other"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更高阶的用法中，<code>_</code> 可以嵌套使用，这时候就远超出 <code>default</code> case 的作用了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _, _) =&gt; <span class="string">" a list with three element and the first element is 1 "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(_*)  =&gt; <span class="string">" a list with zero or more elements "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>[_, _] =&gt; <span class="string">" matches a map with any key type and any value type "</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">" others "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h2><p>Scala 和 Python、C++ 等语言一样，也有匿名函数的设定。下划线 <code>_</code> 可用作是匿名函数的参数的占位符，但对于每一个参数，只能用下划线占位一次。例如，在 Scala 中 <code>2 * _</code> 相当于 Python 中的 <code>lambda x: 2 * x</code> 或者 C++ 中的 <code>[](auto x) { return 2 * x; }</code>；但对于 Python 中的 <code>lambda x: x * x</code> 不能写成 Scala 中的 <code>_ * _</code>——因为在 Scala 中，<code>_ * _</code> 表示匿名函数接受 2 个参数，函数返回值是两个参数的乘积。又例如，下列 Scala 代码中的 <code>print(_)</code> 相当于 <code>x =&gt; print(x)</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).foreach(print(_))</span><br></pre></td></tr></table></figure><p>下列 Scala 代码中的 <code>_ + _</code> 相当于 <code>(x, y) =&gt; x + y</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduceLeft(_ + _)</span><br></pre></td></tr></table></figure><h2 id="阻止函数意外调用"><a href="#阻止函数意外调用" class="headerlink" title="阻止函数意外调用"></a>阻止函数意外调用</h2><p>众所周知，Scala 是函数式语言。在 Scala 中，函数是一等公民，和普通变量一样可以赋值。但由于在 Scala 中函数调用时可省略括号，如果你打算将一个函数赋值给一个新的变量，则函数可能会被意外地调用而后将函数的返回值赋值。这种时候，我们需要在函数名之后加上 <code>_</code> 来阻止函数调用——类似 TeX 中的 <code>\relax</code> 阻止继续执行的作用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> bar = foo _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区分-getter-和-setter"><a href="#区分-getter-和-setter" class="headerlink" title="区分 getter 和 setter"></a>区分 getter 和 setter</h2><p>在 Scala 中，对象中的非私有成员会自动生成一对 getter 和 setter。对于私有成员，程序员也可以自己实现 getter 和 setter。这时候，我们需要在 setter 后加上下划线 <code>_</code> 来实现类似 C++ 中函数重载的效果。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= a</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age_</span> </span>= (n:<span class="type">Int</span>) = &#123;</span><br><span class="line">    require(n &gt; <span class="number">0</span>)</span><br><span class="line">    a = n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t = <span class="keyword">new</span> <span class="type">Test</span></span><br><span class="line">t.age = <span class="number">5</span></span><br><span class="line">println(t.age)</span><br></pre></td></tr></table></figure><p>相当于 C++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">age</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a_)</span> </span>&#123;</span><br><span class="line">    a = a_;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line">t.age(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.age() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间开始学习使用 Scala。和大多数初学者一样，面对 Scala 的各种符号，我也是一脸懵哔。尤其是 Scala 中的下划线 &lt;code&gt;_&lt;/code&gt; 在不同场合有不同含义，简直慌。适应一段时间之后，这里总结记录一下我遇见的下划线的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Scala" scheme="https://liam.page/tags/Scala/"/>
    
      <category term="Underscore" scheme="https://liam.page/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>解决公司 Win7 更新时的 0x80092004 错误</title>
    <link href="https://liam.page/2019/10/18/0x80092004-error-on-Windows-7/"/>
    <id>https://liam.page/2019/10/18/0x80092004-error-on-Windows-7/</id>
    <published>2019-10-18T07:57:06.000Z</published>
    <updated>2019-10-22T08:18:16.216Z</updated>
    
    <content type="html"><![CDATA[<p>从大概 8 月份开始，公司配发的电脑（Windows 7 系统）就总是提示有更新，但每次更新都安装失败。不断提示更新很打扰工作思路，于是下决心解决。</p><a id="more"></a><p>经检查，问题出在 KB4512506/KB4516065（Windows 7 月安全质量汇总更新）上，尝试安装该更新时，系统会提示 <code>0x80092004</code> 错误。上网检查后确认，该错误代码与 <code>CRYPT_E_NOT_FOUND</code> 有关。也就是说，Windows Update 发现更新文件的散列值不匹配，于是拒绝安装。</p><p><img alt="`0x80092004` 错误" data-src="/uploads/images/computer-skills/kb4516065.png"></p><p>进一步检查发现，微软在给 Windows 7 和 Windows Server 2008 R2 的更新中修改了散列值签名方式，而 19 年 8 月发布的 7 月安全质量汇总更新，正是新签名方式第一次生效的时候。具体来说，原先会使用 SHA-1 和 SHA-2 同时签名；但因为众所周知的安全问题，微软放弃了 SHA-1 签名转而仅使用 SHA-2 签名。但如果 Windows 7 上的 Windows Update 依旧检查 SHA-1 签名，则会发现更新文件的散列值不匹配，于是拒绝安装，并报错 <code>0x80092004</code>。</p><p>为解决这一问题，微软先期发布了两个相关更新：</p><ul><li><a href="https://support.microsoft.com/en-us/help/4474419/sha-2-code-signing-support-update" target="_blank" rel="noopener">KB4474419</a>：用于在 Windows 7 等系统上支持 SHA-2 签名。</li><li><a href="https://support.microsoft.com/en-us/help/4490628/servicing-stack-update-for-windows-7-sp1-and-windows-server-2008-r2" target="_blank" rel="noopener">KB4490628</a>：服务堆栈更新，解决了安装仅使用 SHA-2 哈希算法签名的更新时服务堆栈中的问题。</li></ul><p>安装 KB4512506 前，系统必须安装好这两个前置依赖，否则就会因签名问题报错 <code>0x80092004</code>。</p><p>经检查，我的系统里安装了 KB4474419，但是没有安装 KB4490628。那么这就是导致问题的直接原因了。</p><p>那么根本原因在哪里呢？答案是：公司电脑的组策略配置决定了 Windows Update 由公司 IT 管理员来管理。公司 IT 可能没有正确配置安装 KB4490628，于是有后续问题。更加无奈的是，因为组策略配置的限制，我无法在 Windows Update 中搜索安装 KB4490628。幸运的是，我在<a href="http://catalog.update.microsoft.com/v7/site/search.aspx?q=4490628" target="_blank" rel="noopener">微软 Update Catalog</a> 当中找到了 KB4490628 的独立安装包。下载安装 KB4490628 的过程一切顺利。</p><p>安装完 KB4490628 之后，再次打开 Windows Update，尝试安装 KB4516065 则一切顺利。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从大概 8 月份开始，公司配发的电脑（Windows 7 系统）就总是提示有更新，但每次更新都安装失败。不断提示更新很打扰工作思路，于是下决心解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows 7" scheme="https://liam.page/tags/Windows-7/"/>
    
      <category term="Windows Update" scheme="https://liam.page/tags/Windows-Update/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 中抹除磁盘上所有已删除文件的痕迹</title>
    <link href="https://liam.page/2019/09/16/safe-clean-all-data-on-disks-in-Windows/"/>
    <id>https://liam.page/2019/09/16/safe-clean-all-data-on-disks-in-Windows/</id>
    <published>2019-09-16T09:59:24.000Z</published>
    <updated>2019-10-22T08:18:16.213Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在电脑上删除文件时，并不会真的删除数据，而仅仅是在文件系统中将相应文件的索引删除。哪怕是格式化，在「快速格式化」的情况下，也不会删除磁盘上的数据。这种删除/格式化的操作，有歹心的人是有可能恢复数据的。</p><p>因此，在某些情况下——例如归还借用的电脑时——我们会希望能够真正地「粉碎」文件，避免被人恢复敏感数据。</p><p>市面上有不少「粉碎文件」的工具。但：</p><ul><li>为了信息安全这件事情，专门安装第三方工具，这件事情本身就很吊诡；</li><li>如果要粉碎大量文件，同时保证全盘没有遗漏，这些第三方工具往往不可靠。</li></ul><p>这篇介绍用 Windows 自带的工具解决这个问题。</p><a id="more"></a><h2 id="CIPHER"><a href="#CIPHER" class="headerlink" title="CIPHER"></a><code>CIPHER</code></h2><p>Windows 自带有名为 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cipher" target="_blank" rel="noopener"><code>CIPHER</code></a> 的工具。这个工具本身是用来在 NTFS 格式的磁盘上加密磁盘或磁盘上的文件的。不过，我们这里要用到它的 <code>/w</code> 参数。以下是这个参数的作用：</p><blockquote><p>Removes data from available unused disk space on the entire volume. If you use the /w parameter, all other parameters are ignored. The directory specified can be located anywhere in a local volume. If it is a mount point or points to a directory in another volume, the data on that volume is removed.</p></blockquote><p>翻译：<code>cipher /w:&lt;directory&gt;</code> 移除卷上所有未使用的空间并忽略所有其他参数。这里，<code>&lt;directory&gt;</code> 可以是卷上的任意目录。如果该目录是其他卷的挂载点，则 <code>cipher</code> 将会移除被挂载的卷上的数据。</p><p>这个介绍有一点没介绍明白：具体怎样移除卷上的所有空间呢？作为一个用于加密的工具，「移除」的方法当然是很安全的啦。实际上，<code>cipher /w:&lt;directory&gt;</code> 会在磁盘上所有可用空间上，先全部写入 <code>0x00</code>，再全部写入 <code>0xFF</code>，再全部写入随机值。如此一来，磁盘上空闲空间里的内容，就变得难以恢复了。</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>今天写了一个 Windows 批处理脚本，利用 <code>cipher /w</code> 在所有磁盘的空闲空间上抹除数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">for %%i in (A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z) do (</span><br><span class="line">  if exist %%i:\ (</span><br><span class="line">    echo &quot;will start to cipher %%i&quot;</span><br><span class="line">    cipher /w:%%i:\</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在桌面上新建一个文本文件 <code>cipher_disks.txt</code>，将这些内容粘贴上去，而后修改后缀名为 <code>.bat</code>，即改名为 <code>cipher_disks.bat</code>。如此一来，只需双击该批处理脚本，即可抹除所有磁盘上的空闲空间中的数据了。</p><p>于是，在归还电脑时，只需先将个人数据/敏感文件全部删除，然后执行该批处理脚本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在电脑上删除文件时，并不会真的删除数据，而仅仅是在文件系统中将相应文件的索引删除。哪怕是格式化，在「快速格式化」的情况下，也不会删除磁盘上的数据。这种删除/格式化的操作，有歹心的人是有可能恢复数据的。&lt;/p&gt;
&lt;p&gt;因此，在某些情况下——例如归还借用的电脑时——我们会希望能够真正地「粉碎」文件，避免被人恢复敏感数据。&lt;/p&gt;
&lt;p&gt;市面上有不少「粉碎文件」的工具。但：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了信息安全这件事情，专门安装第三方工具，这件事情本身就很吊诡；&lt;/li&gt;
&lt;li&gt;如果要粉碎大量文件，同时保证全盘没有遗漏，这些第三方工具往往不可靠。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇介绍用 Windows 自带的工具解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows" scheme="https://liam.page/tags/Windows/"/>
    
      <category term="Disks" scheme="https://liam.page/tags/Disks/"/>
    
      <category term="Cipher" scheme="https://liam.page/tags/Cipher/"/>
    
  </entry>
  
  <entry>
    <title>FTRL 不太简短之介绍</title>
    <link href="https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/"/>
    <id>https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/</id>
    <published>2019-08-31T12:01:23.000Z</published>
    <updated>2019-10-22T08:18:16.211Z</updated>
    
    <content type="html"><![CDATA[<p>FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 <code>$L_1$</code> 正则化的<a href="/2018/10/10/logistic-regression/">逻辑回归</a>类模型时，效果非常出色：能够得到性能较好的稀疏解。</p><p>中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我看来，已有的关于 FTRL 的介绍，都或多或少有些值得调整和改进的地方。这促成了这篇文章。</p><p>这篇文章讲 FTRL 的理论部分，大致会按照这样的路径来阐述：</p><ul><li>我们想要解决什么问题？</li><li>FTRL 的前辈们是怎么尝试解决问题的？</li><li>前辈们之间是什么关系？又留下了哪些尚未解决的问题？FTRL 是如何解决这些遗留问题的？</li></ul><p>而后，在下一篇工程部分的文章中，我们会讨论一下 FTRL 的工程实现有哪些值得谈一谈的问题。</p><a id="more"></a><h2 id="我们面临的问题"><a href="#我们面临的问题" class="headerlink" title="我们面临的问题"></a>我们面临的问题</h2><p>传统的运用机器学习解决实际问题的步骤如下：</p><ul><li>数据融合，获取数据样本的标签。</li><li>特征工程及其 ETL，获取每个样本的特征。</li><li>样本处理，处理正负样本比例、无效或作弊样本等问题，输出用于训练、验证、测试的样本集。</li><li>构建模型，根据业务特点和数据特点，选取恰当的模型；比如 LR、FM、GBDT、DNN 等。</li><li>训练模型，在训练集上训练模型，在验证集上调参。</li><li>模型评估，在测试机上评估模型。</li><li>在线预测，将有效模型上线，进行在线预测。</li></ul><p>这样的流程能够解决很多问题，但存在至少两方面的瓶颈：</p><ol><li>整套流程在样本维度是「批量」的，在特征高维数据大量的情况下，这导致模型更新周期较长。在工程能力强的团队手上，模型的更新周期最好能做到小时级别；在工程能力差的团队手上，这个周期可能是天级甚至是周级别的。</li><li>模型的复杂度和线上预测性能之间难以权衡：模型复杂度低，线上预测效果差；模型复杂度高，线上预测效果好，但需要的存储、时间资源也随之升高，无法保证 RT 和 QPS。</li></ol><p>为了解决这里的问题 (1)，在线学习（Online Learning）逐渐兴起；为了解决问题 (2)，人们从各种正则、剪枝开始，尝试用各种手段，在保证模型精度的前提下，尽可能获得稀疏的模型。</p><h3 id="在线学习的兴起"><a href="#在线学习的兴起" class="headerlink" title="在线学习的兴起"></a>在线学习的兴起</h3><p>我曾经在多个场合谈到，机器学习模型的三要素是：</p><ul><li>模型结构；</li><li>优化目标；</li><li>求解方法。</li></ul><p>在这里，模型结构通常会需要根据实际问题的特点进行调整。例如，对于具有稠密特征样本的分类问题，GBDT 类的树模型往往效果良好。又例如，对于具有高维稀疏特征的大规模样本，<a href="/2018/10/10/logistic-regression/">逻辑回归</a>和<a href="https://liam.page/2019/03/25/Factorization-Machine/">因子分解机</a>（及其<a href="https://liam.page/2019/06/28/variants-of-FM/">变体</a>）就会是不错的选择。</p><p>优化目标往往会以目标函数这一数学形式来表达。目标函数中的损失函数，则是用来描述「模型对经验数据拟合程度好坏」的方法。目标函数（或损失函数）的选择，通常也是和实际问题的特点相关的。例如对于回归问题和分类问题，通常就会选择不同的损失函数。</p><blockquote><p>对于样本集合 <code>$\mathcal{D}$</code> 中编号为 <code>$i$</code> 的样本 <code>$\{\vec x_i, y_i\}$</code> 来说，在确定好模型结构 <code>$h(\cdot; \vec\omega)$</code> 的基础上，损失函数记为<br><code>$$\ell\bigl(h(\vec x_i; \vec\omega), y_i\bigr).$$</code></p></blockquote><p>求解方法则是解决如何在有限的时间内，求得一个既简单（模型复杂度低，不易过拟合）性能又好（对经验数据拟合程度较高）的模型。在模型结构确定的基础上，机器学习模型的学习，往往会化归为带参数目标函数的最优化求解问题。如何解决这些最优化问题，或者说，采用何种求解方法，往往要根据问题特点、模型结构、目标函数等等各种因素的不同，综合考虑。</p><h4 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h4><p>在机器学习兴起的早期，由于数据规模较小，计算性能较低与求解复杂度较高的矛盾尚不明显，人们很自然地选择与直觉相符合的批量求解方式来优化模型。具体来说，人们通常会随机给定模型参数 <code>$\vec\omega$</code> 的初值 <code>$\vec\omega_0$</code>，通过迭代，不断更新来调整 <code>$\vec\omega$</code> 的取值，使得目标函数在样本集合 <code>$\mathcal{D}$</code> 上的加和取得或接近最小值：</p><p><code>$$\begin{aligned}  L(\vec\omega\mid \mathcal{D}) &amp;{} = \sum_{\{\vec x_i, y_i\} \in \mathcal{D}}\ell\bigl(h(\vec x_i; \vec\omega), y_i\bigr) \\  \vec\omega^{*} &amp;{} = \mathop{\arg\,\min}_{\vec\omega} L(\vec\omega\mid \mathcal{D})\end{aligned}$$</code></p><p>对于这种解法，典型的方式是梯度下降（Gradient Descend）和牛顿法、拟牛顿法等。以梯度下降法为例，其 <code>$t$</code> 轮迭代的更新如下所示：</p><p><code>$$\vec\omega^{(t + 1)} \gets \vec\omega^{(t)} - \eta^{(t)}\cdot\nabla_{\vec\omega^{(t)}}L(\vec\omega^{(t)}\mid \mathcal{D}).$$</code></p><p>在这种做法当中，每一次迭代，都需要扫描整个样本集合 <code>$\mathcal{D}$</code> 以计算全局损失 <code>$L$</code>，而后才能更新参数 <code>$\vec\omega$</code>。对于数据规模较小的情况，这样做的好处是能够准确计算每一次迭代时的梯度，避免「跑偏」。但对于随着数据规模的增大，每一次计算全局梯度的代价变得过高，完成训练的时间就会变得很长。为了解决这个问题，人们引入了随机（小批量）的解法。</p><h4 id="随机小批量"><a href="#随机小批量" class="headerlink" title="随机小批量"></a>随机小批量</h4><p>我在<a href="/2019/06/18/OCD-needs-stochastic-gradient-descent/">强迫症患者也需要随机梯度下降</a>一文中介绍了随机（小批量）梯度下降（Stochastic Gradient Descend）的方法和它的好处。按照本文的记号约定，随机梯度下降第 <code>$t$</code> 轮迭代的更新如下所示：</p><p><code>$$\vec\omega^{(t + 1)} \gets \vec\omega^{(t)} - \eta^{(t)}\cdot\nabla_{\vec\omega^{(t)}}L(\vec\omega^{(t)}\mid \mathcal{D}^{(t)}).$$</code></p><p>这里描述的是随机小批量梯度下降。其中 <code>$\mathcal{D}^{(t)}$</code> 是当前轮次的迭代从全部样本集 <code>$\mathcal{D}$</code> 中随机选取的子集。当子集 <code>$\mathcal{D}^{(t)}$</code> 当中只有 1 个元素时，算法退化为纯粹的随机梯度下降。</p><p>在这种做法当中，每一次迭代，无需扫描整个样本集合 <code>$\mathcal{D}$</code> 以计算全局损失 <code>$L$</code>。取而代之的是，计算一个随机选取的小集合 <code>$\mathcal{D}^{(t)}$</code> 中的局部损失，即可更新参数 <code>$\vec\omega$</code>。对于数据规模较大的情况，这样的做法节省了每次迭代的计算量，虽然代价是需要迭代更多轮次，但是总体来说极大地降低了整体的训练时间；与此同时，如<a href="/2019/06/18/OCD-needs-stochastic-gradient-descent/">强迫症患者也需要随机梯度下降</a>一文中介绍的那样，随机梯度下降还能带来其它一些好处。</p><h4 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h4><p>随机（小批量）的优化方法解决了一部分问题，但做到极限，模型的更新周期也只能缩短到小时级。因此，在线学习逐渐走上了舞台。</p><p>和前辈们相比，在线学习最大的特点（或者说需求）有两个：</p><ul><li>每次只处理少数几个样本，甚至每次只处理一个样本；</li><li>处理过的样本对于优化过程来说会被「丢弃」，再也看不到了，因此在线学习需要一种「不吃后悔药」的优化方法。</li></ul><p>回过头来看随机（小批量）梯度下降，我们发现它恰好能满足在线学习的这两方面需求。对于第一个需求来说，这是显然的。对于第二个需求来说，在线接收的样本某种意义上就可以理解为是一种随机，只要这些随机送到优化器的样本的梯度在统计期望上与总体样本是一致的（而这是在线学习的基本假设），那就适用随机（小批量）梯度下降。</p><p>事情看起来很美妙，只需要把随机（小批量）梯度下降整合进在线学习的工程框架当中就可以了。但是事情没有那么美妙，因为这依然无法解决我们面临的第二个问题——对模型稀疏性的追求。</p><h3 id="对模型稀疏性的追求"><a href="#对模型稀疏性的追求" class="headerlink" title="对模型稀疏性的追求"></a>对模型稀疏性的追求</h3><h4 id="模型稀疏的好处"><a href="#模型稀疏的好处" class="headerlink" title="模型稀疏的好处"></a>模型稀疏的好处</h4><p>模型稀疏的好处有几个方面。</p><p>一是能解决之前提到的「模型复杂度低，线上预测效果差；模型复杂度高，线上预测效果好，但需要的存储、时间资源也随之升高，无法保证 RT 和 QPS」之问题。这是比较显然的。稀疏的模型会大大减少预测时的内存和复杂度。以 LR 为例，若已知输入向量的维度是 <code>$d$</code> 而 LR 中不为 0 的参数的数量是 <code>$w$</code>，若 <code>$d \gg w$</code>，那么绝大多数特征甚至不需要去采集。这样一来，从特征采集到预测运算整个步骤都能省下很多内存和计算复杂度。</p><p>二是模型的稀疏与 <code>$L_1$</code> 正则化不谋而合（见<a href="/2017/03/30/L1-and-L2-regularizer/">谈谈 L1 与 L2-正则项</a>一文），这意味着运用 <code>$L_1$</code> 正则化一方面可以使得模型变得稀疏，另一方面还能够降低模型过拟合的风险。</p><p>三是稀疏性较好的模型，相对来说可解释性更好。这对于我们来说，特别是在实际应用当中，是很有好处的。以那个经典的例子来解释，假设你现在需要训练一个模型，解释人的某些特征和罹患某种疾病之间的关系。如果模型稀疏，那么意味着，罹患某种疾病只与少数一些特征有关。这种模型，对于医生来说，是很友好的。因为当医生拿到一个人的指标数据（特征），他就能根据模型，很容易地告诉来访的就医者说：「你的 XX 指标比较高，而 YY 指标比较低，这是罹患 ZZ 疾病的高危因素。因此你需要在日常生活中注意某些方面，同时定期进行身体检查。」</p><h4 id="在批量梯度下降中，追求模型稀疏性"><a href="#在批量梯度下降中，追求模型稀疏性" class="headerlink" title="在批量梯度下降中，追求模型稀疏性"></a>在批量梯度下降中，追求模型稀疏性</h4><p>我们从最基本的批量梯度下降开始，逐步探寻如何解得一个稀疏的模型。</p><p>如<a href="/2017/03/30/L1-and-L2-regularizer/">谈谈 L1 与 L2-正则项</a>一文所说的那样，我们只需将 <code>$L_1$</code> 范数引入模型求解过程中的目标函数，即可获得相对稀疏的模型。注意，由于我们的终极目标是「稀疏」，这意味着要有尽可能多的权重项为 0。这样看起来，使用 <code>$L_0$</code> 范数可能更好（向量 <code>$\vec x$</code> 的 <code>$L_0$</code> 范数 <code>$\lVert \vec x\rVert_0$</code> 是向量 <code>$\vec x$</code> 各维度中不为 0 的维度的数量）。但由于 <code>$L_0$</code> 范数是非凸的，在求解优化上比较困难，故而采用 <code>$L_0$</code> 范数的最紧凸放松，即 <code>$L_1$</code> 范数作为替代。</p><p>这样一来，模型优化时需要最小化的目标函数变更为如下形式：</p><p><code>$$\text{Obj}(\vec\omega\mid \mathcal{D}) = L(\vec\omega\mid \mathcal{D}) + \lambda_1\frac{\lVert \vec\omega\rVert_1}{n}, \quad\lambda_1 &gt; 0.$$</code></p><p>这里，等式右边的第一项表示模型在训练集 <code>$\mathcal{D}$</code> 上经验损失，第二项则表示模型的 <code>$L_1$</code> 正则项。其中 <code>$\lVert \vec\omega\rVert_1$</code> 表示向量 <code>$\vec\omega$</code> 的 <code>$L_1$</code> 范数，<code>$n$</code> 表示向量 <code>$\vec\omega$</code> 的维度。</p><p>那么为什么加入 <code>$L_1$</code> 正则项，有助于产出稀疏解呢？</p><p>我们假设对于某个 <code>$i \in \{1, 2, \ldots, n\}$</code> 来说，<code>$\omega_i = 0$</code>。然后，在接下来的迭代中，<code>$\omega_i$</code> 被更新为 <code>$\omega_i \gets 0 - \eta\frac{\partial \text{Obj}}{\partial \omega_i}$</code> 而其它参数保持不变。这意味着，对于 <code>$L_1$</code> 正则项来说，在这一轮迭代中增加了 <code>$\Delta\Omega = \eta\frac{\lambda_1}{n}\Bigl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\Bigr\rvert$</code>；对于损失函数来说，在这一轮迭代中大约下降了 <code>$\Delta L = \eta\Bigl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\Bigr\rvert\Bigl\lvert \frac{\partial L}{\partial \omega_i}\Bigr\rvert$</code>。而如果 <code>$\Delta L &lt; \Delta\Omega$</code>，即 <code>$\Bigl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\Bigr\rvert &lt; \frac{\lambda_1}{n}$</code>，那么目标函数整体是变大了（而不是变小了）。因此，对于这种情况，优化器会拒绝更新 <code>$\omega_i$</code>，也就是拒绝将 <code>$\omega_i$</code> 更新为非 0 值。由此就得到了相对稀疏的模型。</p><h4 id="L-1-正则在-SGD-中"><a href="#L-1-正则在-SGD-中" class="headerlink" title="$L_1$ 正则在 SGD 中"></a><code>$L_1$</code> 正则在 SGD 中</h4><p>注意，在批量梯度下降中，<code>$L_1$</code> 正则项能有效的原因在于下式的成立：</p><p><code>$$\biggl\lvert \frac{\partial \text{Obj}}{\partial \omega_i}\biggr\rvert &lt; \frac{\lambda_1}{n}.$$</code></p><p>但是，SGD 的假设（随机梯度的期望等于全局梯度）并不能保证在全局梯度满足上式的情况下，随机梯度总能使上式成立。这意味着，在 SGD 的场景中，使用 <code>$L_1$</code> 正则化有助于提升模型的稀疏性，但并不能很好地保证有在批量梯度下降中的那种稀疏化效果。</p><p>那么问题就来了：按之前的说法，在线学习中，我们必然要依赖类似 SGD 的算法；但 <code>$L_1$</code> 正则化并不能在 SGD 中确保模型是足够稀疏的。于是，<strong>我们迫切需要找到一种能够满足在线学习的需要，同时又能保证模型稀疏性的优化方法</strong>。</p><h2 id="FTRL-的前辈们"><a href="#FTRL-的前辈们" class="headerlink" title="FTRL 的前辈们"></a>FTRL 的前辈们</h2><p>前面提到，加入 <code>$L_1$</code> 正则项，是获得稀疏模型的主要手段；但由于 SGD 的原因，<code>$L_1$</code> 正则项又很难发挥作用。因此，我们需要新的手段——或者在 <code>$L_1$</code> 正则化的基础上改进，或者有全新的手段——来解决模型稀疏化的问题。完全创新总是比较困难的。事实上，目前也没有发现完全独立于 <code>$L_1$</code> 范数同时又十分有效的稀疏化方法。因此，人们的目光还是更多地会聚焦在，如何基于 <code>$L_1$</code> 正则项进行改进之上。</p><p>一个粗暴有简单的想法是：基于 <code>$L_1$</code> 正则项，对模型参数进行截断。具体是这样做的，以 <code>$k$</code> 轮迭代为一组：</p><ul><li>按带 <code>$L_1$</code> 正则项的 SGD 的方法训练 <code>$k - 1$</code> 轮</li><li>在第 <code>$k$</code> 轮迭代中，先按通常的 SGD 进行更新，得到 <code>$\vec\omega^{(k&#39;)}$</code>，然后对所有参数进行考察al，以超参数 <code>$\theta$</code> 进行截断置零：</li></ul><p><code>$$\omega_i^{(k)} \gets \begin{cases}0 &amp; \text{if $\Bigl\lvert\omega_{i}^{(k&#39;)}\Bigr\rvert &lt; \theta$,} \\\omega_{i}^{(k&#39;)} &amp; \text{otherwise.}\end{cases}$$</code></p><p>显然，这种做法太过粗暴，存在很多问题；但它是所有类似方法的祖师爷，反映的是「不等式约束下的凸优化」的思路。在这种思路下，求到的梯度 <code>$g^{(t)} = \frac{\partial \text{Obj}}{\partial \omega_i}$</code> 被视作是次梯度（subgradient）。根据次梯度更新的结果，可能落在不等式约束的范围之外。此时，就要取该梯度在不等式约束范围内的投影作为真正的迭代结果。</p><p>简单截断法采取的投影方式，是直接截断。接下来，我们看看 FTRL 的其他前辈们是怎么做的。</p><h3 id="Truncated-Gradient"><a href="#Truncated-Gradient" class="headerlink" title="Truncated Gradient"></a>Truncated Gradient</h3><p>既然简单地截断过于粗暴，那么我们就让截断温和一点。这就是 09 年提出的截断梯度法。</p><ul><li>按带 <code>$L_1$</code> 正则项的 SGD 的方法训练 <code>$k - 1$</code> 轮</li><li>在第 <code>$k$</code> 轮迭代中，先按通常的 SGD 进行更新，得到 <code>$\vec\omega^{(k&#39;)}$</code>，然后对所有参数进行考察，以超参数 <code>$\theta$</code> 和 <code>$\alpha$</code> 进行截断：</li></ul><p><code>$$\omega_i^{(k)} \gets \begin{cases}0&amp; \text{if $\Bigl\lvert\omega_{i}^{(k&#39;)}\Bigr\rvert \leqslant \alpha$,} \\\omega_{i}^{(k&#39;)} - \alpha\,\text{sgn}\Bigl(\omega_{i}^{(k&#39;)}\Bigr) &amp; \text{if $\alpha &lt; \Bigl\lvert\omega_{i}^{(k&#39;)}\Bigr\rvert \leqslant \theta$,} \\\omega_{i}^{(k&#39;)} &amp; \text{otherwise.}\end{cases}$$</code></p><p>这里 <code>$\alpha$</code> 通常取学习率 <code>$\eta^{(k)}$</code> 的倍数，例如 <code>$\alpha^{(k)} = \eta^{(k)}\lambda$</code>。截断梯度法采用的投影方式，是以分段函数的方式，对参数进行截断。</p><p>显然，<code>$\alpha$</code> 或 <code>$\theta$</code> 越大，模型越容易求得稀疏解。当 <code>$\alpha = \theta$</code>，TG 退化为简单截断法；当 <code>$\theta = \infty$</code> 且 <code>$k = 1$</code>，在截断区域之外，TG 继续退化为 SGD-<code>$L_1$</code>，此时 <code>$\omega_i$</code> 的更新是：</p><p><code>$$\omega_{i}^{(t + 1)} \gets \omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} - \eta^{(t)}\lambda\,\text{sgn}\Bigl(\omega_{i}^{(t)}\Bigr).$$</code></p><h3 id="FOBOS-Forward-Backward-Splitting"><a href="#FOBOS-Forward-Backward-Splitting" class="headerlink" title="FOBOS (Forward-Backward Splitting)"></a>FOBOS (Forward-Backward Splitting)</h3><p>FOBOS 最开始的名字叫做 Forward Looking Subgradients，简写叫做 FOLOS；后来改名叫做 Forward-Backward Splitting，按说应该简写成 FOBAS。但作者为了减少可能的困扰，就只修改了一个字母，变成了 FOBOS。</p><blockquote><p>吐槽：但实际上，变得更加困惑了好不好……</p></blockquote><p>FOBOS 可以看做是 TG 的改进。</p><p>首先，FOBOS 将 <code>$k$</code> 设置为 1。如此一来，每一轮迭代都一样了：先根据次梯度做梯度下降，再做一步投影操作。</p><p>其次，FOBOS 将投影操作改进如下：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{2}\Bigl\lVert\vec\omega - \vec\omega^{t&#39;}\Bigr\rVert^{2} + \eta^{(t&#39;)}\Omega(\vec\omega)\biggr\}.$$</code></p><p>这里，优化符号中的第一项保证了投影之后的结果距离梯度下降的结果不太远，第二项是正则项，用于产生稀疏性。我们将它转换为无约束优化的形式：</p><p><code>$$\begin{aligned}\vec\omega^{(t + 1)} \gets{}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{2}\Bigl\lVert\vec\omega - \vec\omega^{(t)} + \eta^{(t)}\nabla\text{Obj}(\vec\omega^{(t)})\Bigr\rVert^{2} + \eta^{(t&#39;)}\Omega(\vec\omega)\biggr\},  \\={}&amp; \vec\omega^{(t)} - \eta^{(t)}\nabla\text{Obj}(\vec\omega^{(t)}) - \eta^{(t&#39;)}\nabla\Omega(\vec\omega^{(t + 1)}).\end{aligned}$$</code></p><p>可见，更新结果不仅与上一轮迭代的结果有关（梯度下降），还与迭代之后的状态有关（正则约束），这就是所谓的 Forward-Backword Splitting。</p><p>当 <code>$\Omega(\cdot) = \eta^{(t&#39;)}\lambda\lVert\cdot\rVert_1 = \tilde\lambda\lVert\cdot\rVert_1$</code> 时，我们将向量形式再化简到具体某一维度的更新：</p><p><code>$$\begin{aligned}\omega_{i}^{(t + 1)} \gets{}&amp; \text{sgn}\bigl(\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}\bigr)\cdot\max\Bigl\{0, \bigl\lvert \omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} \bigr\rvert - \tilde\lambda\Bigr\}, \\={}&amp; \begin{cases}0 &amp; \text{if $\lvert\omega_{i}^{(t&#39;)}\rvert &lt; \tilde\lambda$,} \\\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} - \tilde\lambda\,\text{sgn}\Bigl(\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}\Bigr) &amp; \text{otherwise.}\end{cases}\end{aligned}$$</code></p><p>不难发现，它与 TG 的形式非常接近。当 TG 中的 <code>$\theta = \infty$</code>, <code>$\alpha = \tilde\lambda$</code>, <code>$k = 1$</code> 时，TG 与 FOBOS 的唯一差别就在于惩罚项上。TG 是惩罚在迭代前的项上，FOBOS 是惩罚在经过次梯度迭代后的项上。</p><h3 id="RDA-Regularized-Dual-Averaging"><a href="#RDA-Regularized-Dual-Averaging" class="headerlink" title="RDA (Regularized Dual Averaging)"></a>RDA (Regularized Dual Averaging)</h3><p>RDA 是微软 10 年发表的研究成果，其权重更新策略如下：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{t}\sum_{r = 1}^{t}\Bigl\langle \nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr), \vec\omega\Bigr\rangle + \Omega(\vec\omega) + \frac{\beta^{(t)}}{t}h(\vec\omega)\biggr\}.$$</code></p><p>这里，</p><ul><li><code>$\Bigl\langle \nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr), \vec\omega\Bigr\rangle$</code> 表示梯度 <code>$\nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr)$</code> 对参数 <code>$\vec\omega$</code> 的积分中值，即：第 <code>$r$</code> 轮迭代中的梯度对参数 <code>$\vec\omega$</code> 产生的变动在所有样本上产生的平均影响。</li><li><code>$\frac{1}{t}\sum_{r = 1}^{t}\Bigl\langle \nabla\text{Obj}\bigl(\vec\omega^{(r)}\bigr), \vec\omega\Bigr\rangle$</code> 则是前 <code>$r$</code> 轮迭代上述平均影响的平均值（Dual Average）。</li><li><code>$\Omega(\vec\omega)$</code> 是正则项。</li><li><code>$\frac{\beta^{(t)}}{t}h(\vec\omega)$</code> 是额外的正则项。<ul><li><code>$\bigl\{\beta^{(t)}\mid t \geqslant 1\bigr\}$</code> 是一个非负的非降序列。</li><li><code>$h(\vec\omega)$</code> 是一个严格的凸函数。</li></ul></li></ul><p>除开正则项的变化，和 FOBOS 及之前的截断方法比较，RDA 最大的差别在于丢弃了梯度下降的那一项，换成了梯度的二次平均值。接下来，我们取</p><ul><li><code>$\Omega(\vec\omega) = \lambda\lVert\vec\omega\rVert_1$</code>，其中 <code>$\lambda &gt; 0$</code>；</li><li><code>$h(\vec\omega) = \frac{1}{2}\lVert\vec\omega\rVert_2^2$</code>；</li><li><code>$\beta^{(t)} = \gamma\sqrt{t}$</code>，其中 <code>$\gamma &gt; 0$</code>。</li></ul><p>记 <code>$g_i^{(1:t)} = \frac{1}{t}\sum_{r = 1}^{t} g_i^{(r)}$</code>，于是得到第 <code>$i$</code> 维权重的更新：</p><p><code>$$\omega_{i}^{(t + 1)} \gets \begin{cases}0&amp; \text{if $\bigl\lvert g_i^{(1:t)}\bigr\rvert &lt; \lambda$,} \\-\frac{\sqrt{t}}{\gamma}\Bigl(g_i^{(1:t)} - \lambda\,\text{sgn}\bigl(g_i^{(1:t)}\bigr)\Bigr) &amp; \text{otherwise.}\end{cases}$$</code></p><p>可见，当某一维度参数的二次平均梯度小于阈值 <code>$\lambda$</code> 时，这一维度被截断，产生稀疏性。</p><h2 id="FTRL-Follow-The-Regularized-Leader"><a href="#FTRL-Follow-The-Regularized-Leader" class="headerlink" title="FTRL (Follow The Regularized Leader)"></a>FTRL (Follow The Regularized Leader)</h2><p>接下来介绍 FTRL。</p><h3 id="FOBOS-和-RDA-的区别"><a href="#FOBOS-和-RDA-的区别" class="headerlink" title="FOBOS 和 RDA 的区别"></a>FOBOS 和 RDA 的区别</h3><p>为便于比较，这里把 FOBOS 和 RDA 在单一维度上的更新策略再次抄录如下。</p><p><code>\begin{equation}\omega_{i}^{(t + 1)} \gets \begin{cases}0 &amp; \text{if $\lvert\omega_{i}^{(t&#39;)}\rvert &lt; \tilde\lambda$,} \\\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)} - \tilde\lambda\,\text{sgn}\Bigl(\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}\Bigr) &amp; \text{otherwise.}\end{cases}\tag{FOBOS}\label{eq:FOBOS}\end{equation}</code></p><p><code>\begin{equation}\omega_{i}^{(t + 1)} \gets \begin{cases}0&amp; \text{if $\bigl\lvert g_i^{(1:t)}\bigr\rvert &lt; \lambda$,} \\-\frac{\sqrt{t}}{\gamma}\Bigl(g_i^{(1:t)} - \lambda\,\text{sgn}\bigl(g_i^{(1:t)}\bigr)\Bigr) &amp; \text{otherwise.}\end{cases}\tag{RDA}\label{eq:RDA}\end{equation}</code></p><p>首先我们看 FOBOS 和 RDA 的截断部分的差异。</p><p>FOBOS 的截断判断取的是单次梯度下降的结果，而 RDA 的截断判断取的是往期所有梯度的二次平均。考虑到我们面临的是「在线学习」，样本在局部抖动的几率比较大。因此 FOBOS 的做法容易因为某些异常、离群样本的出现而错误地截断；RDA 的做法则稳妥许多，参考了过去所有样本的梯度结果。</p><p>FOBOS 的截断阈值是 <code>$\tilde\lambda = \eta^{(t&#39;)}\lambda$</code>。考虑到学习率 <code>$\eta^{(t&#39;)}$</code> 往往会随着 <code>$t$</code> 的增加而减小。故而 FOBOS 的截断阈值是不断减小的；与之相对，RDA 的截断阈值是固定的 <code>$\lambda$</code>。这说明，随着训练的进程，FOBOS 对截断的要求越放越松，因而 RDA 相对更容易得到稀疏解。</p><p>接下来我们看 FOBOS 和 RDA 截断之外部分的差异。</p><p>FOBOS 的取值主体是 <code>$\omega_{i}^{(t)} - \eta^{(t)}g_{i}^{(t)}$</code>，即梯度下降的结果，在此基础上做微调——向 0 的方向微调 <code>$\tilde\lambda$</code> 步长。按「下山」的比喻，FOBOS 的取值，是在梯度反方向上下山，每次做一定的微调。RDA 的取值，主体是往期所有梯度的二次平均的缩放（<code>$-\frac{\sqrt{t}}{\gamma}$</code>），在此基础上做微调——向 0 的方向微调 <code>$\lambda$</code>。按同样的比喻，RDA 的取值，是在山顶上试探很多步，平均之后只走出一小步。从感性的认知来说，FOBOS 的准确度显然会更高一些。</p><p>这也就是说，FOBOS 的精度较高，但解的稀疏性相对较差；RDA 的解的稀疏性好，但精度较差。于是，很自然地，我们会问：<strong>是否有办法，将二者的优点合在一起呢</strong>？</p><h3 id="统一-FOBOS-和-RDA-的形式"><a href="#统一-FOBOS-和-RDA-的形式" class="headerlink" title="统一 FOBOS 和 RDA 的形式"></a>统一 FOBOS 和 RDA 的形式</h3><p>想要取长补短，就要想办法将 FOBOS 和 RDA 的形式统一起来。这样才方便拆墙补墙。</p><p>首先看 FOBOS 的无约束优化形式：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\frac{1}{2}\Bigl\lVert\vec\omega - \vec\omega^{(t)} + \eta^{(t)}\vec g^{(t)}\Bigr\rVert^{2} + \eta^{(t)}\lambda\lVert\vec\omega\rVert_1\biggr\}.$$</code></p><p>注意，这里 <code>$\vec g^{(t)} = \nabla\text{Obj}(\vec\omega^{(t)})$</code>，并且令 <code>$\eta^{(t&#39;)} = \eta^{(t)} = \frac{\gamma}{\sqrt{t}}$</code>。我们将之按维度拆开：</p><p><code>$$\begin{aligned}&amp; \min_{\omega_i\in\mathbb{R}}\biggl\{\frac{1}{2}\Bigl\lVert\omega_i - \omega_i^{(t)} + \eta^{(t)}g_i^{(t)}\Bigr\rVert^{2} + \eta^{(t)}\lambda\lvert\omega_i\rvert\biggr\} \\={}&amp; \min_{\omega_i\in\mathbb{R}}\biggl\{\omega_ig_i^{(t)} + \lambda\lvert\omega_i\rvert + \frac{1}{2\eta^{(t)}}\bigl(\omega_i - \omega_i^{(t)}\bigr)_2^2 + \biggl[ \frac{\eta^{(t)}}{2}\bigl(g_i^{(t)}\bigr)_2^2 + \omega_i^{(t)}g_i^{(t)} \biggr]\biggr\} \\={}&amp; \min_{\omega_i\in\mathbb{R}}\biggl\{\omega_ig_i^{(t)} + \lambda\lvert\omega_i\rvert + \frac{1}{2\eta^{(t)}}\bigl(\omega_i - \omega_i^{(t)}\bigr)_2^2\biggr\}.\end{aligned}$$</code></p><p>再合并起来有，</p><p><code>$$\begin{aligned}\vec\omega^{(t + 1)} \gets&amp;{} \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec g^{(t)}\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac{1}{2\eta^{(t)}}\bigl\lVert\vec\omega - \vec\omega^{(t)}\bigr\rVert_2^2\biggr\} \\=&amp;{} \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec g^{(t)}\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac{1}{2}\sigma^{(1:t)}\bigl\lVert\vec\omega - \vec\omega^{(t)}\bigr\rVert_2^2\biggr\}.\end{aligned}$$</code></p><p>其中 <code>$\sigma^{(t)} = \frac{1}{\eta^{(t)}} - \frac{1}{\eta^{(t - 1)}}$</code>，以及 <code>$\sigma^{(1:t)} = \sum_{r = 1}^{t}\sigma^{(r)} = \frac{1}{\eta^{(t)}}$</code>（注意与 <code>$\vec g^{(1:t)}$</code> 不同，<code>$\sigma^{(1:t)}$</code> 在求和符号外没有 <code>$\frac{1}{t}$</code>）。类似地，对于 RDA 有：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + t\lambda\lVert\vec\omega\rVert_1 + \frac{1}{2}\sigma^{(1:t)}\bigl\lVert\vec\omega - \vec 0\bigr\rVert_2^2\biggr\}.$$</code></p><p>这里 <code>$\vec G^{(t)} = \vec g^{(t)}$</code>，而 <code>$\vec G^{(1:t)} = \sum_{r = 1}^{t}\vec G^{(t)} = t\cdot\vec g^{(1:t)}$</code>。</p><h3 id="拆墙补墙得到-FTRL"><a href="#拆墙补墙得到-FTRL" class="headerlink" title="拆墙补墙得到 FTRL"></a>拆墙补墙得到 FTRL</h3><p>统一了 FOBOS 和 RDA 的形式之后，我们就可以将它们各自的优点拿出来了。</p><p>对于 FOBOS，它的优点体现在 <code>$ \frac{1}{2}\sigma^{(1:t)}\bigl\lVert\vec\omega - \vec\omega^{(t)}\bigr\rVert_2^2$</code> 这一项上；对于 RDA，它的优点体现在 <code>$\vec G^{(1:t)}\cdot\vec\omega$</code> 这一项上。于是，我们将这两项组合起来，得到的就是标准的 FTRL 了（11 年的论文中的原始版本）：</p><p><code>$$\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\}.$$</code></p><p>注意这里式中第 3 项与 FOBOS 的第三项稍有区别。我们还可以为它加上 <code>$L_2$</code> 正则项，变成：</p><p><code>\begin{equation}\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\lambda_2\lVert\vec\omega\rVert_2^2 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\}.\tag{FTRL}\label{eq:FTRL}\end{equation}</code></p><h3 id="FTRL-更新公式的推导"><a href="#FTRL-更新公式的推导" class="headerlink" title="FTRL 更新公式的推导"></a>FTRL 更新公式的推导</h3><p>我们将 \ref{eq:FTRL} 展开，得到</p><p><code>$$\begin{aligned}\vec\omega^{(t + 1)} \gets{}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\lambda_2\lVert\vec\omega\rVert_2^2 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\} \\={}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec z^{(1:t)}\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\Bigl(\lambda_2 + \sum_{r = 1}^{t}\sigma^{(r)}\Bigr)\lVert\vec\omega\rVert_2^2 + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\lVert\vec\omega^{(r)}\rVert_2^2\biggr\} \\={}&amp; \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec z^{(1:t)}\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac{1}{2}\Bigl(\lambda_2 + \sum_{r = 1}^{t}\sigma^{(r)}\Bigr)\lVert\vec\omega\rVert_2^2\biggr\}.\end{aligned}$$</code></p><p>其中 <code>$\vec z^{(t)} = \vec g^{(t)} - \sigma^{(t)}\cdot\vec\omega^{(t)}$</code>，而 <code>$\vec z^{(1:t)} = \sum_{r = 1}^{t}\vec z^{(r)}$</code>。我们将之按维度拆开，有</p><p><code>\begin{equation}\min_{\omega_{i}\in\mathbb{R}}\biggl\{z_i^{(t)}\omega_{i} + \lambda_1\lvert\omega_i\rvert + \frac{1}{2}\Bigl(\lambda_2 + \sigma^{(1:t)}\Bigr)\omega_{i}^{2}\biggr\}.\label{eq:ftrl-one-dim}\end{equation}</code></p><p>式 \ref{eq:ftrl-one-dim} 是一个无约束的非平滑参数优化问题，其中第二项 <code>$\lambda_1\lvert\omega_i\rvert$</code> 在 <code>$\omega_i = 0$</code> 处不可导。假设 <code>$\omega_i^*$</code> 是使式 \ref{eq:ftrl-one-dim} 得到最优解的 <code>$\omega_i$</code> 的取值；定义 <code>$\xi\in\partial\lvert\omega_i^*\rvert$</code> 是 <code>$\lvert\omega_i\rvert$</code> 在 <code>$\omega_i^*$</code> 处的次导数，于是有</p><p><code>\begin{equation}\partial\lvert\omega_i^*\rvert = \begin{cases}1  &amp; \text{if $\omega_i^* &gt; 0$}, \\{-1 &lt; \xi &lt; 1} &amp; \text{if $\omega_i^* = 0$}, \\-1 &amp; \text{if $\omega_i^* &lt; 0$}.\end{cases}\label{eq:ftrl-subgradient}\end{equation}</code></p><p>根据式 \ref{eq:ftrl-subgradient} 定义的次导数，对式 \ref{eq:ftrl-one-dim} 待优化的部分求导，令其为零，得到方程：</p><p><code>\begin{equation}z_i^{(t)} + \lambda_1\cdot\xi + \bigl(\lambda_2 + \sigma^{(1:t)}\bigr)\omega_{i}^* = 0.\label{eq:ftrl-equation}\end{equation}</code></p><p>式 \ref{eq:ftrl-equation} 中，<code>$\lambda_1 &gt; 0$</code> 且 <code>$\bigl(\lambda_2 + \sigma^{(1:t)}\bigr) &gt; 0$</code>。对 <code>$z_i^{(t)}$</code> 的取值进行分类讨论：</p><ul><li>当 <code>$\bigl\lvert z_i^{(t)}\bigr\rvert &lt; \lambda_1$</code> 时，有 <code>$\omega_i^{*} = 0$</code>。因为若不然：<ul><li>当 <code>$\omega_i^{*} &lt; 0$</code>，有 <code>$\xi = -1$</code>。式 \ref{eq:ftrl-equation} 左边有 <code>$z_i^{(t)} - \lambda_1 + \bigl(\lambda_2 + \sigma^{(1:t)}\bigr)\omega_{i}^* &lt; z_i^{(t)} - \lambda_1 &lt; 0$</code>，与式 \ref{eq:ftrl-equation} 矛盾。</li><li>当 <code>$\omega_i^{*} &gt; 0$</code>，有 <code>$\xi = 1$</code>。式 \ref{eq:ftrl-equation} 左边有 <code>$z_i^{(t)} + \lambda_1 + \bigl(\lambda_2 + \sigma^{(1:t)}\bigr)\omega_{i}^* &gt; z_i^{(t)} + \lambda_1 &gt; 0$</code>，与式 \ref{eq:ftrl-equation} 矛盾。</li></ul></li><li>当 <code>$z_i^{(t)} &gt; \lambda_1$</code> 时，有 <code>$\omega_i^{*} = -\frac{1}{\lambda_2 + \sigma^{(1:t)}}\bigl(z_i^{(t)} - \lambda_1\bigr) &lt; 0$</code>。因为若不然：<ul><li>当 <code>$\omega_i^{*} = 0$</code>，由式 \ref{eq:ftrl-equation} 知 <code>$\xi = -\frac{z_i^{(t)}}{\lambda_1} &lt; -1$</code>，与式 \ref{eq:ftrl-subgradient} 矛盾。</li><li>当 <code>$\omega_i^{*} &gt; 0$</code>，与 <code>$\bigl\lvert z_i^{(t)}\bigr\rvert &lt; \lambda_1$</code> 的情况类似，与式 \ref{eq:ftrl-equation} 矛盾。</li></ul></li><li>当 <code>$z_i^{(t)} &lt; -\lambda_1$</code>，类似分析，有 <code>$\omega_i^{*} = -\frac{1}{\lambda_2 + \sigma^{(1:t)}}\bigl(z_i^{(t)} + \lambda_1\bigr) &gt; 0$</code>。</li></ul><p>如此一来，我们得到 FTRL 的更新公式：</p><p><code>\begin{equation}\omega_i^{(t + 1)} = \begin{cases}0 &amp; \text{if $\lvert z_i^{(t)}\rvert &lt; \lambda_1$}, \\-\frac{1}{\lambda_2 + \sigma^{(1:t)}}\bigl(z_i^{(t)} - \text{sgn}(z_i^{(t)})\lambda_1\bigr) &amp; \text{otherwise}.\end{cases}\label{eq:ftrl-updates}\end{equation}</code></p><p>从式 \ref{eq:ftrl-updates} 来看，加入 <code>$L_2$</code> 正则，没有影响模型的稀疏性，而只是使得参数的取值趋向零。</p><h3 id="FTRL-为什么是有效的"><a href="#FTRL-为什么是有效的" class="headerlink" title="FTRL 为什么是有效的"></a>FTRL 为什么是有效的</h3><p>我们引出 FTRL 是按「稀疏性」的路径，从 FOBOS 和 RDA 拆借出来的。从上面的推导，我们能看出 FTRL 能够较好地获得稀疏解。但是，我们仍未能说明，FTRL 能够获得较好的稀疏解。（大家来找茬，笑）这一小节里，我们来说明 FTRL 是有效的。</p><p>首先回顾一下 SGD 的更新公式：</p><p><code>\begin{equation}\vec\omega_i^{(t + 1)} \gets \vec\omega_i^{(t)} - \eta^{(t)}\vec g^{(t)}.\label{eq:sgd}\end{equation}</code></p><p>我们丢掉式 \ref{eq:FTRL} 中有关 <code>$L_1$</code> 和 <code>$L_2$</code> 正则相关的部分，有</p><p><code>\begin{equation}\vec\omega^{(t + 1)} \gets \mathop{\arg\,\min}_{\vec\omega}\biggl\{\vec G^{(1:t)}\cdot\vec\omega + \frac{1}{2}\sum_{r = 1}^{t}\sigma^{(r)}\bigl\lVert\vec\omega - \vec\omega^{(r)}\bigr\rVert_2^2\biggr\}.\label{eq:ftrl-pure}\end{equation}</code></p><p>记式 \ref{eq:ftrl-pure} 中待优化的部分为 <code>$f(\vec\omega)$</code>。对其求导，有：</p><p><code>\begin{equation}\frac{\partial f(\vec\omega)}{\partial\vec\omega} = \vec G^{(1:t)} + \sum_{r = 1}^{t}\sigma^{(r)}\bigl(\vec\omega - \vec\omega^{(r)}\bigr).\label{eq:ftrl-pure-gradient}\end{equation}</code></p><p>当式 \ref{eq:ftrl-pure-gradient} 为 0 时的 <code>$\vec\omega$</code>，式 \ref{eq:ftrl-pure} 取得极值。此即有</p><p><code>\begin{equation}\begin{aligned}\vec G^{(1:t)} + \sum_{r = 1}^{t}\sigma^{(r)}\bigl(\vec\omega^{(t + 1)} - \vec\omega^{(r)}\bigr) ={}&amp; 0 \\\sigma^{(1:t)} \vec\omega^{(t + 1)} ={}&amp; \sum_{r = 1}^{t}\sigma^{(r)} \vec\omega^{(r)} - \vec G^{(1:t)}\end{aligned}\label{eq:ftrl-pure-gradient-equation}\end{equation}</code></p><p>在式 \ref{eq:ftrl-pure-gradient-equation} 中，以 <code>$t - 1$</code> 替换 <code>$t$</code>，得到</p><p><code>\begin{equation}\sigma^{(1:t - 1)} \vec\omega^{(t)} = \sum_{r = 1}^{t - 1}\sigma^{(r)} \vec\omega^{(r)} - \vec G^{(1:t - 1)}\label{eq:ftrl-pure-gradient-equation-minus}\end{equation}</code></p><p>用式 \ref{eq:ftrl-pure-gradient-equation} 减去式 \ref{eq:ftrl-pure-gradient-equation-minus} 得到</p><p><code>\begin{equation}\begin{aligned}\sigma^{(1:t)} \vec\omega^{(t + 1)} - \sigma^{(1:t - 1)} \vec\omega^{(t)} ={}&amp; \sigma^{(t)}\vec\omega^{(t)} - \vec g^{(t)} \\\sigma^{(1:t)} \vec\omega^{(t + 1)} ={}&amp; \sigma^{(1:t)} \vec\omega^{(t)} - \vec g^{(t)}\end{aligned}\label{eq:ftrl-sgd-equiv}\end{equation}</code></p><p>考虑 <code>$\sigma^{(1:t)} = \frac{1}{\eta^{(t)}}$</code>，化简式 \ref{eq:ftrl-sgd-equiv} 即得到式 \ref{eq:sgd}。这也就是说，FTRL 去掉 <code>$L_1$</code> 和 <code>$L_2$</code> 部分后，和 SGD 是等价的。这说明 FTRL 能够较好地获得稀疏解并且能够获得较好的稀疏解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 &lt;code&gt;$L_1$&lt;/code&gt; 正则化的&lt;a href=&quot;/2018/10/10/logistic-regression/&quot;&gt;逻辑回归&lt;/a&gt;类模型时，效果非常出色：能够得到性能较好的稀疏解。&lt;/p&gt;
&lt;p&gt;中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我看来，已有的关于 FTRL 的介绍，都或多或少有些值得调整和改进的地方。这促成了这篇文章。&lt;/p&gt;
&lt;p&gt;这篇文章讲 FTRL 的理论部分，大致会按照这样的路径来阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们想要解决什么问题？&lt;/li&gt;
&lt;li&gt;FTRL 的前辈们是怎么尝试解决问题的？&lt;/li&gt;
&lt;li&gt;前辈们之间是什么关系？又留下了哪些尚未解决的问题？FTRL 是如何解决这些遗留问题的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而后，在下一篇工程部分的文章中，我们会讨论一下 FTRL 的工程实现有哪些值得谈一谈的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Logistic Regression" scheme="https://liam.page/tags/Logistic-Regression/"/>
    
      <category term="FTRL" scheme="https://liam.page/tags/FTRL/"/>
    
      <category term="Online Optimization" scheme="https://liam.page/tags/Online-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>从前序遍历结果中重建二叉搜索树</title>
    <link href="https://liam.page/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/"/>
    <id>https://liam.page/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/</id>
    <published>2019-08-29T06:38:23.000Z</published>
    <updated>2019-10-22T08:18:16.209Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个有趣的问题：已知有一个无重复元素的二叉搜索树的前序遍历结果，要求重建该二叉搜索树。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>首先回顾一下前序遍历和二叉搜索树的概念。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>二叉树的前序遍历指得是：对于任意的节点及其左右子节点，在遍历结果中出现的顺序总是「父节点 -&gt; 左子树（如果有） -&gt; 右子树（如果有）」；由于二叉树的自相似结构，这种描述唯一确定的遍历顺序即是前序遍历。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是一种特殊的二叉树，它要求：对于任意的节点及其左右子节点作为根节点形成的左右子树，满足：左子树的所有节点的值小于父节点的值，右子树的所有节点的值大于父节点的值。</p><blockquote><p>显然，二叉搜索树的中序遍历是从小到大排序的。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><p>首先要考虑，一个无重复元素的二叉搜索树的前序遍历结果能否唯一确定一个二叉搜索树？答案是可以的，简要证明如下：</p><ul><li>已知二叉搜索树的前序遍历结果，即知晓二叉搜索树中所有元素；</li><li>对二叉搜索树中所有元素进行从小到大排序，根据二叉搜索树的性质，即得到该二叉搜索树的中序遍历结果；</li><li>已知二叉树的前序遍历结果和中序遍历结果，可以唯一地确定一个二叉树，即该二叉搜索树。</li></ul><p>由此可知，一个无重复元素的二叉搜索树的前序遍历结果，确实能够唯一地确定一个二叉搜索树。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>重建二叉搜索树必然要获知该二叉搜索树中的全部结果。因此，时间复杂度必然不小于 <code>$O(n)$</code>，由此我们得到一个下界。</p><p>又从上述唯一性证明的过程中可知一种重建方法，分析该方法的复杂度可得到一个上界。现在我们简单分析一下该方法的时间复杂度。</p><blockquote><p>一种恢复二叉搜索树的方法：</p><ol><li>对结果进行从小到大排序，得到中序遍历结果。</li><li>根据前序遍历结果和中序遍历结果，重建二叉树。</li></ol></blockquote><p>该方法的时间复杂度是两步之和，其中第 (1) 步的时间复杂度为 <code>$O(n\log(n))$</code>；关键要求得第 (2) 步的时间复杂度。</p><blockquote><p>根据前序遍历结果和中序遍历结果，重建二叉树的方法：</p><ol><li>根据前序遍历结果，确定树根</li><li>根据中序遍历结果，确定树根位置</li><li>根据中序遍历结果，确定左子树（如果有）元素数量</li><li>根据 (3) 的结果，在前序遍历结果中，确定左右子树（如果有）的树根位置</li><li>如此分治递归</li></ol></blockquote><p>若使用支持随机访问的数组存储前序、中序遍历结果，这里的 (1), (3), (4) 步的复杂度均是常数 <code>$O(1)$</code>。对于 (2)，若中序遍历是有序结果（二叉搜索树的情况），可用二分搜索确定树根位置，这一步的复杂度是 <code>$O(\log(n))$</code>，否则只能逐一遍历，复杂度是 <code>$O(n)$</code>。根据「主定理」，这种重建二叉树的方法的时间复杂度不超过 <code>$O(n\log(n))$</code>。</p><p>由此可知，根据前序遍历结果重建二叉搜索树的方法，其时间复杂度下界是 <code>$O(n)$</code>，上界是 <code>$O(n\log(n))$</code>。</p><h2 id="向-Theta-n-进发"><a href="#向-Theta-n-进发" class="headerlink" title="向 $\Theta(n)$ 进发"></a>向 <code>$\Theta(n)$</code> 进发</h2><p>回顾借助中序遍历结果重建二叉树的步骤，我们发现，中序遍历结果的核心作用是通过确定左子树（如果有）元素的数量，在前序遍历中确定左右子树的根节点。考虑到，在前序遍历中，左子树的根节点的位置是平凡的——如果存在左子树，左子树根节点就是整棵树根节点的在前序遍历中的下一个元素。所以关键是要想办法确定右子树（如果有）根节点的位置。</p><p>好消息是，我们现在需要重建的二叉树是二叉搜索树。因此，树根的右孩子，就是前序遍历中第一个比根节点大的那个元素。这样一来，我们就能确定根节点的左右孩子的位置了，如此一来，只需要递归就能解决问题。</p><p>于是，遗留的问题变成了：如何在常数时间内找到第一个比根节点大的元素的位置。</p><p>讲道理，单就查找元素的问题而言，我们是做不到的。最快的二分的复杂度也有 <code>$\Theta(\log(n))$</code>，何况它还有额外要求。但是，我们已知：根节点到根节点右孩子（如果有）之间的所有元素，都是根节点左子树（如果有）的元素（假设其个数是 <code>$k$</code>）。如果我们有办法在寻找右孩子的过程中，把左子树构建出来，我们就能把寻找右孩子的复杂度 <code>$\Theta(k)$</code> 均摊到这 <code>$k$</code> 个左子树的元素上去，复杂度就变成了常数。要做到这一点，依赖于实现。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rebuildBST</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">int</span> bound = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::max())</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (preorder.size() == i <span class="keyword">or</span> preorder[i] &gt; bound) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">  ++i;</span><br><span class="line">  node-&gt;left = rebuildBST(preorder, node-&gt;val);</span><br><span class="line">  node-&gt;right = rebuildBST(preorder, bound);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，所有递归调用都共享同一个下标 <code>i</code>，它从 <code>0</code> 开始自增到 <code>preorder.size()</code> 后，所有递归退出。在每次递归调用中，除开构建节点的开销，都只有常数项的操作：至多两次比较，一次变量自增。因此，复杂度是 <code>$\Theta(n)$</code>。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>再多一点挑战：有没有办法用非递归的方式去实现这一算法呢？</p><p>既然会问出来，那答案肯定是「有」。</p><p>我们分析一下递归版本的代码。</p><ul><li>函数的默认参数 <code>std::numeric_limits&lt;int&gt;::max()</code> 实际上是为了简化代码实现，而引入的「哨兵」。</li><li>变量 <code>i</code> 在所有递归调用中共享，从 <code>0</code> 开始自增到 <code>preorder.size()</code> 后，所有递归退出，实际上起到了循环的作用。</li><li>每次递归调用中，<code>preorder</code> 是不变的，变化的只有 <code>bound</code>；它保证了在处理右子树之前，先处理完左子树的所有节点。</li></ul><p>因此，若要非递归地实现这一算法，我们需要：</p><ul><li>用某种方式，重新引入哨兵 <code>std::numeric_limits&lt;int&gt;::max()</code>；</li><li>循环，从 <code>0 -&gt; preorder.size()</code>；</li><li>提供一个栈，直接或间接地保存这里的 <code>bound</code>。</li></ul><p>于是有实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rebuildBST</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">  TreeNode* dummy = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::max());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">  s.push(dummy);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x : preorder) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(x);</span><br><span class="line">    TreeNode* wk = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (; s.top()-&gt;val &lt; x; wk = s.top(), s.pop()) &#123; ; &#125;</span><br><span class="line">    <span class="keyword">if</span> (wk == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      s.top()-&gt;left = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wk-&gt;right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode* res = dummy-&gt;left;</span><br><span class="line">  dummy-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">delete</span> dummy;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>dummy</code> 起到了哨兵的作用；<code>for (:)</code> 是上述提到的循环；<code>for (;;)</code> 里每一次弹栈，都意味着遇到了右孩子，对应递归版本中的 <code>return nullptr;</code>。</p><p>从非递归的版本中看时间复杂度是很明显的。<code>for (:)</code> 之外的内容只有常数复杂度，<code>for (:)</code> 循环之内的内容要重点分析 <code>for (;;)</code> 循环。<code>for (;;)</code> 循环每执行一次，都有一次 <code>s.pop()</code> 操作，它与 <code>s.push(node)</code> 一一对应。因此，有多少次 <code>s.push(node)</code> 就有多少次 <code>s.pop()</code>（不算 <code>s.push(dummy)</code>）。于是，均摊到每次 <code>for (:)</code> 循环中去，<code>for (;;)</code> 恰好只执行一次 <code>wk = s.top()</code> 和 <code>s.pop()</code>。于是 <code>for (:)</code> 之内的内容也只有常数复杂度。于是，这个实现的复杂度为 <code>$\Theta(n)$</code>。</p><p>这里非递归的实现，是从递归实现中变形出来的。但实际上，非递归的实现，也有其自身的含义。</p><p>首先看「栈」。由于是「前序遍历」，所以一个节点的祖辈节点一定在父辈节点之前。考虑到任何一个节点，都只和父亲节点直接建立联系，因此从前往后遍历 <code>preorder</code> 时，必然要用到栈结构，保存历代祖先。（捶桌笑）</p><p>然后看弹栈的循环。这实际上透露的是一种自底向上的思路：如果我遇到了一个节点，它是某个节点的左孩子，那么一定是刚才入栈的节点；如果它是某个节点的右孩子，这意味着这个节点的左子树都已经处理完了，就要依次弹栈。通过这样的方式，我们能找到每一个「孩子」的「父亲」是谁。与之对应，递归版本的实现，则是一种自顶向下的思路：我现在有一个节点，它的左孩子在哪里，你给我找出来（递归调用），找到之后再继续找它的右孩子（递归调用）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到这个问题，我们的分析从确定唯一性开始。运用二叉搜索树中序遍历元素有序的特点，我们借助「前序中序唯一确定二叉树」的定理，很快确定了唯一性。（这要感谢 <code>@linjie</code>）</p><p>顺着唯一性出发，我们马上确定了一种重建二叉树的方法，从而确定了一个时间复杂度上界。</p><p>在确定上界之后，我们会希望继续降低算法的时间复杂度。自然而然地，我们从已有的方法出发，寻找可能的改进点。由于我们手头只有前序遍历结果，自然地，我们就会去想中序遍历在已有算法中起到的作用是什么，并寻找其替代。</p><p>如此，我们自顶向下地，很容易地找到了上述递归实现。在转递归为非递归的过成功中，我们又发现了自底向上的解法。这促使我们在将来的日子里，在符合常规思维的「自顶向下」中，多去找找「自底向上」的解法，可能会有奇效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到一个有趣的问题：已知有一个无重复元素的二叉搜索树的前序遍历结果，要求重建该二叉搜索树。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="BST" scheme="https://liam.page/tags/BST/"/>
    
      <category term="Preorder Traversal" scheme="https://liam.page/tags/Preorder-Traversal/"/>
    
  </entry>
  
  <entry>
    <title>Beamer frame 中的抄录环境</title>
    <link href="https://liam.page/2019/08/26/verbatim-environments-and-frame-in-beamer/"/>
    <id>https://liam.page/2019/08/26/verbatim-environments-and-frame-in-beamer/</id>
    <published>2019-08-26T04:19:34.000Z</published>
    <updated>2019-10-22T08:18:16.207Z</updated>
    
    <content type="html"><![CDATA[<p>今天 <code>@Butui Hu</code> 在群里问了一个老问题：怎么在 Beamer 的 frame 当中使用 <code>minted</code> 环境？</p><p>这个问题的答案很简单：其实不论是 <code>minted</code> 还是 <code>lstlisting</code> 还是基本的 <code>verbatim</code>，这些「抄录」环境与 <code>frame</code> 联用时，统统都需要给 <code>frame</code> 加上 <code>fragile</code> 参数，形如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;frame&#125;</span><span class="string">[fragile]</span></span></span><br><span class="line"><span class="comment">% verbatim-like environment.</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;frame&#125;</span></span></span><br></pre></td></tr></table></figure><p>但问题是，为啥事情会变成这个样子？这篇文章简单讨论一下。</p><a id="more"></a><h2 id="抄录环境是怎么实现的？"><a href="#抄录环境是怎么实现的？" class="headerlink" title="抄录环境是怎么实现的？"></a>抄录环境是怎么实现的？</h2><p>首先我们要解决的第一个问题是，类似 <code>verbatim</code> 的抄录环境是怎么实现的？</p><p>基本上说，抄录环境有这么一些特征：</p><ul><li>使用等宽字符字族 <code>\ttfamily</code> 排版内容；</li><li>排版所有空格，而非<a href="/2018/01/31/TeX-by-Topic-the-Structure-of-the-TeX-processor/#%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5">让输入处理器进入 S 状态忽略空格</a>；</li><li>在每个回车处换行；</li><li>原样抄录<strong>每一个</strong>字符。</li></ul><p>当然，对于 <code>minted</code> 和 <code>lstlisting</code> 之类的环境，还会有为特定字符、词组渲染颜色的功能。但这些都是「锦上添花」，我们要关注的核心还是上面四条。</p><p>很显然，抄录环境对于输入内容的处理方式与正常内容的处理方式有很大差异。比如，反斜线 <code>\</code> 原本作为 TeX 默认的转义字符，此时却要原样输出。我们知道，TeX 中之所以有诸多特殊用途的字符（<code>\</code>, <code>{</code>, <code>}</code>, <code>$</code> 等等），其原因在于<a href="/2018/05/05/TeX-by-Topic-Category-Codes-and-Internal-States/">输入处理器读入内容时，会为每个字符分配分类码</a>。输入处理器会根据字符和字符的分类码，将输入内容处理成记号流（token stream），交由展开处理器继续处理。显然，抄录环境要改变 TeX 中特殊用途的字符的行为，就必须要改变他们的分类码。实际上，这些字符的分类码，在抄录环境中，都会被设置为 <code>12</code>（other）。</p><p>此外，为了恢复这些特殊用途的字符，TeX 要在合适的位置重新设置这些字符的分类码。对于 LaTeX 使用者来说，很显然这个「时机」就应该是 <code>\end{varbatim}</code> 出现时了。这个论断说对也对，说不对也不完全对。考虑到，进入抄录环境之后，诸如 <code>\</code> 的分类码已经改变，因此 <code>\end{varbatim}</code> 不会像正常的「结束环境」的标志那样被 TeX 识别并处理。于是，为了达到预期效果，你必须把 <code>\end{varbatim}</code> 单独成行，作为恢复分类码的标志。也就是说，<code>\end{varbatim}</code> 在这里起到的是一个纯粹的标志作用，而不是通常意义上「结束环境」的作用。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begingroup</span></span></span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span> `|=0 <span class="tag">\<span class="name">catcode</span></span> `[= 1 <span class="tag">\<span class="name">catcode</span></span>`]=2</span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span> `<span class="tag">\<span class="name">&#123;</span>=<span class="number">12</span></span> <span class="tag">\<span class="name">catcode</span></span> `<span class="tag">\<span class="name">&#125;</span>=<span class="number">12</span></span> <span class="tag">\<span class="name">catcode</span></span>`<span class="tag">\<span class="name">\</span>=<span class="number">12</span></span></span><br><span class="line">|gdef|@xverbatim#1<span class="tag">\<span class="name">end</span><span class="string">&#123;verbatim&#125;</span><span class="string">[#1|end[verbatim]</span></span>]</span><br><span class="line">|gdef|@sxverbatim#1<span class="tag">\<span class="name">end</span><span class="string">&#123;verbatim*&#125;</span><span class="string">[#1|end[verbatim*]</span></span>]</span><br><span class="line">|endgroup</span><br></pre></td></tr></table></figure><p>上面这段代码是 LaTeX2e 中有关抄录环境结束的命令的定义。在由 <code>begingroup</code> 和 <code>endgroup</code> 形成的 semi-group 分组中，我们将 <code>|</code> 定义为转义字符（<code>0</code>），<code>[]</code> 分别定义为分组开始和结束的字符（<code>1</code>, <code>2</code>），然后把 <code>{}\</code> 都定义为「其他字符」（<code>12</code>）。虽有，用 <code>|gdef</code>（相当于平时的 <code>\gdef</code>）超出 semi-group 的范围，定义控制序列 <code>@xverbatim</code>，它接受 1 个参数，这个参数以 <code>\end{verbatim}</code> 这串字符结尾，同时将它的内容替换成实际内容 <code>#1</code>，以及有实际含义的 <code>|end[verbatim]</code>（后者会被展开成 <code>\endverbatim</code> 命令，负责真正的「结束环境」的工作）。</p><p>一顿操作猛如虎，最终还靠分类码。而最最重要的是我们得知道，<strong>分类码是由输入处理器在读入文件时设置的</strong>。</p><h2 id="脆弱命令是怎么回事？"><a href="#脆弱命令是怎么回事？" class="headerlink" title="脆弱命令是怎么回事？"></a>脆弱命令是怎么回事？</h2><p>在输入处理器把文本流变成记号流之后，展开处理器和执行处理器就开始工作啦！通常来说，展开处理器会拼了老命将记号展开成更加底层的记号，直到不可展开，然后执行处理器开始执行各个不可展开的底层记号。</p><p>但某些情况下，这个流程会有问题。其中一个典型的例子，就是所谓的「移动参数」问题。</p><p>考虑 <code>\section{}</code> 命令。它做四件事：</p><ol><li>编号自增 1</li><li>输出章节标题</li><li>处理目录（和 PDF 书签）</li><li>做页眉的章节标记</li></ol><p>其中 (3) 依赖于将标题内容和编号写入 <code>&lt;jobname&gt;.toc</code> 文件，当 TeX 第二遍编译时，从 <code>&lt;jobname&gt;.toc</code> 文件读入内容再去排版目录。也就是说，此类命令的具体含义在两次编译过程中是不一样的，而具体它是什么含义（最终效果），要等排版完成之后才能确定。</p><p>问题在于：</p><ol><li>TeX 在写文件时，会将宏——此处特别注意 <code>\section{}</code> 参数中可能包含的宏——完全展开；</li><li>但完全展开写入文件之后，又要重新为 TeX 所读入，这时可能造成奇怪的错误。</li></ol><blockquote><p>比方说，<code>\(\)</code> 展开后会包含很多带有 <code>@</code> 的内容，如果将这些内容写入文件，再重新读入，就会因为 <code>@</code> 的分类码是 <code>12</code> 而非 <code>11</code> 不能作为控制序列的一部分而报错。</p></blockquote><p>我们将提前展开和延后展开的最终效果不一样的命令，称之为脆弱命令（fragile commands）。与之对应的，就是健壮命令（robust commands）。</p><h2 id="这和-frame-有什么关系？"><a href="#这和-frame-有什么关系？" class="headerlink" title="这和 frame 有什么关系？"></a>这和 <code>frame</code> 有什么关系？</h2><p>为此我们需要查看 Beamer 的文档。文档 12.9 节提到：</p><blockquote><p>If you wish to use a <code>{verbatim}</code> environment in a <code>frame</code>, you have to add the option <code>[fragile]</code> to the <code>{frame}</code> environment. In this case, <code>[...]</code> and the <code>\end{frame}</code> must be alone on a single line. Using this option will cause the frame contents to be written to an external file and the read back.</p></blockquote><p>这段提到了在 <code>frame</code> 当中使用抄录环境，必须制定 <code>fragile</code> 参数。但仍然没有解释「为啥要用」。继续找到文档 8.1 节：</p><blockquote><p>If a frame contains fragile text, different internal mechanisms are used to typeset the frame to ensure that inside the frame the character codes can be reset. The price of switching to another internal mechanism is that either you cannot use overlays or an external file needs to be written and read back (which is not always desirable).</p><p>In detail, the following happens when this option is given for normal (pdf)LaTeX: The contents of the frame is scanned and then written to a special file named <code>⟨jobname⟩.vrb</code> or, if a label has been assigned to the frame, <code>⟨jobname⟩.⟨current frame number⟩.vrb</code>. Then, the frame is started anew and the content of this file is read back. Since, upon reading of a file, the character codes can be modified, this allows you to use both verbatim text and overlays.</p><p>To determine the end of the frame, the following rule is used: The first occurence of a single line containing exactly <code>\end{⟨frame environment name⟩}</code> ends the frame. The <code>⟨environment name⟩</code> is normally <code>frame</code>, but it can be changed using the <code>environment</code> option. This special rule is needed since the frame contents is, after all, not interpreted when it is gathered.</p></blockquote><p>这样我们就明白了。<code>frame</code> 在某种程度上限制了环境内容对分类码的修改。因此，对于抄录环境这样需要修改分类码来实现目的的「脆弱内容」，我们要指定 <code>fragile</code> 参数，然后 Beamer 会将这些内容写入到外部文件（为此 <code>frame</code> 环境变成了脆弱命令）。然后，在再次读入这些内容时，让输入处理器有机会正确处理分类码。如此一来，才能顾全这些「脆弱内容」的渲染，和 Beamer 的 <code>overlay</code> 效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天 &lt;code&gt;@Butui Hu&lt;/code&gt; 在群里问了一个老问题：怎么在 Beamer 的 frame 当中使用 &lt;code&gt;minted&lt;/code&gt; 环境？&lt;/p&gt;
&lt;p&gt;这个问题的答案很简单：其实不论是 &lt;code&gt;minted&lt;/code&gt; 还是 &lt;code&gt;lstlisting&lt;/code&gt; 还是基本的 &lt;code&gt;verbatim&lt;/code&gt;，这些「抄录」环境与 &lt;code&gt;frame&lt;/code&gt; 联用时，统统都需要给 &lt;code&gt;frame&lt;/code&gt; 加上 &lt;code&gt;fragile&lt;/code&gt; 参数，形如：&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;\&lt;span class=&quot;name&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;[fragile]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;% verbatim-like environment.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;\&lt;span class=&quot;name&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但问题是，为啥事情会变成这个样子？这篇文章简单讨论一下。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Beamer" scheme="https://liam.page/tags/Beamer/"/>
    
      <category term="Verbatim" scheme="https://liam.page/tags/Verbatim/"/>
    
      <category term="Fragile" scheme="https://liam.page/tags/Fragile/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 上挂载/卸载磁盘</title>
    <link href="https://liam.page/2019/08/23/mount-and-unmount-disk-in-Linux/"/>
    <id>https://liam.page/2019/08/23/mount-and-unmount-disk-in-Linux/</id>
    <published>2019-08-23T06:30:19.000Z</published>
    <updated>2019-10-22T08:18:16.206Z</updated>
    
    <content type="html"><![CDATA[<p>昨天正在训练线上模型的机器被人误操作，不得不重做系统。万幸模型相关的训练状态保存在另一块磁盘上，没有受到影响。要想恢复训练状态相关数据，就必须把磁盘挂载好。因为这个操作不常用，一时居然都没想起来怎么做。因此这里「烂笔头」记录下来。</p><a id="more"></a><h2 id="查看机器上的磁盘"><a href="#查看机器上的磁盘" class="headerlink" title="查看机器上的磁盘"></a>查看机器上的磁盘</h2><p><code>fdisk</code> 是 Linux 上用来操作磁盘分区表的工具。使用 <code>fdisk -l</code> 命令，可以列出系统识别的所有磁盘及其分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 599.1 GB, 599051206656 bytes, 1170021888 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 262144 bytes / 262144 bytes</span><br><span class="line">Disk label type: # masked</span><br><span class="line">Disk identifier: # masked</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048   204802047   102400000   83  Linux</span><br><span class="line">/dev/sda2       204802048   213190655     4194304   82  Linux swap / Solaris</span><br><span class="line">/dev/sda3   *   213190656  1170020351   478414848   83  Linux</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 6118.5 GB, 6118546079744 bytes, 11950285312 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 262144 bytes / 262144 bytes</span><br></pre></td></tr></table></figure><p><code>/dev</code> 目录下的 <code>sd?</code> 即是物理磁盘。例如 <code>sda</code> 是系统读到的第一块磁盘，<code>sdb</code> 则是第二块磁盘。在较老的 kernel 中，由于没有 ATA 支持，因此物理磁盘可能是 <code>/dev/hd?</code>（IDE）或者是 <code>/dev/sd?</code>（SCSI）。</p><p><code>/dev/sda?</code> 则是 <code>sda</code> 这块物理磁盘上的分区。<code>/dev/sda1</code> 是该磁盘上的第一块分区。</p><p>这里 <code>/dev/sdb</code> 这块磁盘尚未被正确挂载，而正是它保存了所需的数据。</p><h2 id="创建挂载点"><a href="#创建挂载点" class="headerlink" title="创建挂载点"></a>创建挂载点</h2><p>在挂载磁盘之前，首先要为它创建一个挂载点。挂载点说白了是一个目录，在执行 <code>mount</code> 命令挂载前，它必须是已经存在的目录。挂载成功后，访问该目录即可访问相应磁盘的内容。若挂载前挂载点中存在内容，则挂载后这些内容暂不可见，当卸载后这些内容又会变得可见。</p><p>比如我想将磁盘挂载于 <code>/mnt/data</code> 就要创建这样一个空目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/data</span><br></pre></td></tr></table></figure><h2 id="确定磁盘文件系统类型"><a href="#确定磁盘文件系统类型" class="headerlink" title="确定磁盘文件系统类型"></a>确定磁盘文件系统类型</h2><p>在挂载磁盘之前，还需要确定磁盘（分区）的文件系统类型。若不然，挂载时选错文件系统类型可能造成一系列奇怪的现象。为此，我们需要执行 <code>parted -l</code> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> parted -l</span></span><br><span class="line">Model: # masked</span><br><span class="line">Disk /dev/sda: 599GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End    Size    Type     File system     Flags</span><br><span class="line"> 1      1049kB  105GB  105GB   primary  xfs</span><br><span class="line"> 2      105GB   109GB  4295MB  primary  linux-swap(v1)</span><br><span class="line"> 3      109GB   599GB  490GB   primary  xfs             boot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: # masked</span><br><span class="line">Disk /dev/sdb: 6119GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: loop</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start  End     Size    File system  Flags</span><br><span class="line"> 1      0.00B  6119GB  6119GB  ext4</span><br></pre></td></tr></table></figure><p>由此可见，目标磁盘 <code>/dev/sdb</code> 的文件系统类型是 <code>ext4</code>。</p><h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><p>此时，我们就能挂载磁盘了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext4 /dev/sdb /mnt/data</span><br></pre></td></tr></table></figure><p>这里 <code>-t ext4</code> 表示目标磁盘（分区）的文件系统类型是 <code>ext4</code>，<code>/dev/sdb</code> 是待挂载的磁盘（分区），<code>/mnt/data</code> 是目标挂载点。</p><h2 id="卸载磁盘"><a href="#卸载磁盘" class="headerlink" title="卸载磁盘"></a>卸载磁盘</h2><p>与 <code>mount</code> 相对的命令是 <code>umount</code>。注意是 <code>umount</code> 而不是 <code>unmount</code>——没有那个 <code>n</code>。</p><p>卸载时，给 <code>umount</code> 的参数可以是挂载点，也可以是磁盘（分区）的名字。在这里，以下两种操作等价：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sdb</span><br><span class="line">umount /mnt/data</span><br></pre></td></tr></table></figure><p>若是希望挂载的磁盘正在被其他进程读写，则 Linux 会提示 <code>device is busy</code>。此时，可以执行 <code>umount -l</code> 命令，让 Linux 在无其他进程读写目标磁盘时，再行卸载。或者，也可以用 <code>ps</code> 命令查看使用该磁盘的进程有哪些，然后妥当处理后再卸载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天正在训练线上模型的机器被人误操作，不得不重做系统。万幸模型相关的训练状态保存在另一块磁盘上，没有受到影响。要想恢复训练状态相关数据，就必须把磁盘挂载好。因为这个操作不常用，一时居然都没想起来怎么做。因此这里「烂笔头」记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
      <category term="Disk" scheme="https://liam.page/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>找到两个有序数组的中位数</title>
    <link href="https://liam.page/2019/08/22/find-median-of-two-sorted-arrays/"/>
    <id>https://liam.page/2019/08/22/find-median-of-two-sorted-arrays/</id>
    <published>2019-08-22T04:08:21.000Z</published>
    <updated>2019-10-22T08:18:16.204Z</updated>
    
    <content type="html"><![CDATA[<p>这是 LeetCode 的<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">第 4 题</a>，<code>@linjie</code> 问到我说，这题网上的解答看完都迷迷糊糊的，希望我能写篇博客重新讲一下。于是有此篇。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现有不同时为空的非降序排列的数组 <code>A</code> 和 <code>B</code>，其长度分别是 <code>m</code> 和 <code>n</code>。不失一般性，假设 <code>m &lt;= n</code>。记 <code>A</code> 和 <code>B</code> 的中位数为 <code>x</code>。要求写代码实现，在 <code>$\Theta(\log(m + n))$</code> 的时间复杂度内找到 <code>x</code>。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>见到时间复杂度要求中有 <code>$\log$</code>，就肯定要想到二分搜索。</p><p>二分搜索的本质是在一个有序 randomly accessible array 中，寻找一个满足某种跟元素顺序相关的条件的元素的方法。这个「跟元素顺序相关的条件」，在最初的版本里是「等于某个数值」，扩展版本可以是「第一个不小于给定数值的值」之类的（参考<a href="https://liam.page/2018/11/23/binary-search-and-its-variants/">前作</a>）。展开来说，满足以下 4 个要素时，可以用到二分搜索：</p><ul><li>array 只有 1 个，或者可以将多个 array 问题简化成 1 个 array 的问题；</li><li>array 是 randomly accessible 的；</li><li>array 是有序的；</li><li>搜索 array 中的元素时，限制条件是跟元素顺序有关的。</li></ul><p>因此，为了利用二分搜索，我们必须要想办法：</p><ol><li>变两个序列的问题为 1 个序列的问题；</li><li>找到某个「跟元素顺序相关的条件」。</li></ol><p>首先考虑 (1)。</p><p>设 <code>i</code> 是 <code>A</code> 中的下标，而 <code>j</code> 是 <code>B</code> 中的下标：<code>A[i]</code> 是 <code>A</code> 中第一个大于等于中位数 <code>x</code> 的元素；同时 <code>B[j]</code> 是 <code>B</code> 中第一个大于等于中位数 <code>x</code> 的元素。当 <code>A</code> 中元素全部小于 <code>x</code> 时，<code>i = m</code>；同理，当 <code>B</code> 中元素全部小于 <code>x</code> 时，<code>j = n</code>。</p><p>这意味着，<code>A</code> 中小于 <code>x</code> 的元素数量为 <code>i</code>，<code>B</code> 中小于 <code>x</code> 的元素数量为 <code>j</code>；<code>A</code> 中大于等于 <code>x</code> 的元素数量为 <code>m - i</code>，<code>B</code> 中大于等于 <code>x</code> 的元素数量为 <code>n - j</code>。满足条件：</p><ul><li>当 <code>m + n</code> 是偶数：<code>i + j = (m - i) + (n - j)</code>，此时 <code>j = (m + n) / 2 - i</code>。</li><li>当 <code>m + n</code> 是奇数：<code>i + j = (m - i) + (n - j) - 1</code>，此时 <code>j = (m + n - 1) / 2 - i = (m + n) / 2 - i</code>（考虑整数除法除不尽时向零取整）。</li></ul><p>所以 <code>j</code> 有统一的表达式 <code>(m + n) / 2 - i</code>。这样一来，我们就建立了两个序列下标之间的对应关系，从而将两个序列的问题变为了 1 个序列的问题。</p><p>接着考虑 (2)。</p><p>考虑 <code>x</code> 是中位数，而 <code>A[i]</code> 和 <code>B[j]</code> 分别是 <code>A</code> 和 <code>B</code> 两个序列中第一个大于等于中位数 <code>x</code> 的元素。因此有：</p><ol><li><code>A[i - 1] &lt; x &lt;= A[i]</code>；</li><li><code>A[i - 1] &lt; x &lt;= B[j]</code>；</li><li><code>B[j - 1] &lt; x &lt;= A[i]</code>；</li><li><code>B[j - 1] &lt; x &lt;= B[j]</code>。</li></ol><p>其中 (1) 和 (4) 是 trivial 的。考虑 (2) 和 (3)，即得到目标「条件」：<code>(i == 0 or A[i - 1] &lt; x &lt;= B[j]) and (i == m or B[j - 1] &lt; x &lt;= A[i])</code>。</p><p>因此有伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, m + 1):</span><br><span class="line">  bsearch to find i, s.t.:</span><br><span class="line">    (i == 0 or A[i - 1] &lt; x &lt;= B[j]) and (i == m or B[j - 1] &lt; x &lt;= A[i])</span><br><span class="line"></span><br><span class="line">if (m + n) % 2 == 0:</span><br><span class="line">  # carefully handle index out-of-bound</span><br><span class="line">  return static_cast&lt;double&gt;(max(A[i - 1], B[j - 1]) + min(A[i], B[j])) / 2.0</span><br><span class="line">else:</span><br><span class="line">  # carefully handle index out-of-bound</span><br><span class="line">  return min(A[i], B[j])</span><br></pre></td></tr></table></figure><p>算法的时间复杂度是 <code>$\Theta(\log(\min(m, n)))$</code>，空间复杂度是 <code>$\Theta(1)$</code>。</p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h2><p>给一个 C++ 版本的完整实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> findMedianInSortedArray(B);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> findMedianInSortedArray(A);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> bsearchWrapper(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">findMedianInSortedArray</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = v.size();</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v[len / <span class="number">2</span>] + v[len / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> v[len / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">bsearchWrapper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> m = A.size(), n = B.size();</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">return</span> bsearchHelper(A, B);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> bsearchHelper(B, A);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">bsearchHelper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> m = A.size(), n = B.size();</span><br><span class="line">    <span class="keyword">size_t</span> left = <span class="number">0</span>, right = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      i = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      j = (m + n) / <span class="number">2</span> - i;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">not</span>(i == m <span class="keyword">or</span> B[j - <span class="number">1</span>] &lt; A[i])) &#123;</span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">not</span>(i == <span class="number">0</span> <span class="keyword">or</span> A[i - <span class="number">1</span>] &lt; B[j])) &#123;</span><br><span class="line">        right = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">double</span> mx = (i == m) ? B[j] : ((j == n) ? A[i] : <span class="built_in">std</span>::min(A[i], B[j]));</span><br><span class="line">      <span class="keyword">double</span> mn = (i == <span class="number">0</span>) ? B[j - <span class="number">1</span>] : ((j == <span class="number">0</span>) ? A[i - <span class="number">1</span>] : <span class="built_in">std</span>::max(A[i - <span class="number">1</span>], B[j - <span class="number">1</span>]));</span><br><span class="line">      <span class="keyword">return</span> (mn + mx) / <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (i == m) ? B[j] : ((j == n) ? A[i] : <span class="built_in">std</span>::min(A[i], B[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 LeetCode 的&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第 4 题&lt;/a&gt;，&lt;code&gt;@linjie&lt;/code&gt; 问到我说，这题网上的解答看完都迷迷糊糊的，希望我能写篇博客重新讲一下。于是有此篇。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="LeetCode" scheme="https://liam.page/tags/LeetCode/"/>
    
      <category term="bsearch" scheme="https://liam.page/tags/bsearch/"/>
    
  </entry>
  
  <entry>
    <title>使用 vimdiff 时忽略白空格的修改</title>
    <link href="https://liam.page/2019/08/06/ignnore-white-space-differences-when-using-vimdiff/"/>
    <id>https://liam.page/2019/08/06/ignnore-white-space-differences-when-using-vimdiff/</id>
    <published>2019-08-06T14:07:12.000Z</published>
    <updated>2019-10-22T08:18:16.203Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>vimdiff</code> 能够方便地观察多个文件之间的异同。但有时我们会希望 VIM 忽略白空格的变化。比如，对于 Python 脚本，有时我们会修改缩进来对代码进行格式化；此时对比新旧文件之间的差异时，我们更多地是希望看看有没有手误修改了其他不应修改的部分，从而应当忽略白空格的变化。</p><p>这篇文章简单记录一下这个问题的解法。</p><a id="more"></a><p>这个问题其实不难解决，只需在 <code>vimrc</code> 中加入以下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> diffopt+=iwhite</span><br></pre></td></tr></table></figure><p>不过，这样设定也会影响到 VIM 正常编辑时所处的模式。如果希望这一设定只限定在 <code>vimdiff</code> 模式，则可以这样修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &amp;diff</span><br><span class="line">    <span class="built_in">set</span> diffopt+=iwhite</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>若是想要自由切换，则可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &amp;diff</span><br><span class="line">  map gs :call IwhiteToggle()&lt;CR&gt;</span><br><span class="line">  <span class="keyword">function</span>! IwhiteToggle()</span><br><span class="line">    <span class="keyword">if</span> &amp;diffopt =~ <span class="string">'iwhite'</span></span><br><span class="line">      <span class="built_in">set</span> diffopt-=iwhite</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">set</span> diffopt+=iwhite</span><br><span class="line">    endif</span><br><span class="line">  endfunction</span><br><span class="line"> endif</span><br></pre></td></tr></table></figure><p>最后，若不想修改 <code>vimrc</code> 可以在命令行这样启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff -c <span class="string">'set diffopt+=iwhite'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;vimdiff&lt;/code&gt; 能够方便地观察多个文件之间的异同。但有时我们会希望 VIM 忽略白空格的变化。比如，对于 Python 脚本，有时我们会修改缩进来对代码进行格式化；此时对比新旧文件之间的差异时，我们更多地是希望看看有没有手误修改了其他不应修改的部分，从而应当忽略白空格的变化。&lt;/p&gt;
&lt;p&gt;这篇文章简单记录一下这个问题的解法。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="VIM" scheme="https://liam.page/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>科技论文中的图片</title>
    <link href="https://liam.page/2019/07/30/figures-in-scitech-papers/"/>
    <id>https://liam.page/2019/07/30/figures-in-scitech-papers/</id>
    <published>2019-07-30T02:35:07.000Z</published>
    <updated>2019-10-22T08:18:16.201Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说「一图胜千言」。图片带来的信息量往往远超同样面积文字带来的信息量——君不见，「看图说话」这一技能从小学开始一直训练到大学甚至研究生阶段。可见图片是论文写作中很重要的一环。</p><p>另一方面，图片无处不在；普通用户从刚接触计算机开始，就接触了很多的图片。对于司空见惯的事物，人们往往会「自我感觉良好」而忽略了其中的很多细节。这种忽略，造成了论文写作中千奇百怪的图片问题。</p><p>这篇文章受邀就图片的格式和分辨率做一些展开讨论，希望能帮助读者避免一些坑。</p><a id="more"></a><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>图片的格式多种多样，最常见的有 <code>jpg</code>, <code>png</code>, <code>gif</code> 等。在具体讨论这些图片格式之前，首先我们要讨论一下矢量图和位图的区别。</p><table><thead><tr><th></th><th>矢量图</th><th>位图</th></tr></thead><tbody><tr><td>表示图像的方法</td><td>用点、直线、多边形表示</td><td>用像素表示</td></tr><tr><td>保存的信息</td><td>只需要保存点、距离、线条颜色、填充颜色等信息，文件体积小</td><td>需要保存每个像素的颜色信息，文件体积大</td></tr><tr><td>缩放</td><td>放大或缩小不会失真</td><td>放大到一定程度时会失真</td></tr><tr><td>常见格式</td><td><code>ai</code>, <code>eps</code>, <code>pdf</code>, <code>svg</code>, <code>dwg</code>, <code>dxf</code>, <code>cdr</code>, <code>emf</code></td><td><code>bmp</code>, <code>jpg</code>, <code>png</code>, <code>gif</code>, <code>tif(f)</code></td></tr></tbody></table><p>显然，因为矢量图的种种优异特性，在有选择余地时，我们应当优先选择矢量图作为论文插图格式。</p><p>这里需要注意的一点是，虽然诸如 <code>eps</code> 格式的图片支持矢量图，但并不是所有格式为 <code>eps</code> 的图片都是矢量图。这是因为，出于兼容性考虑，往往支持矢量图的格式，也能够用来保存位图。因此，</p><ul><li>位图格式的图片，一定是位图；</li><li>矢量图格式的图片，可能是矢量图，也可能是位图，需要仔细判断。</li></ul><p>对于 LaTeX 用户来说，建议的图片格式顺序如下：</p><ul><li><code>pdf</code>：PDF 格式支持矢量图，并且一般用 LaTeX 输出的就是 PDF 格式的文档，兼容性相对最好。</li><li><code>png</code>：PNG 格式是位图里信息丢失较少的格式，因此推荐。</li><li><code>jpg</code>：对于「照片」类图片资源，使用 JPG 格式也是可以接受的。</li><li><code>eps</code>：EPS 格式可以支持矢量图，但由于历史原因，和 EPS 格式相关的问题很多，因此除非在期刊有要求的情况下，不推荐使用 EPS 格式的图片。</li></ul><h2 id="图片分辨率"><a href="#图片分辨率" class="headerlink" title="图片分辨率"></a>图片分辨率</h2><p><img alt data-src="/uploads/images/LaTeX/resolution_illustration.png"></p><p>分辨率这个概念用处比较多。对于图片来说有分辨率，对于显示器来说有分辨率，对于打印机、光学鼠标、扫描仪等来说也有分辨率。因此分辨率这个概念，粗看好像很容易理解，细细一想也是蛮让人头疼的。</p><p>要确切地理解分辨率，就要从源头开始，搞清楚为什么会设定这样一个概念。</p><p>抛开量子力学来说，普通人能接触到的自然世界的物体，都可以认为是连续的。但是，在涉及到图像处理时，由于硬件的限制，计算机往往很难用连续的办法描绘、应用图像。这种情况下，人们就发明了「像素」这个概念——用一个像素来描绘像素内的平均图像信息。——这其实是「模拟信号」和「数字信号」的关系。这样一来，当单个像素面积趋向于无穷小时，计算机描绘的整体图像就趋近于真实情况。反过来说，单位面积的像素趋向于无穷大时，计算机描绘的整体图像就趋向于真实情况。</p><p>请注意，这里用了「描绘」这样一个相对来说比较模糊的词。这是为了让这一阐述能够适应多个涉及到图像处理的情况。</p><ul><li>对于位图，「描绘」就简单地指位图所记录的图像信息。显然像素越小，图像信息的细节就越丰富。</li><li>对于显示器，「描绘」指显示器对图像信息的「呈现」。显然像素越小，显示器描绘的图像就越逼真。</li><li>对于打印机，「描绘」侧重打印时对图像细节信息的重现。显然像素越小，打印机的打印结果就越清晰。</li><li>对于光学鼠标、扫描仪、感光设备，「描绘」侧重对图像光学信号的「捕捉」。显然像素越小，光学鼠标、扫描仪、感光设备就越灵敏。</li></ul><p>小结一下，由于计算机很难直接处理模拟信号，因此不得不借用像素这个概念将图像信息转换成数字信号。因此，计算机内部处理的图像数据对真实情况描绘得越精确，就要求像素越小，也就是单位面积像素的数量越高。</p><p>于是，我们将单位长度（通常以英寸计）内像素数量 ppi 作为分辨率的单位。在感光设备上，我们也用单位长度内感光元件（点）的数量 dpi 作为分辨率的单位。值得一提的是，感光元件（点）一般来说最终会一一对应到像素上。因此在不严肃的场合下，ppi 和 dpi 可以认为是同一单位。</p><p>接下来的问题是，在科技论文写作过程中，如果无法提供矢量图——因为矢量图永远是足够清晰的——而只能提供位图，我们提供多高分辨率的图片比较合适呢？与直觉可能相反：图像本身的细节越丰富，则投稿时图像所需的分辨率越低。这是因为，图像本身的细节丰富，意味着图像本身携带信息的冗余度较高。这时因为分辨率下降而带来的信息损失，对于阅读来说不容易造成坏的影响。按照以往经验，推荐的分辨率如下表所示。</p><table><thead><tr><th>图像细节丰富程度</th><th>建议的分辨率</th></tr></thead><tbody><tr><td>细节丰富的彩色、灰度图</td><td>300ppi</td></tr><tr><td>以色块区分的图表</td><td>600ppi</td></tr><tr><td>以单纯线条区分的黑白图表</td><td>1200 ppi</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说「一图胜千言」。图片带来的信息量往往远超同样面积文字带来的信息量——君不见，「看图说话」这一技能从小学开始一直训练到大学甚至研究生阶段。可见图片是论文写作中很重要的一环。&lt;/p&gt;
&lt;p&gt;另一方面，图片无处不在；普通用户从刚接触计算机开始，就接触了很多的图片。对于司空见惯的事物，人们往往会「自我感觉良好」而忽略了其中的很多细节。这种忽略，造成了论文写作中千奇百怪的图片问题。&lt;/p&gt;
&lt;p&gt;这篇文章受邀就图片的格式和分辨率做一些展开讨论，希望能帮助读者避免一些坑。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Graphics" scheme="https://liam.page/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>谈谈红眼睛悖论</title>
    <link href="https://liam.page/2019/07/27/the-paradox-of-red-eyes/"/>
    <id>https://liam.page/2019/07/27/the-paradox-of-red-eyes/</id>
    <published>2019-07-27T09:26:19.000Z</published>
    <updated>2019-10-22T08:18:16.196Z</updated>
    
    <content type="html"><![CDATA[<p>华人数学家陶哲轩曾经设计了这么一个有趣的思维实验：</p><ul><li>一个村子里有 100 聪明人；</li><li>100 人中，有 5 人眼睛是红色的，其余 95 人的眼睛是蓝色的；</li><li>村子里禁止讨论「眼睛颜色」这个话题；</li><li>通过任何方式知道自己眼睛颜色的人，第二天必须在村子中心的广场上公开自杀。</li></ul><p>现在有一个路过的外乡人看到村子之后，公开说了这么一句话：「村子里存在红眼睛的人」。然后，5 天后，村子里红眼睛的人就在村子中心的广场上集体自杀了。</p><p>这篇文章讨论这个有趣的思维实验。</p><a id="more"></a><h2 id="自杀的原因"><a href="#自杀的原因" class="headerlink" title="自杀的原因"></a>自杀的原因</h2><p>这一节里，我们来解惑，为什么外乡人宣布「村子里存在红眼睛的人」之后 5 天，这些人就集体自杀。这里我们要用到曾经用到过的<a href="/2018/11/07/pirates-and-golds-and-president-Trump/#%E9%80%86%E5%90%91%E6%8E%A8%E7%90%86">逆向推理</a>。</p><h3 id="只有-1-人红眼睛"><a href="#只有-1-人红眼睛" class="headerlink" title="只有 1 人红眼睛"></a>只有 1 人红眼睛</h3><p>首先我们假设，村子里有 99 人眼睛是蓝色的，只有 1 人眼睛是红色的。我们记他为 A。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，A 发现村子里其他人的眼睛都不是红色的，那么自己的眼睛肯定是红色的。因此，</li><li>在外乡人离开后的第 1 天，A 自杀了。</li></ul><h3 id="有-2-人红眼睛"><a href="#有-2-人红眼睛" class="headerlink" title="有 2 人红眼睛"></a>有 2 人红眼睛</h3><p>这一次我们假设，村子里有 98 人眼睛是蓝色的，只有 2 人眼睛是红色的。我们记他为 A 和 B。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，以 A 为例：在他看来，如果自己的眼睛不是红色的，那么 B 明天就该自杀了，自己则平安无事。考虑到 A 和 B 地位等同，于是</li><li>在外乡人离开后的第 1 天，平安无事，无人自杀。这回，A 开始犯嘀咕了：B 没有自杀，那么我的假设就错了，那么我的眼睛就是红色的，我明天得自杀了。考虑到 A 和 B 地位等同，因此，</li><li>在外乡人离开后的第 2 天，A 和 B 自杀了。</li></ul><h3 id="有-3-人红眼睛"><a href="#有-3-人红眼睛" class="headerlink" title="有 3 人红眼睛"></a>有 3 人红眼睛</h3><p>这一次我们假设，村子里有 97 人眼睛是蓝色的，只有 3 人眼睛是红色的。我们记他为 A、B 和 C。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，以 A 为例：如果自己的眼睛不是红色，那么村子里有 2 人红眼睛，情况回到了上一小节描述的那样：B 和 C 应该在外乡人离开后的第 2 天自杀，自己则平安无事。考虑到 A、B 和 C 地位等同，于是，</li><li>在外乡人离开后的第 2 天，平安无事，无人自杀。这回，A 开始犯嘀咕了：B 和 C 没有自杀，那么我的假设就错了，那么我的眼睛就是红色的，我明天得自杀了。考虑到 A、B 和 C 地位等同，因此，</li><li>在外乡人离开后的第 3 天，A、B 和 C 自杀了。</li></ul><h3 id="有-k-人红眼睛"><a href="#有-k-人红眼睛" class="headerlink" title="有 $k$ 人红眼睛"></a>有 $k$ 人红眼睛</h3><p>这一次我们假设，村子里有 $100 - k$ 人眼睛是蓝色的，只有 $k$ 人眼睛是红色的。我们记他为 A 和他的红眼睛小伙伴们。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，以 A 为例：如果自己的眼睛不是红色，那么村子里有 <code>$k - 1$</code> 人红眼睛：这些红眼睛的小伙伴们应该在外乡人离开后的第 <code>$k - 1$</code> 天自杀，自己则平安无事。考虑到 A 和他的小伙伴们地位等同，于是，</li><li>在外乡人离开后的第 <code>$k - 1$</code> 天，平安无事，无人自杀。这回，A 开始犯嘀咕了：红眼睛的小伙伴们没有自杀，那么我的假设就错了，那么我的眼睛就是红色的，我明天得自杀了。考虑到 A 和他的小伙伴们地位等同，因此，</li><li>在外乡人离开后的第 <code>$k$</code> 天，A 和他的小伙伴们自杀了。</li></ul><p>当 $k = 5$ 时，就是陶哲轩思维实验中的情况。</p><h2 id="悖论"><a href="#悖论" class="headerlink" title="悖论"></a>悖论</h2><p>藏在这个思维实验中的悖论在于这个外乡人。在外乡人自己看来：这个存在本来就有红眼睛的人，而且每个人都知道这一点；那么自己的言论并没有带来新的信息，因此红眼睛的小伙伴们自杀跟我无关。但是显然，思维实验中的 5 个红眼睛的人自杀，必然经历了「我发现自己的眼睛是红色的」这样的过程。也就是说，他们从外乡人的言论里获得了新的信息。显然，这是一个悖论。</p><p>那么这是怎么一回事呢？</p><h3 id="平凡的情况"><a href="#平凡的情况" class="headerlink" title="平凡的情况"></a>平凡的情况</h3><p>对于平凡的情况，也就是 <code>$k = 1$</code> 的情况，这个悖论很好解释。当 <code>$k = 1$</code> 时，红眼睛的 A 原本是不知道村子里有红眼睛的人的。此时外乡人的言论就给 A 带来了新的信息量。</p><h3 id="非平凡的情况"><a href="#非平凡的情况" class="headerlink" title="非平凡的情况"></a>非平凡的情况</h3><p>对于非平凡的情况，也就是 <code>$k \geq 2$</code> 的情况，这个悖论就不那么好解释了。为了解释这个悖论，这里引入两个概念：</p><ul><li>共有信息：在一个群体里，如果每个人都知道某个信息，那么这个信息就是这个群体的共有信息。</li><li>公共信息：在一个群体里，如果每个人都确定其他所有人知道某个共有信息，那么这个信息就是公共信息。</li></ul><p>对于信息本身来说，从共有信息到公共信息的转变过程中，信息量没有变化。因为信息还是那个信息。但对于持有共有信息的群体来说，一个信息从共有信息到公共信息的转变过程中，群体持有的信息量是增加了的。因为群体从「不知道别人知道」变成了「知道别人知道」。</p><p>如此一来，我们就能解释这个悖论了。</p><p>在外乡人「宣布」之前，「村子中存在红眼睛的人」这个信息，是共有信息。村子里的每个人都知道这个信息，但是村子里的每个人都不确定其他人是否知道这个信息——这是由「禁止讨论眼睛的颜色」这一设定保证的。</p><p>在外乡人「宣布」之后，「村子中存在红眼睛的人」这个信息，就从共有信息变成了公共信息。村子里的每个人都知道这个信息，这一点没有改变。但是，这一次，村子里的每个人都知道其他所有人都知道这个信息。因此，对于村子中的所有村民来说，他们所持有的信息量增加了。这种信息量的增加，最终导致了 <code>$k$</code> 个红眼睛的人将在外乡人宣布这一信息之后的第 <code>$k$</code> 天集体自杀。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="表白"><a href="#表白" class="headerlink" title="表白"></a>表白</h3><p>在学生时代，很多人都经历过「暗恋」这个状态。具体来说，A 和 B 两个人互相喜欢。A 显然知道自己喜欢 B，A 也能从 B 平时的表现猜出 B 喜欢自己。也就是说，A 猜测自己和 B 是「彼此相爱」的。对于 B 来说，也是这样。</p><p>我们也知道，大多数的「暗恋」没有发展成恋人关系。这是为啥咧？因为「彼此相爱」这个信息，是 A 和 B 的共有信息，但不是公共信息。换言之，A 和 B 都不知道对方是否明白「彼此相爱」，于是不敢发展成恋人关系。我们知道，从共有信息转变成公共信息的过程，需要「宣布」这个动作。在恋爱关系中，「宣布」即是「表白」。也就是说，从暗恋状态转变为恋爱状态，需要 A 和 B 之间发生「表白」这个动作。</p><p>然而，由于害羞、父母师长的限制等因素，学生时代的暗恋往往缺少「表白」这个转换为恋爱关系的必要过程。这就是大多数暗恋没有发展成恋人关系的原因。</p><h3 id="垃圾股"><a href="#垃圾股" class="headerlink" title="垃圾股"></a>垃圾股</h3><p>如果一个股票的价格很高，但股票对应的公司业绩很差、不足以支撑股价，那么这种股票称之为垃圾股。现在的问题是，为什么垃圾股的股价能够持续虚高呢？</p><p>垃圾股「股价虚高」这个信息，对于持有该股票的投资人来说是共有信息。这些投资人——或者说投机者——都知道股价虚高，但是他们不确定别人是否知道。于是他们会期待会有「不知情」的人，以同样虚高的价格购入股票——我们称之为他们在等待「接盘侠」。</p><p>这时候，如有负面信息放出，告诉大家：「这公司业绩不行，这是个垃圾股」。这时候共有信息变成公共信息，导致的后果往往就是股价一泻千里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;华人数学家陶哲轩曾经设计了这么一个有趣的思维实验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个村子里有 100 聪明人；&lt;/li&gt;
&lt;li&gt;100 人中，有 5 人眼睛是红色的，其余 95 人的眼睛是蓝色的；&lt;/li&gt;
&lt;li&gt;村子里禁止讨论「眼睛颜色」这个话题；&lt;/li&gt;
&lt;li&gt;通过任何方式知道自己眼睛颜色的人，第二天必须在村子中心的广场上公开自杀。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在有一个路过的外乡人看到村子之后，公开说了这么一句话：「村子里存在红眼睛的人」。然后，5 天后，村子里红眼睛的人就在村子中心的广场上集体自杀了。&lt;/p&gt;
&lt;p&gt;这篇文章讨论这个有趣的思维实验。&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Paradox" scheme="https://liam.page/tags/Paradox/"/>
    
      <category term="Knowledge" scheme="https://liam.page/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统与计算广告差别之我见</title>
    <link href="https://liam.page/2019/07/27/difference-between-recommendation-system-and-computational-advertising/"/>
    <id>https://liam.page/2019/07/27/difference-between-recommendation-system-and-computational-advertising/</id>
    <published>2019-07-27T07:11:29.000Z</published>
    <updated>2019-10-22T08:18:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>这篇谈谈我眼中推荐系统和计算广告之间的差别。</p><p>当然，限于角色和身份，我只能站在算法工程师的角度，去谈一谈两种系统的优化目标之间的差异，以及这种差异引起的一系列不同。</p><a id="more"></a><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>从产品的角度来说，推荐系统一般被理解为是一种用户产品，而计算广告被理解为是一种商业产品。也就是说，推荐系统的终极目标是为了提高、维持、促进用户体验的，而计算广告的终极目标是为了赚钱、赚更多的钱、持续地赚更多的钱。</p><p>这样一来，推荐系统本质上是要处理<strong>用户体验</strong>的问题，而计算广告则复杂一些，需要平衡和协调好广告主、用户和广告平台（媒体）之间的利益。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>因为目标的不同，推荐系统和计算广告的优化方式就必然会有不同。以 CTR 预估模型为例：</p><ul><li>因为推荐系统的终极目标是提高、维持和促进用户体验，因此全部根据用户历史行为进行推荐，无异于是竭泽而渔——这会使用户很快对推荐系统推荐的内容产生倦怠感，从而离开推荐系统，造成用户流失。因此，推荐系统在使用 CTR 预估模型时，不宜全部按照 CTR 预估的结果从高到低排序，而是要兼顾诸如内容多样性、新颖性、时效性、流行度等因素。</li><li>对于计算广告来说，则简单一些。因为计算广告的目标是产生更多收益，因此在使用 CTR 预估的结果时，倾向于从高到低排序，将预估 CTR 较高的结果排在前面。</li></ul><h2 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h2><p>因为目标的不同，推荐系统和计算广告各自又会演化出不同的技术。这里仅举几例。</p><p>对于推荐系统来说，为了维持和促进用户体验，就必须要去挖掘用户的长期兴趣，这就引出了探索与利用（exploitation &amp; exploration）这一技术方向。此外，为了顾全多样性、时效性，推荐系统需要对新物料进行尽可能多且恰当的推荐。这就引出了新物料冷启动的问题。再者，考虑到长尾效应，有用户反馈的物料始终是少数，这必然会导致训练集数据倾斜较重。这就引出了有偏数据的处理相关的技术。</p><p>对于计算广告来说，由于要协调广告主、用户和广告平台（媒体）之间的利益，就会产生很多博弈。对于广告价格来说，广告主之间为了竞争广告位会有博弈，广告主和广告平台因为利益冲突也会有博弈。由此引出了出价策略（bidding strategy）的技术。另外，广告平台在同一时间能够提供的广告位是有限的，为了在获得一段时间内整体收入最高，就有必要对广告主投放的广告进行排期。由此引出了排期优化（yielding optimization）的技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇谈谈我眼中推荐系统和计算广告之间的差别。&lt;/p&gt;
&lt;p&gt;当然，限于角色和身份，我只能站在算法工程师的角度，去谈一谈两种系统的优化目标之间的差异，以及这种差异引起的一系列不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Insightful Thoughts" scheme="https://liam.page/categories/Insightful-Thoughts/"/>
    
    
      <category term="RecSys" scheme="https://liam.page/tags/RecSys/"/>
    
      <category term="CaclAd" scheme="https://liam.page/tags/CaclAd/"/>
    
  </entry>
  
  <entry>
    <title>为网页标题添加「崩溃了」彩蛋</title>
    <link href="https://liam.page/2019/07/22/crash-title-cheat/"/>
    <id>https://liam.page/2019/07/22/crash-title-cheat/</id>
    <published>2019-07-22T03:18:12.000Z</published>
    <updated>2019-10-22T08:18:16.186Z</updated>
    
    <content type="html"><![CDATA[<p>经常浏览<a href="/">「始终」博客</a>的读者很容易会发现，当你在浏览器中切换 tab 页到其它网页时，始终博客的页面会有一定概率「崩溃」。具体来说，tab 页上的标题会变成 <code>╭(°A°`)╮ 页面崩溃啦~</code> 这样子，切换回来之后又会发现页面其实没问题，同时标题会变成 <code>(ฅ&gt;ω&lt;*ฅ) 咦，又好了~</code> 这样子。因为这个彩蛋比较有趣，所以很多朋友回点回来看一看页面发生了什么。想想还是蛮有趣的。</p><p>最近有不少朋友问到这个效果是怎么实现的。这里记录一下。</p><a id="more"></a><p>因为功能十分简单，所以直接放代码出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;      <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> crashSwitched = <span class="literal">false</span>;               <span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="built_in">parseFloat</span>(&#123;&#123; theme.crash_title_cheat.probability &#125;&#125;)) &#123;         <span class="comment">// 3.</span></span><br><span class="line">      crashSwitched = <span class="literal">true</span>;              <span class="comment">// 2.a.</span></span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'&#123;&#123; theme.crash_title_cheat.crash_string &#125;&#125;'</span> + originalTitle;     <span class="comment">// 1.a.</span></span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (crashSwitched == <span class="literal">true</span>) &#123;</span><br><span class="line">      crashSwitched = <span class="literal">false</span>;             <span class="comment">// 2.b.</span></span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'&#123;&#123; theme.crash_title_cheat.recover_string &#125;&#125;'</span> + originalTitle;   <span class="comment">// 1.b.</span></span><br><span class="line">      titleTime = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = originalTitle;  <span class="comment">// 1.c.</span></span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>首先解释一下以下一些 Hexo 变量：</p><ul><li><code>theme.crash_title_cheat.probability</code>：值为 <code>0.25</code>。意味着当用户从博客页面切走时，有 <code>0.25</code> 的概率会触发「页面崩溃」的彩蛋。</li><li><code>theme.crash_title_cheat.crash_string</code>：值为 <code>╭(°A°`)╮ 页面崩溃啦~</code>，这就是「页面崩溃」时你看到的字符串。</li><li><code>theme.crash_title_cheat.recover_string</code>：值为 <code>(ฅ&gt;ω&lt;*ฅ) 咦，又好了~</code>，这就是「页面恢复」时你看到的字符串。</li></ul><p>而后我们看 <code>(1)</code> 处用变量 <code>originalTitle</code> 记录了当前页面的原始标题；<code>(2)</code> 处用变量 <code>crashSwitched</code> 记录当前页面是否有触发该彩蛋。当页面被隐藏切走时，在 <code>(3)</code> 处有一定概率触发页面崩溃的彩蛋。彩蛋被触发时，首先 <code>(2.a)</code> 修改触发标记，然后 <code>(1.a)</code> 修改页面标题。当页面被切回时，则会检查触发标记。若标记触发，则首先 <code>(2.b)</code> 抹掉触发标记，然后 <code>(1.b)</code> 添加「咦，又好了~」这样的字符串，最后在 <code>2000</code> 毫秒之后 <code>(1.c)</code> 恢复为真实标题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常浏览&lt;a href=&quot;/&quot;&gt;「始终」博客&lt;/a&gt;的读者很容易会发现，当你在浏览器中切换 tab 页到其它网页时，始终博客的页面会有一定概率「崩溃」。具体来说，tab 页上的标题会变成 &lt;code&gt;╭(°A°`)╮ 页面崩溃啦~&lt;/code&gt; 这样子，切换回来之后又会发现页面其实没问题，同时标题会变成 &lt;code&gt;(ฅ&amp;gt;ω&amp;lt;*ฅ) 咦，又好了~&lt;/code&gt; 这样子。因为这个彩蛋比较有趣，所以很多朋友回点回来看一看页面发生了什么。想想还是蛮有趣的。&lt;/p&gt;
&lt;p&gt;最近有不少朋友问到这个效果是怎么实现的。这里记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="JavaScript" scheme="https://liam.page/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中解包 std::vector 作为函数参数</title>
    <link href="https://liam.page/2019/07/04/unpack-vector-as-parameters-for-functions/"/>
    <id>https://liam.page/2019/07/04/unpack-vector-as-parameters-for-functions/</id>
    <published>2019-07-04T01:52:30.000Z</published>
    <updated>2019-10-22T08:18:16.182Z</updated>
    
    <content type="html"><![CDATA[<p>昨天 jsteward 问我，有一个接受若干个同类型参数的函数 <code>template &lt;typename U, typename T&gt; U func(T a, T b, T c)</code>，现在有一个 <code>std::vector&lt;T&gt; args</code>，希望将 <code>std::vector&lt;T&gt;</code> 当中的元素作为函数参数传进去，要怎么办。</p><p>这篇来解决这个问题。</p><a id="more"></a><p>首先，待执行的函数的参数个数，在编译时就能知道；比如这里是 3 个。于是，很自然地，我们最终肯定需要类似这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>现在的问题是，我们希望这种调用代码能够自动生成，而不是手动去写。因为 <code>func</code> 的参数，在实际情况下，可能不止 3 个。C++ 11 引入了参数包（parameter pack）的概念，能够将若干个模板参数，打包在一起，然后再用 <code>...</code> 的方式展开。参数包可以是类型参数包，比如 <code>template &lt;typename... Args&gt;</code>，这样 <code>(*Args)...</code> 就是各个类型的指针；参数包也可以是变量参数包，比如 <code>size_t... I</code>，这样 <code>args[I]...</code> 就是 <code>args[0], args[1], args[2]</code> 这样的展开。后者正是我们要的。</p><p>于是，为了利用参数包，我们首先需要根据函数 <code>func</code> 的参数数量，构建一个参数包，作为索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> next = indices&lt;Indices..., <span class="keyword">sizeof</span>...(Indices)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> build_indices&lt;N - <span class="number">1</span>&gt;::type::next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span>&lt;0&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = indices&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> BuildIndices = <span class="keyword">typename</span> build_indices&lt;N&gt;::type;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br></pre></td></tr></table></figure><p>这里用到了<a href="/2019/02/19/recursive-like-function-template-calling/">前作</a>提到过的技巧。我们看：</p><ul><li><code>BuildIndices&lt;0&gt;</code> 是 <code>build_indices&lt;0&gt;::type</code> 也就是全特化的 <code>indices&lt;&gt;</code>；</li><li><code>BuildIndices&lt;1&gt;</code> 是 <code>build_indices&lt;1&gt;::type</code> 也就是 <code>build_indices&lt;0&gt;::type::next</code> 也就是 <code>indices&lt;&gt;::next</code> 也就是 <code>indices&lt;0&gt;</code>；</li><li>同理，<code>BuildIndices&lt;2&gt;</code> 是 <code>build_indices&lt;2&gt;::type</code> 也就是 <code>build_indices&lt;1&gt;::type::next</code> 也就是 <code>build_indices&lt;0&gt;::type::next::next</code> 也就是 <code>indices&lt;0&gt;::next</code> 也就是 <code>indices&lt;0, 1&gt;</code>；</li><li>以此类推 <code>BuildIndices&lt;N&gt;</code> 是 <code>indices&lt;0, 1, ..., N - 1&gt;</code>。</li></ul><p>于是我们很容易构建出 caller 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> T, <span class="keyword">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Func&amp; func, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; args, indices&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">  f(args[I]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时只需要这样既可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call(func, args, BuildIndices&lt;num_args&gt;());</span><br></pre></td></tr></table></figure><p>我们将整个封装起来，写成一个完整的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> next = indices&lt;Indices..., <span class="keyword">sizeof</span>...(Indices)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> build_indices&lt;N<span class="number">-1</span>&gt;::type::next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span>&lt;0&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = indices&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> BuildIndices = <span class="keyword">typename</span> build_indices&lt;N&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> returnT, <span class="keyword">typename</span> valueT, <span class="keyword">size_t</span> num_args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unpack_caller</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType, <span class="keyword">size_t</span>... I&gt;</span><br><span class="line">  <span class="function">returnT <span class="title">call</span><span class="params">(FuncType&amp; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;valueT&gt;&amp; args, indices&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(args[I]...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType&gt;</span><br><span class="line">  <span class="function">returnT <span class="title">operator</span><span class="params">()</span><span class="params">(FuncType&amp; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;valueT&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> call(f, args, BuildIndices&lt;num_args&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; args = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> i = util::unpack_caller&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="number">3</span>&gt;()(func, args);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样还不是很爽。因为在调用 <code>util::unpack_caller</code> 的时候，我们不得不输入函数相关信息。如果有办法能够获取函数的参数类型、参数量、返回值类型，我们就可以避免这个问题了。为此，我们还要定义一套 <code>function_traits</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_defs</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> arity = <span class="keyword">sizeof</span>...(Args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> result_type = ReturnType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">arg</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V = <span class="keyword">void</span>&gt;</span><br><span class="line">struct function_traits</span><br><span class="line">    : function_traits_impl&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;T, decltype((void)&amp;T::operator())&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_impl&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这里，<code>function_traits_defs</code> 是 traits 的具体定义，<code>function_traits_impl</code> 则是针对各种情况（函数、函数指针、仿函数的各种 cv 修饰符及引用情况）做的实现，<code>function_traits</code> 则是暴露在外面的接口。如此一来，我们可以对 <code>util::unpack_caller</code> 做一些改进。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> details &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">          <span class="keyword">typename</span> VecType,</span><br><span class="line">          <span class="keyword">size_t</span>... I,</span><br><span class="line">          <span class="keyword">typename</span> Traits = function_traits&lt;FuncType&gt;,</span><br><span class="line">          <span class="keyword">typename</span> ReturnT = <span class="keyword">typename</span> Traits::result_type&gt;</span><br><span class="line">ReturnT do_call(FuncType&amp; func,</span><br><span class="line">                VecType&amp; args,</span><br><span class="line">           indices&lt;I...&gt; ) &#123;</span><br><span class="line">  <span class="keyword">return</span> func(args[I]...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">          <span class="keyword">typename</span> VecType,</span><br><span class="line">          <span class="keyword">typename</span> Traits = function_traits&lt;FuncType&gt;,</span><br><span class="line">          <span class="keyword">typename</span> ReturnT = <span class="keyword">typename</span> Traits::result_type&gt;</span><br><span class="line">ReturnT unpack_call(FuncType&amp; func,</span><br><span class="line">                VecType&amp; args) &#123;</span><br><span class="line">  <span class="keyword">return</span> details::do_call(func, args, BuildIndices&lt;Traits::arity&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，完整的示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_defs</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> arity = <span class="keyword">sizeof</span>...(Args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> result_type = ReturnType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">arg</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V = <span class="keyword">void</span>&gt;</span><br><span class="line">struct function_traits</span><br><span class="line">    : function_traits_impl&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;T, decltype((void)&amp;T::operator())&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_impl&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> next = indices&lt;Indices..., <span class="keyword">sizeof</span>...(Indices)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> build_indices&lt;N - <span class="number">1</span>&gt;::type::next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span>&lt;0&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = indices&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> BuildIndices = <span class="keyword">typename</span> build_indices&lt;N&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> details &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">          <span class="keyword">typename</span> VecType,</span><br><span class="line">          <span class="keyword">size_t</span>... I,</span><br><span class="line">          <span class="keyword">typename</span> Traits = function_traits&lt;FuncType&gt;,</span><br><span class="line">          <span class="keyword">typename</span> ReturnT = <span class="keyword">typename</span> Traits::result_type&gt;</span><br><span class="line">ReturnT do_call(FuncType&amp; func, VecType&amp; args, indices&lt;I...&gt;) &#123;</span><br><span class="line">  <span class="keyword">return</span> func(args[I]...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> VecType&gt;</span><br><span class="line"><span class="function">ReturnT <span class="title">unpack_caller</span><span class="params">(FuncType&amp; func, VecType&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> details::do_call(func, args, BuildIndices&lt;Traits::arity&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; args = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j = util::unpack_caller(func, args);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天 jsteward 问我，有一个接受若干个同类型参数的函数 &lt;code&gt;template &amp;lt;typename U, typename T&amp;gt; U func(T a, T b, T c)&lt;/code&gt;，现在有一个 &lt;code&gt;std::vector&amp;lt;T&amp;gt; args&lt;/code&gt;，希望将 &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; 当中的元素作为函数参数传进去，要怎么办。&lt;/p&gt;
&lt;p&gt;这篇来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Function" scheme="https://liam.page/tags/Function/"/>
    
      <category term="std::vector" scheme="https://liam.page/tags/std-vector/"/>
    
      <category term="unpack" scheme="https://liam.page/tags/unpack/"/>
    
  </entry>
  
  <entry>
    <title>谈谈因子分解机模型的各种变体</title>
    <link href="https://liam.page/2019/06/28/variants-of-FM/"/>
    <id>https://liam.page/2019/06/28/variants-of-FM/</id>
    <published>2019-06-28T02:56:41.000Z</published>
    <updated>2019-10-22T08:18:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>先前我们从 LR 开始，讨论了<a href="/2019/03/25/Factorization-Machine/">因子分解机（FM）模型</a>。FM 解决了稀疏数据场景下的自动特征组合问题，因而在广告、推荐等具有高维稀疏特征的领域被广泛使用。因其简单、可解释性强、效果好，FM 模型通常会被作为业务初期快速取得收益的首选。</p><p>这里将 FM 模型家族至今为止的演进做一个整理总结。</p><a id="more"></a><h2 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h2><p>首先回顾一下 FM 模型的预测函数。</p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle x_ix_j.$$</code></p><p>这里 $n$ 是特征向量 $\vec x$ 的长度，即特征的维数。<code>$v_i$</code> 是长度为 $k$ 的向量，与特征 id 对应，称为特征的隐向量。特征的隐向量是特征相互作用之后得到的抽象表征。经验来说，一般有 <code>$k = \max\Big\{4, \big\lfloor\sqrt[4]{n}\big\rfloor\Big\}$</code>。</p><h2 id="在特征交叉方向上的改进"><a href="#在特征交叉方向上的改进" class="headerlink" title="在特征交叉方向上的改进"></a>在特征交叉方向上的改进</h2><p>对 FM 的第一个改进方向是在特征交叉方向上去做改进。</p><h3 id="FFM-Field-aware-FM"><a href="#FFM-Field-aware-FM" class="headerlink" title="FFM (Field-aware FM)"></a>FFM (Field-aware FM)</h3><blockquote><p><a href="https://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf" target="_blank" rel="noopener">https://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf</a></p></blockquote><p>FFM 是 NTU（国立台湾大学）的 Yu-Chin Juan（阮毓钦，现在美国 Criteo 工作）与其比赛队员，借鉴了来自 Michael Jahrer 的论文中的 field 概念提出了 FM 的升级版模型。</p><p><code>$$\hat y = w_0 + \sum_{i = 1}^n w_i x_i + \sum_{0 &lt; i &lt; j &lt;= n} \langle \vec {v}_{i, f_j}, \vec {v}_{j, f_i} \rangle x_i x_j.$$</code></p><p>相比 FM，FFM 为每个特征构造的不再是隐向量，而是隐矩阵；具体来说，是一个 $k$ 行 $F$ 列的矩阵。它由 $F$ 个 $k$ 维列向量组成；每个列向量 <code>$\vec v_{i, f}$</code> 表示特征 $i$ 与其他所有第 $f$ 个 field 中的特征相互作用得到的抽象表征。式中 <code>$f_i$</code> 表示第 $i$ 维特征所属 field 的 id。</p><p>从隐向量升级到隐矩阵，一方面带来的是参数量的增长（乘以 $F$ 倍）而在训练、预测时对内存产生更大压力，另一方面是无法如 FM 那样简化计算。因此它训练时的复杂度是非常高的。这使得它在各种竞赛中有所表现，但在实际业界应用有限。</p><h3 id="AFM-Attentional-FM"><a href="#AFM-Attentional-FM" class="headerlink" title="AFM (Attentional FM)"></a>AFM (Attentional FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1708.04617v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1708.04617v1.pdf</a></p></blockquote><p>AFM 是浙大（Jun Xiao, Hao Ye, Fei Wu）和新加坡国大（Xiangnan He, Hanwang Zhang, Tat-Seng Chua）几位同学提出来的模型。AFM 首先对 FM 做了神经网络改造，而后加入了注意力机制，为不同特征的二阶组合分配不同的权重。</p><p><img alt data-src="/uploads/images/MachineLearning/attention-fm.png"></p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\alpha_{ij}\big\langle \vec p, (\vec v_i \odot \vec v_j)\big\rangle x_ix_j.$$</code></p><p>这里，<code>$\alpha_{ij}$</code> 是通过注意力机制学习得到的特征 $i$ 和特征 $j$ 组合的权重，$\vec p$ 是对隐向量每个维度学习得到的权重，<code>$\vec v_i \odot \vec v_j$</code> 表示向量 <code>$\vec v_i$</code> 和 <code>$\vec v_j$</code> 逐项相乘得到的新向量。显然，当 <code>$\alpha_{ij} \equiv 1$</code> 且 $\vec p = \vec 1$ 时，AFM 退化为标准的 FM 模型。</p><p>AFM 和 FFM 都是从「特征和不同特征进行组合时，表征应该稍有差异」这个点出发，尝试对 FM 进行改进的。FFM 是基于 field 的概念，使得特征对不同 field 里的特征采取不同的表征，同时特征对不同 field 特征里的表征互不关联。AFM 是基于 attention 机制的，对不同特征的表征仅有权重（<code>$\alpha_{ij}$</code>）上的不同。从参数数量来说，AFM 会远小于 FFM。从这个角度说，AFM 在业界的应用前景应该比 FFM 更好。</p><h3 id="FwFM-Field-weighted-FM"><a href="#FwFM-Field-weighted-FM" class="headerlink" title="FwFM (Field-weighted FM)"></a>FwFM (Field-weighted FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1806.03514.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1806.03514.pdf</a></p></blockquote><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}r_{f_if_j}\langle \vec v_i, \vec v_j\rangle x_ix_j.$$</code></p><p>这里 <code>$r_{f_if_j}$</code> 是针对特征 $i$ 所属 field <code>$f_i$</code> 和特征 $j$ 所属 field <code>$f_j$</code> 学习的参数。</p><p>FwFM 改进的出发点与 FFM 和 AFM 相同，但吸取了 FFM 和 AFM 各自的优点。它相当于是 $\vec p = \vec 1$ 且 <code>$\alpha_{ij}$</code> 简化为 <code>$r_{f_if_j}$</code> 的 AFM。相对于 FFM，它改掉了用隐矩阵来 model field 的做法，而是用 <code>$r_{f_if_j}$</code> 捕捉 field 的信息，因而大大降低了参数数量。</p><h2 id="引入深度神经网络"><a href="#引入深度神经网络" class="headerlink" title="引入深度神经网络"></a>引入深度神经网络</h2><p>对 FM 进行改进的第二个方向是引入深度神经网络。</p><h3 id="DeepFM"><a href="#DeepFM" class="headerlink" title="DeepFM"></a>DeepFM</h3><blockquote><p><a href="https://arxiv.org/pdf/1703.04247.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1703.04247.pdf</a></p></blockquote><p>DeepFM 的论文发表在 IJCAI 2017 上。它是在 Wide &amp; Deep 框架上，将 LR 部分替换成了 FM，以增强 wide 部分对二阶交叉特征的捕捉能力。目前来说，它已被业界快速跟进和应用到推荐、广告、搜索等场景。</p><p>其实 Wide &amp; Deep 框架才是这一改进的精髓。不难发现，除了将 FM 与 NN 拼起来得到 DeepFM，我们还可以将 FFM、AFM、FwFM 和 NN 拼起来得到相应的 DeepXFM 版本。但这样难免有水论文的嫌疑了……</p><h3 id="NFM-Neural-FM"><a href="#NFM-Neural-FM" class="headerlink" title="NFM (Neural FM)"></a>NFM (Neural FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1708.05027v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1708.05027v1.pdf</a></p></blockquote><p>DeepFM 是用 Wide &amp; Deep 框架，在 FM 旁边加了一个 NN，最后一并 sigmoid 输出。NFM 的做法则是利用隐向量逐项相乘得到的向量作为 MLP 的输入，构建的 FM + NN 模型。</p><p><img alt data-src="/uploads/images/MachineLearning/nfm.png"></p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + f(\vec x).$$</code></p><p>如图所示的是上述第三项 $f(\vec x)$ 的结构。Embedding 层中的向量即是传统 FM 模型中的 <code>$x_i\vec v_i$</code>；Bi-interaction 池化层则是将特征两两交叉后，逐项向量相乘再做向量加法，即池化层的输出是一个与隐向量长度相同的向量：</p><p><code>$$\sum_{0 &lt; i &lt; j &lt;= n} x_ix_j(\vec v_i \odot \vec v_j).$$</code></p><p>紧接着再以上述向量作为一个 <code>$L$</code> 层的 MLP 的输入，接一个全链接的 MLP 而后输出。显然，和 AFM 中的情况类似，当 <code>$L = 0$</code> 且输出层参数全为 <code>$1$</code> 时，NFM 退化为原始的 FM 模型。</p><p>NFM 的复杂度是传统 FM 的复杂度与 MLP 的合。因此它与 DeepFM 的复杂度是相同的。</p><h2 id="利用偏序概率，迁移到-rank-任务上"><a href="#利用偏序概率，迁移到-rank-任务上" class="headerlink" title="利用偏序概率，迁移到 rank 任务上"></a>利用偏序概率，迁移到 rank 任务上</h2><p>以前提到过 <a href="/2016/07/10/a-not-so-simple-introduction-to-lambdamart/#RankNet-的创新">RankNet 的创新</a>。通过引入偏序概率，我们可以把任何一个模型转变成 pairwise 的排序模型。</p><p>具体来说，对于待排序的 item <code>$x_i$</code> 和 <code>$x_j$</code>，有模型的打分函数 <code>$f$</code>，从而求得得分 <code>$s_i = f(x_i)$</code>, <code>$s_j = f(x_j)$</code>，而后得到偏序概率</p><p><code>$$P_{ij} = P(x_i \rhd x_j) = \text{sigmoid}(s_i, s_j).$$</code></p><p>这样，我们就将排序问题中的偏序，转换成了二分类问题（<code>$x_i$</code> 是否应该排在 <code>$x_j$</code> 之前）。之后只需要套用二分类问题的解法即可。</p><h3 id="Pairwise-FM"><a href="#Pairwise-FM" class="headerlink" title="Pairwise FM"></a>Pairwise FM</h3><p>Pairwise FM 的做法就是如此。只需要将上述打分函数 <code>$f$</code> 设为 FM 即可。</p><h3 id="LambdaFM"><a href="#LambdaFM" class="headerlink" title="LambdaFM"></a>LambdaFM</h3><p>和 <a href="/2016/07/10/a-not-so-simple-introduction-to-lambdamart/">LambdaMART</a> 中的做法一样，若在 FM 的基础上，将梯度上辅以 <code>$\Delta Z$</code> 作为 pair 的权重，则变成了 listwise 的排序算法。</p><h2 id="其他魔改"><a href="#其他魔改" class="headerlink" title="其他魔改"></a>其他魔改</h2><p>上述三类对 FM 模型的改进，相对来说都有比较明确的方向。还有一些改进，在模型本身的角度没有形成特定的方向。但这些改进也有一些意义，因此罗列如下。</p><h3 id="加入-FTRL-框架"><a href="#加入-FTRL-框架" class="headerlink" title="加入 FTRL 框架"></a>加入 FTRL 框架</h3><blockquote><p><a href="https://www.kdd.org/kdd2018/accepted-papers/view/sketched-follow-the-regularized-leader-for-online-factorization-machine" target="_blank" rel="noopener">https://www.kdd.org/kdd2018/accepted-papers/view/sketched-follow-the-regularized-leader-for-online-factorization-machine</a></p></blockquote><p>FTRL 框架是一个在线学习框架。最早是 Google 提出来应用在 LR 上的。这篇发表在 KDD 2018 的文章将 FTRL 引入了 FM 模型。但这其实不是什么新鲜事，CastellanZhang 早在 2016 年就开源了相应的实现 <a href="https://github.com/CastellanZhang/alphaFM" target="_blank" rel="noopener">alphaFM</a>。</p><h3 id="DFM-Discrete-FM"><a href="#DFM-Discrete-FM" class="headerlink" title="DFM (Discrete FM)"></a>DFM (Discrete FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1805.02232.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1805.02232.pdf</a></p></blockquote><p>原始 FM 的隐向量是在实数空间的向量。虽然 FM 可经过数学变换将复杂度降低到线性（相对隐向量长度 $k$），但在某些场景，复杂度仍然很高。因此山东大学（Han Liu, Liqiang Nie）、新加坡国大（Xiangnan He, Fuli Feng）、电子科技大学（Rui Liu）和新加坡南洋理工（Hanwang Zhang）的几位同学提出了 DFM 模型。</p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec b_i, \vec b_j\rangle x_ix_j.$$</code></p><p>它和原始 FM 模型唯一的差别是将隐向量从实数空间简化到 <code>$\{-1, +1\}$</code>。不难预见，效果相对 FM 会有一定下降。</p><h3 id="RFM-Robust-FM"><a href="#RFM-Robust-FM" class="headerlink" title="RFM (Robust FM)"></a>RFM (Robust FM)</h3><blockquote><p><a href="http://delivery.acm.org/10.1145/3190000/3186148/p669-punjabi.pdf?ip=202.108.14.240&amp;id=3186148&amp;acc=OPEN&amp;key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;__acm__=1561711947_55e776a6a5f3d314ac25bac873e6196a" target="_blank" rel="noopener">http://delivery.acm.org/10.1145/3190000/3186148/p669-punjabi.pdf?ip=202.108.14.240&amp;id=3186148&amp;acc=OPEN&amp;key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;__acm__=1561711947_55e776a6a5f3d314ac25bac873e6196a</a></p></blockquote><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_i(x_i + \mu_i) + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle (x_ix_j + \Sigma_{jk}).$$</code></p><p>Robust 即是「鲁棒性」的那个英文单词。这一个改进的出发点是 FM 大量用于和用户反馈相关的场景（例如推荐、计算广告），而 FM 模型有一个隐含假设：用户的反馈都是真实的。RFM 认为这些反馈不一定都是真实的，因此加入用于捕捉随机噪声的 <code>$\mu_i$</code> 和 <code>$\Sigma_{ij}$</code> 两项。</p><p>从个人的判断来说，这种改进对 FM 的鲁棒性确实会有提升。但是，（也许是我孤陋寡闻）没有了解到业界有广泛的应用这一改进。猜测可能的原因是 <code>$\Sigma_{ij}$</code> 项的加入破坏了原 FM 的数学变形，使得时间复杂度变成了 <code>$\Theta(kn^2)$</code> 从而降低效率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>近年来，针对原始 FM 的改进主要集中在三个方向：</p><ul><li>细化二阶特征交叉的处理方式，以捕捉更多信息；</li><li>与 NN 结合，利用 NN 捕捉高阶交叉特征；</li><li>利用偏序概率，迁移到 rank 任务上去。</li></ul><p>特别地，也有所谓的 High-order FM 的改进。但个人认为这种接法属于「脱裤子放屁」——NN 是公认地能够较好地捕捉高阶交叉特征的方法，再去魔改 FM 意义不大。</p><p>当然，在其他方向，也有一些改进。但这些改进目前未成体系，看起来也不容易在方向上成为一个流派。因此这些改进在本文中一律归到「魔改」的范畴中了。</p><p>希望本文能够让读者对 FM 的各种变体、改进有一个比较直观的认知。另祝 @turbo0628 同学生日快乐~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先前我们从 LR 开始，讨论了&lt;a href=&quot;/2019/03/25/Factorization-Machine/&quot;&gt;因子分解机（FM）模型&lt;/a&gt;。FM 解决了稀疏数据场景下的自动特征组合问题，因而在广告、推荐等具有高维稀疏特征的领域被广泛使用。因其简单、可解释性强、效果好，FM 模型通常会被作为业务初期快速取得收益的首选。&lt;/p&gt;
&lt;p&gt;这里将 FM 模型家族至今为止的演进做一个整理总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Ranking" scheme="https://liam.page/tags/Ranking/"/>
    
      <category term="Factorization Machine" scheme="https://liam.page/tags/Factorization-Machine/"/>
    
      <category term="CTR" scheme="https://liam.page/tags/CTR/"/>
    
      <category term="Variants" scheme="https://liam.page/tags/Variants/"/>
    
  </entry>
  
  <entry>
    <title>强迫症患者也需要随机梯度下降</title>
    <link href="https://liam.page/2019/06/18/OCD-needs-stochastic-gradient-descent/"/>
    <id>https://liam.page/2019/06/18/OCD-needs-stochastic-gradient-descent/</id>
    <published>2019-06-18T06:52:18.000Z</published>
    <updated>2019-10-22T08:18:16.176Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个强迫症（OCD）患者，曾经我一直对随机梯度下降（Stochastic Gradient Descent）表示怀疑。毕竟，每次只选择少量样本计算梯度，这靠谱吗？强迫症患者心里泛起了浓浓的怀疑。然而经年的实践经验结合理论分析表明，强迫症患者也需要随机梯度下降。</p><p>这篇文章尝试尽可能用少的数学公式，讲一讲这个问题。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这里讨论的梯度下降（Gradient Descent）和随机梯度下降，都是为了解决机器学习/深度学习当中模型训练中的优化问题而设计的。在机器学习/深度学习当中，模型的训练问题往往会被转换成求使得目标函数值最小的参数组合的最优化问题。具体来说是</p><p><code>$$\vec{\theta}^{*} = \mathop{\arg\min}_{\vec{\theta}}\text{Obj}\bigl(h(\vec x;\vec{\theta})\bigr).$$</code></p><p>这里，<code>$h(\vec x;\vec{\theta})$</code> 是目标模型，其中 <code>$\vec x$</code> 是输入特征向量，<code>$\vec{\theta}$</code> 是模型的参数，<code>$\text{Obj}(\cdot)$</code> 是目标函数。</p><p>在样本集给定时，可将 <code>$\text{Obj}\bigl(h(\vec x;\vec{\theta})\bigr)$</code> 看做是 <code>$\vec\theta$</code> 的函数——不妨将其记为 <code>$f(\vec\theta)$</code>，则我们的目标就是要找到该函数等高线中的最低谷位置对应的 <code>$\vec\theta$</code> 的取值。</p><p><img alt="只有两维参数时目标函数的图像" data-src="/uploads/images/MachineLearning/objective_function.png"></p><!--import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)ax.set_xlabel(r'$\theta_1$', rotation = 90)ax.set_ylabel(r'$\theta_2$')ax.set_zlabel(r'$f(\vec \theta)$', rotation = 90)# X, Y valueX = np.arange(-4, -.5, 0.1)Y = np.arange(-2, 4, 0.1)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = np.sin(np.sin(X)) * np.sin(np.cos(Y)) * 2 + np.sin(X + Y / 4)ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap('rainbow'))plt.show() --><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>既然要找到目标函数的「山谷」，那我们就要想办法「下山」。在数学上，上升最快的方向是函数的梯度方向，于是梯度方向的反方向就是下降最快的方向。于是有参数更新</p><p><code>$$\vec \theta_{n + 1} \gets \vec\theta_{n} - \eta\nabla f(\vec\theta_{n}).$$</code></p><p>这里，<code>$\vec\theta_{n}$</code> 是第 $n$ 轮迭代后的参数；<code>$\nabla f(\vec\theta_{n})$</code> 则是第 $n$ 轮迭代后目标函数的梯度；<code>$\eta$</code> 是学习率，也就是梯度下降的步长。</p><p><img alt="只有两维参数时目标函数的梯度下降" data-src="/uploads/images/MachineLearning/gradient_descent.png"></p><!--import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport randomfig = plt.figure()ax = Axes3D(fig)ax.set_xlabel(r'$\theta_1$', rotation = 90)ax.set_ylabel(r'$\theta_2$')ax.set_zlabel(r'$f(\vec \theta)$', rotation = 90)# X, Y valueX = np.arange(-4, -.5, 0.1)Y = np.arange(-2, 4, 0.1)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = np.sin(np.sin(X)) * np.sin(np.cos(Y)) * 2 + np.sin(X + Y / 4)ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap('rainbow'))x = np.arange(-3.5, -1.5, 0.2)y = np.arange(-.35, -.15, 0.02)y_noice = np.random.rand(len(y)) * 0.2 - 0.1y = y + y_noicez = np.sin(np.sin(x)) * np.sin(np.cos(y)) * 2 + np.sin(x + y / 4)ax.plot(x, y, z, 'o-')plt.show() --><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>梯度下降优美、清晰、明确。但梯度下降也有它的问题。</p><p>第一个问题是效率低。梯度下降法需要处理计算所有样本，而在工程中我们面对的样本集合往往非常大。这样一来，处理所有样本就会变得效率非常低，缓慢得不可接受。</p><p>第二个问题是缺乏跳出陷阱的能力。这里的陷阱指得是诸如鞍点、局部最优点之类的梯度为零的点。</p><p><img alt="鞍点" data-src="/uploads/images/MachineLearning/saddle_point.png"></p><!--import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport randomfig = plt.figure()ax = Axes3D(fig)ax.set_xlabel(r'$\theta_1$', rotation = 90)ax.set_ylabel(r'$\theta_2$')ax.set_zlabel(r'$f(\vec \theta)$', rotation = 90)# X, Y valueX = np.arange(-2, 2, 0.1)X_zeros = np.zeros(len(X))Y = np.arange(-2, 2, 0.1)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = X ** 2 - Y ** 2ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap('rainbow'))X = np.arange(-2, 2, 0.1)X_zeros = np.zeros(len(X))ax.plot(X, X_zeros, X ** 2, '-', color = 'cyan', linewidth = 2)ax.plot(X_zeros, X, - X ** 2, '-', color = 'cyan', linewidth = 2)ax.text(-.4, 0, 0.7, "saddle point")plt.show() --><p>这是因为，当目标函数落入陷阱后，梯度为零。于是目标函数的参数再也无法更新，模型实质上收敛在不恰当的位置。</p><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>随机梯度下降（Stochastic Gradient Descent，SGD）的表达式和梯度下降差别不大：</p><p><code>$$\vec \theta_{n + 1} \gets \vec\theta_{n} - \eta_ng_n.$$</code></p><p>这里，<code>$g_n$</code> 是随机梯度。具体来说，它是用单个样本（而非所有样本）计算得到的梯度。在实践中，也可能是使用较小的集合（mini batch）计算得到的梯度。随机梯度满足</p><p><code>$$E[g_n] = \nabla f(\vec\theta_n).$$</code></p><p>这也就是说，尽管由于样本选择带来了一定的随机性，但在期望的角度，随机梯度是等于真实的梯度的。用等高线图来表示，随机梯度下降就像是喝醉了酒的梯度下降：它依稀认得路，最后也能自己走回家，但是走得歪歪扭扭。（黄色的是梯度下降的路线，绿色的是随机梯度下降的路线）</p><!--import numpy as npimport matplotlib.pyplot as pltimport randomfig = plt.figure()plt.xlabel(r'$\theta_1$')plt.ylabel(r'$\theta_2$')# X, Y valueX = np.arange(-4, -.5, 0.01)Y = np.arange(-2, 4, 0.01)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = np.sin(np.sin(X)) * np.sin(np.cos(Y)) * 2 + np.sin(X + Y / 4)plt.contour(X, Y, Z, 16)plt.contourf(X, Y, Z, 16)x = np.arange(-3.5, -1.5, 0.2)y = np.arange(-.35, -.15, 0.02)y_noice = np.random.rand(len(y)) * 0.2 - 0.1y = y + y_noicex[0]  = -3.5x[-1] = -1.5y[0]  = -.35y[-1] = -.15plt.plot(x, y, 'o-', color = "yellow")x = np.arange(-3.5, -1.5, 0.05)y = np.arange(-.35, -.15, 0.005)x_noice = np.random.rand(len(x)) - 0.5y_noice = np.random.rand(len(y)) - 0.5x = x + x_noicey = y + y_noicex[0]  = -3.5x[-1] = -1.5y[0]  = -.35y[-1] = -.15plt.plot(x, y, 'o-', color = 'green')plt.show() --><p><img alt data-src="/uploads/images/MachineLearning/stochastic_gradient_descent.png"></p><h3 id="效率的提升"><a href="#效率的提升" class="headerlink" title="效率的提升"></a>效率的提升</h3><p>显而易见，随机梯度下降想要收敛，需要更多的迭代步骤。但是，由于每次只需要少量样本来计算随机梯度，实际上的效率会提升很多。试想，若训练数据集有 100 万个样本点，每次我们取其中的 100 个计算随机梯度。这样，在计算梯度的时候，效率就提升了 1 万倍。如此一来，哪怕多迭代几倍甚至十几倍，总体来说效率也是提升了。</p><h3 id="效果的提升"><a href="#效果的提升" class="headerlink" title="效果的提升"></a>效果的提升</h3><p>虽然强迫症肯定会怀疑，随机梯度下降每次只用部分样本，这样的随机性和噪声靠谱吗？但实际上，哪怕梯度下降的训练时间比随机梯度下降多千百倍，但实际效果却远不如随机梯度下降得到的模型。</p><p>这里蕴含着两层含义：</p><ol><li>随机梯度下降能很好地收敛；</li><li>随机梯度下降能收敛到更好的最优点上。</li></ol><p>关于 (1)，这里不打算展开来讲。但有大量的理论工作证明，在 $f$ 是凸函数的情况下，只要噪声不离谱，随机梯度下降都能很好地收敛。(2) 的性质实际上是在说 SGD 能够较好地逃离鞍点这类「陷阱」。为了说明这一点，首先要引入一个概念：strict saddle 函数。它是说，对于函数定义域内的任意一个点 $x$，满足：</p><ul><li>函数在 $x$ 点的导数比较大（因而能够做梯度下降）；或者，</li><li>函数在 $x$ 点附近有最小值（因而已接近完成优化任务）；或者，</li><li>函数在 $x$ 点的二阶偏导组成的 Hessian 矩阵至少含有一个负的特征值（因而沿着这个方向能够滑下去，降低函数值）。</li></ul><p>在机器学习/深度学习任务中，大多数用到的函数都满足（或者近似满足，虽然我不知道怎么证……）strict saddle 函数的定义。对于 strict saddle 函数，如果梯度下降遇到了鞍点，只需要在鞍点加扰动，能够顺着负的特征值方向滑下去降低函数值了。金驰菊苣 17 年的论文（<a href="https://arxiv.org/abs/1703.00887" target="_blank" rel="noopener">How to Escape Saddle Points Efficiently</a>）就说明了这一点：SGD 引入的扰动，能够在较大概率下逃离鞍点。文章证明的思路很巧妙，它首先证明了任意两个点在负特征值方向上的投影距离大于 $u / 2$，则其中至少有一个点能够通过有限步的 GD 迭代逃离鞍点。接下来，只需要通过 $u$ 计算出落入这一区间的概率下界，说明它足够小，就能说明 SGD 引入的扰动，能够在较大概率下逃离鞍点了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OCD 患者也需要 SGD，因为相对于 GD，它：</p><ul><li>效率较高；</li><li>能够收敛；</li><li>能够收敛到更好的最优点上。</li></ul><blockquote><p>因最近工作较忙，这篇文章有些「虎头蛇尾」。实际上，这篇文章从三月中旬动笔至此已经两个多月了，可见其中受了多少打扰。拖延至今实不愿继续拖沓下去，因此本着「烂尾好过无尾」的想法（真不要脸），就这样草草结尾了。望各位看官见谅。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个强迫症（OCD）患者，曾经我一直对随机梯度下降（Stochastic Gradient Descent）表示怀疑。毕竟，每次只选择少量样本计算梯度，这靠谱吗？强迫症患者心里泛起了浓浓的怀疑。然而经年的实践经验结合理论分析表明，强迫症患者也需要随机梯度下降。&lt;/p&gt;
&lt;p&gt;这篇文章尝试尽可能用少的数学公式，讲一讲这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Optimizer" scheme="https://liam.page/tags/Optimizer/"/>
    
      <category term="Gradient Descent" scheme="https://liam.page/tags/Gradient-Descent/"/>
    
      <category term="Stochastic Gradient Descent" scheme="https://liam.page/tags/Stochastic-Gradient-Descent/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 下批量将 Markdown 文档转为 Word 文档</title>
    <link href="https://liam.page/2019/05/17/markdown-convert-to-docx-batch/"/>
    <id>https://liam.page/2019/05/17/markdown-convert-to-docx-batch/</id>
    <published>2019-05-17T10:34:52.000Z</published>
    <updated>2019-10-22T08:18:16.174Z</updated>
    
    <content type="html"><![CDATA[<p>转换本身需要通过开源的 Pandoc 来进行。因此，你首先需要<a href="https://pandoc.org/installing.html" target="_blank" rel="noopener">安装 Pandoc</a>。</p><p>而后，可以仿照<a href="/2014/08/21/bitmap-convert-to-eps-batch/">前作</a>的做法，批量转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">for /f &quot;tokens=* delims=&quot; %%i in (&apos;dir /b *.md&apos;) do (</span><br><span class="line">  @echo %%i</span><br><span class="line">  pandoc -f markdown -t docx -o &quot;%%~ni.docx&quot; &quot;%%i&quot;</span><br><span class="line">  @echo Finished</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>具体操作路径：</p><ul><li><a href="https://pandoc.org/installing.html" target="_blank" rel="noopener">安装 Pandoc</a>（按需）。</li><li>将<a href="https://tar.cat/uploads/bat_scripts/md2docx.bat" target="_blank" rel="noopener">脚本</a>保存在某个目录（例如桌面）。</li><li>将需要转换的 Markdown 文件也保存在该目录。</li><li>双击执行脚本。</li><li>收获一堆 Word 文档。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转换本身需要通过开源的 Pandoc 来进行。因此，你首先需要&lt;a href=&quot;https://pandoc.org/installing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装 Pandoc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而后，可以仿照&lt;
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Markdown" scheme="https://liam.page/tags/Markdown/"/>
    
      <category term="Pandoc" scheme="https://liam.page/tags/Pandoc/"/>
    
      <category term="Word" scheme="https://liam.page/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>修复 Win10 变更默认浏览器时设置 App 崩溃的问题</title>
    <link href="https://liam.page/2019/05/10/Setting-App-crash-when-changing-default-browswer-to-Chrome-due-to-Edge/"/>
    <id>https://liam.page/2019/05/10/Setting-App-crash-when-changing-default-browswer-to-Chrome-due-to-Edge/</id>
    <published>2019-05-10T03:18:36.000Z</published>
    <updated>2019-10-22T08:18:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>单位配发的电脑问题比较多。昨天提交 IT 修复电脑时，出现了更多问题，不得不重装系统并升级为 Windows 10。初次接触 Windows 10 的我，又遇到了不少问题。所幸，大多数问题都经由 Google 帮助解决。但仍有一个问题始终无法解决：</p><ol><li>Microsoft Edge 闪退；</li><li>退而求其次使用 Google Chrome，但尝试将 Chrome 设置为默认浏览器时，设置 App 崩溃，设置失败。</li></ol><a id="more"></a><p>显而易见，本质上是 Edge 有问题，连累了设置 App。Google 搜索的结果千篇一律，无非是删除当前用户 <code>AppData</code> 目录下 Edge 的相关文件后在 Powershell 中重新注册 Edge。但反复试验之后都无法解决问题。</p><p>最后在英文版 Microsoft Community 上找到了解决办法：</p><ol><li>设置 -&gt; 应用 -&gt; 应用和功能</li><li>搜索 Edge -&gt; 单击 -&gt; 高级选项</li><li>重置 -&gt; 修复 -&gt; 重置</li></ol><p>这样一路操作会把 Edge 整个重置掉。此后再去设置当中修改默认浏览器就能绕过 Edge 崩溃的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位配发的电脑问题比较多。昨天提交 IT 修复电脑时，出现了更多问题，不得不重装系统并升级为 Windows 10。初次接触 Windows 10 的我，又遇到了不少问题。所幸，大多数问题都经由 Google 帮助解决。但仍有一个问题始终无法解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Microsoft Edge 闪退；&lt;/li&gt;
&lt;li&gt;退而求其次使用 Google Chrome，但尝试将 Chrome 设置为默认浏览器时，设置 App 崩溃，设置失败。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Edge" scheme="https://liam.page/tags/Edge/"/>
    
      <category term="Chrome" scheme="https://liam.page/tags/Chrome/"/>
    
      <category term="Windows 10" scheme="https://liam.page/tags/Windows-10/"/>
    
  </entry>
  
</feed>
