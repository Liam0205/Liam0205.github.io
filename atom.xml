<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2022-10-29T11:26:04.503Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Yonex AX100zz 打感自测</title>
    <link href="https://liam.page/2022/10/29/Yonex-AX100zz/"/>
    <id>https://liam.page/2022/10/29/Yonex-AX100zz/</id>
    <published>2022-10-29T10:48:51.000Z</published>
    <updated>2022-10-29T11:26:04.503Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是 Yonex AX100zz 的打感自测。</p><span id="more"></span><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>新入手的球拍（简写 AX100zz）情况：</p><ul><li>Yonex Astrox 100zz（老色，藏青色）</li><li>4U&#x2F;G6</li><li>保留底胶 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><p>作为对比，过去六年常用的球拍（简写 Arc11）情况：</p><ul><li>Yonex ArcSaber 11（老色，带亮黄色带）</li><li>3U&#x2F;G5</li><li>去除底胶 + 缓震膜 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><h2 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h2><p>挥重方面，实测 AX100zz 和 Arc11 的挥重接近。大约是因为 Arc11 去除底胶的缘故，实际平衡点有所前移。</p><p>挥速方面，相同发力的条件下，AX100zz 的挥速较 Arc11 慢。这主要应该是 AX100zz 采用盒式拍框而 Arc11 采用破风拍框的缘故。</p><p>中杆方面，AX100zz 的中杆相对较硬，但硬得有限。传统上，我们习惯用软硬来评价中杆。但 AX100zz 的中杆更为显著的特性是回弹快。这一特性是建立在实心中杆 + 钨丝的黑科技结构上的。这一特性要求你能用 AX100zz 做出足够快的挥速。若然，相较 Arc11，击球感明显更加干脆；若不然，AX100zz 的击球会显得有一些「木」。</p><p>这即是说，AX100zz 对小臂内旋和屈指发力的技术动作要求更高。而一旦动作到位，AX100zz 的击球球速会比 Arc11 要更快。</p><h2 id="后场击球"><a href="#后场击球" class="headerlink" title="后场击球"></a>后场击球</h2><p>高远方面，步伐到位的情况下，AX100zz 的击球感和 Arc11 差别不算很大；被动的情况下，AX100zz 会稍微更废力一些。</p><p>重杀方面，第一次杀球用的还是 Arc11 的发力习惯。相较而言，球路稍微有些发飘，落点更长。稍作调整后，能够感受到更明显的下压感，暴击音也不出期待地非常舒爽。按对手的反馈，球速有区别，但不大。</p><p>点杀方面。有重杀的经验，点杀时加大了屈指的力量，效果喜人。实战中，头顶突击点杀对角，落点可以比较轻松做到在发球线附近。相同的条件，Arc11 打出同样的落点个人感觉更困难一些。</p><p>劈杀方面，这本身不是我可称擅长的技术，平时用得也偏少。实战中，尝试正手区劈杀斜线，许是还没有完全适应发力变化的缘故，总体感觉和 Arc11 区别不算大。</p><p>吊球方面，劈吊和 Arc11 区别不大；而滑板吊的动作由于本身发力更难，使用 AX100zz 的失误率比 Arc11 要明显高一些。</p><p>反手高远方面，AX100zz 对发力的要求明显更高。前三拍感觉都没能很好发力，打得有点木木的。调整后整体感觉 AX100zz 明显吃力一些。</p><h2 id="前场击球"><a href="#前场击球" class="headerlink" title="前场击球"></a>前场击球</h2><p>个人感觉，前场的搓放由于发力小而巧，影响回球质量更多的是拍面大小和拍线（型号和磅数）。实际 AX100zz 的拍面和 Arc11 相比只是稍微小一些，而拍线又完全相同（穿线师傅都是同一个），整体感觉前场搓放差异不大。但是，不知是不是错觉，使用 AX100zz 做假动作搓放时，感觉更得心应手一些。</p><p>挑推方面，个人感觉差异不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>4U 版本的 AX100zz 属于相对容易上手的高端拍。但其对发力的要求，不那么糖水，需要更短粗的爆发发力才能驾驭。</p><p>个人意见，可以视作是 3U 版本 Arc11 的进攻加强版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇是 Yonex AX100zz 的打感自测。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Yonex" scheme="https://liam.page/tags/Yonex/"/>
    
      <category term="Racket" scheme="https://liam.page/tags/Racket/"/>
    
  </entry>
  
  <entry>
    <title>为英文信件选用合适的结束语</title>
    <link href="https://liam.page/2022/06/19/Email-Closing-Lines/"/>
    <id>https://liam.page/2022/06/19/Email-Closing-Lines/</id>
    <published>2022-06-19T09:55:23.000Z</published>
    <updated>2022-06-20T04:28:02.063Z</updated>
    
    <content type="html"><![CDATA[<p>编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。</p><span id="more"></span><h2 id="对熟人"><a href="#对熟人" class="headerlink" title="对熟人"></a>对熟人</h2><p>从自然到刻意，可选项有：</p><ul><li>什么都不留：都已经比较熟悉了，还留啥结束语呢？</li><li>XOXO：这是表示好友间拍对方屁股那种熟稔的情感表达。</li><li>Tnx：Thanks 的缩写，因为是熟人，所以缩写也没毛病。</li><li>Love&#x2F;With Love&#x2F;Much love：刻意程度依次增加，但都还好。</li><li>Sincerely：熟人用 Sincerely 还是可以的，但是显得刻意。</li><li>Yours truly&#x2F;Yours sincerely：就很刻意有没有！</li></ul><h2 id="对不熟悉的人"><a href="#对不熟悉的人" class="headerlink" title="对不熟悉的人"></a>对不熟悉的人</h2><p>从自然到刻意，可选项有：</p><ul><li>Best&#x2F;Best regards：万金油，如果拿捏不准，就一个 Best 完事儿就好了。完全体的 Best regards 会显得有些生分，初次沟通可以用。</li><li>Cheers：好像是和不熟悉的人，远远干一杯的感觉。</li><li>Sincerely：跟不熟悉的人说 Sincerely 也是合适的，而且因为不熟悉，所以也不会显得那么刻意。</li><li>All the best：不那么自然，但是也不会显得刻意。相对来说比较正式。</li><li>Thank you：正常人谁说「Thank you」呀！</li><li>With warm regards：艾玛，老古板的形象跃然纸上啊哈哈哈！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Mail" scheme="https://liam.page/tags/Mail/"/>
    
      <category term="E-Mail" scheme="https://liam.page/tags/E-Mail/"/>
    
      <category term="Closing" scheme="https://liam.page/tags/Closing/"/>
    
  </entry>
  
  <entry>
    <title>提升时间机器（Time Machine）的备份速度</title>
    <link href="https://liam.page/2022/05/07/speed-up-time-machine-backup/"/>
    <id>https://liam.page/2022/05/07/speed-up-time-machine-backup/</id>
    <published>2022-05-07T09:47:17.000Z</published>
    <updated>2022-05-07T09:56:16.682Z</updated>
    
    <content type="html"><![CDATA[<p>时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。</p><span id="more"></span><p>经查，类似时间机器备份或是自 MAS 下载和安装软件的行为，苹果将其优先级调低，并设置有限流（throttle）这一设定。这是为了保证这些优先级较低的行为不会占用过多的系统资源，干扰正常的工作。</p><p>这个设定的出发点是好的，但存在一个问题。比如说，对我而言，使用时间机器备份通常发生在无需使用电脑工作的时间段。此时，限流的这个设定就十分让人蛋疼了。为此，我们可以在命令行暂时关闭限流，待备份完成后再重新打开。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭限流功能，加速备份</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=0</span><br><span class="line"><span class="comment"># 备份完成，重新打开限流功能，避免意外的干扰</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="Time Machine" scheme="https://liam.page/tags/Time-Machine/"/>
    
  </entry>
  
  <entry>
    <title>设计一个线程池</title>
    <link href="https://liam.page/2022/05/05/design-a-thread-pool/"/>
    <id>https://liam.page/2022/05/05/design-a-thread-pool/</id>
    <published>2022-05-05T12:30:35.000Z</published>
    <updated>2022-05-05T15:33:37.396Z</updated>
    
    <content type="html"><![CDATA[<p>此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。</p><span id="more"></span><h2 id="初步讨论"><a href="#初步讨论" class="headerlink" title="初步讨论"></a>初步讨论</h2><h3 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h3><p>自 C++11 起，在 C++ 中使用线程就变得很简单。最基本地，可以用 <code>std::thread</code> 来管理一个线程。若是要异步地执行任务，搭配使用 <code>std::async</code> 和 <code>std::future</code> 也很方便。在有这些基础设施的基础上，我们为什么还需要线程池？或者说，我们什么时候需要线程池？</p><p>众所周知，线程作为一种系统资源，其创建和销毁是需要时间的。因此，如果创建和销毁线程的时间和执行任务所需的时间处在同一个数量级，那么频繁地创建和销毁线程带来的性能损耗就会变得十分可观。此时，我们就要考虑使用线程池。</p><h3 id="线程池应有哪些特点？"><a href="#线程池应有哪些特点？" class="headerlink" title="线程池应有哪些特点？"></a>线程池应有哪些特点？</h3><p>线程池的本质就是一组待用的线程。在 C++ 中，它可以表示为一个 <code>std::thread</code> 的数组或是向量。在实际工程中，为便于进行可能的扩展，使用 <code>std::vector&lt;std::thread&gt;</code> 显然会更加合适。</p><p>对于线程池中的每个线程，它都可能在某个时刻接收到一个任务。而这个任务具体是什么，在线程创建时并不知道。用 C++ 的语言表达就是说，线程池中的线程：</p><ul><li>应当可以执行任意函数——支持任何参数列表，也支持任何返回值类型；</li><li>应当可以将任务的执行结果反馈给任务的发布者；</li><li>应当可以在需要时被唤醒执行任务，而在无需时不占用过多 CPU 资源；</li><li>应当可以被主控线程控制，在适当的时候暂停任务、停止接收任务、丢弃未完成任务等。</li></ul><p>对于第一条，modern C++ 的做法应该是利用 <code>functional</code> 头文件提供的基础设施（<code>std::bind</code>, <code>std::function</code> 等）结合模板参数包来实现。对于第二条，old-fashion 的做法是在发布任务时同时注册回调函数；modern C++ 的做法应该是利用 <code>std::packaged_task</code> 结合 <code>std::future</code> 来实现。对于第三条，若是任务来得不那么频繁，应当考虑使用 <code>std::condition_variable</code> 来实现；若是任务十分频繁，则可以考虑使用 <code>std::this_thread::yield</code>。对于第四条，则可以设置一个内部变量作为标记，让每个工作线程都定期检查该标记来实现。</p><p>我们讨论到了任务。显然，我们会需要一个线程安全的队列来管理其他线程发布的任务。</p><h2 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h2><p>我们不妨直接从代码入手，逐步分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocking_queue</span> : <span class="keyword">protected</span> std::queue&lt;T&gt; &#123;  <span class="comment">// 1.</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> wlock = std::unique_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.a</span></span><br><span class="line">  <span class="keyword">using</span> rlock = std::shared_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.b</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">blocking_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">blocking_queue</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">blocking_queue</span>(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="built_in">blocking_queue</span>(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.b</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>; <span class="comment">// 3.c</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.d</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.a</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.b</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.a</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">push</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.b</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">emplace</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; holder)</span> </span>&#123;  <span class="comment">// 6.</span></span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      holder = std::<span class="built_in">move</span>(std::queue&lt;T&gt;::<span class="built_in">front</span>());</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::shared_mutex mtx_;  <span class="comment">// 7.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>blocking_queue</code> 继承 <code>std::queue</code>，最基本的队列的实现交给标准库。</li><li>利用 <code>std::shared_mutex</code> 结合 <code>std::unique_lock</code> 和 <code>std::shared_lock</code> 实现读写锁。</li><li>此处我们禁用了拷贝和移动构造函数及对应的赋值运算符。这纯粹是因为在实现线程池的过程中我们用不到它们。如果需要，是可以按需实现的。</li><li>在两个 observers 当中，我们使用了只读锁。</li><li><code>push</code> 和 <code>emplace</code> 是类似的操作，都是在队尾追加元素。他们的区别与联系就和标准库容器的接口一样。注意在 <code>emplace</code> 当中，我们用到了完美转发技术。</li><li>这里的 <code>pop</code> 其实更合适称作 <code>try_pop</code>。因为 <code>pop</code> 动作在此处并不一定成功，在队列为空时，函数返回 <code>false</code> 而不会对队列做任何修改。</li><li>这是一把针对整个队列的粗粒度锁。实际上，因为队列的 push 和 pop 一定程度上是分开的，小心地话，可以实现一个细粒度版本的锁，在 push 和 pop 操作都频繁的情况下会有显著的性能提升。关于这一点，我们之后可以单列一篇文章进行讨论。</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>按先前的讨论，我们可以整理出线程池的大致模样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;  <span class="comment">// stop and process all delegated tasks</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">()</span></span>;     <span class="comment">// stop and drop all tasks remained in queue</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 2.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_running</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;  <span class="comment">// 4.</span></span><br><span class="line">  <span class="keyword">mutable</span> blocking_queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks_;  <span class="comment">// 5.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一组的三个接口是整个线程池的控制接口。<code>init</code> 接口启动线程池，其参数 <code>num</code> 即是线程池中线程的数量。<code>terminate</code> 接口终止线程池，不再接受新的任务，并保证将已接受的任务处理完毕。<code>cancel</code> 与 <code>terminate</code> 类似，但它将丢弃已接受但未处理完毕的任务。</li><li>第二组的三个接口均是 observers。</li><li>第三组中的唯一一个接口是线程池接受外部任务的接口。它和标准库提供的 <code>std::async</code> 几乎一致，接受任意函数，并返回一个 <code>std::future</code>。</li><li>这是线程池本体。</li><li>这是任务队列。</li></ol><h3 id="线程池的控制接口"><a href="#线程池的控制接口" class="headerlink" title="线程池的控制接口"></a>线程池的控制接口</h3><p>接下来我们讨论控制接口的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::init</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_, [<span class="keyword">this</span>, num]() &#123;  <span class="comment">// 1.</span></span><br><span class="line">    wlock <span class="built_in">lock</span>(mtx_);  <span class="comment">// 2.</span></span><br><span class="line">    stop_ = <span class="literal">false</span>;</span><br><span class="line">    cancel_ = <span class="literal">false</span>;</span><br><span class="line">    workers_.<span class="built_in">reserve</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      workers_.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;threadpool::spawn, <span class="keyword">this</span>));  <span class="comment">// 3.a</span></span><br><span class="line">    &#125;</span><br><span class="line">    inited_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::spawn</span><span class="params">()</span> </span>&#123;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">bool</span> pop = <span class="literal">false</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">      cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, &amp;pop, &amp;task] &#123;</span><br><span class="line">        pop = tasks_.<span class="built_in">pop</span>(task);</span><br><span class="line">        <span class="keyword">return</span> cancel_ || stop_ || pop;  <span class="comment">// 4.</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cancel_ || (stop_ &amp;&amp; !pop)) &#123;  <span class="comment">// 5.a</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 5.b</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::terminate</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.a</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      stop_ = <span class="literal">true</span>;  <span class="comment">// 7.a</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::cancel</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.b</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      cancel_ = <span class="literal">true</span>;  <span class="comment">// 7.b</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tasks_.<span class="built_in">clear</span>();  <span class="comment">// 8.</span></span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> threadpool::_is_running() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> inited_ &amp;&amp; !stop_ &amp;&amp; !cancel_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>init</code> 完成的工作，在逻辑上只能进行一次。但我们无法保证用户代码确实如我们所想地这样执行。因此，我们利用 <code>std::call_once</code> 保证相关工作只执行一次。</li><li>因为涉及到修改 <code>threadpool</code> 的状态，所以此处使用写入锁。</li><li><code>spawn</code> 接口是线程函数，也就是线程启动后一直运行的函数。</li><li>当线程被唤醒时（无论是意外唤醒，还是被 <code>notify_*</code> 函数唤醒），若线程池没有被 <code>cancel</code> 或是 <code>terminate</code>，也没能从任务队列中取出任务，则线程应该继续沉眠，否则就应该醒来继续处理。</li><li>如果线程池被 <code>cancel</code>，则不执行当前任务；如果线程池被停止并且没能从任务队列中取出任务，则也不执行当前任务；否则就执行当前任务。</li><li><code>terminate</code> 和 <code>cancel</code> 的实现几乎完全相同；</li><li>唯独 <code>terminate</code> 修改 <code>stop_</code> 变量而 <code>cancel</code> 修改 <code>cancel_</code> 变量。</li><li>此外，<code>cancel</code> 接口显式地清空了任务队列。</li></ol><h3 id="线程池的观察器"><a href="#线程池的观察器" class="headerlink" title="线程池的观察器"></a>线程池的观察器</h3><p>观察器比较简单，唯一值得一提的是这里使用了读取锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::inited</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> inited_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::is_running</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> _is_running();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">threadpool::size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> workers_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务接口"><a href="#任务接口" class="headerlink" title="任务接口"></a>任务接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">threadpool::async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">return_t</span> = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 1.a</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">future_t</span> = std::future&lt;<span class="type">return_t</span>&gt;;  <span class="comment">// 1.b</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">task_t</span> = std::packaged_task&lt;<span class="built_in">return_t</span>()&gt;;  <span class="comment">// 1.c</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span> (stop_ || cancel_)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">          <span class="string">&quot;Delegating task to a threadpool &quot;</span></span><br><span class="line">          <span class="string">&quot;that has been terminated or canceled.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bind_func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);  <span class="comment">// 3.</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">task_t</span>&gt; task = std::<span class="built_in">make_shared</span>&lt;<span class="type">task_t</span>&gt;(std::<span class="built_in">move</span>(bind_func));  <span class="comment">// 4.a</span></span><br><span class="line">  <span class="type">future_t</span> fut = task-&gt;<span class="built_in">get_future</span>();  <span class="comment">// 4.b</span></span><br><span class="line">  tasks_.<span class="built_in">emplace</span>([task]() -&gt; <span class="type">void</span> &#123; (*task)(); &#125;);  <span class="comment">// 5.</span></span><br><span class="line">  cond_.<span class="built_in">notify_one</span>();  <span class="comment">// 6.</span></span><br><span class="line">  <span class="keyword">return</span> fut;  <span class="comment">// 4.c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>using</code> 定义的三个类型，见文知意。</li><li>这里不涉及对线程池状态的修改，因此只需要读取锁即可。显然，此处我们禁止对已经 <code>terminate</code> 或是 <code>cancel</code> 的线程池继续发布任务。</li><li>由于任务队列只接收 <code>std::function&lt;void()&gt;</code> 的可调用对象，此处我们利用 <code>std::bind</code> 先匹配参数列表。</li><li>此处我们利用 <code>std::packaged_task</code> 将待执行的任务与一个 <code>std::future</code> 关联起来，并将 <code>std::future</code> 返回给外界，以便任务发布者可以在将来取得任务执行结果。</li><li>这里我们利用一个 lambda，既执行了任务，又将返回值抹去（但会被 future 管理），以便匹配 <code>std::function&lt;void()&gt;</code>。</li><li>此处我们通过条件变量唤醒工作线程。</li></ol><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>完整实现可见 <a href="https://github.com/Liam0205/toy-threadpool">Liam0205&#x2F;toy-threadpool</a>，其中包括了单元测试和相比 <code>std::async</code> 的性能对比。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>这里我们实现了一个可看使用的线程池。但如 GitHub 的 repo 名字一样，它还只是个玩具。若要在工程中使用，还可以做一系列优化。例如说：</p><ul><li>对线程安全队列进行优化，使用更细粒度的锁（完整实现当中已有），或者换用无锁实现。</li><li>完善的线程池，除了支持本文提到的几种状态，还可以有暂停、扩张（任务过多时自动扩张）、收缩（空闲线程过多时自动收缩）等能力。</li></ul><p>这些内容都可以继续去深挖、优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Thread" scheme="https://liam.page/tags/Thread/"/>
    
      <category term="Threadpool" scheme="https://liam.page/tags/Threadpool/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS Monterey 12.3 上因缺失 Python 2.7 导致的问题</title>
    <link href="https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/"/>
    <id>https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/</id>
    <published>2022-04-01T04:10:06.000Z</published>
    <updated>2022-04-16T12:21:08.293Z</updated>
    
    <content type="html"><![CDATA[<p>最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Termination Reason: Namespace DYLD, Code 1 Library missing</span><br><span class="line">Library not loaded: /System/Library/Frameworks/Python.framework/Versions/2.7/Python</span><br><span class="line">Referenced from: /Applications/CHIRP.app/Contents/CHIRP</span><br><span class="line">Reason: tried: &#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file), &#x27;/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file)</span><br></pre></td></tr></table></figure><p>这是由于 Apple 在 macOS Monterey 12.3 开始，<a href="https://developer.apple.com/documentation/macos-release-notes/macos-12_3-release-notes#Python">移除了随系统发行的 Python 2.7</a>；于是，尚在依赖 Python 2.7 的 App 在启动时的动态链接阶段就会出错而崩溃。</p><p>考虑到部分 App 尚未更新以解除对 Python 2.7 的依赖，这里我们需要手动安装 Python 2.7。为此，我们可在 Python 官网上找到历史版本（<a href="https://www.python.org/ftp/python/2.7.18/python-2.7.18-macosx10.9.pkg">Python 2.7.18</a>）并下载安装。按我的经验，自主安装 Python 2.7.18 之后，问题即得到解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Monterey" scheme="https://liam.page/tags/Monterey/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑬）：C++ 的内存顺序·下</title>
    <link href="https://liam.page/2021/12/14/memory-order-cpp-03/"/>
    <id>https://liam.page/2021/12/14/memory-order-cpp-03/</id>
    <published>2021-12-13T16:14:42.000Z</published>
    <updated>2021-12-18T11:52:24.022Z</updated>
    
    <content type="html"><![CDATA[<p>在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于<a href="/2021/06/05/memory-model-cpp/">内存模型</a>和内存顺序（<a href="/2021/06/06/memory-order-cpp-01/">上</a>、<a href="/2021/12/11/memory-order-cpp-02/">中</a>）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。</p><p>此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。</p><span id="more"></span><h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>让我们从一个最简单的生产者&#x2F;消费者的例子出发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;  <span class="comment">// 1.a.</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 1.b.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">1024</span>);  <span class="comment">// 2.</span></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready.<span class="built_in">load</span>()) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; data[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 5.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::thread a&#123;producer&#125;, b&#123;consumer&#125;;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，(1) 初始化了全局共享的数据 <code>data</code> 和原子标记 <code>ready</code>。生产者线程中，(2) 对全局共享的数据进行修改，并在 (3) 处将标记设置为 <code>true</code>。消费者线程中，(4) 循环等待原子标记（当然，它效率极低；作为示例我们暂时忽略这个问题），而后在 (5) 处读取共享数据。</p><p>我们知道，在多个线程中，并发读写同一个内存位置（此处的 <code>&amp;data[0]</code>）可能造成数据竞争，必须有相应的同步机制。此处同步机制由原子标记 <code>ready</code> 协助建立。</p><ul><li>(2) <ins>先于（happens-before）</ins> (3)；</li><li><strong>当 (4) 读到 <code>ready.load()</code> 为真</strong>，则 (3) 与 (4) 建立<ins>同步（synchronizes-with）</ins>关系，因而有 (3) <ins>先于（happens-before）</ins> (4)；</li><li>(4) <ins>先于（happens-before）</ins> (5)。</li></ul><p>在原子标记 <code>ready</code> 的协助下，我们建立了对 <code>data</code> 的写<ins>先于（happens-before）</ins>读的顺序关系，数据竞争的风险就此解除。</p><p>整体看下来，这一过程非常符合直觉。而我们知道，原子变量除了保证其上原子操作的原子性之外，各个操作还有内存顺序标记。不同的顺序标记会影响编译器优化和 CPU 执行时的行为；更准确地，影响原子操作附近访问内存的顺序。默认的顺序标记是 <code>std::memory_order_seq_cst</code>。之所以将它作为默认标记，是因为它能带来这一符合直觉的结果。</p><p>接下来，我们顺势讨论<ins>先于（happens-before）</ins>关系和<ins>同步（synchronizes-with）</ins>关系。</p><h2 id="两种关系"><a href="#两种关系" class="headerlink" title="两种关系"></a>两种关系</h2><h3 id="同步（synchronizes-with）关系"><a href="#同步（synchronizes-with）关系" class="headerlink" title="同步（synchronizes-with）关系"></a><ins>同步（synchronizes-with）</ins>关系</h3><p><ins>同步（synchronizes-with）</ins>关系，追根究底只能由原子操作提供。我们能见到的所有产生同步关系的办法，其底层都包含了某些原子操作。同步关系是这样建立的，</p><ul><li>首先有在线程 A 中对原子变量 <code>x</code> 打上恰当标记的写入操作 <code>W</code>；</li><li>而后有在线程 B 中对原子变量 <code>x</code> 打上恰当标记的读取操作 <code>R</code>。</li></ul><p>若 <code>R</code> 读到的值，来自以下任意一种情况，则说 <code>W</code> 与 <code>R</code> <ins>同步（synchronizes-with）</ins>。</p><ul><li><code>W</code> 的写入；或者</li><li>线程 A（<code>W</code> 所在线程）中，<code>W</code> 之后的某次写入；或者</li><li>任意线程中的一系列 read-modify-write 操作中的写入值，其中第一次 read-modify-write 操作读到的值来自 <code>W</code> 的写入。</li></ul><p>这得到一个最基本的认知：（在顺序标记恰当的情况下，）如果线程 B 的读取操作读到的是线程 A 的写入操作的写入值，则写入操作与读取操作同步。</p><p>如此一来，所有的细节就在「恰当」二字之上了。不过，我们先来讨论<ins>先于（happens-before）</ins>关系。</p><h2 id="先于（happens-before）关系"><a href="#先于（happens-before）关系" class="headerlink" title="先于（happens-before）关系"></a><ins>先于（happens-before）</ins>关系</h2><p><ins>先于（happens-before）</ins>关系是讨论内存顺序中最重要的基石。若 A <ins>先于（happens-before）</ins> B，则 B 能看到 A 带来的副作用。</p><p>在单线程里面，<ins>先于（happens-before）</ins>关系很简单。单线程当中的<ins>先于（happens-before）</ins>关系即是<ins>先序（sequenced-before）</ins>关系。一般来说，不考虑编译器优化重排和 CPU 乱序执行重排时，在代码当中，靠前的语句当中的操作<ins>先于（happens-before）</ins>靠后的语句当中的操作。但实际上，我们需要考虑编译器优化和 CPU 乱序执行对先序关系带来的影响。</p><p>在线程之间，若线程 A 的写入操作与线程 B 的读取操作<ins>同步（synchronizes-with）</ins>，则该写入操作<ins>线程间先于（inter-thread happens-before）</ins>该读取操作，也因此该写入操作<ins>先于（happens-before）</ins>该读取操作。</p><h2 id="三种顺序模型"><a href="#三种顺序模型" class="headerlink" title="三种顺序模型"></a>三种顺序模型</h2><p>按前文，顺序标记共有六种：</p><ul><li><code>std::memory_order_relaxed</code></li><li><code>std::memory_order_consume</code></li><li><code>std::memory_order_acquire</code></li><li><code>std::memory_order_release</code></li><li><code>std::memory_order_acq_rel</code></li><li><code>std::memory_order_seq_cst</code></li></ul><p>六种标记又能组成三种顺序模型：</p><ul><li>顺序一致模型（sequentially consistent ordering）：最强的顺序模型。对编译器优化限制最多，所需额外 CPU 同步指令最多，性能也最差；但最符合直觉。涉及到的顺序标记是 <code>std::memory_order_seq_cst</code>。</li><li>宽松模型（relaxed ordering）：最弱的顺序模型。对编译器优化限制最少（几乎没有），所需额外 CPU 同步指令最少（几乎没有），性能也最好；但无法建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_relaxed</code>。</li><li>获取-释放模型（acquire-release ordering）：介于二者之间。对编译器优化限制适中，所需额外的 CPU 同步指令也适中（在部分平台上，不许额外同步指令），性能也适中；可以建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_acq_rel</code>, <code>std::memory_order_acquire</code>, <code>std::memory_order_release</code> 和 <code>std::memory_order_consume</code>。</li></ul><blockquote><p>注意，<code>std::memory_order_consume</code> 与 <code>std::memory_order_acquire</code> 相似，但比后者更弱。但完整地实现 <code>std::memory_order_consume</code> 的语义，需要追踪变量之间的依赖链。目前，还没有已知的编译器实现了它。现有的编译器，都将 <code>std::memory_order_consume</code> 提升为 <code>std::memory_order_acquire</code>。故而此处也将 <code>std::memory_order_consume</code> 归在获取-释放模型当中。此外，考虑 <code>std::memory_order_consume</code> 的语义可能发生变化，目前标准也不建议使用 <code>std::memory_order_consume</code>。</p></blockquote><h3 id="顺序一致模型（sequentially-consistent-ordering）"><a href="#顺序一致模型（sequentially-consistent-ordering）" class="headerlink" title="顺序一致模型（sequentially consistent ordering）"></a>顺序一致模型（sequentially consistent ordering）</h3><p>默认的顺序模型是「顺序一致模型」。如果所有原子操作的顺序标记都是 <code>std::memory_order_seq_cst</code>，那么多线程程序的行为就好像这些操作以某一特定的顺序在单一的线程中执行一样。特别地，站在所有被打上 <code>std::memory_order_seq_cst</code> 标记的操作上来看，所有先于该操作发生的原子操作（<code>std::memory_order_seq_cst</code>），都具有同样的顺序。</p><p>这是最符合直觉的模型。多数人第一次接触到多线程，会假定多线程中的各个操作是可能并发执行的，因此将他们理解为按照某个不确定的顺序穿插执行。然后在脑海中想象并构建这一固定的顺序，并按照这一顺序假定各个线程会如何工作。但这种符合直觉的模型并不总是成立。这种多线程之间全局统一的顺序，即是顺序一致性带来的保证。一旦保证不了顺序一致性，则这种基于「穿插执行」假定出来的全局统一顺序也就不成立了。</p><!-- From the point of view of synchronization, a sequentially consistent store synchronizes-with a sequentially consistent load of the same variable that reads the value stored. This provides one ordering constraint on the operation of two (or more) threads, but sequential consistency is more powerful than that. Any sequentially con- sistent atomic operations done after that load must also appear after the store to other threads in the system using sequentially consistent atomic operations. The example in listing 5.4 demonstrates this ordering constraint in action. This constraint doesn’t carry forward to threads that use atomic operations with relaxed memory orderings; they can still see the operations in a different order, so you must use sequentially con- sistent operations on all your threads in order to get the benefit. --><p>站在同步的角度来看，顺序一致 store 操作与读到本次写入值的顺序一致的 load 操作<ins>同步（synchronizes-with）</ins>。如前所述，这种同步关系在线程之间提供了一定的顺序限制。但顺序一致模型还保证，在这一顺序一致的 load 操作之后的顺序一致操作，在其他所有使用顺序一致原子操作的线程看来，也是发生在此次顺序一致 store 之后的。注意，如若某一线程中的某个原子操作没有使用 <code>std::memory_order_seq_cst</code> 标记，则在该操作看来，顺序一致的诸多操作的顺序可能与其他线程看到的不同。</p><p>前作当中的<a href="/2021/12/11/memory-order-cpp-02/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E9%A1%BA%E5%BA%8F%EF%BC%88Sequentially-consistent-ordering%EF%BC%89">例子</a>很好地说明了顺序一致性的效果。</p><!-- This ease of understanding can come at a price, though. On a weakly ordered machine with many processors, it can impose a noticeable performance penalty, because the overall sequence of operations must be kept consistent between the pro- cessors, possibly requiring extensive (and expensive!) synchronization operations between the processors. That said, some processor architectures (such as the common x86 and x86-64 architectures) offer sequential consistency relatively cheaply, so if you’re concerned about the performance implications of using sequentially consis- tent ordering, check the documentation for your target processor architectures. --><p>这种便利是有代价的。在默认的顺序保证相对较弱的平台上（如 ARM），顺序一致模型会引入可观的性能代价。这是因为，全局顺序一致需要在 CPU 逻辑核心之间保持一致性，这使得 CPU 逻辑核心之间需要使用代价高昂的同步操作。相较而言，部分处理器架构（例如 x86 和 x86-64）保证顺序一致性的代价较低。为避免这种同步代价，我们需要拥抱非顺序一致性模型。</p><hr><p>在处理非顺序一致性模型时，我们就要丢弃脑海中那种简洁漂亮的交替执行的思维模型。<strong>它不存在了</strong>。在没有顺序一致性保障的情况下，各个线程看到的原子操作的顺序并不保证统一。也就是说，虽然依旧是并发（所以穿插执行），但是每个线程看到的穿插的顺序可能是不一样的。在非顺序一致模型下写代码时，要时刻关注这一点。</p><p>不过，也有一致的地方。虽说各个线程观察到的原子操作发生的顺序可能不一致，但是，对于<strong>每一个特定的原子变量</strong>，作用在其上的原子操作的修改顺序（modification-order），在各个线程看来是统一的。</p><p>为了充分理解非顺序一致性模型，我们可以先考虑宽松模型。待对非顺序一致性有足够了解之后，再回到获取-释放模型。</p><h3 id="宽松模型（relaxed-ordering）"><a href="#宽松模型（relaxed-ordering）" class="headerlink" title="宽松模型（relaxed ordering）"></a>宽松模型（relaxed ordering）</h3><p>顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作不参与构建<ins>同步（synchronizes-with）</ins>关系。在同一线程中，对<strong>同一</strong>原子变量的原子操作的顺序遵循源代码中的<ins>先序（sequenced-before）</ins>关系（从而有<ins>先于（happens-before）</ins>关系）。但是，在另外的线程看来，这种顺序无法保证。由于未加任何同步限制，顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作只是简单地遵循各个原子变量自身的修改顺序（modification-order）而已。</p><p>首先看一段简单的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    z.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(<span class="number">0</span> != z.<span class="built_in">load</span>());  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照经典的「穿插思维模型」（即顺序一致性模型），(3) 处循环等待直到 <code>y</code> 为真，那么<strong>由于 (1) 先于 (2) 发生，(3) 先于 (4) 发生</strong>，所以 (4) 必然为真，因此 (5) 的断言永不失效。但实际上，由于 (1) -- (4) 的顺序标记都是 <code>std::memory_order_relaxed</code>，此处并无同步保证，也没有单线程中的先序关系保证。这也就是说，上述两个先于关系不一定成立；即便成立，(2) 不必然与 (3) <ins>同步（synchronizes-with）</ins>，因此也就无法传递上述两个先于关系。所以站在 (4) 的角度看，并不保证 (1) <ins>先于（happens-before）</ins> (4) 发生。所以 (4) 可能读到 <code>false</code> 导致断言失败。</p><p>接下来再看一个更加复杂的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> upper&#123;<span class="number">10UL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Snapshot t1[upper];</span><br><span class="line">Snapshot t2[upper];</span><br><span class="line">Snapshot t3[upper];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;* var, Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.a.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.a.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.a.</span></span><br><span class="line">    var-&gt;<span class="built_in">store</span>(i + <span class="number">1</span>, std::memory_order_relaxed);  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; snapshot.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; snapshot.y &lt;&lt; <span class="string">&quot;)&quot;</span>;  <span class="comment">// 5.</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">T1</span><span class="params">(increase, &amp;x, t1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T2</span><span class="params">(increase, &amp;y, t2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T3</span><span class="params">(observe, t3)</span></span>;</span><br><span class="line"></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 1.c.</span></span><br><span class="line"></span><br><span class="line">  T3.<span class="built_in">join</span>();</span><br><span class="line">  T2.<span class="built_in">join</span>();</span><br><span class="line">  T1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(t1);</span><br><span class="line">  <span class="built_in">print</span>(t2);</span><br><span class="line">  <span class="built_in">print</span>(t3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">(0,2),(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,10),(9,10)</span><br><span class="line">(0,0),(0,1),(0,2),(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9)</span><br><span class="line">(1,3),(2,4),(2,5),(3,6),(4,7),(5,8),(6,8),(7,9),(8,10),(8,10)</span><br></pre></td></tr></table></figure><p>我们首先来观察一下代码和结果。</p><p>代码部分，</p><ul><li><code>increase</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 次循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中，而后以 <code>std::memory_order_relaxed</code> 的顺序标记更新 <code>var</code> 指向的原子变量（要么是 <code>x</code>，要么是 <code>y</code>）。</li><li><code>observe</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 词循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中。</li><li><code>print</code> 打印历次循环得到的快照 (5)。每个二元组中，第一个数是当次循环读到的 <code>x</code> 的值；第二个数是对应的 <code>y</code> 的值。</li><li><code>ready</code> 变量确保三个线程在几乎相同的时间开始，以防（例如说）<code>T1</code> 已经执行完毕而 <code>T3</code> 还尚未开始执行。</li></ul><p>结果部分，</p><ul><li>第一行、第二行、第三行分别记录了 <code>T1</code>, <code>T2</code>, <code>T3</code> 在历次循环过程中记录下来的 <code>x</code> 和 <code>y</code> 的值的快照。</li><li>关于写<ul><li>对于 <code>T1</code> 来说，只有该线程修改 <code>x</code> 的值，每次读到它，都恰好自增 <code>1</code>；</li><li>同样对于 <code>T2</code> 来说，<code>y</code> 每次自增 <code>1</code>。</li></ul></li><li>关于读<ul><li>对于 <code>T1</code> 和 <code>T3</code> 来说，它们只读 <code>y</code> 的值。因为 <code>y</code> 的修改序列中，<code>y</code> 的值是递增的；因此 <code>T1</code> 和 <code>T3</code> 每次读到的 <code>y</code> 的值都不小于前一次读到的 <code>y</code> 的值；但递增的步长不一定均衡。</li><li>对于 <code>T2</code> 和 <code>T3</code> 来说，它们只读 <code>x</code> 的值。基于同样的理由，它们每次读到的 <code>x</code> 的值都是非递减的；但递增的步长不一定均衡。</li></ul></li></ul><p>这里我们只给出了一个可能的结果，实际上，符合上述规律的结果，都是可能出现的。</p><p>接下来我们正式地描述宽松模型下的规律。</p><ul><li>对于任意给定的原子变量，其<ins>修改顺序（modification-order）</ins>是全局唯一的。</li><li>对于任意线程，<ul><li>若未曾读取过该变量的值，则可能读取到修改顺序上任意可能的值。</li><li>一旦读取了某个原子变量在修改顺序上的某个值，将来再读取时，要么读取相同的值，要么读取到在修改顺序上更靠后的值，而不可能读到在修改顺序上更靠前的值。</li></ul></li><li>对于任意线程，一旦写入了某个原子变量，将来再读取时，要么读取到此次写入的值，要么读取到修改顺序上相对此次写入更靠后的值。</li></ul><p>我们可以使用这一规律来回顾本节第一段代码。对于变量 <code>x</code> 来说，其修改顺序是：默认值 <code>false</code>，由 <code>write_x_then_y</code> 写入的值 <code>true</code>。在 <code>read_y_then_x</code> 线程当中，由于从未读取过 <code>x</code> 的值，因此可能读到 <code>x</code> 的修改顺序上的任意值。——可能是 <code>false</code>，亦可能是 <code>true</code>。故而断言可能失败。</p><h3 id="获取-释放模型（acquire-release-ordering）"><a href="#获取-释放模型（acquire-release-ordering）" class="headerlink" title="获取-释放模型（acquire-release ordering）"></a>获取-释放模型（acquire-release ordering）</h3><p>接下来，我们讨论居于宽松模型和顺序一致模型当中的获取-释放模型（acquire-release ordering）。</p><p>获取-释放模型当中，依然不存在顺序一致模型当中那样的全局唯一操作顺序，但相较宽松模型，增加了部分同步能力。在获取-释放模型当中，</p><ul><li>原子-store 操作是<ins>释放操作（release-operation）</ins>（<code>std::memory_order_acquire</code>）；</li><li>原子-load 操作是<ins>获取操作（acquire-operation）</ins>（<code>std::memory_order_release</code>）；</li><li>原子-read-modify-write 操作（例如 <code>fetch_add</code> 或是 <code>exchange</code>）则要么是释放操作，要么是获取操作，要么同时是释放-获取操作（<code>std::memory_order_acq_rel</code>）。</li></ul><p>同步总是在线程之间成对出现的。一个线程中的释放操作与另一个线程中读到该次写入的获取操作<ins>同步（synchronizes-with）</ins>。这意味着，不同线程可能观察到不同的操作顺序，但这些顺序是有所限制的。</p><p>同样地，我们来看一个示例。这个例子是从顺序一致性模型的例子上稍加修改而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 6.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// can fire</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，断言可能失败。我们来做进一步分析。</p><p>(1) 处是释放操作；(3) 处通过循环确保读到 (1) 写入的值。因而 (1) 的释放操作与 (3) 的获取操作配对，建立<ins>同步（synchronizes-with）</ins>关系，于是 (1) 顺势与 (4) 建立<ins>先于（happens-before）</ins> 关系。同理，(2) 与 (5) 之间也有同步关系，(2) 顺势与 (6) 建立<ins>先于（happens-before）</ins> 关系。</p><p>然而，我们无法建立 (1) <ins>先于（happens-before）</ins> (6) 的关系。故而 (6) 可能读到变量 <code>x</code> 的修改序列上的任意值。例如说，可能读到 <code>false</code>。同理 (4) 也可能读到 <code>false</code>。二者同时发生时，断言失败。</p><p>因为 store 操作发生在不同的线程，故而我们无法借助一个原子变量的同步关系，构造另一个原子变量的写与读之间的先于关系。这告诉我们两件事情。一是，对于多写多读的场景，我们往往需要顺序一致性模型。二是，若要应用获取-释放模型，store 操作应当发生在同一线程。</p><p>接下来我们再看一例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 3.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑 (1) 和 (2) 在同一线程中，有<ins>先序（sequenced-before）</ins>关系（release 语义保证不乱序）；(3) 处的 spin-wait 保证读到 (2) 的写入，因而 (2) 与 (3) <ins>同步（synchronizes-with）</ins>，再有 (3) 与 (4) 在同一线程中，也有先序关系（acquire 语义保证不乱序）。故而 (1) 必须先于 (4)，从而 (4) 的判断必定成立，而 (5) 的断言永不失败。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>C++ 标准库也提供了内存屏障 <code>std::atomic_thread_fence</code>，它也可以打上顺序标签。</p><p>理解起来，带上 <code>std::memory_order_release</code> 的内存屏障，倾向于向下结合一个 store 操作，将它的内存顺序提升为 <code>std::memory_order_release</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。带上 <code>std::memory_order_acquire</code> 的内存屏障，倾向于向上结合一个 load 操作，将它的内存顺序提升为 <code>std::memory_order_acquire</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。从而建立获取-释放的同步关系。</p><p>我们可以将上例稍加修改得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2.a.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 3.a.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 3.b.</span></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，(2.a) 的 release-屏障向下与 (2.b) 的宽松-store 操作结合，使得该操作提升为 release-store；(3.b) 的 acquire-屏障向上与 (3.a) 的宽松-load 操作结合，使得该操作提升为 acquire-load。reloease-store 和 acquire-load 构成<ins>同步（synchronizes-with）</ins>，又有 release&#x2F;acquire 语义保证局部顺序，因此有 (1) <ins>先于（happens-before）</ins> (4)，从而 (5) 的断言不会失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;和内存顺序（&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;上&lt;/a&gt;、&lt;a href=&quot;/2021/12/11/memory-order-cpp-02/&quot;&gt;中&lt;/a&gt;）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。&lt;/p&gt;
&lt;p&gt;此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑫）：C++ 的内存顺序·中</title>
    <link href="https://liam.page/2021/12/11/memory-order-cpp-02/"/>
    <id>https://liam.page/2021/12/11/memory-order-cpp-02/</id>
    <published>2021-12-11T00:27:42.000Z</published>
    <updated>2021-12-13T16:05:00.905Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇（<a href="/2021/06/05/memory-model-cpp/">内存模型</a>与<a href="/2021/06/06/memory-order-cpp-01/">内存顺序·上</a>）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>的翻译，但会展开做一些讨论。</p><span id="more"></span><h2 id="六种内存顺序标记"><a href="#六种内存顺序标记" class="headerlink" title="六种内存顺序标记"></a>六种内存顺序标记</h2><p>C++ 标准库定义了六中内存顺序标记（memory order tag）。他们被定义为一个枚举类型。在 C++11 之后、C++20 之前，定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p>在 C++20 中，则使用新的 <code>enum class</code> 重新定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">memory_order</span> : <span class="comment">/*unspecified*/</span> &#123;</span><br><span class="line">    relaxed, consume, acquire, release, acq_rel, seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_relaxed = memory_order::relaxed;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_consume = memory_order::consume;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acquire = memory_order::acquire;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_release = memory_order::release;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acq_rel = memory_order::acq_rel;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_seq_cst = memory_order::seq_cst;</span><br></pre></td></tr></table></figure><p>我们知道，原子变量上没有数据竞争，从而提供了良定义的多线程并发读写能力。因此，原子变量有可能实际上建立了线程间的同步关系，于是建立了某种<ins>先于（happens-before）</ins>关系。</p><p>在原子操作上添加六种内存顺序标记（中的一部分），会<strong>影响（但不一定改变；视 CPU 架构）原子操作附近的内存访问顺序（包括其他原子操作，亦包含对非原子变量的读写操作）</strong>。注意，内存顺序（通过六种标记）讨论的实际上是线程内原子操作附近非原子操作访问内存的顺序，而非是多线程之间的执行顺序。只不过，因为原子变量自身可能建立了线程间的同步关系，所以<strong>两个线程内各自的内存顺序会经由原子变量的同步建立间接的顺序关系</strong>。亦即，<strong>内存顺序本质上是在讨论单线程内指令执行顺序对多线程影响</strong>的问题。显然，通过添加内存顺序标记，编译器优化和 CPU 指令多发射（multiple issue）、CPU 乱序执行（out-of-order execution）都可能受到一定影响。</p><p>所有原子操作默认的内存顺序标记是 <code>std::memory_order_seq_cst</code>，亦即，提供顺序一致性的顺序保证（后续讨论）。目前而言，在绝大多数 CPU 架构上，顺序一致性模型都需要或多或少地在原子操作前后加上内存屏障（memory fence）。因而，顺序一致性虽好，但会损失部分性能。使用其它内存顺序标记则或多或少降低顺序一致性的保证。</p><table><thead><tr><th>标记</th><th>作用</th></tr></thead><tbody><tr><td><code>memory_order_relaxed</code></td><td>宽松操作：仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。</td></tr><tr><td><code>memory_order_consume</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E6%B6%88%E8%B4%B9%E6%93%8D%E4%BD%9C%EF%BC%88consume-operation%EF%BC%89">消费操作（consume operation）</a></ins>：当前线程中，所有依赖当前 load 操作读取的值的读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>依赖的变量的写入，对当前线程是可见的。多数平台上，该标记仅影响编译器优化。</td></tr><tr><td><code>memory_order_acquire</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E5%8D%A0%E6%9C%89%E6%93%8D%E4%BD%9C%EF%BC%88aquire-operation%EF%BC%89">占有操作（aquire operation）</a></ins>：当前线程中，所有读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前线程是可见的。</td></tr><tr><td><code>memory_order_release</code></td><td>打上此标记的 store 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%EF%BC%88release-operation%EF%BC%89">释放操作（release operation）</a></ins>：当前线程中，所有读写操作不得重排至当前操作之后。因此，当前操作所在线程之前的写入操作，在其他线程中，对该原子变量施加<ins>占有操作（aquire operation）</ins>之后是可见的。也因此，当前操作所在线程中，当前操作所依赖的写入操作，在其他线程中，对该原子变量施加<ins>消费操作（consume operation）</ins>之后是可见的。</td></tr><tr><td><code>memory_order_acq_rel</code></td><td>打上此标记的 read-modify-write 操作既是<ins>占有操作（aquire operation）</ins>又是<ins>释放操作（release operation）</ins>：当前线程中的读写操作不能重排至当前操作之后（如果原本在之前），亦不能重排至当前操作之前（如果原本在之后）。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前 modification 是可见的；该 modification 对其他线程中相同原子变量<ins>占有操作（aquire operation）</ins>之后亦是可见的。</td></tr><tr><td><code>memory_order_seq_cst</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins>占有操作（aquire operation）</ins>；打上此标记的 store 操作对相关内存位置施加<ins>释放操作（release operation）</ins>；打上此标记的 read-modify-write 对相关内存位置施加<ins>占有操作（aquire operation）</ins>和<ins>释放操作（release operation）</ins>。此外，对所有线程来说，所有打上该标记的写操作，存在一个全局修改顺序（尽管具体顺序在执行时才确定）。也就是说，对于所有线程来说，看见的这些写操作的顺序是一致的。</td></tr></tbody></table><h2 id="宽松顺序（Relaxed-ordering）"><a href="#宽松顺序（Relaxed-ordering）" class="headerlink" title="宽松顺序（Relaxed ordering）"></a>宽松顺序（Relaxed ordering）</h2><p>宽松顺序仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。因此，它们不是同步操作，仅保证原子变量上读写操作的原子性，以及各个原子变量自身修改顺序的一致性（对于同一个变量的两次修改，虽然顺序不一定，但是所有其他线程观察到的修改顺序都是相同的）。</p><p>假定 <code>x</code> 和 <code>y</code> 是两个全局变量，均被初始化为零，则下列代码执行完毕之后，存在 <code>r1 == r2 == 42</code> 的可能性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed);  <span class="comment">// B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// C</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// D</span></span><br></pre></td></tr></table></figure><p>这是因为，虽然在线程 1 和线程 2 之间没有任何同步；于是，对于原子变量 <code>y</code> 的<ins>修改顺序（Modification Order）</ins>来说，D 可能先于 A 发生；同样，对于原子变量 <code>x</code> 的<ins>修改顺序（Modification Order）</ins>来说，B 可能先于 C 发生。</p><p>宽松顺序的典型场景是不断增加的计数器。计数器的增加只需有原子性的保证，而对同步或是内存顺序没有要去。例如，<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> 当中的引用计数的增加。实例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        cnt.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : v) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final counter value is 10000</span><br></pre></td></tr></table></figure><p>不过，对于 <code>std::shard_ptr</code> 当中的引用计数来说，其减少需要与析构函数当中的 load 操作有 acquire-release 的同步。</p><h2 id="释放-获取顺序（Release-Acquire-ordering）"><a href="#释放-获取顺序（Release-Acquire-ordering）" class="headerlink" title="释放-获取顺序（Release-Acquire ordering）"></a>释放-获取顺序（Release-Acquire ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_acquire</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行释放操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在部分强顺序的 CPU 架构中（例如 <code>x86</code>, SPARC TSO, IBM mainframe 等），释放-获取顺序对大多数操作来说都是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将非原子的 load 操作挪到原子 load-acquire 操作之前）。</p><p>在弱顺序的 CPU 架构中（例如 ARM,Itanium, PowerPC），则需加入额外的 CPU 指令或是内存屏障。</p><p>互斥锁（例如 <a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>&#x2F;<a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag">atomic spinlock</a>）亦属于释放-获取同步：当锁被线程 A 释放而后被线程 B 获取，则在锁被释放之前临界区中所有对共享变量的写入操作在线程 B 获取锁之后均可见。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的获取-释放同步，因此两个 <code>assert</code> 永远不会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="type">int</span> data&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_acquire)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例则展示了在三个线程之中，获取-释放顺序的传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_acq_rel)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放-消费顺序（Release-Consume-ordering）"><a href="#释放-消费顺序（Release-Consume-ordering）" class="headerlink" title="释放-消费顺序（Release-Consume ordering）"></a>释放-消费顺序（Release-Consume ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_consume</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中依赖该原子变量的表达式和函数看来都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 中依赖该原子变量的表达式和函数可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行消费操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在除 DEC Alpha 之外的主流 CPU 上，释放-消费顺序（亦称：依赖顺序）是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将涉及到依赖链的非原子的 load 操作挪到原子 load-consume 操作之前）。</p><p>该顺序的使用，往往见于对并发共享数据结构有频繁读取而极少写入的场景（例如路由表、安全策略、防火墙规则等）。</p><p>注意，截至 2015 年 2 月，尚未有编译器追踪了依赖链条，因此，消费操作被提升为获取操作。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的释放-消费同步，因此第一个 <code>assert</code> 永远不会失败，但第二个 <code>assert</code> 可能失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序一致顺序（Sequentially-consistent-ordering）"><a href="#顺序一致顺序（Sequentially-consistent-ordering）" class="headerlink" title="顺序一致顺序（Sequentially-consistent ordering）"></a>顺序一致顺序（Sequentially-consistent ordering）</h2><p>标记上 <code>std::memory_order_seq_cst</code> 的原子操作不仅满足释放-获取顺序的要求（一个线程中 store-release 之前的写入操作在另一个 load-acquire 之后都可见），而且为所有如此标记的原子操作建立了<strong>唯一的全局统一修改顺序（single total modification order）</strong>。</p><p>正式地说，在不考虑 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence"><code>std::atomic_thread_fence</code></a> 的情况下，对于每个 load 原子变量 M 的操作 B（标记为 <code>std::memory_order_seq_cst</code>），它读取到的值来自以下三种可能：</p><ul><li>在上述<strong>唯一的全局统一修改顺序</strong>中的上一个修改了 M 的操作 A 的结果；</li><li>若存在这样的 A，B 还可能读到另一个修改了 M 的操作 C，它没有标记为 <code>std::memory_order_seq_cst</code>，并且不<ins>先于（happens-before）</ins> A；</li><li>若不存在这样的 A，B 读取的结果来自另一个修改了 M 的没有标记为 <code>std::memory_order_seq_cst</code>的操作 D。</li></ul><!-- Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order. --><p>顺序一致对于多生产者多消费者的情形是必要的。这是因为，所有消费者必须能够以相同的顺序观察到所有生产者的行为。</p><!-- Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core. --><p>在所有多核系统中（注：逻辑核），完全的顺序一致都会插入大量内存屏障指令。这使得相应的内存访问需要对所有核心进行广播，因而可能成为性能瓶颈。</p><!-- This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads c and d to observe changes to the atomics x and y in opposite order. --><p>下例中，顺序一致即是必要的。其他更弱的顺序模型可能导致线程 C 和线程 D 观察到原子变量 <code>x</code> 和 <code>y</code> 以不同的顺序修改，从而导致 <code>assert</code> 失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// will never happen</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与-volatile-的关系"><a href="#与-volatile-的关系" class="headerlink" title="与 volatile 的关系"></a>与 <code>volatile</code> 的关系</h2><!-- Within a thread of execution, accesses (reads and writes) through volatile glvalues cannot be reordered past observable side-effects (including other volatile accesses) that are sequenced-before or sequenced-after within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. --><p>在<strong>同一线程</strong>中，对 <code>volatile</code> 修饰的<a href="https://en.cppreference.com/w/cpp/language/value_category#glvalue">泛左值</a>（包括左值和将亡值）的访问（包括读写）不允许被重排序至<ins>先序于（sequenced-before）</ins>该操作的可观测的副作用（包括其他 <code>volatile</code> 访问）之前，亦不允许被重排序至<ins>后序于（sequenced-after）</ins>该操作的可观测的副作用（同上）之后。然而，<code>volatile</code> 访问并未建立线程之间的同步，故而在其他线程中，上述顺序无法得到保证。</p><!-- In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access). --><p>此外，对 <code>volatile</code> 修饰的泛左值的访问不是原子的（这意味着读写同一内存位置上的 <code>volatile</code> 变量属于<a href="https://en.cppreference.com/w/cpp/language/memory_model">数据竞争</a>），同时也不影响内存顺序（非 <code>volatile</code>-访问可以在 <code>volatile</code>-访问附近自由重排序）。</p><!-- One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (Microsoft Docs), and thus volatiles may be used for inter-thread synchronization. Standard volatile semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a std::signal handler that runs in the same thread when applied to sig_atomic_t variables. --><p>一个例外是 Visual Studio。根据<a href="https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp">微软提供的文档</a>，在默认设置下，<code>volatile</code>-读自带 acquire 语义而 <code>volatile</code>-写自带 release 语义。因此，这些 <code>volatile</code>-访问可被用来建立线程间的同步。但要注意，标准的 <code>volatile</code> 语义不应被用于多线程编程。（这一点在<a href="/2018/01/18/volatile-in-C-and-Cpp/">前作</a>中也有讨论）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇（&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;与&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;内存顺序·上&lt;/a&gt;）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;对应页面&lt;/a&gt;的翻译，但会展开做一些讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
  <entry>
    <title>论善良</title>
    <link href="https://liam.page/2021/06/17/discussion-on-kind/"/>
    <id>https://liam.page/2021/06/17/discussion-on-kind/</id>
    <published>2021-06-17T13:07:31.000Z</published>
    <updated>2021-06-17T15:52:46.963Z</updated>
    
    <content type="html"><![CDATA[<p>博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。</p><span id="more"></span><h2 id="善良是什么？"><a href="#善良是什么？" class="headerlink" title="善良是什么？"></a>善良是什么？</h2><p>善良一词，与我所见最早者，当出自《礼记·学记》。曰：「发虑宪，求善良，足以謏闻，不足以动众。」</p><p>按文言一贯作风，善良虽在现代汉语中成词已久，但在文言中大概是分别表意的。在文言文词典中，<a href="https://wyw.hwxnet.com/view/hwxE5hwx96hwx84.html">善</a>作名词表示「好的行为」，作形容词表示「赞许的」或是「熟悉」。显然，此处应取「值得赞许的」的含义。<a href="https://wyw.hwxnet.com/view/hwxE8hwx89hwxAF.html">良</a>作形容词表示「好」。因此，讲白了，文言中的「善良」大约就是人类品德中所有好的品德的集合体。</p><p>在现代汉语中，善良的表意某种意义上被圈定在「和善」、「心地好」这样的意思上了。</p><h2 id="人善被人欺？"><a href="#人善被人欺？" class="headerlink" title="人善被人欺？"></a>人善被人欺？</h2><p>大多数生长于传统中国家庭的孩子，大都从小被教育「要善良」。与之相应，孩子被要求「爱分享」、「乐于助人」等。</p><p>然而，步入社会之后，或多或少地，这些从小被教育要善良的孩子，都因「善良」吃过亏。其中不乏「屡教不改」抑或是「执迷不悔」的人，当然也有些人从此「黑化」或是抑郁。</p><p>这些时候，「孩子们」大约会想起父母的另一句话「害人之心不可有，防人之心不可无」。可是，爸爸妈妈，你们从来没教过我们要如何才能「防人」呀……</p><p>所以，到底要怎么办？</p><h2 id="善心？善举？"><a href="#善心？善举？" class="headerlink" title="善心？善举？"></a>善心？善举？</h2><p>面对这个问题，我们不能逃避。因为你能逃一次，但将来不断发生的事情，会不断质疑你的内心。最终逃无可逃，必须直面。</p><p>为了解决这个问题，我们将善良分为两个部分，或者说两个层次：善心和善举。善心是无条件的，行善举是有条件的。若是行善举会危害到自己的核心利益，那便要慎重。世人多被要求善良，却不分善举和善心。无差别的善举最终往往害人害己。</p><p>对于以善良为代表的一切「美好的德行」，都有<strong>论心不论迹</strong>。也就是说，我们要将善心和善举区分开来；而后，常怀善心，擅行善举。</p><h2 id="何时行善举？"><a href="#何时行善举？" class="headerlink" title="何时行善举？"></a>何时行善举？</h2><p>是否要行善举，这其实是一个选择题。</p><p>在我看来，这一选择题理当无有特殊性。也就是说，人生中其他类似的选择题如何做，这一道选择题就如何做。亦即，人自身的一切行为，都要有统一的标准去考量。不能因为善举于道德地位更高，就降低评判标准，而后决定施行，而不顾其可能带来的负面影响。</p><p>操作层面上，当意图行善时，脑回路里加一个步骤：这事儿做了之后最坏的结果自己能不能接受。如果不能接受的话，哪怕是善举，也慎重一些。</p><h2 id="不为善其与为恶异乎？"><a href="#不为善其与为恶异乎？" class="headerlink" title="不为善其与为恶异乎？"></a>不为善其与为恶异乎？</h2><p>或曰：「不为善者与为恶者，无异也」。曰：「道德绑架者也。」</p><p>有人认为，善而不为，其与恶无异。此类谬误有二。一者，忽略世界的多样性，将善恶二元对立，认为非善即恶。他们认为，不做善事就是恶；不作恶事就是善。二者，将善良至于绝对片面的语境之下，忽略实际情况，忽略自身自我，将善良狭隘化为一个放之四海而皆准的道德标尺。殊不知，因为行善举，而将自己置于无法承受的危险之下，实际上是忽略了自我。「我」都没有了，还谈什么善良呢？这不是善良，而是伪善。</p><p>这些人可能也会拿汉昭烈帝的「勿以善小而不为」来做例证。然而，刘备遗诏中的意思，是强调善举大小、影响范围，却没有教刘禅不分青红皂白应当一律行善。</p><p>因此，认为不行善举即是作恶的人，其实就是道德绑架罢了。</p><h2 id="真正的英雄主义"><a href="#真正的英雄主义" class="headerlink" title="真正的英雄主义"></a>真正的英雄主义</h2><p>罗曼·罗兰说：「世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它」。</p><p>如何能做到这一点？</p><p>自己的善举可能为自己带来危害，这也是生活的真相之一。被伤害过后，你还愿意保持善良吗？被伤害过后，你能控制自己不去伤害别人吗？换言之，被伤害过后，你还热爱这个世界吗？</p><p>广义地看待善良，将善心和善举分开，常怀善心、擅行善举，则哪怕不能成为真的英雄，也常在成为英雄的路上了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Kind" scheme="https://liam.page/tags/Kind/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑪）：C++ 的内存顺序·上</title>
    <link href="https://liam.page/2021/06/06/memory-order-cpp-01/"/>
    <id>https://liam.page/2021/06/06/memory-order-cpp-01/</id>
    <published>2021-06-06T04:16:06.000Z</published>
    <updated>2021-06-06T12:55:12.344Z</updated>
    
    <content type="html"><![CDATA[<p>此篇继<a href="/2021/06/05/memory-model-cpp/">前文</a>讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>术语部分的翻译，有删减和补充。</p><span id="more"></span><p>线程间同步及内存顺序决定表达式的<ins>求值（evaluations）</ins>及其<ins>副作用（side effects）</ins>在不同线程中的顺序。首先有相关术语的定义。</p><h2 id="消费操作（consume-operation）"><a href="#消费操作（consume-operation）" class="headerlink" title="消费操作（consume operation）"></a>消费操作（consume operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_consume</code></a> 或更强的内存顺序的原子读操作是消费操作（consume operation）。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比消费操作更强。</p><h2 id="占有操作（aquire-operation）"><a href="#占有操作（aquire-operation）" class="headerlink" title="占有操作（aquire operation）"></a>占有操作（aquire operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_acquire</code></a> 或更强的内存顺序的原子读操作是占有操作（aquire operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex">互斥量（mutex）</a>上执行 <code>lock()</code> 操作亦属于占有操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比占有操作更强。</p><h2 id="释放操作（release-operation）"><a href="#释放操作（release-operation）" class="headerlink" title="释放操作（release operation）"></a>释放操作（release operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_release</code></a> 或更强的内存顺序的原子读操作是释放操作（release operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex">互斥量（mutex）</a>上执行 <code>unlock()</code> 操作亦属于释放操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比释放操作更强。</p><h2 id="表达式求值（evaluations-of-expressions）"><a href="#表达式求值（evaluations-of-expressions）" class="headerlink" title="表达式求值（evaluations of expressions）"></a>表达式求值（evaluations of expressions）</h2><p>对一个表达式<ins>求值（evaluation）</ins>包含以下两个部分：</p><ul><li><ins>值计算（value computations）</ins>：计算表达式的返回值。其中可能涉及到对象的识别（identity of the object；左值求值）或是读取对象中保存的值（右值求值）。前者例如返回某个对象的引用，后者例如返回一个数值。</li><li><ins>副作用（side effect）</ins>：通过一个易变左值访问（读&#x2F;写）对象；修改对象；调用函数库中的 I&#x2F;O 函数；或调用包含上述操作的其他函数。</li></ul><h2 id="先序（sequenced-before）关系"><a href="#先序（sequenced-before）关系" class="headerlink" title="先序（sequenced-before）关系"></a>先序（sequenced-before）关系</h2><p>先序关系描述同一个线程中两次求值之间的偏序关系。</p><ul><li>若 A <ins>先序于（sequenced-before）</ins> B，则 A 将在 B 开始执行之前完成。</li><li>若 A 不先序于 B，而 B 先序于 A，则 B 将在 A 开始执行之前完成。</li><li>若 A 不先序于 B 而 B 亦不先序于 A，则有两种可能性<ul><li>A 和 B 的求值不存在序列关系：二者可能以任意顺序求值，并且它们的求值动作在时间上可能重叠（在同一线程中，编译器可能打乱组成 A 和 B 的指令的顺序，使他们相互穿插）。</li><li>A 和 B 的求值序列关系不确定：二者可能以任意顺序求值，但它们的求值动作在时间上不可能重叠。此外，程序再次执行时，二者的执行顺序可能和上一次不同。</li></ul></li></ul><h2 id="带去依赖（Carries-dependency）"><a href="#带去依赖（Carries-dependency）" class="headerlink" title="带去依赖（Carries dependency）"></a>带去依赖（Carries dependency）</h2><p>在同一线程中，若 A <ins>先序于</ins> B，则在下列情况下，A 为 B 带去依赖（即，B 依赖于 A）：</p><ul><li>A 的返回值是 B 的操作数，但下列情形除外：<ul><li>B 是对 <a href="https://en.cppreference.com/w/cpp/atomic/kill_dependency"><code>std::kill_dependency</code></a> 的调用；</li><li>A 的返回值是内建 <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code> 或是 <code>,</code> 运算符的左操作数。</li></ul></li><li>执行 A 的过程中写入标量 M，而执行 B 的过程读取标量 M。</li><li>A 为 X 带去依赖，而 X 为 B 带去依赖。（即依赖关系具有传递性）</li></ul><h2 id="修改顺序（Modification-Order）"><a href="#修改顺序（Modification-Order）" class="headerlink" title="修改顺序（Modification Order）"></a>修改顺序（Modification Order）</h2><p>对于某个原子变量来说，其全部写入操作组成一个全局修改顺序。</p><p>所有原子操作都保证符合以下四个要求：</p><ol><li>写写一致性：若对原子变量 M 的写入操作 A <ins>先于（happens-before）</ins>对同一原子变量的写入操作 B。则在 M 的<ins>修改顺序（modification order）</ins>中，A 在 B 之前。</li><li>读读一致性：若 A 和 B 的值计算均读取原子变量 M，且 A <ins>先于</ins> B；又假定 A 读到的原子变量 M 的值来自某个对 M 有写操作的表达式 X；则 B 读到的值，要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li><li>读写一致性：若 A 的值计算读取原子变量 M 而 B 写入 M，且 A <ins>先于</ins> B；则 A 读到的值来自在 M 的<ins>修改顺序（modification order）</ins>中早于 B 的某个写入 X。</li><li>写读一致性：若 X 对原子变量 M 有写入，而 B 的值计算读取原子变量 M；又假定 X <ins>先于</ins> B；则 B 读到的值要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li></ol><h2 id="释放序列（Release-sequence）"><a href="#释放序列（Release-sequence）" class="headerlink" title="释放序列（Release sequence）"></a>释放序列（Release sequence）</h2><p>假定 A 是原子变量 M 上的一个<ins>释放操作（release operation）</ins>。则在 M 的修改顺序中，<strong>位于 A 之后</strong>的由下列操作组成的最长连续子序列被称为以 A 为首的<ins>释放序列（release sequence）</ins>：</p><ol><li>执行 A 的线程中，对 M 的写入操作（until C++20）；</li><li>任意线程对 M 的读-改-写操作（CAS 成功时的操作）。</li></ol><h2 id="依赖顺序上先于（Dependency-ordered-before）"><a href="#依赖顺序上先于（Dependency-ordered-before）" class="headerlink" title="依赖顺序上先于（Dependency-ordered before）"></a>依赖顺序上先于（Dependency-ordered before）</h2><p>满足下列某个情况时，我们称表达式 A 在<ins>依赖顺序上先于（dependency-ordered before）</ins>表达式 B——其中 A 和 B 处于不同线程。</p><ol><li>A 对原子变量 M 执行<ins>释放操作（release operation）</ins>，在另一线程中 B 对同一原子变量 M 执行<ins>消费操作（consume operation）</ins>，且 B 读取的值来自 A（以 A 为首的<ins>释放序列（release sequence）</ins>中的任意部分（until C++20））的写入。</li><li>A 在依赖顺序上先于 X，而 X 为 B 带去依赖。</li></ol><h2 id="线程间先于（Inter-thread-happens-before）"><a href="#线程间先于（Inter-thread-happens-before）" class="headerlink" title="线程间先于（Inter-thread happens-before）"></a>线程间先于（Inter-thread happens-before）</h2><p>若满足下列条件之一，则称对表达式 A 的求值<ins>线程间先于（inter-thread happens-before）</ins>对表达式 B 的求值：</p><ol><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>依赖顺序上先于</ins> B；</li><li>A 与某个表达式 X <ins>同步</ins>，而 X <ins>先序于</ins> B；</li><li>A <ins>先序于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B；</li><li>A <ins>线程间先于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B。</li></ol><h2 id="先于（happens-before）"><a href="#先于（happens-before）" class="headerlink" title="先于（happens-before）"></a>先于（happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>线程间先于（inter-thread happens-before）</ins> B。</li></ol><p>编译器实现应当引入必要的同步措施，以保证表达式求值之间的先于关系链不成环。（仅当引入消费操作（consume operation）时有此必要；参见 <a href="http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf">Betty 等的论文</a>）</p><p>若某个求值操作修改了一个内存位置（见<a href="/2021/06/05/memory-model-cpp/">前文</a>），另一个求值操作读写同一内存位置，且至少其一不是原子操作，除非二者之间存在<ins>先于</ins>关系，程序行为未定义（程序有数据竞争）。</p><h2 id="简单先于（Simply-happens-before；since-C-20）"><a href="#简单先于（Simply-happens-before；since-C-20）" class="headerlink" title="简单先于（Simply happens-before；since C++20）"></a>简单先于（Simply happens-before；since C++20）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>简单先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>简单先于</ins> 某个表达式 X 的求值，而 X <ins>简单先于</ins> B。</li></ol><p>注：没有消费操作（consume operation）时，简单先于等价于先于。</p><h2 id="强先于（Strongly-happens-before）"><a href="#强先于（Strongly-happens-before）" class="headerlink" title="强先于（Strongly happens-before）"></a>强先于（Strongly happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>强先于（strongly happens-before）</ins>对表达式 B 的求值：</p><h3 id="until-C-20"><a href="#until-C-20" class="headerlink" title="until C++20"></a>until C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：C++20 之前的强先于，即是 C++20 及之后的简单先于。</p><h3 id="since-C-20"><a href="#since-C-20" class="headerlink" title="since C++20"></a>since C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>，且 A&#x2F;B 均为顺序一致（sequentially consistent）的原子操作；</li><li>A <ins>先序于（sequenced-before）</ins> X，X <ins>简单先于</ins> Y，Y <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：不正式地讲，若 A <ins>强先于（strongly happens-before）</ins> B，则在任何上下文中，A 都先于 B 求值。</p><p>注：强先于关系排除了消费操作（consume operation）。</p><h2 id="可见副作用（Visible-side-effects）"><a href="#可见副作用（Visible-side-effects）" class="headerlink" title="可见副作用（Visible side-effects）"></a>可见副作用（Visible side-effects）</h2><p>若下列条件均成立，则 A 对于标量 M 的副作用（写操作）于在标量 M 上的求值 B（读操作）可见：</p><ol><li>A <ins>先于</ins> B；</li><li>任意满足 A <ins>先于</ins> X 且 X <ins>先于</ins> B 的表达式 X 对标量 M 没有副作用。</li></ol><p>若 A 的副作用对 B 可见，则在 M 的修改顺序当中 B 之前的最长连续副作用子集称之为 B 可见的副作用序列。（B 见到的 M 的值是上述副作用其中之一写入的）</p><p>注：线程间同步本质是要通过建立<ins>先于（happens-before）</ins>关系来避免数据竞争以及定义在哪些条件下哪些副作用可见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇继&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;前文&lt;/a&gt;讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;对应页面&lt;/a&gt;术语部分的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（十）：C++ 的内存模型</title>
    <link href="https://liam.page/2021/06/05/memory-model-cpp/"/>
    <id>https://liam.page/2021/06/05/memory-model-cpp/</id>
    <published>2021-06-05T02:36:41.000Z</published>
    <updated>2021-12-11T14:18:33.647Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/language/memory_model">对应页面</a>的翻译，有删减和补充。</p><span id="more"></span><p>内存模型为 C++ 抽象机器定义了计算机内存存储语义。</p><p>C++ 程序可用的内存是一个或多个连续的字节序列。每个字节有自己独有的内存地址。</p><h2 id="字节（Byte）"><a href="#字节（Byte）" class="headerlink" title="字节（Byte）"></a>字节（Byte）</h2><p>字节是内存中的最小可寻址单元，由连续的多个比特组成。C++ 中，<code>char</code>&#x2F;<code>unsigned char</code>&#x2F;<code>signed char</code> 的对象存储和<a href="https://en.cppreference.com/w/cpp/language/object">值表示</a>均使用恰好 1 字节。于是，字节中有多少比特，可以通过 <a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><code>std::numeric_limits&lt;unsigned char&gt;::digits</code></a>取得。</p><h2 id="内存位置（Memory-Location）"><a href="#内存位置（Memory-Location）" class="headerlink" title="内存位置（Memory Location）"></a>内存位置（Memory Location）</h2><p>内存位置是</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/type">标量类型</a>（算数类型、指针类型、枚举类型或是 <code>std::nullptr_t</code>）的对象；</li><li>或是，长度不为零的<a href="https://en.cppreference.com/w/cpp/language/bit_field">位域</a>组成的最长连续序列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">// memory location #1</span></span><br><span class="line">    <span class="type">int</span> b : <span class="number">5</span>;  <span class="comment">// memory location #2</span></span><br><span class="line">    <span class="type">int</span> c : <span class="number">11</span>, <span class="comment">// memory location #2 (continued)</span></span><br><span class="line">          : <span class="number">0</span>,  <span class="comment">// zero-length, as a delimiter of continued sequence of bit-fields</span></span><br><span class="line">        d : <span class="number">8</span>;  <span class="comment">// memory location #3</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">int</span> ee : <span class="number">8</span>; <span class="comment">// memory location #4</span></span><br><span class="line">    &#125; e;</span><br><span class="line">&#125; obj; <span class="comment">// The object &#x27;obj&#x27; consists of 4 separate memory locations</span></span><br></pre></td></tr></table></figure><p>注意：语言中的许多特性会引入额外的内存位置。这些内存位置程序无法访问，而是为编译器实现自行管理。这些特性例如：<a href="https://en.cppreference.com/w/cpp/language/reference">引用</a>和<a href="https://en.cppreference.com/w/cpp/language/virtual">虚函数</a>。</p><h2 id="线程与数据竞争（Thread-and-data-races）"><a href="#线程与数据竞争（Thread-and-data-races）" class="headerlink" title="线程与数据竞争（Thread and data races）"></a>线程与数据竞争（Thread and data races）</h2><p>程序中的线程是自 <a href="https://en.cppreference.com/w/cpp/thread/thread/thread"><code>std::thread::thread</code></a>, <a href="https://en.cppreference.com/w/cpp/thread/async"><code>std::async</code></a> 或者其他方式调用顶层函数开始的控制流。</p><p>任一线程都可能访问程序中的任意对象。其中，原子及<a href="https://en.cppreference.com/w/cpp/language/storage_duration">线程内部存储</a>亦可能为其它线程通过指针或引用来访问。</p><p>在没有同步或阻塞的情况下，不同线程可并发访问（读&#x2F;写）不同内存位置。</p><p>若一个表达式求值对某一内存位置进行写操作，而另一求值过程对同一内存位置进行读或写操作，则两个求值过程存在冲突。除非满足下列条件，程序中冲突的求值操作将引发数据竞争：</p><ul><li>存在冲突的求值操作在同一线程中执行，或在同一<a href="https://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler">信号处理函数</a>中执行；或者</li><li>存在冲突的求值操作均是原子操作（参见 <a href="https://en.cppreference.com/w/cpp/atomic/atomic"><code>std::atomic</code></a>）；或者</li><li>存在冲突的求值操作，其一<ins>先于（happens-before）</ins>另一发生（参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order</code></a>）。</li></ul><p>数据竞争将导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using atomic variable</span></span><br></pre></td></tr></table></figure><p>特别地，对于同一个 <a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>，在一个线程中释放它与在另一线程中获取它是<ins>同步的（synchronized-with）</ins>，故而释放动作<ins>先于（happens-before）</ins>获取动作。因此，可用 <code>std::mutex</code> 来避免数据竞争。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; std::lock_guard&lt;std::mutex&gt; <span class="built_in">lk</span>(mtx); cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using mutex to ensure happens-before semantic</span></span><br></pre></td></tr></table></figure><h2 id="内存顺序（Memory-Order）"><a href="#内存顺序（Memory-Order）" class="headerlink" title="内存顺序（Memory Order）"></a>内存顺序（Memory Order）</h2><p>线程自某个内存位置取值时，读到的可能是它的初始值，也可能是当前线程写入的值，亦可能是其他线程写入的值。有关内存顺序的细节可参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order</code></a>；其中讨论了线程的写入操作在其他线程可见性的问题。</p><h2 id="前向执行（Forward-Progress）"><a href="#前向执行（Forward-Progress）" class="headerlink" title="前向执行（Forward Progress）"></a>前向执行（Forward Progress）</h2><h3 id="无阻塞（Obstruction-freedom）"><a href="#无阻塞（Obstruction-freedom）" class="headerlink" title="无阻塞（Obstruction freedom）"></a>无阻塞（Obstruction freedom）</h3><p>仅有一个未被标准库函数阻塞的线程在执行无锁<a href="https://en.cppreference.com/w/cpp/atomic">原子函数（atomic function）</a>时，该原子函数必能执行完毕（标准库内所有无锁操作均<a href="obstruction-free">无阻塞</a>）。</p><h3 id="无锁（Lock-freedom）"><a href="#无锁（Lock-freedom）" class="headerlink" title="无锁（Lock freedom）"></a>无锁（Lock freedom）</h3><p>一个或更多无锁原子函数并发执行时，至少其中之一必能执行完毕（标准库内所有无所操作均<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom">无锁</a>——编译器实现会保证它们不会被一直锁住，例如持续地被窃走缓存行（cache-line stealing；一种因为执行其他线程的 CPU 核心对内存数据做预取而导致当前 CPU 核心缓存行变脏的现象））。</p><blockquote><p>关于 cache-line stealing，参见：<a href="https://www.researchgate.net/publication/221497089_Tackling_Cache-Line_Stealing_Effects_Using_Run-Time_Adaptation">这篇论文</a>。</p></blockquote><h3 id="执行之担保（Progress-guarantee）"><a href="#执行之担保（Progress-guarantee）" class="headerlink" title="执行之担保（Progress guarantee）"></a>执行之担保（Progress guarantee）</h3><p>在正确的 C++ 程序当中，所有线程终将执行到下列情形之一：</p><ul><li>终止；</li><li>调用 I&#x2F;O 库的函数；</li><li>经由<a href="https://en.cppreference.com/w/cpp/language/cv">易变（volatile）</a>的左值（lvalue）或者将亡值（xvalue）——拥有内存地址的长寿对象——访问外部设备；</li><li>执行原子操作或是同步操作。</li></ul><p>若一个线程执行上述任一操作（I&#x2F;O, volatile, 原子操作或是同步操作），或是阻塞在标准库函数当中，亦或是因其他为阻塞线程正在并发执行导致调用一个无锁原子操作却尚未完成，则称该线程<ins>有进展（make progress）</ins>。</p><h3 id="并发前向执行（Concurrent-forward-progress-since-C-17）"><a href="#并发前向执行（Concurrent-forward-progress-since-C-17）" class="headerlink" title="并发前向执行（Concurrent forward progress; since C++17）"></a>并发前向执行（Concurrent forward progress; since C++17）</h3><p>若某线程有<ins>并发前向执行之担保（concurrent forward progress guarantee）</ins>，则在它终止之前，无论其他线程（若有）是否有进展，它都将于有限时间内取得如上定义之<ins>进展（make progress）</ins>。</p><p>C++ 标准鼓励（但并不强求）主线程和其他由 <code>std::thread</code> 启动的线程提供<ins>并发前向执行之担保</ins>。</p><h3 id="并行前向执行（Parallel-forward-progress-since-C-17）"><a href="#并行前向执行（Parallel-forward-progress-since-C-17）" class="headerlink" title="并行前向执行（Parallel forward progress; since C++17）"></a>并行前向执行（Parallel forward progress; since C++17）</h3><p>若某线程有<ins>并行前向执行之担保（parallel forward progress guarantee）</ins>，则</p><ul><li>在它尚未执行任何步骤（I&#x2F;O, volatile, 原子操作或是同步操作）时，编译器实现不保证它在有限时间内有<ins>进展</ins>；</li><li>而一旦它执行了某一步骤，它提供<ins>并发前向执行之担保</ins>。</li></ul><p>此规则表明，线程池中的线程可以按照任意顺序执行任务。</p><h3 id="弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）"><a href="#弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）" class="headerlink" title="弱并行前向执行（Weakly parallel forward progress; since C++17）"></a>弱并行前向执行（Weakly parallel forward progress; since C++17）</h3><p>若某线程有<ins>弱并行前向执行之担保（weakly parallel forward progress guarantee）</ins>，则无论其他线程是否有<ins>进展</ins>，它都不保证它在有限时间内有<ins>进展</ins>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/memory_model&quot;&gt;对应页面&lt;/a&gt;的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>xTR 预估任务中的特征工程</title>
    <link href="https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/"/>
    <id>https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/</id>
    <published>2021-05-23T13:59:12.000Z</published>
    <updated>2021-07-31T07:45:45.071Z</updated>
    
    <content type="html"><![CDATA[<p>xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&gt; W&amp;D 系列 -&gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。</p><p>此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。</p><span id="more"></span><h2 id="时间类特征"><a href="#时间类特征" class="headerlink" title="时间类特征"></a>时间类特征</h2><blockquote><p>作者：大博<br>链接：<a href="https://www.zhihu.com/question/350863682/answer/860524396">https://www.zhihu.com/question/350863682/answer/860524396</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>考虑问题中的「时间」。从三个角度：用户的时间，商品的时间，用户与商品间的时间。每个角度可以包括的时间类型：时间绝对值，时间间隔值。每个时间类型可以有不同的计算方法：统计型，独立型。（备注：一下就计算来的值算独立型，通过一堆独立值统计来的，用「平均&#x2F;最大」等描述的特征算统计型。）</p><ul><li>用户的时间：(刻画用户本身的习惯)<ul><li>时间绝对值<ul><li>统计型：一个月内最高频的浏览时间</li><li>独立型：用户当前浏览时间&#x2F;用户上一次浏览时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户曾经两次浏览的时间间隔的「平均」</li><li>独立型：用户本次浏览与上次浏览的时间间隔</li></ul></li></ul></li><li>商品的时间：(刻画商品本身的属性)<ul><li>时间绝对值<ul><li>统计型：商品最常被购买的时间</li><li>独立型：商品上架时间&#x2F;预计下架时间（上下架指一个动作）</li></ul></li><li>时间间隔值<ul><li>统计型：三天除以三天内商品被购买次数</li><li>独立型：商品的在线时间&#x2F;当前时间与商品常被购买时间的间隔</li></ul></li></ul></li><li>用户与商品间的时间：(刻画该用户到该商品的匹配程度)<ul><li>时间绝对值<ul><li>统计型：用户历史购买该商品的平均时间分布</li><li>独立型：用户上次购买该商品的时间&#x2F;用户上次购买该商品所属品类的时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户历史购买该品类商品的平均时间间隔</li><li>独立型：用户上次购买该商品到当前时间的时间间隔</li></ul></li></ul></li></ul><p>最后总结下思路：</p><ol><li>一般强特征都是用户到商品的交叉特征，「商品」要从商品id扩展到「品类」&#x2F;「商户」&#x2F;「标签」等等能交叉的角度。</li><li>时间间隔一般是强特。</li><li>历史统计型特征可以用条件概率去理解，虽不是强特，但多了是有用的。</li><li>哪怕是从「时间」考虑特征，特征所反应的含义应该是：这个人平时愿不愿意买东西，这件商品平时的受众是怎样的，这个人对这个商品的敏感程度是怎样的。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&amp;gt; W&amp;amp;D 系列 -&amp;gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。&lt;/p&gt;
&lt;p&gt;此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="xTR" scheme="https://liam.page/tags/xTR/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之十：名词性从句</title>
    <link href="https://liam.page/2021/05/09/noun-subordinate-clauses/"/>
    <id>https://liam.page/2021/05/09/noun-subordinate-clauses/</id>
    <published>2021-05-09T09:28:51.000Z</published>
    <updated>2021-05-09T14:59:56.649Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第十篇。<a href="/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/">前作</a>介绍了复合句的概念，并介绍了分析和练习复合句的方法。</p><p>考虑到合句本身简单，所以在本系列中略去不讲，将来另开一系列讨论。本系列从此篇开始，介绍各种类型的复句。此篇介绍名词性从句。</p><span id="more"></span><h2 id="复句的种类"><a href="#复句的种类" class="headerlink" title="复句的种类"></a>复句的种类</h2><p>在英文当中，除动词外，几种主要词类在剧中充当成分时，都能为相应的从句代替，从而与主句一起组成复句。由此，我们可知英文当中有以下复句类型：</p><ul><li>名词性从句<ul><li>主语从句</li><li>宾语从句</li><li>补语从句（表语从句）</li><li>同位语从句</li></ul></li><li>形容词性从句<ul><li>各类状语从句</li></ul></li><li>副词性从句<ul><li>各类关系从句</li></ul></li></ul><p>此篇我们介绍名词性从句。</p><h2 id="名词性从句的主要特点"><a href="#名词性从句的主要特点" class="headerlink" title="名词性从句的主要特点"></a>名词性从句的主要特点</h2><p>名词性从句有以下一些特点：</p><ol><li>在句中充当名词的角色。这也是名词性从句的由来。</li><li>本身是一个完整的独立子句。也就是说，名词性从句自身可归于五种基本句型里去，并且有相应的组成成分。</li><li>名词性从句通常以一个有时可以省略的 <code>that</code> 开头；它不表意，只有语法功能，表示引导了一个名词性从句。当名词性从句的引导词需要参与表意时，往往需要相应的 <code>wh-</code> 疑问词或是 <code>whether</code>&#x2F;<code>if</code> 来引导。</li></ol><h2 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h2><p>当名词性从句出现在主语位置时，它就是主语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong><em>That he finished writing the composition in such a short time</em> surprised us all.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>he finished writing the composition in such a short time. | 他于短时间内写完作文。</li><li>something surprised us all. | 某事震惊了我们所有人。</li></ol><p>以 <code>that</code> 加在第一个独立子句之前，形成主语从句，替代第二个独立子句的 <code>something</code> 即得到原句。原句翻译为：他于短时间内写完作文震惊了我们所有人。</p><p>此句重点在于表达「我们所有人都惊了」，至于为何事震惊实际处于次要地位。因此，于修辞计，考虑到从句很长，我们倾向于让主句的内容先出来。为此，我们用附加虚词 <code>it</code> 来代替主语从句的内容，作为「形式主语」。原句变为：「It surprised us all <em>that he finished writing the composition in such a short time</em>.」</p><p><strong><em>Who you are</em> doesn&#39;t matter at all.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>who you are. | 你是谁？</li><li>the question doesn&#39;t matter at all. | 这问题根本不重要。</li></ol><p><code>wh-</code> 疑问词 <code>who</code> 一方面具有表意功能，另一方面可以直接引导句子。因而，第一个独立子句可以直接替换主句中的 <code>the question</code>，充作主语从句而得到原句。原句的翻译为：你是谁（这个问题）根本不重要。</p><p>当名词性从句替换的名词是一个问题（the question&#x2F;a question）时，我们往往需要 <code>wh-</code> 疑问词参与表意。</p><p><strong><em>Whether he is telling the truth or not</em> is anyone&#39;s guess.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>which he is telling either the truth or not. | 他在讲真话还是假话？</li><li>the question is anyone&#39;s guess. | 这问题谁也不知道答案。</li></ol><p><code>wh-</code> 疑问词 <code>which</code> 一方面具有表意功能，另一方面可以直接引导句子。再注意到，<code>whether</code> 实际是 <code>which</code> 和 <code>either</code> 的合成。因而，第一个独立子句可以直接替换主句中的 <code>the question</code>，充作主语从句而得到原句。原句的翻译为：他在讲真话还是假话（这个问题）谁也不知道答案。</p><p>既知 <code>whether</code> 是 <code>which</code> 和 <code>either</code> 的合成，那么，在表达「是否」的含义并引导名词性从句时我们就可以用它了。在成词日久之后，由于 <code>if</code> 也能表示「是否」的含义，所以在一些情况下以 <code>whether</code> 引导名词性从句时也可以由 <code>if</code> 来引导。但并非所有情形都适合做这样的替换。以下距离不能替换的场景：</p><ul><li><code>whether</code> 引导名词性从句位于句首时。此时 <code>if</code> 容易被误认为是在引导一个条件状语从句，产生歧义，故不可。</li><li><code>whether</code> 引导名词性从句位于介词之后，充当介词宾语时（此时必然是宾语从句）。此时，介词与 <code>which</code> 组成固定短语，不适合替换成 <code>if</code>，而只能由合成词 <code>whether</code> 来担此任务。</li></ul><h2 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h2><p>当名词性从句出现在宾语位置时，它就是宾语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong>Liam swears <em>that he will love Sophia forever.</em></strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>Liam swears something. | Liam 发誓说了什么。</li><li>he will love Sophia forever. | 他会永远爱 Sophia。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成宾语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「Liam 发誓说他会永远爱 Sophia」。</p><p>这里，因为 <code>swears</code> 是一个及宾动词。陈述句中，位于及宾动词之后的，肯定是宾语。所以，此处即使去掉 <code>that</code>，读者也能看出这是一个宾语从句，不至于引起歧义：「Liam swears *he will love Sophia forever.*」于是，在及宾动词之后，于修辞计，引导宾语从句的 <code>that</code> 可以省略。</p><p>举一个反例，若我们在 <code>swears</code> 之后加上方式状语 <code>on the Bible</code>，变成：「Liam swears on the Bible *that he will love Sophia forever.*」，引导词 <code>that</code> 就不适合省略了。若不然，句子变成「Liam swears on the Bible *he will love Sophia forever.*」很容易让人困惑。</p><p><strong>We all found <em>that he finished writing the composition in such a short time</em> surprising.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>We all found something surprising. | 我们都发现了某事令人惊奇。</li><li>he finished writing the composition in such a short time. | 他于短时间内写完作文。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成宾语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「我们都发现他于短时间内写完作文这件事令人惊奇」。</p><p>和主语从句的情形类似。此句重点在于表达「我们所有人都惊了」，至于为何事震惊实际处于次要地位。因此，于修辞计，考虑到从句很长，我们倾向于让主句的主要成分之一的补语（surprising）先出来。为此，我们用附加虚词 <code>it</code> 来代替宾语从句的内容，作为「形式宾语」。原句变为：「We all found it surprising <em>that he finished writing the composition in such a short time</em>.」</p><p>与主语从句的情况类似，宾语从句也可以由 <code>wh-</code> 疑问词引导。读者可自己试着造句，此处不做展开。</p><p>在某些情况下，宾语从句的内容比主句本身要重要。这时候，宾语从句会被提前。（山东人民应该会感到舒服，笑~）我们来看一个例子。</p><p><strong>This is what you&#39;ve done, I suppose.</strong></p><p>这里，正常语序实际应该是：I suppose that this is what you&#39;ve done. 不过，因为宾语从句的内容比「我猜」更重要，所以它被提到前面，同时去掉引导词 <code>that</code> 并和主句之间用逗号分隔开。</p><h2 id="补语从句"><a href="#补语从句" class="headerlink" title="补语从句"></a>补语从句</h2><p>当名词性从句出现在补语位置时，它就是补语从句。充作主语的补语时，传统语法也称之为表语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong>The point is <em>that nobody died in the accident</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The point is something. | 要点在于某事。</li><li>nobody died in the accident. | 事故中无人死亡。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成补语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「要点在于事故中无人死亡」。</p><p>与宾语从句的情况类似，位于联系动词之后的，肯定是补语。所以，此处即使去掉 <code>that</code>，读者也能看出这是一个补语从句，不至于引起歧义：「The point is <em>nobody died in the accident</em>.」因此，充作主语补语的补语从句，其引导词 <code>that</code> 在非正式场合下也可以省略。</p><p><strong>My education and my experience made me <em>that&#x2F;who I am today</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>My education and my experience made me something. | 我所接受的教育和过去的经历塑造我成为某事。</li><li>I am today. | 我如今的样子。</li></ol><p>以 <code>that</code>&#x2F;<code>who</code> 加在第二个独立子句之前，形成（宾语）补语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「我所接受的教育和过去的经历塑造我成为我如今的样子」。注意这里的 <code>am</code> 单独出现，表示「存在」。「我如今的存在」即是「我如今的样子」。</p><p>继续 <code>that</code> 省略的讨论。此处，由于补语从句充作宾语的补语，故而前面没有明确的联系动词作为提示。故而，此处不宜将引导词 <code>that</code> 省略。</p><p>此处还要额外注意一点。实际上，充当补语的既可以是名词也可以是形容词。因此，简单地说补语从句是一种名词性从句，其实并不能另所有人信服。基于同样的原因，将它归类为形容词性从句，也会有同样的问题。若是把补语从句同时归纳于名词性从句和形容词性从句里面，又生造了一个特例，无甚必要。处理这一问题，我们还是要从表意的角度出发，不要过度纠结，以简御繁为上。</p><h2 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h2><p>名词性从句当中，比较容易产生误会的就是同位语从句了。为此，我们先来确定一下什么是同位语。所谓同位语，就是用不同的方式，把一个概念再说一遍，并且用逗号隔开。它通常是对抽象概念的解释说明——毕竟，确切的概念也就不必反复说明了嘛。</p><p>举几个🌰：</p><ul><li>My wife, <em>Sophia</em>, is compatible with me very well. | 我爱人，Sophia，与我很合得来。</li><li>The fact, <em>rabbit eats carrot</em>, is not suprising. | 兔子爱吃胡萝卜这一事实不会令人意外。</li></ul><p>两个例子中，<em>Sophia</em> 和 <em>rabbit eats carrot</em> 都是各自主语的同位语，他们和各自的主语是同一个概念。对于同位语，我们往往可以用联系动词将同位语和它解释的对象连起来。比如：</p><ul><li>My wife is Sophia.</li><li>The fact is that rabbit eats carrot.</li></ul><p>同位语可以解释主语，也可以解释宾语。比如：</p><ul><li>I love my wife, <em>Sophia</em>. | 我爱我的妻子 Sophia。</li></ul><p>同样，宾语 my wife 及其同位语，也可以用联系动词连起来。比如：</p><ul><li>My wife is Sophia.</li></ul><p>以上例子应该足够讲清楚同位语是什么。同时我们也不难发现，<strong>同位语和补语之间有不少相似之处</strong>。在后续的文章里，我们会再次看到这一点。</p><hr><p>现在我们来看同位语从句。同样地，此处举几个例子，并随附说明一些注意要点。</p><p><strong>The fact <em>that rabbit eats carrot</em> is not suprising.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The fact is not suprising. | 这一事实不会令人意外。</li><li>rabbit eats carrot. | 兔子吃胡萝卜。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中的主语 <em>the fact</em> 本身。于是我们在第二个独立子句之前加上引导词  <code>that</code> ，形成同位语从句，作为第一个独立子句的 the fact 的同位语即得到原句。原句翻译为：「兔子爱吃胡萝卜这一事实不会令人意外」。</p><p>类似地，我们可以改造出一个对宾语做同位语从句的例子。</p><p><strong>One will not be suprised by the fact <em>that rabbit eats carrot</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>One will not be suprised by the fact. | 人们不会对这一事实感到惊讶。</li><li>rabbit eats carrot. | 兔子吃胡萝卜。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中的宾语 <em>the fact</em> 本身。于是我们在第二个独立子句之前加上引导词  <code>that</code> ，形成同位语从句，作为第一个独立子句的 the fact 的同位语即得到原句。原句翻译为：「人们不会对兔子吃胡萝卜这一事实感到惊讶」。</p><p>和其他名词从句类似，当被同位语解释的对象是一个问题时，<code>wh-</code> 疑问词就会登场。</p><p><strong>The question <em>who the killer is</em> is on the police officer&#39;s mind.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The question is on the police officer&#39;s mind. | 这个问题萦绕在警官心头。</li><li>who the killer is. | 杀手是谁。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中主语 <em>the question</em> 本身。考虑到第二个子句是个问句，已经有 <code>wh-</code> 疑问词 <em>who</em>，此处无需 <code>that</code> 做引导即可作为同位语从句。原句翻译为：「杀手是谁这一问题萦绕在警官心头」。</p><blockquote><p> 有这三个例子打底，我们来分析一下同位语从句和定语从句的区别。在这里，同位语从句和限定修饰先行名词的定语从句十分相似。他们同样放在名词后面，同样可以由 <code>that</code> 或者 <code>wh-</code> 疑问词引导。从形式上来看，他们很相似。同位语从句和限定修饰先行名词的定语从句之间的区别，主要体现在两个方面：</p><ul><li>从表意上说：<ul><li>同位语从句的内容，就是被其解释的抽象名词本身。因此，被解释的名词和同位语从句之间，可以用联系动词连起来，形成 SVC 的结构。这也体现了同位语和补语之间紧密的联系——实际上在某些语法体系里面，甚至没有同位语的概念，而是将之作为补语的一种来处理。</li><li>限定修饰先行名词的定语从句的内容，对先行名词起到限定修饰的作用。先行名词和定语从句之间，无法用联系动词直接连接在一起。</li></ul></li><li>从形式上说：<ul><li>同位语的 <code>that</code> 只有语法功能，没有表意能力；从句去掉 <code>that</code> 是一个完整句子。</li><li>定语从句的 <code>that</code> 不仅有语法功能，还在从句中充当先行词本身；从句去掉 <code>that</code> 变得不完整。</li></ul></li></ul><p> 借助上述三个例子，我们择其一来观察同位语从句和定语从句之间的区别。</p><ul><li>The fact <em>that rabbit eats carrot</em> is not suprising. | 兔子爱吃胡萝卜这一事实不会令人意外。</li><li>The fact <em>that is figured out by Liam</em> is not suprising. | 为 Liam 所指出的事实不会令人意外。</li></ul><p> 第二个例子当中 <code>that</code> 引导的是定语从句，限定修饰先行词 the fact。显然，我们没法讲：「The fact is that is figured out by Liam」。一是因为表意上不通；二是因为 <code>that</code> 后的句子看起来是个补语从句，但是缺少主语。</p><p> 如此，读者应该能比较明确地分辨同位语从句和定语从句。</p></blockquote><p>上述三个例子都是比较典型的同位语从句。下面举三个不那么典型的同位语从句。</p><ul><li>I&#39;m afraid <em>that I cannot help you</em>. | 我恐怕没法帮你。</li><li>You should take care <em>that the baby is sleeping well</em>. | 你应当小心让宝贝睡好。</li><li>I&#39;m not sure <em>whether the police officer will find the killer or not</em>. | 我不确定警官是否能找出杀手。</li></ul><p>在这三个例子当中，去掉斜体标识的同位语从句，在主句中我们找不到可供同位语从句解释说明的名词。实际上，这类 case 的主句有被简化。如果把主句改成下面这样，就不难理解了：</p><ul><li>I&#39;m afraid <strong>of the thing</strong>.</li><li>You should take care <strong>of the thing</strong>.</li><li>I&#39;m not sure <strong>about the thing</strong>.</li></ul><p>原来，同位语从句是在解释说明被省略掉的 the thing。只不过，在长期的语言实践当中，由于 the thing 本身太虚，没有含义，处于修辞的考虑，就被省略掉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第十篇。&lt;a href=&quot;/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/&quot;&gt;前作&lt;/a&gt;介绍了复合句的概念，并介绍了分析和练习复合句的方法。&lt;/p&gt;
&lt;p&gt;考虑到合句本身简单，所以在本系列中略去不讲，将来另开一系列讨论。本系列从此篇开始，介绍各种类型的复句。此篇介绍名词性从句。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
      <category term="Subordinate Clause" scheme="https://liam.page/tags/Subordinate-Clause/"/>
    
      <category term="Subjective Clause" scheme="https://liam.page/tags/Subjective-Clause/"/>
    
      <category term="Predicative Clause" scheme="https://liam.page/tags/Predicative-Clause/"/>
    
      <category term="Objective Clause" scheme="https://liam.page/tags/Objective-Clause/"/>
    
      <category term="Appositive Clause" scheme="https://liam.page/tags/Appositive-Clause/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之⑨：忘记长难句，欢迎来到复合句的世界</title>
    <link href="https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/"/>
    <id>https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/</id>
    <published>2021-05-07T14:46:19.000Z</published>
    <updated>2021-05-09T09:34:40.274Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第⑨篇。<a href="/2021/05/06/model-verbs-and-moods-in-English/">前作</a>处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。</p><p>从此篇开始，我们要进入复合句的世界。</p><span id="more"></span><h2 id="忘记长难句"><a href="#忘记长难句" class="headerlink" title="忘记长难句"></a>忘记长难句</h2><p>前北京新东方 GMAT 名师杨鹏著有《GRE&amp;GMAT 阅读难句教程》一书。因书中对 GRE 和 GMAT 考试阅读题中常常出现的长句难句做了一些解读，故而被坊间惯称为「杨鹏长难句」。然而，以数学系学生的视角，我对这本书是不甚满意的。这种不满在于它没有很好地解决一个基本问题：到底多长算长句，又到底多难算难句？对于难句，是你觉得难算难，还是我觉得难算难？因为缺少一个客观稳定的标准，在我的视角，它很难提出一个完备的方案去处理所有的情况。</p><p>因此，虽然《长难句》一书仍可一看，但忘记「长难句」这一概念却是必要的。</p><h2 id="破而立……什么？"><a href="#破而立……什么？" class="headerlink" title="破而立……什么？"></a>破而立……什么？</h2><p>或曰：「你不能光顾着破坏，还要负责建设」。</p><p>忘记长难句，我们要以怎样的视角去切入英文中那些看起来很长又很难的句子呢？答案是，以简单句和复合句的视角。</p><p>我们在系列第一篇介绍了五种基本句型，在系列第五篇（非谓语动词篇）里又提到了独立子句（independent clause）的概念。据此，我们可以给出一个明确的结论：有且只有一套主谓结构的句子，是独立子句。独立子句必属于五种基本句型之一。独立子句单独成句时，就是简单句。</p><p>在简单句的定义基础上，我们又能「非此即彼」地定义出复合句：不是简单句的句子，就是复合句。复合句由若干个独立子句组合而成。独立子句组成复合句又有两种方式。一是由 and&#x2F;or&#x2F;but 等连接词连接的两个并列子句组成的合句（compound sentence）；二是由各种从句与主句连接而成的复句（complex sentence）。</p><p>你看，按照这样的定义，绝不会有一个句子被遗漏。于是我们有信心能处理所有的情况。</p><h2 id="怎样分析和练习复合句？"><a href="#怎样分析和练习复合句？" class="headerlink" title="怎样分析和练习复合句？"></a>怎样分析和练习复合句？</h2><p>系列的后续文章，会处理各种类型的复合句。这里提前讲一讲，在理解各种类型复合句的基础上，如何分析和练习。在这里，分析是为了解决阅读方面的问题，让你在阅读遇到复合句时不至于抓瞎；练习是为了解决写作方面的问题，让你在写作时能自如地应用复合句。</p><p>这里总结整理了一个四步分析法：</p><ol><li>标记出复合句当中的各个独立子句。</li><li>对于每个独立子句，识别其应用的基本句型，而后标出其中的主要成分。</li><li>对于每个独立子句，翻译之。</li><li>将独立子句的翻译组合起来，得到整个复合句的翻译。——注意，一定要写下来翻译成通顺的人话（可以打字）。</li></ol><p>反复应用这一分析法，按我这等笨人的经验，每天坚持分析五个句子并坚持一个月能在阅读 GRE&#x2F;GMAT&#x2F;LSAT 级别的文章上有一个质的飞跃。（当然 GRE 级别的文章不只是复合句一个问题需要解决就是了。）相信读者老爷们这么聪明，应当相比当年的我，能更快获得提升。</p><p>分析完成之后，就要练习。练习的方法也很简单：模仿造句——牙牙学语嘛！对每个你初时感到困难的复合句进行三到五次模仿造句——模仿它的句子结构，也模仿子句之间的逻辑关系。</p><p>按照这样分析和练习的方法，每天花费大概半个小时的时间，你将能一劳永逸地征服英语复合句。它不香吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第⑨篇。&lt;a href=&quot;/2021/05/06/model-verbs-and-moods-in-English/&quot;&gt;前作&lt;/a&gt;处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们要进入复合句的世界。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
      <category term="Single Sentence" scheme="https://liam.page/tags/Single-Sentence/"/>
    
      <category term="Compound Sentence" scheme="https://liam.page/tags/Compound-Sentence/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之八：情态动词与虚拟语气</title>
    <link href="https://liam.page/2021/05/06/model-verbs-and-moods-in-English/"/>
    <id>https://liam.page/2021/05/06/model-verbs-and-moods-in-English/</id>
    <published>2021-05-06T13:36:57.000Z</published>
    <updated>2021-06-05T02:16:29.759Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第八篇。<a href="/2021/04/29/adverbs/">前作</a>处理了副词，此篇我们引出语气的问题，然后处理情态动词。</p><span id="more"></span><h2 id="语气是什么"><a href="#语气是什么" class="headerlink" title="语气是什么"></a>语气是什么</h2><p>我们从<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>开始（在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇中又一次强调），就从表意的角度解读：一个完整句子表达的无非是「一个人&#x2F;一个东西怎么样（了）」。但这其实是一个「善意的谎言」；若说它不是谎言，也至少是不完整的。它欠缺的部分，就是「语气」。</p><p>语气的英文是 mood。在 AHD 中可见它有几层与文法中的语气相关意思：</p><ul><li>心情、情绪：A state of mind or emotion.</li><li>印象、感受：A pervading impression of an observer.</li><li>倾向、意愿：Inclination; disposition.</li></ul><p>无论何种解释，mood 都是「唯心」的，天然带有一层模糊的、不确定的感觉；这与「一个人&#x2F;一个东西怎么样（了）」这种确定性的表述有明显差别。于是我们有：</p><ul><li><strong>语气其实就是句子表意过程中的不确定性</strong>；</li><li>确定的表意总是相似的；</li><li>不确定的表意则各有各的不确定（在不确定的程度和不确定的方式上）。</li></ul><p>在英文中，普通动词本身只能表达确定性的语义。例如：I like math. 若是要表达不确定性的语义，则必须有其他动词的帮助才行。帮助其他动词进行表意的动词，通称「助动词」。表达各种类别和各种程度的不确定性的助动词，是情态动词（modal verbs）。</p><blockquote><p>情态动词这个翻译，我认为不好。但因已成惯例，所以不去改它。更好的翻译应该是「语气动词」。modal 这个词，在 AHD 当中关于文法的解释只有一条「Of, relating to, or expressing the mood of a verb.」，即：语气的：属于，有关或表达一个动词的语气的。可见「语气动词」翻译之贴切。</p></blockquote><p>接下来的问题是，英文当中都有哪些语气呢？这是个令人头秃的问题，因为不同的语法专家对此的认知并不相同。有人认为英文当中语气分三种：陈述语气、祈使语气、虚拟语气。有人认为英文当中语气分四类，在上述三类基础上增加「疑问语气」。有人认为应当分五类，在上述四类基础上增加「感叹语气」。</p><p>于我看来，不论如何分类，祈使语气、疑问语气和感叹语气是不会有太多争议的。表达这三种语气时，在句法上会有很规律的变化，以至于有「祈使句」、「疑问句」和「感叹句」之说。因而人们想要弄混它们都不太容易。我们的宗旨是从表意和修辞出发。既然它们不容易弄混，我们就干脆地将他们放下，不尊「务虚论理者多，经世致用者少」那等做派。这样一来，剩下的问题就在陈述语气和虚拟语气当中了。</p><h2 id="以简御繁：关于不确定性的讨论"><a href="#以简御繁：关于不确定性的讨论" class="headerlink" title="以简御繁：关于不确定性的讨论"></a>以简御繁：关于不确定性的讨论</h2><p>以简御繁的手段是去摸索句子表意当中的不确定性。</p><h3 id="陈述语气（indicative）"><a href="#陈述语气（indicative）" class="headerlink" title="陈述语气（indicative）"></a>陈述语气（indicative）</h3><p>如果一个句子的表意十分确定，那显然就是陈述语气了。例如有：</p><ul><li>It rains. | 天在下雨。</li><li>You are right. | 你是对的。</li><li>I like mathematics. | 我喜欢数学。</li><li>Sophia gives me her pencil. | Sophia 将她的铅笔给我。</li><li>Liam finds the house big. | Liam 发现房子很大。</li></ul><h3 id="条件语气（conditional）"><a href="#条件语气（conditional）" class="headerlink" title="条件语气（conditional）"></a>条件语气（conditional）</h3><p>若在陈述语气的基础上，加上心情、情绪（例如 must）或是印象、感受（例如 can&#x2F;could, may&#x2F;might）亦或是倾向、意愿（例如 will&#x2F;would, shall&#x2F;should；注意此处并不表示将来时态，而是表示倾向意愿），句子中就有了不确定性了。在上述例子的基础上，我们处理一下：</p><ul><li>It <em>may&#x2F;might</em> rain. | 天可能在下雨。</li><li>You <em>must</em> be right. | 你一定是对的。</li><li>I <em>shall</em> like mathematics. | 我应当喜欢数学。</li><li>Sophia <em>can&#x2F;could</em> give me her pencil. | Sophia 可以将她的铅笔给我。</li><li>Liam <em>shall&#x2F;should</em> have found the house big. | Liam 应当已经发现房子很大了。</li></ul><p>此处有两点需要注意。一是我们在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇里讲过的，情态动词后面，实际上是无修饰的不定式，因而要用动词原型。二是尽管部分情态动词有其过去式的形态，但对「不确定性」表达过去本身无意义，因此需要借用完成式来表达对过去的猜测（或曰，表达过去时态下的不确定性）。</p><p>在陈述语气的句子上，直接加上情态动词（可能还需要对动词做一些变形）可以表达不同类型和程度的不确定性。但这些不确定性，都没有否定陈述句意本身，只是在语气上的弱化。为便于归纳，我们把这类语法现象称之为条件语气。</p><h3 id="虚拟语气（subjunctive）"><a href="#虚拟语气（subjunctive）" class="headerlink" title="虚拟语气（subjunctive）"></a>虚拟语气（subjunctive）</h3><p>还有一种情况，我们的表意需要否定陈述句意本身。这种表意发生在假定一个不存在的事实的基础上，作出的推定。这里有四点需要注意的地方：</p><ul><li>因为假定非事实，所以称为虚拟语气；</li><li>因为假定非事实，所以从句中假定本身需要比正常时态退一格（现在 -&gt; 过去；过去 -&gt; 过去完成；将来 -&gt; 过去将来）；</li><li>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式表达强烈的不确定性；</li><li>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式。</li></ul><p>对虚拟语气，举几个例子。</p><p><strong>If I <em>were</em> you, I <em>would</em> fend off that shot. | 要我是你的话，我会把那一球扑出去。</strong></p><p>表达「我是你」，应该用 I am you 才对。但我不是你，这非是事实，所以要退一格，用过去式来表意。那么为什么是 <code>were</code> 而非是 <code>was</code> 呢？因为 <code>be</code> 这个动词是这样的：</p><ul><li>原型：be</li><li>第一人称单数现在陈述语气：am</li><li>第三人称单数现在陈述语气：is</li><li>其余人称和单复数的现在陈述语气：are</li><li>现在分词：being</li><li>过去分词：been</li><li>第一和第三人称单数过去陈述语气：was</li><li>第二人称单数和复数，第一人称复数，第三人称复数，过去陈述语气：were</li><li>过去虚拟语气：were</li></ul><p>亦即，在虚拟语气中，be-动词的过去式就是 were，不区分单复数，也不区分人称。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>would</code> 表达强烈的不确定性。</p><p><strong>If I <em>had known</em> that earlier, I <em>might have revised</em> for the examination harder. | 要早知道的话，我会为考试更努力复习。</strong></p><p>表达「我知道」，应该用 I knew that earlier 才对。但实际我并不知道，这非是事实，所以要退一格，用过去完成式来表意，变成 <code>had known</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>might</code> 表达强烈的不确定性。</p><p>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式，有 <code>might have revised</code>。</p><p><strong>If I <em>should take</em> the bribe, <em>could</em> you <em>keep</em> the secret for me? | 要我收下了那笔贿赂，你能替我保守秘密吗？</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>should take</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><p><strong>If I <em>were to take</em> the bribe, my fingers <em>could be</em> illicit from then on. | 要我收下了那笔贿赂，我的手就再也不干净了。</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>were to take</code>。这和上例的 <code>should take</code> 又有所不同。虽然都非是事实，用 should take 表示还有一些 take 的可能性，而用 were to take 则十分决绝，毫无可能。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>借助「不确定性」的表意，我们轻而易举地处理了虚拟语气，可见其以简御繁的为例。</p><p>虚拟语气中还有一个倒装的问题，属修辞范畴。我们在后续的文章中再来讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第八篇。&lt;a href=&quot;/2021/04/29/adverbs/&quot;&gt;前作&lt;/a&gt;处理了副词，此篇我们引出语气的问题，然后处理情态动词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Model Verbs" scheme="https://liam.page/tags/Model-Verbs/"/>
    
      <category term="Moods" scheme="https://liam.page/tags/Moods/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之七：副词</title>
    <link href="https://liam.page/2021/04/29/adverbs/"/>
    <id>https://liam.page/2021/04/29/adverbs/</id>
    <published>2021-04-29T13:47:12.000Z</published>
    <updated>2021-04-30T14:47:48.651Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第七篇。<a href="/2021/04/21/adjectives/">前作</a>处理了形容词，此篇我们处理同为修饰词类的副词。</p><p>从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。</p><p>除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。</p><p>除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 <code>-ly</code>。因此，在双音节的副词变为比较级和最高级时，若是以 <code>-ly</code> 结尾，则应保持不变，通过联合 <code>more</code> 及 <code>most</code> 来实现。</p><span id="more"></span><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><p>如何以简御繁？这是很重要的问题。</p><p>从系列第一篇读至此的朋友，若是细心就会发现我们至今为止以简御繁的两大法宝：</p><ul><li>从表意上考量——我们相信文法是为表意服务的；</li><li>从修辞上考量——我们相信文法形成过程中，人们有趋同的修辞偏好。</li></ul><p>这两大法宝将在整个系列贯穿始终、提纲挈领。我们从表意上，把副词分为以下几大类，分别处理：</p><ul><li>表达方式方法的副词；</li><li>表达强调的副词；</li><li>修饰句子的副词。</li></ul><h2 id="表达方式方法的副词"><a href="#表达方式方法的副词" class="headerlink" title="表达方式方法的副词"></a>表达方式方法的副词</h2><p>表达方式方法的副词，在传统语法当中被称为「方式状语」。方式状语直接修饰动词，表达动作发出的方式方法。</p><p>至于副词的位置——因为方式状语直接修饰动词，所以理想状态，它应该距离动词较近；若不然，人们很难领会到二者之间修饰 - 被修饰的关系。又考虑到动词本身肯定比修饰语要重要一些，所以作为修饰语的副词，一般性应该要放在动词后面。这是表达方式方法的副词的典型位置。</p><p>接下来，我们按<a href="/2014/06/21/basic-sentence-and-the-complement/">五种基本句型</a>各举一例，说明表达方式方法的副词在句子中位置应当如何处理。</p><ul><li>The girl cries <em>sadly</em> after being betrayed by her ex-boyfriend. | 被前男友背叛后，女孩哭得很伤心。</li></ul><p>句子中，我们把表达方式方法的副词放在动词 cries 后面。可选的位置还有两个。一是放在 cries 之前。这样做是可以的，但是 cries 后面没有句子主干成分了（宾语、补语之类）；所以还是放在 cries 后面，凸显动词更佳。另一是放在整个 after 短语之后。但这样距离 cries 太远，反而距离另一个动词 betrayed 更近，造成句意不明。</p><ul><li>The girl swings her bat <em>vigorously</em>. | 女孩用力挥动她的棒球棒。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是和上例一样，放在动词 swing 后面。但这样就把句子的主干成分 her bat（句子中做宾语）挤到后面去了，不利于表意。另一是放在 swing 之前。这也属于可以考虑的方案，但此处宾语并不冗长，放在宾语之后距离被修饰的动词 swing 也不算太远，所以显得有些鸡肋。但如果换成下面的句子，副词就最好放在动词 swing 之前了——若不然，就距离动词太遥远了。</p><blockquote><p>The girl <em>vigorously</em> swings her brand new Italian aluminum alloy bat. | 女孩用力挥动她那崭新的意大利产铝合金棒球棒。</p></blockquote><ul><li>The girl becomes mature <em>gradually</em>. | 女孩逐渐变得成熟。</li></ul><p>句子中，我们表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一个是放在动词 becomes 之前，这没问题。另一是放在动词 becomes 之后，变成「The girl becomes <em>gradually</em> mature.」。这样一来，因为副词既可以修饰动词，又可以修饰形容词，放在这里的 gradually 很容易让人困惑它到底是修饰 becomes 的还是修饰 mature 的。</p><ul><li>The girl gave him a jar of honey <em>readily</em>. | 女孩爽快地给了他一罐蜂蜜。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是放在动词 gave 之前，这没问题。另一是放在动词 gave 之后，变成「The girl gave <em>readily</em> him a jar of honey.」。这样做，表意上倒是不至于有歧义，但副词 readily 把句子的主干成分（直接宾语 + 间接宾语）挤到后面去了，所以在修辞上不好。</p><ul><li>The priest <em>happily</em> announced the boy and the girl man and wife. | 神父高兴地宣布男孩和女孩结为夫妻。</li></ul><p>句子中，我们把表达方式方法的副词放在了动词 announced 之前。可选的位置还有两个。一是放在动词 announced 之后，但这会让句子的主干成分（宾语 + 宾语补语）后移，在修辞上不佳。二是放在句子最后。但这个句子重点是要强调二者结为夫妻，若是将 happily 放在句子最后，一则显得我们在强调神父是高兴的，二则让副词和被修饰的动词距离过远。</p><h2 id="表达强调的副词"><a href="#表达强调的副词" class="headerlink" title="表达强调的副词"></a>表达强调的副词</h2><p>副词当中，还有一大类是表达强调的副词（Intensifier）。这些副词的修饰对象广泛，可以修饰几乎全部词类，特别是可以修饰几种主要词类：名词、动词、形容词、副词。因之，这些副词必须和被修饰的对象紧密相连（而且通常都是放在被修饰对象的前面）。若不然，可能会被误以为是修饰其他句子成分，表意出现漂移。</p><p>表达强调意味的副词，大致有三类。以下分别处理。</p><h3 id="强调范围的副词"><a href="#强调范围的副词" class="headerlink" title="强调范围的副词"></a>强调范围的副词</h3><p>表达强调的副词中，有一部分是用来强调所谈事物的范围的，将所谈事物的范围限定在一个小的范围内。这类副词加与不加、加在何处，对句子的表意影响很大。这类副词中，一个典型是「只有」。举例如下。</p><p>原句：Liam studied mathematics when he was young. | Liam 年轻时学习数学。</p><p>添加「只有」：</p><ul><li><em>Only</em> Liam studied mathematics when he was young. | 只有 Liam 年轻时学习数学。——别人年轻时不学。</li><li>Liam <em>only</em> studied mathematics when he was young. | Liam 年轻时只学习数学。——但没对数学做别的事情；比如对数学并不热爱。</li><li>Liam studied <em>only</em> mathematics when he was young. | Liam 年轻时只学习数学。——但没学别的学科。</li><li>Liam studied mathematics <em>only</em> when he was young. | Liam 只在年轻时学习数学。——长大之后不学了。</li></ul><p>不难发现，添加「只有」之后的四个变种，其表意各不相同，亦与原句表意不同。由此可见「这类副词加与不加、加在何处，对句子的表意影响很大」之说。此又印证「这些副词必须和被修饰的对象紧密相连」之言。</p><p>常见的用于强调表意范围的副词还有：</p><ul><li>only &#x2F; just &#x2F; merely | 只有</li><li>also | 也</li><li>especially &#x2F; particularly | 尤其、特别地</li><li>even | 更加、甚至、居然、恰如</li><li>exactly &#x2F; precisely | 恰恰</li><li>……</li></ul><h3 id="强调程度的副词"><a href="#强调程度的副词" class="headerlink" title="强调程度的副词"></a>强调程度的副词</h3><p>表达强调的副词中的第二类是强调程度的副词。这些副词也是句子表意中很重要的一部分；同样地，这类副词加与不加对句意影响很大。举一例：</p><ul><li>原句：Liam knows Wenyue well. | Liam 了解 Wenyue。</li><li>改程度：Liam knows Wenyue <em>rather</em> well. | Liam 还算了解 Wenyue。</li></ul><p>再举一例：</p><ul><li>原句：The task is done. | 任务已完成。</li><li>改程度：The task is <em>almost</em> done. | 任务已近完成。</li></ul><p>不难发现，这些表达程度的副词也是句子表意的重要组成部分。若是去掉它们，句子表意会发生巨大变化。常见的用于强调程度的副词不少，就不举例了。</p><h3 id="强调语气的副词"><a href="#强调语气的副词" class="headerlink" title="强调语气的副词"></a>强调语气的副词</h3><p>强调语气的副词看起来和强调程度的副词很像。但是，去掉句子当中强调语气的副词只是影响语气，不影响句子表意。举几例：</p><ul><li>Fat XXX looks <em>very much</em> a ball. | 胖子 XXX 看着就是个球。</li><li>XXX is <em>absolutely</em> insane. | XXX 绝对是疯了。</li><li>XXX <em>urgently</em> need being hospitalized. | XXX急需入院治疗。</li></ul><h2 id="修饰句子的副词"><a href="#修饰句子的副词" class="headerlink" title="修饰句子的副词"></a>修饰句子的副词</h2><p>这是一类特殊的副词。和一般（狭隘的）认知不同，有些副词可以用来修饰整个句子。举例来说：</p><ul><li><em>Therefore</em>, Wenyue is less than too fat. | 因此，Wenyue 还称不上太胖。</li><li><em>Frankly</em>, Wenyue is very much a gentleman. | 坦率地说，Wenyue 是个绅♂士。</li></ul><p>例中，无论是 <em>therefore</em> 还是 <em>frankly</em>，在句中都找不到被它们直接修饰的句子成分。这是因为它们都是修饰整个句子的副词。此二例中，看着相似，但实际仍有区别。第二例中的 <em>frankly</em>，实际是一条件状语从句的缩写：</p><blockquote><p>If we are specking frankly, Wenyue is very much a gentleman.</p></blockquote><p>对于这类从副词从句缩写而来的副词，我们称之为分离副词。此外，不难发现，分离副词前后的逗号，原就是两个句子之间的逗号。这种简化，最早应是出于修辞的考虑；简化之后保留逗号，则是出自表意的考虑。</p><p>第一例中的 <em>therefore</em> 本身能表达逻辑关系。因之，此类副词被称为连接副词。这些副词还有</p><ul><li>表达逻辑等号的：therefore, besides, futhermore, ...</li><li>表达逻辑不等号的：however, nonetheless, ...</li></ul><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>此篇，我们通过「两大法宝」，串起了几大类副词，同时辨析了各类副词在句中的用法。所谓渔重于🐟，读者在了解各类副词用法的同时，更重要地是善用两大法宝，复习过去学过的文法和学习新的文法知识。</p><p>下一篇我们处理情态动词和虚拟语气。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第七篇。&lt;a href=&quot;/2021/04/21/adjectives/&quot;&gt;前作&lt;/a&gt;处理了形容词，此篇我们处理同为修饰词类的副词。&lt;/p&gt;
&lt;p&gt;从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。&lt;/p&gt;
&lt;p&gt;除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。&lt;/p&gt;
&lt;p&gt;除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 &lt;code&gt;-ly&lt;/code&gt;。因此，在双音节的副词变为比较级和最高级时，若是以 &lt;code&gt;-ly&lt;/code&gt; 结尾，则应保持不变，通过联合 &lt;code&gt;more&lt;/code&gt; 及 &lt;code&gt;most&lt;/code&gt; 来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adverbs" scheme="https://liam.page/tags/Adverbs/"/>
    
  </entry>
  
  <entry>
    <title>喉咙和声带的结构</title>
    <link href="https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/"/>
    <id>https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/</id>
    <published>2021-04-26T16:28:03.000Z</published>
    <updated>2021-04-26T16:34:00.953Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！</p><span id="more"></span><p>声带是两片相对的膜状韧带，有长度宽度和厚度。</p><p>声带附近有四块软骨：甲状软骨、勺状软骨（两块）和环状软骨。</p><p>连接软骨有肌肉：甲杓（读音：彪）肌（连接甲状软骨和勺状软骨；TA 肌）、杓间肌（连接两块勺状软骨，横向一条，斜向两条；IA 肌）、环杓侧肌（在侧面连接环状软骨和勺状软骨；LCA 肌）、环杓后肌（在后面连接勺状软骨和环状软骨；PCA 肌）、环甲肌（在前面连接环状软骨和甲状软骨；CT 肌）。</p><p>肌肉通过拉扯软骨，来改变连接着软骨的声带的形状。相对来说，有四种：</p><ul><li>变短变厚：甲杓肌收缩，发出响亮的中低音，传说中的「真声」。</li><li>变长变薄：环甲肌收缩，引起整个环状软骨绕环甲连接处转动，从而带动勺状软骨后移，拉动声带变长变薄。</li><li>闭合：杓间肌和环杓侧肌收缩，拉近两块勺状软骨之间的距离。</li><li>张开：环杓后肌收缩，拉开两块勺状软骨之间的距离，声带分开。</li></ul><p>当声带闭合，又有气流从下而上推出，两片声带在气流的冲击和伯努利效应（边界层表面效应）的作用下会不断相互拍击，发出声音。</p><p>接下来的问题就是，要想唱好歌，本质上就是要在各种情况下，相应的肌肉都有足够的力量，去使声带作出相应的动作。所以，练歌，本质上和去健身房撸铁没啥区别——都是要锻炼肌肉。下回如果有人跟你说要去撸铁，不一定是去健身房，也可能是去练歌房。</p><p>唔哈哈哈，是不是很有趣~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Vocal" scheme="https://liam.page/tags/Vocal/"/>
    
      <category term="Autopsy" scheme="https://liam.page/tags/Autopsy/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之六：形容词</title>
    <link href="https://liam.page/2021/04/21/adjectives/"/>
    <id>https://liam.page/2021/04/21/adjectives/</id>
    <published>2021-04-21T13:49:22.000Z</published>
    <updated>2021-04-22T14:24:34.516Z</updated>
    
    <content type="html"><![CDATA[<p>这个<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>最近<a href="https://github.com/Liam0205/liam0205.github.io/issues/333#issuecomment-808816973">又被吐槽了</a>。<a href="https://github.com/PolyMark">PolyMark</a> 讲我更新的太慢。遭不住催更的我，于是就又开始更新了。</p><p>英文当中，用来修饰其他词的词类有两种：形容词和副词。</p><p>大体上，形容词是修饰名词的词，副词则用来修饰名词以外的词类。不过也有少许例外。一方面，少数副词也可以修饰名词；另一方面，用来修饰名词的，不仅仅是狭义上的形容词。比方说，形容词性从句及其简化版本、介词短语、复合词等，在一些场合下，都能充当形容词，承担相应的表意功能。</p><p>此篇先介绍最简单的部分——单词形状的形容词。</p><span id="more"></span><p>单词形状的形容词是英文文法当中比较简单的部分，就只有三大主题：</p><ul><li>补语位置（包括主语补语和宾语补语）的形容词；</li><li>名词短语当中的形容词；</li><li>形容词的比较级。</li></ul><p>我们分别来处理。</p><h2 id="补语位置的形容词——从几个例子开始"><a href="#补语位置的形容词——从几个例子开始" class="headerlink" title="补语位置的形容词——从几个例子开始"></a>补语位置的形容词——从几个例子开始</h2><p>名词短语当中的形容词，在我们处理名词短语时已经见过。它出现在限定词和名词之间，是「属性形容词」（attribute adjectives），描述名词的一种属性。我们举几个例子复习一下。（下划线部分是限定词，加粗部分是形容词）：</p><ul><li><u>a</u> <strong>new</strong> book | 一本新书</li><li><u>many</u> <strong>good</strong> students | 许多好学生</li><li><u>his</u> <strong>beautiful</strong> wife | 他美丽的妻子</li><li><u>the</u> <strong>best</strong> answer | （那个）最佳答案</li><li><u>those</u> <strong>sweet</strong> roses | 那些芳香的玫瑰</li><li><strong>dirty</strong> water | 脏水</li><li><strong>Fat</strong> Wenyue doesn&#39;t like taking exercises. | 胖 Wenyue 不喜欢运动</li></ul><p>出现在补语位置的形容词则是「叙述形容词」（predicate adjectives），它通常是对名词做临时性、暂时性的叙述。同样举几个例子。</p><ul><li>Wenyue is <strong>fat</strong>. | Wenyue 很胖。</li><li>Eating too many junk foods and lack of working-out make Wenyue <strong>fat</strong>. | 吃过多垃圾食品又缺少锻炼导致 Wenyue 很胖。</li></ul><p>比较关于 Wenyue 的几个例子，我们不难发现：<strong>出现在名词短语当中的形容词，暗含一种固有、长期的感觉</strong>。「Fat Wenyue」的表述告诉大家，Wenyue 他就是个胖子，不管他说什么做什么，都很难瘦下来。反过来，<strong>出现在补语位置的形容词，则缺乏固有、长期的意味</strong>。不管是充作主语的补语还是充作宾语的补语，你都能感觉 Wenyue 只是暂时有点胖，过段时间还是有可能瘦下去的，还是有救的，不能放弃治疗。</p><blockquote><p>P.S. 此文的打赏请备注，我需要给模特儿 Wenyue 分润一些。哈哈~！</p></blockquote><p>我们知道，来自古英语中，有一些以「a-」开头的形容词，往往都表示短暂的状态。这类形容词就喜欢出现在补语位置——尽管他们也可以出现在名词短语中，但会有一些小的变化，而且显得多少有些奇怪。</p><ul><li>The sick man is still <strong>alive</strong>. | 那个久病之人仍旧活着。</li><li>The balloon stays <strong>afloat</strong>. | 气球保持漂浮。</li><li>Coffee keeps modern people <strong>awake</strong>. | 咖啡让现代人保持清醒。</li></ul><p>补语是对名词的一种补述，单靠一个单词显然是难以完成各种各样的表意的。因此，补语位置的形容词形式比较自由。除了单词形式的形容词之外，还可以是各种短语。举几个例子：</p><ul><li>She always wants to make everyone <strong>happy</strong>.</li><li>I heard her <strong>playing the violin</strong> yesterday.</li><li>The lake is <strong>large</strong>.</li></ul><h2 id="名词短语当中的形容词"><a href="#名词短语当中的形容词" class="headerlink" title="名词短语当中的形容词"></a>名词短语当中的形容词</h2><p>属性形容词这个主题下，我们已有名词短语当中的讨论打底，因此只需要处理几个问题就好。</p><ul><li>后置的形容词；</li><li>名词形容词化；</li><li>复合词做形容词；</li><li>属性形容词的相对顺序。</li></ul><h3 id="后置的形容词"><a href="#后置的形容词" class="headerlink" title="后置的形容词"></a>后置的形容词</h3><p>在处理名词短语时，我们讲修饰词要放在限定词（如果有）和名词（如果有）之间。也就是说，相对名词，修饰名词的形容词要前置。但是，有两种情形，形容词需要后置。</p><h4 id="复合名词与-else-联用"><a href="#复合名词与-else-联用" class="headerlink" title="复合名词与 else 联用"></a>复合名词与 else 联用</h4><p>首先还是看一个例子。</p><ul><li>Someone <strong>else</strong> will handle it well.</li></ul><p>在这个例子当中，形容词 else 放在名词 someone 的后面。这几乎已经是「习以为常」的用法了，在传统语法当中可能会被解释成「约定俗成」。但是我们就偏偏要掰扯掰扯到底是怎样「俗成」的。</p><p>其实这里，someone 是所谓「复合名词」。这类复合名词把名词短语当中的限定词和名词粘连到一起了，于是修饰词失去了位置，就只好往后放了。就这么简单。</p><blockquote><p>类似的复合名词还有（不完整举例）：someone, everyone, anyone, somebody, everybody, anybody...</p></blockquote><h4 id="古英语当中的-a-形容词"><a href="#古英语当中的-a-形容词" class="headerlink" title="古英语当中的 a- 形容词"></a>古英语当中的 <code>a-</code> 形容词</h4><p>之前我们已经讲到，古英语当中的 <code>a-</code> 形容词往往都表示短暂的状态，因此不适合放在名词之前作为属性，而只能后置。举一个例子看看：</p><ul><li>Money <strong>alone</strong> cannot solve every problem, meanwhile, without money solves no problem. | 钱不是万能的，没钱是万万不能的。</li></ul><p>显然，alone 不可能是 money 的一种属性。在句子当中，money alone 表示「只有钱」这一种特殊而暂时的状态。</p><h3 id="名词形容词化"><a href="#名词形容词化" class="headerlink" title="名词形容词化"></a>名词形容词化</h3><p>初看起来，可能会觉得名词形容词化是个很吓人的事情。但其实它真的很常见。比如，中文当中「校门」这个词，实际上「校」就是名词充作了形容词。所以名词形容词化不是什么值得大惊小怪的事情。我们看几个例子。</p><ul><li>a <strong>government</strong> shop | 一家公营商店</li><li><strong>movie</strong> theaters | 电影院（其实就是 cinema <code>: )</code>）</li></ul><p>值得一讲的是，名词既已形容词化，那就要遵循形容词的一些「规矩」。比如电影院，实际上不可能只放映一部电影。但由于形容词不存在复数的概念，所以我们不能写作 movies theaters。</p><h3 id="复合词做形容词"><a href="#复合词做形容词" class="headerlink" title="复合词做形容词"></a>复合词做形容词</h3><p>名词短语中的修饰词位置只能放单词形状的词。因此，如果有一个短语形状的形容词想要放进名词短语当中，就需要用连字符（hyphen）将短语连起来变成一个词；同时，为了遵循形容词的规矩，短语中如果有复数名词应该变成单数形式。举几个例子完事儿~</p><ul><li>an <strong>eye-opening</strong> show | 一场令人大开眼界的表演</li><li>a <strong>five-year-old</strong> girl | 一个五岁的小女孩儿</li></ul><h3 id="属性形容词的相对顺序"><a href="#属性形容词的相对顺序" class="headerlink" title="属性形容词的相对顺序"></a>属性形容词的相对顺序</h3><p>这又是国内英语考试喜欢考察的考点之一。传统语法书惯常让人背诵一个特定的顺序。然而，学生每次都会发现，考卷上的题目会涉及到一个之前没背过的东西，然后就抓耳挠腮。</p><p>实际上，稍作思考就能想清楚了。属性形容词表达的是名词的属性。那么，越接近名词本质的，就要越靠近名词；反过来，越是容易变化或是主观感受的，就要相对远离名词。</p><p>举个两栗子。</p><ul><li>A <strong>poisoned small green</strong> almost kills the White Snow. | 一个有毒的小小绿色苹果差点毒死了白雪公主。</li><li>The murderer left behind a <strong>bloody old black US leather</strong> glove. | 凶手在现场遗留了一个带血的老旧黑色美国皮手套。</li></ul><p>稍微体会一下就容易感受出来了，不是吗？</p><h2 id="形容词的比较级"><a href="#形容词的比较级" class="headerlink" title="形容词的比较级"></a>形容词的比较级</h2><p>形容词和副词都有比较级和最高级。二者有一个共同的问题需要处理：<strong>拼法</strong>。除此之外，最高级比较简单，只有一个定冠词的问题需要处理。比较级则复杂一些。因为比较就一定会导致句子当中出现重复的成分，于是就会有省略和倒装的语法现象。</p><p>我们先来看看比较级和最高级的几个基本例子，然后分别来看这几个问题。</p><h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><p>比较级就是为了解决表意中「大于」、「小于」、「等于」、「不等于」而出现的。前两者的基本形态是「A is <em>adj.-er</em> than B.」；后两者是同级比较，基本形态是「A is <em>(not) as adj. as</em> B」。</p><ul><li>Liam is <em>taller</em> than Sophia. | Liam 比 Sophia 高。</li><li>Liam is <em>as old as</em> Sophia. | Liam 和 Sophia 年岁一般大。</li></ul><p>最高级是为了解决表意中「最」的概念而出现的。举例：</p><ul><li>The Hua Mountain is the <em>most precipitous</em> mountain in China. | 华山是中国最险峻的山。</li><li>The Hua Mountain is <em>most crowded</em> in public holidays. | 华山在公共假期时最拥挤。</li></ul><h3 id="拼法"><a href="#拼法" class="headerlink" title="拼法"></a>拼法</h3><p>对于单音节形容词来说，比较级和最高级的拼法很简单——加 <code>-er</code> 或者 <code>-est</code> 即可。额外多一句就是，以 <code>y</code> 结尾的词，为发音规则计，需要改 <code>y</code> 为 <code>i</code> 再加 <code>-er</code> 或者 <code>-est</code>。对于三音节或更多音节的长词来说，比较级和最高级的拼法也很简单——联用用 <code>more adj.</code>&#x2F;<code>most adj.</code> 来解决。</p><p>麻烦事儿出现在双音节上。它不长不短，到底是联用 <code>more</code> 好呢？还是加 <code>-er</code> 小尾巴好呢？传统语法书，又要让你背诵了。仔细观察，其实这事儿也很简单。一句话版本：如果形容词有典型的形容词后缀，那就和 <code>more</code> 联用；不然，两者皆可。</p><p>举几个典型形容词后缀的例子。</p><ul><li>act<em>ive</em> -&gt; more act<em>ive</em> -&gt; most act<em>ive</em></li><li>fam<em>ous</em> -&gt; more fam<em>ous</em> -&gt; most fam<em>ous</em></li><li>use<em>ful</em> -&gt; more use<em>ful</em> -&gt; most use<em>ful</em></li><li>lov<em>ing</em> -&gt; more lov<em>ing</em> -&gt; most lov<em>ing</em></li></ul><h3 id="定冠词与最高级"><a href="#定冠词与最高级" class="headerlink" title="定冠词与最高级"></a>定冠词与最高级</h3><p>「最高级前面要加定冠词」可能对于中国学生来说是深入人心的。但看看刚才华山的两个例子，立马就「打脸」了。</p><p>其实，回顾我们在名词短语篇中的讨论就知道，定冠词是限定词的一种，是名词短语的一部分。如果需要表达 that 语义的时候，就要用 the。但是，在有关华山的第二个例子当中，最高级 <em>most crowded</em> 根本就不是名词短语的一部分，当然就谈不上用定冠词了。</p><blockquote><p>我们继续走在秒杀英文文法要点的道路上……嘻嘻……</p></blockquote><h3 id="重复——省略和倒装"><a href="#重复——省略和倒装" class="headerlink" title="重复——省略和倒装"></a>重复——省略和倒装</h3><p>我们先来看两个例子。</p><ul><li>Children grown up in cities are likely to be somewhat more self-confident than children grown up in countryside. | 某种意义上，城里长大的小孩相比农村长大的小孩相较而言更显自信。</li><li>Golden retriever dog has as much I.Q. as a child of five or six has I.Q. | 金毛狗拥有和五六岁小孩一般多的智商。</li></ul><p>啥感觉？读起来累不累？是不是感觉累赘？那就对了！若非是简单的二者直接比较，而是比较具有不同属性的相同物体，物体本身就必然重复。若非是简单地二者直接比较，而是比较不同的二者做的同样的事，做的事情就必然重复。</p><p>那么，问题来了。有重复咋办呢？对于重复的物体，我们可以用代词来指代。对于重复的动作，我们可以用助动词来代替，在加入倒装以便让助动词和它代替的动作在句子里距离更近。我们来分析这两个例子。</p><p>在第一个例子中，重复的物体是 children。我们用 those 来代替它，句子变成：Children grown up in cities are likely to be somewhat more self-confident than <em>those</em> grown up in countryside.</p><p>在第二个例子中，重复的动作是 has I.Q.。我们用 does 来代替它，句子变成：Golden retriever dog has as much I.Q. as a child of five or six <em>does</em>. 此时我们发现助动词 does 距离它实际表意的 has I.Q. 特别远，于是我们来倒装，将助动词 <em>does</em> 提前：Golden retriever dog has as much I.Q. as <em>does</em> a child of five or six.</p><p>关于形容词的事情，就这样齐活儿啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;最近&lt;a href=&quot;https://github.com/Liam0205/liam0205.github.io/issues/333#issuecomment-808816973&quot;&gt;又被吐槽了&lt;/a&gt;。&lt;a href=&quot;https://github.com/PolyMark&quot;&gt;PolyMark&lt;/a&gt; 讲我更新的太慢。遭不住催更的我，于是就又开始更新了。&lt;/p&gt;
&lt;p&gt;英文当中，用来修饰其他词的词类有两种：形容词和副词。&lt;/p&gt;
&lt;p&gt;大体上，形容词是修饰名词的词，副词则用来修饰名词以外的词类。不过也有少许例外。一方面，少数副词也可以修饰名词；另一方面，用来修饰名词的，不仅仅是狭义上的形容词。比方说，形容词性从句及其简化版本、介词短语、复合词等，在一些场合下，都能充当形容词，承担相应的表意功能。&lt;/p&gt;
&lt;p&gt;此篇先介绍最简单的部分——单词形状的形容词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adjectives" scheme="https://liam.page/tags/Adjectives/"/>
    
  </entry>
  
  <entry>
    <title>Again：不要重新造轮子</title>
    <link href="https://liam.page/2021/03/17/do-not-reinventing-the-wheel-again/"/>
    <id>https://liam.page/2021/03/17/do-not-reinventing-the-wheel-again/</id>
    <published>2021-03-17T03:56:10.000Z</published>
    <updated>2021-04-21T13:48:50.293Z</updated>
    
    <content type="html"><![CDATA[<p>最近，宝玉在群里抛了一个 case，大意是说，因为 <code>npm</code> 更新了上游一个包，导致他们的服务性能下降明显。排查之后发现，上游把一个处理字符串的函数（用于将 <code>&amp;&lt;&gt;&quot;</code> 替换为相应的 HTML 转义）从类似 <code>str.replace(/&quot;/g, &#39;&amp;quot;&#39;)</code> 的写法，改成了循环遍历 <code>str</code>，然后逐个字符检查，再用 <code>+=</code> 拼接到新的输出字符串上。</p><p>显然，这又是一个重新造的轮子不圆引发的问题。</p><span id="more"></span><p>为啥这么说呢？我不了解 JavaScript，但对 Python 有所了解。我找了一下 Python 对字符串 replace 的实现，一下就看明白了差距。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://svn.python.org/projects/python/trunk/Objects/stringobject.c</span></span><br><span class="line">Py_LOCAL(PyStringObject *)</span><br><span class="line">replace(PyStringObject *self,</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *from_s, Py_ssize_t from_len,</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *to_s, Py_ssize_t to_len,</span><br><span class="line">    Py_ssize_t maxcount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxcount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxcount = PY_SSIZE_T_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxcount == <span class="number">0</span> || PyString_GET_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* nothing to do; return the original string */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxcount == <span class="number">0</span> ||</span><br><span class="line">        (from_len == <span class="number">0</span> &amp;&amp; to_len == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/* nothing to do; return the original string */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle zero-length special cases */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from_len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* insert the &#x27;to&#x27; string everywhere.   */</span></span><br><span class="line">        <span class="comment">/*    &gt;&gt;&gt; &quot;Python&quot;.replace(&quot;&quot;, &quot;.&quot;)     */</span></span><br><span class="line">        <span class="comment">/*    &#x27;.P.y.t.h.o.n.&#x27;                   */</span></span><br><span class="line">        <span class="keyword">return</span> replace_interleave(self, to_s, to_len, maxcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Except for &quot;&quot;.replace(&quot;&quot;, &quot;A&quot;) == &quot;A&quot; there is no way beyond this */</span></span><br><span class="line">    <span class="comment">/* point for an empty self string to generate a non-empty string */</span></span><br><span class="line">    <span class="comment">/* Special case so the remaining code always gets a non-empty string */</span></span><br><span class="line">    <span class="keyword">if</span> (PyString_GET_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* delete all occurances of &#x27;from&#x27; string */</span></span><br><span class="line">        <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_delete_single_character(</span><br><span class="line">                self, from_s[<span class="number">0</span>], maxcount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_delete_substring(self, from_s, from_len, maxcount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special case where both strings have the same length */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from_len == to_len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_single_character_in_place(</span><br><span class="line">                self,</span><br><span class="line">                from_s[<span class="number">0</span>],</span><br><span class="line">                to_s[<span class="number">0</span>],</span><br><span class="line">                maxcount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_substring_in_place(</span><br><span class="line">                self, from_s, from_len, to_s, to_len, maxcount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise use the more generic algorithms */</span></span><br><span class="line">    <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace_single_character(self, from_s[<span class="number">0</span>],</span><br><span class="line">                                        to_s, to_len, maxcount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* len(&#x27;from&#x27;)&gt;=2, len(&#x27;to&#x27;)&gt;=1 */</span></span><br><span class="line">        <span class="keyword">return</span> replace_substring(self, from_s, from_len, to_s, to_len, maxcount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过边界检查，Python 的 C 实现当中，对 <code>from_s</code> 和 <code>to_s</code> 不同长度的情况作了不同的处理。当二者长度相同的时候，由于无需额外分配内存，可以使用 in-place 的方式解决问题。当二者长度不同时，若 <code>from_s</code> 的长度为 1，走特定优化的版本；否则，走最通用的版本。</p><p>对应到宝玉遇到的问题，显然落到了 <code>from_s</code> 长度为 1 的情形。我们继续再深入看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* len(self)&gt;=1, len(from)==1, len(to)&gt;=2, maxcount&gt;=1 */</span></span><br><span class="line">Py_LOCAL(PyStringObject *)</span><br><span class="line">replace_single_character(PyStringObject *self,</span><br><span class="line">                         <span class="type">char</span> from_c,</span><br><span class="line">                         <span class="type">const</span> <span class="type">char</span> *to_s, Py_ssize_t to_len,</span><br><span class="line">                         Py_ssize_t maxcount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *self_s, *result_s;</span><br><span class="line">    <span class="type">char</span> *start, *next, *end;</span><br><span class="line">    Py_ssize_t self_len, result_len;</span><br><span class="line">    Py_ssize_t count, product;</span><br><span class="line">    PyStringObject *result;</span><br><span class="line"></span><br><span class="line">    self_s = PyString_AS_STRING(self);</span><br><span class="line">    self_len = PyString_GET_SIZE(self);</span><br><span class="line"></span><br><span class="line">    count = countchar(self_s, self_len, from_c, maxcount);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* no matches, return unchanged */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use the difference between current and new, hence the &quot;-1&quot; */</span></span><br><span class="line">    <span class="comment">/*   result_len = self_len + count * (to_len-1)  */</span></span><br><span class="line">    product = count * (to_len<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (product / (to_len<span class="number">-1</span>) != count) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">&quot;replace string is too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result_len = self_len + product;</span><br><span class="line">    <span class="keyword">if</span> (result_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">&quot;replace string is too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (result = (PyStringObject *)</span><br><span class="line">          PyString_FromStringAndSize(<span class="literal">NULL</span>, result_len)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    result_s = PyString_AS_STRING(result);</span><br><span class="line"></span><br><span class="line">    start = self_s;</span><br><span class="line">    end = self_s + self_len;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        next = findchar(start, end-start, from_c);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == start) &#123;</span><br><span class="line">            <span class="comment">/* replace with the &#x27;to&#x27; */</span></span><br><span class="line">            Py_MEMCPY(result_s, to_s, to_len);</span><br><span class="line">            result_s += to_len;</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* copy the unchanged old then the &#x27;to&#x27; */</span></span><br><span class="line">            Py_MEMCPY(result_s, start, next-start);</span><br><span class="line">            result_s += (next-start);</span><br><span class="line">            Py_MEMCPY(result_s, to_s, to_len);</span><br><span class="line">            result_s += to_len;</span><br><span class="line">            start = next+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Copy the remainder of the remaining string */</span></span><br><span class="line">    Py_MEMCPY(result_s, start, end-start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，这是一个对特定情况的专门优化。</p><ol><li>遍历原字符串，计数 <code>from_c</code> 出现的次数；</li><li>计算目标字符串的长度 <code>len(str) + count * (len(to_str) - 1)</code>，提前分配内存；</li><li>循环地找 from_str 下一次出现的位置，然后 memcpy 原始字符串 + memcpy to_str。</li></ol><p>这种操作，肯定会比不断用 <code>+=</code> 追加单个字符要快得多。因此有标题：Again, 不要重复造轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，宝玉在群里抛了一个 case，大意是说，因为 &lt;code&gt;npm&lt;/code&gt; 更新了上游一个包，导致他们的服务性能下降明显。排查之后发现，上游把一个处理字符串的函数（用于将 &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; 替换为相应的 HTML 转义）从类似 &lt;code&gt;str.replace(/&amp;quot;/g, &amp;#39;&amp;amp;quot;&amp;#39;)&lt;/code&gt; 的写法，改成了循环遍历 &lt;code&gt;str&lt;/code&gt;，然后逐个字符检查，再用 &lt;code&gt;+=&lt;/code&gt; 拼接到新的输出字符串上。&lt;/p&gt;
&lt;p&gt;显然，这又是一个重新造的轮子不圆引发的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="JavaScript" scheme="https://liam.page/tags/JavaScript/"/>
    
      <category term="Software Engineering" scheme="https://liam.page/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中类的构造函数中使用 this 指针</title>
    <link href="https://liam.page/2021/03/17/using-this-pointer-in-ctor/"/>
    <id>https://liam.page/2021/03/17/using-this-pointer-in-ctor/</id>
    <published>2021-03-17T03:44:57.000Z</published>
    <updated>2021-04-21T13:48:50.293Z</updated>
    
    <content type="html"><![CDATA[<p>遇见一个有趣的问题。</p><p>C++ 里面，在类的 constructor 当中使用 this 指针访问成员，是否是安全的？在哪些情况下安全？在哪些情况下不安全？</p><span id="more"></span><p>Ao Shen 给了一个<a href="https://isocpp.org/wiki/faq/ctors#using-this-in-ctors">标准答案</a>，跟我之前的认知一致：只要对类内成员初始化顺序，以及对基类子类初始化顺序熟悉，就很容易理解了。</p><p>因为类内成员初始化顺序和类内成员声明顺序一致，基类总是在子类之前初始化。所以</p><ul><li>在父类初始化列表当中，使用 <code>this</code> 引用更早声明的变量初始化是安全的。</li><li>在父类构造函数体当中，使用 <code>this</code> 指针引用类内成员是安全的（不包括子类成员）。</li><li>在父类构造函数体当中，down-cast <code>this</code> 指针为子类指针，这一行为本身是安全的；但是使用 down-casted 指针访问子类成员是不安全的。</li><li>在子类初始化列表当中，使用 <code>this</code> 指针引用父类成员总是安全的。</li><li>访问函数的情况，则看对应的函数访问的类内成员是否已经初始化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇见一个有趣的问题。&lt;/p&gt;
&lt;p&gt;C++ 里面，在类的 constructor 当中使用 this 指针访问成员，是否是安全的？在哪些情况下安全？在哪些情况下不安全？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="this" scheme="https://liam.page/tags/this/"/>
    
      <category term="Constructor" scheme="https://liam.page/tags/Constructor/"/>
    
  </entry>
  
  <entry>
    <title>扩展版领口策略</title>
    <link href="https://liam.page/2021/03/16/the-extended-callar-strategy/"/>
    <id>https://liam.page/2021/03/16/the-extended-callar-strategy/</id>
    <published>2021-03-16T06:43:46.000Z</published>
    <updated>2021-04-21T13:48:50.292Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2021/03/15/price-of-option-and-the-collar-strategy/">前文</a>讨论了期权价格的决定因素并简单介绍了领口策略。</p><p>领口策略通过买入虚值看跌期权（后简称买入 PUT otm）并卖出虚值看涨期权（后简称卖出 CALL otm），在 CALL 有效期内放弃超额收益，在 PUT 有效期内控制风险。此篇我们在基础版领口策略的基础上进行一些扩展，以便能够让领口策略长期滚动起来，并持续获得收益&#x2F;降低持仓成本。</p><blockquote><p>此篇文章介绍的策略，是我从 Ming Ma 先达处学到，而后加工整理的。感谢 Ming Ma 的无私分享和细心解读。</p></blockquote><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基础版的领口策略的 PUT 和 CALL 的过期时间相同，这有一点不好。因为从本性来说，我们对下跌的担忧是长久的，对上涨的期待也是长久的。因此，对于固定行权价的保护性 PUT 来说，我们期待它的过期时间长；对于固定行权价的对冲性 CALL 来说，我们期待它过期时间短，以便能够及时根据市场行情作出调整。这促使我们在构建领口策略的时候，买入远期的 PUT，卖出相对短期的 CALL。</p><p>领口策略的本意，是利用卖出 CALL otm 的收入，抵消&#x2F;降低买入 PUT otm 的成本。现在，我们打算买入远期 PUT otm。那么，它的价格就很难为短期 CALL otm 所抵消。在这种情况下，我们有两种选择。一是继续卖出更多的 CALL otm，二是选择也卖出一些 PUT otm。</p><p>若是继续卖出更多的 CALL otm，那么多出来的这部分 CALL，就会成为没有对应正股保护的敞口风险。构造领口策略是为了降低风险，因此，显然我们不会选择这种平白增加风险的行为。那么选择就很明朗了——卖出部分短期 PUT otm。</p><p>现在，我们的策略由以下部分组成：</p><ul><li>一份正股；</li><li>一份远期，紧跟正股成本价的 PUT otm；</li><li>卖出一份近期，价格稍高的 CALL otm；</li><li>卖出一份近期，价格稍低的 PUT otm。</li></ul><p>最理想的情况，是在卖出的两份近期 option 到期之前，正股价格波动没有击穿 CALL&#x2F;PUT 的行权价格。在这种情况下，两份期权都不会被对家行权，我们白赚权利金。</p><p>但若</p><ul><li>在近期 CALL 到期之前，上涨击穿 CALL 的行权价，则我们持有的一份正股，会被 CALL 走；此时正股被迫平仓，远期 PUT 的保护就失去了意义。这种情况应当补仓。</li><li>或者，在近期 PUT 到期之前，下跌击穿 PUT 的行权价，则对家会 PUT 一份正股给我们；此时正股仓位高于远期 PUT 的保护，形成敞口风险。这种情况应当减仓。</li></ul><h2 id="补仓的策略"><a href="#补仓的策略" class="headerlink" title="补仓的策略"></a>补仓的策略</h2><p>无论是 CALL 还是 PUT 被击穿，恢复策略都涉及两个方面。一是正股，而是围绕正股当前价格的近期 PUT&#x2F;CALL。我们先来讨论 CALL 被击穿时候，补仓的策略。</p><p>对于近期 PUT&#x2F;CALL 来说。</p><p>考虑 PUT。如果 CALL 被提前行权（在到期日之前被行权，仅适用于美式期权），则 PUT 依然在履约期内。此时，由于 1) CALL 被击穿，正股价格相对卖出 PUT otm 时要高，以及 2) 时间的推移，此前我们卖出的 PUT 合约，价格会下跌，低于卖出时的价格。于是我们可以将它买回来。对于 PUT 来说，我们的权利金不会损失。</p><p>考虑 CALL。由于 CALL 被行权，合约结束，权利金完全落入我们的口袋。此时我们的权利金也不会损失。</p><p>因此，我们的结论是，我们应当：</p><ul><li>购回之前卖出的 PUT otm；</li><li>围绕正股当前价格，重新卖出近期的 PUT otm 和 CALL otm。</li></ul><p>对于正股来说，由于卖出的 CALL 被对家行权，我们此时手上没有正股。为了补仓，我们有两种选择。</p><ul><li>一是直接在高于刚刚被击穿的 CALL 行权价，直接购回一份正股。这种情况下，只要购回正股的价格与被击穿的行权价，价格差不超过两份权利金的收入，我们就没有吃亏。</li><li>二是，卖出一份行权价与被击穿的 CALL 的行权价相同的 PUT，并期待正股价格在履约期内跌破行权价，对家行权将正股 PUT 给你。这样操作的好处是，又可以赚一份权利金；但风险在于，如果股价一路上涨，则对家不会行权，我们手头没有正股，从而失去后续正股价格上涨的收益。</li></ul><p>考虑到我们购买远期 PUT 时，是为了在控制风险的情况下长期持有正股。<strong>在基本判断不发生变化的情况下</strong>，更好的选择应该是选择第一种方案：直接购入一份正股。</p><h2 id="减仓的策略"><a href="#减仓的策略" class="headerlink" title="减仓的策略"></a>减仓的策略</h2><p>接下来我们讨论减仓的策略。</p><p>同样地，对于近期 PUT&#x2F;CALL 来说。</p><p>考虑 CALL。如果 PUT 被提前行权（在到期日之前被行权，仅适用于美式期权），则 CALL 依然在履约期内。此时，由于 1) PUT 被击穿，正股价格相对卖出 CALL otm 时要低，以及 2) 时间的推移，此前我们卖出的 CALL 合约，价格会下跌，低于卖出时的价格。于是我们可以将它买回来。对于 CALL 来说，我们的权利金不会损失。</p><p>考虑 PUT。由于 PUT 被行权，合约结束，权利金完全落入我们的口袋。此时我们的权利金也不会损失。</p><p>因此，我们的结论是，我们应当：</p><ul><li>购回之前卖出的 CALL otm；</li><li>围绕正股当前价格，重新卖出近期的 PUT otm 和 CALL otm。</li></ul><p>类似地，对于正股来说，由于卖出的 PUT 被对家行权，我们此时手上有两份正股。为了减仓，我们有两种选择。</p><ul><li>一是直接在低于刚刚被击穿的 PUT 行权价，直接卖出一份正股。（注意，此时手上还卖出了一份 CALL，所以只能卖出一份正股，不能两份全部卖出。）这种情况下，只要卖出正股的价格与被击穿的行权价，价格差不超过两份权利金的收入，我们就没有吃亏。</li><li>二是，卖出一份行权价与被击穿的 PUT 的行权价相同的 CALL，并期待正股价格在履约期内涨过行权价，对家行权将正股 CALL 走。这样操作的好处是，又可以赚一份权利金；但风险在于，如果股价一路下跌，则对家不会行权，我们手头有两份正股，从而需要承担额外的一份正股下跌带来的损失。</li></ul><p>考虑到我们购买远期 PUT 时，是为了在控制风险的情况下长期持有正股。<strong>在基本判断不发生变化的情况下</strong>，更好的选择应该是选择第二种方案：通过卖出 CALL，让对家主动行权，CALL 走我们手头额外的正股。</p><h2 id="风险的分析"><a href="#风险的分析" class="headerlink" title="风险的分析"></a>风险的分析</h2><p>在这个交易体系当中，存在的风险可以罗列如下。</p><ol><li>正股：下跌风险为远期 PUT 保护，在做好远期 PUT 过期的心理建设的情况下，相当于无风险。</li><li>远期 PUT：正股股价长期下跌，被迫行权远期 PUT，承担 otm 部分以及未被近期 option 权利金抵消的风险。</li><li>近期 CALL：正股股价暴涨，导致没有在击穿短期 CALL 后及时补仓，导致没有享受后续正股价格上涨的收益。</li><li>近期 PUT：正股股价暴跌，导致没有在击穿短期 PUT 后及时减仓，导致无远期 PUT 保护的敞口风险。</li></ol><p>可见，为避免这些风险，应用这一交易体系应当满足以下条件：</p><ol><li>正股股价长期看涨——公司基本面良好、正股股价处在低估区间；</li><li>正股股价波动幅度较小——公司体量相对较大。</li></ol><p>在满足这些条件的基础上，应用这一体系，可以在相当低的风险的情况下，获得可观的长期收益。并且，在这个过程中，操作者无需投入大量精力盯盘，只需在关键时间节点做少量操作即可。运作得好，可以以相当低的成本（甚至零成本）持有正股，从此享受股价上涨、分红带来的收益。</p><p>相对应地，这一系统，也不适和追求短期超额收益的投资风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2021/03/15/price-of-option-and-the-collar-strategy/&quot;&gt;前文&lt;/a&gt;讨论了期权价格的决定因素并简单介绍了领口策略。&lt;/p&gt;
&lt;p&gt;领口策略通过买入虚值看跌期权（后简称买入 PUT otm）并卖出虚值看涨期权（后简称卖出 CALL otm），在 CALL 有效期内放弃超额收益，在 PUT 有效期内控制风险。此篇我们在基础版领口策略的基础上进行一些扩展，以便能够让领口策略长期滚动起来，并持续获得收益&amp;#x2F;降低持仓成本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此篇文章介绍的策略，是我从 Ming Ma 先达处学到，而后加工整理的。感谢 Ming Ma 的无私分享和细心解读。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Collar Strategy" scheme="https://liam.page/tags/Collar-Strategy/"/>
    
  </entry>
  
</feed>
