<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2019-08-29T09:41:44.270Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从前序遍历结果中重建二叉搜索树</title>
    <link href="https://liam.page/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/"/>
    <id>https://liam.page/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/</id>
    <published>2019-08-29T06:38:23.000Z</published>
    <updated>2019-08-29T09:41:44.270Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个有趣的问题：已知有一个无重复元素的二叉搜索树的前序遍历结果，要求重建该二叉搜索树。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>首先回顾一下前序遍历和二叉搜索树的概念。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>二叉树的前序遍历指得是：对于任意的结点及其左右子节点，在遍历结果中出现的顺序总是「父节点 -&gt; 左子节点 -&gt; 右子节点」；由于二叉树的自相似结构，这种描述唯一确定的遍历顺序即是前序遍历。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是一种特殊的二叉树，它要求：对于任意的结点及其左右子结点作为根节点形成的左右子树，满足：左子树的所有结点的值小于父节点的值，右子树的所有结点的值大于父节点的值。</p><blockquote><p>显然，二叉搜索树的中序遍历是从小到大排序的。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><p>首先要考虑，一个无重复元素的二叉搜索树的前序遍历结果能否唯一确定一个二叉搜索树？答案是可以的，简要证明如下：</p><ul><li>已知二叉搜索树的前序遍历结果，即知晓二叉搜索树中所有元素；</li><li>对二叉搜索树中所有元素进行从小到大排序，根据二叉搜索树的性质，即得到该二叉搜索树的中序遍历结果；</li><li>已知二叉树的前序遍历结果和中序遍历结果，可以唯一地确定一个二叉树，即该二叉搜索树。</li></ul><p>由此可知，一个无重复元素的二叉搜索树的前序遍历结果，确实能够唯一地确定一个二叉搜索树。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>重建二叉搜索树必然要获知该二叉搜索树中的全部结果。因此，时间复杂度必然不小于 <code>$O(n)$</code>，由此我们得到一个下界。</p><p>又从上述唯一性证明的过程中可知一种重建方法，分析该方法的复杂度可得到一个上界。现在我们简单分析一下该方法的时间复杂度。</p><blockquote><p>一种恢复二叉搜索树的方法：</p><ol><li>对结果进行从小到大排序，得到中序遍历结果。</li><li>根据前序遍历结果和中序遍历结果，重建二叉树。</li></ol></blockquote><p>该方法的时间复杂度是两步之和，其中第 (1) 步的时间复杂度为 <code>$O(n \log(n))$</code>；关键要求得第 (2) 步的时间复杂度。</p><blockquote><p>根据前序遍历结果和中序遍历结果，重建二叉树的方法：</p><ol><li>根据前序遍历结果，确定树根</li><li>根据中序遍历结果，确定树根位置</li><li>根据中序遍历结果，确定左子树（如果有）元素数量</li><li>根据 (3) 的结果，在前序遍历结果中，确定左右子树（如果有）的树根位置</li><li>如此分治递归</li></ol></blockquote><p>若使用支持随机访问的数组存储前序、中序遍历结果，这里的 (1), (3), (4) 步的复杂度均是常数 <code>$O(1)$</code>。对于 (2)，若中序遍历是有序结果（二叉搜索树的情况），可用二分搜索确定树根位置，这一步的复杂度是 <code>$O(\log(n))$</code>，否则只能逐一遍历，复杂度是 <code>$O(n)$</code>。根据「主定理」，这种重建二叉树的方法的时间复杂度不超过 <code>$O(n\log(n))$</code>。</p><p>由此可知，根据前序遍历结果重建二叉搜索树的方法，其时间复杂度下界是 <code>$O(n)$</code>，上界是 <code>$O(n\log(n))$</code>。</p><h2 id="向-Theta-n-进发"><a href="#向-Theta-n-进发" class="headerlink" title="向 $\Theta(n)$ 进发"></a>向 <code>$\Theta(n)$</code> 进发</h2><p>回顾借助中序遍历结果重建二叉树的步骤，我们发现，中序遍历结果的核心作用是通过确定左子树（如果有）元素的数量，在前序遍历中确定左右子树的根节点。考虑到，在前序遍历中，左子树的根节点的位置是平凡的——如果存在左子树，左子树根节点就是整棵树根节点的在前序遍历中的下一个元素。所以关键是要想办法确定右子树（如果有）根节点的位置。</p><p>好消息是，我们现在需要重建的二叉树是二叉搜索树。因此，树根的右孩子，就是前序遍历中第一个比根节点大的那个元素。这样一来，我们就能确定根节点的左右孩子的位置了，如此一来，只需要递归就能解决问题。</p><p>于是，遗留的问题变成了：如何在常数时间内找到第一个比根节点大的元素的位置。</p><p>讲道理，单就查找元素的问题而言，我们是做不到的。最快的二分的复杂度也有 <code>$\Theta(\log(n))$</code>，何况它还有额外要求。但是，我们已知：根节点到根节点右孩子之间的所有元素，都是根节点左子树的元素（假设其个数是 <code>$k$</code>）。如果我们有办法在寻找右孩子的过程中，把左子树构建出来，我们就能把寻找右孩子的复杂度 <code>$\Theta(k)$</code> 均摊到这 <code>$k$</code> 个左子树的元素上去，复杂度就变成了常数。要做到这一点，依赖于实现。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rebuildBST</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">int</span> bound = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::max())</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (preorder.size() == i <span class="keyword">or</span> preorder[i] &gt; bound) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">  ++i;</span><br><span class="line">  node-&gt;left = rebuildBST(preorder, node-&gt;val);</span><br><span class="line">  node-&gt;right = rebuildBST(preorder, bound);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，所有递归调用都共享同一个下标 <code>i</code>，它从 <code>0</code> 开始自增到 <code>preorder.size()</code> 后，所有递归退出。在每次递归调用中，除开构建结点的开销，都只有常数项的操作：至多两次比较，一次变量自增。因此，复杂度是 <code>$\Theta(n)$</code>。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>再多一点挑战：有没有办法用非递归的方式去实现这一算法呢？</p><p>既然会问出来，那答案肯定是「有」。</p><p>我们分析一下递归版本的代码。</p><ul><li>函数的默认参数 <code>std::numeric_limits&lt;int&gt;::max()</code> 实际上是为了简化代码实现，而引入的「哨兵」。</li><li>变量 <code>i</code> 在所有递归调用中共享，从 <code>0</code> 开始自增到 <code>preorder.size()</code> 后，所有递归退出，实际上起到了循环的作用。</li><li>每次递归调用中，<code>preorder</code> 是不变的，变化的只有 <code>bound</code>；它保证了在处理右子树之前，先处理完左子树的所有节点。</li></ul><p>因此，若要非递归地实现这一算法，我们需要：</p><ul><li>用某种方式，重新引入哨兵 <code>std::numeric_limits&lt;int&gt;::max()</code>；</li><li>循环，从 <code>0 -&gt; preorder.size()</code>；</li><li>提供一个栈，直接或间接地保存这里的 <code>bound</code>。</li></ul><p>于是有实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rebuildBST</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">  TreeNode* dummy = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::max());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">  s.push(dummy);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x : preorder) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(x);</span><br><span class="line">    TreeNode* wk = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (; s.top()-&gt;val &lt; x; wk = s.top(), s.pop()) &#123; ; &#125;</span><br><span class="line">    <span class="keyword">if</span> (wk == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      s.top()-&gt;left = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wk-&gt;right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode* res = dummy-&gt;left;</span><br><span class="line">  dummy-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">delete</span> dummy;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>dummy</code> 起到了哨兵的作用；<code>for (:)</code> 是上述提到的循环；<code>for (;;)</code> 里每一次弹栈，都意味着遇到了右孩子，对应递归版本中的 <code>return nullptr;</code>。</p><p>从非递归的版本中看时间复杂度是很明显的。<code>for (:)</code> 之外的内容只有常数复杂度，<code>for (:)</code> 循环之内的内容要重点分析 <code>for (;;)</code> 循环。<code>for (;;)</code> 循环每执行一次，都有一次 <code>s.pop()</code> 操作，它与 <code>s.push(node)</code> 一一对应。因此，有多少次 <code>s.push(node)</code> 就有多少次 <code>s.pop()</code>（不算 <code>s.push(dummy)</code>）。于是，均摊到每次 <code>for (:)</code> 循环中去，<code>for (;;)</code> 恰好只执行一次 <code>wk = s.top()</code> 和 <code>s.pop()</code>。于是 <code>for (:)</code> 之内的内容也只有常数复杂度。于是，这个实现的复杂度为 <code>$\Theta(n)$</code>。</p><p>这里非递归的实现，是从递归实现中变形出来的。但实际上，非递归的实现，也有其自身的含义。</p><p>首先看「栈」。由于是「前序遍历」，所以一个结点的祖辈结点一定在父辈节点之前。考虑到任何一个结点，都只和父亲节点直接建立联系，因此从前往后遍历 <code>preorder</code> 时，必然要用到栈结构，保存历代祖先。（笑死我）</p><p>然后看弹栈的循环。这实际上透露的是一种自底向上的思路：如果我遇到了一个结点，它是某个结点的左孩子，那么一定是刚才入栈的结点；如果它是某个结点的右孩子，这意味着这个节点的左子树都已经处理完了，就要依次弹栈。通过这样的方式，我们能找到每一个「孩子」的「父亲」是谁。与之对应，递归版本的实现，则是一种自顶向下的思路：我现在有一个结点，它的左孩子在哪里，你给我找出来（递归调用），找到之后再继续找它的右孩子（递归调用）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到这个问题，我们的分析从确定唯一性开始。运用二叉搜索树中序遍历元素有序的特点，我们借助「前序中序唯一确定二叉树」的定理，很快确定了唯一性。（这要感谢 <code>@linjie</code>）</p><p>顺着唯一性出发，我们马上确定了一种重建二叉树的方法，从而确定了一个时间复杂度上界。</p><p>在确定上界之后，我们会希望继续降低算法的时间复杂度。自然而然地，我们从已有的方法出发，寻找可能的改进点。由于我们手头只有前序遍历结果，自然地，我们就会去想中序遍历在已有算法中起到的作用是什么，并寻找其替代。</p><p>如此，我们自顶向下地，很容易地找到了上述递归实现。在转递归为非递归的过成功中，我们又发现了自底向上的解法。这促使我们在将来的日子里，在符合常规思维的「自顶向下」中，多去找找「自底向上」的解法，可能会有奇效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到一个有趣的问题：已知有一个无重复元素的二叉搜索树的前序遍历结果，要求重建该二叉搜索树。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="BST" scheme="https://liam.page/tags/BST/"/>
    
      <category term="Preorder Traversal" scheme="https://liam.page/tags/Preorder-Traversal/"/>
    
  </entry>
  
  <entry>
    <title>Beamer frame 中的抄录环境</title>
    <link href="https://liam.page/2019/08/26/verbatim-environments-and-frame-in-beamer/"/>
    <id>https://liam.page/2019/08/26/verbatim-environments-and-frame-in-beamer/</id>
    <published>2019-08-26T04:19:34.000Z</published>
    <updated>2019-08-27T09:43:08.993Z</updated>
    
    <content type="html"><![CDATA[<p>今天 <code>@Butui Hu</code> 在群里问了一个老问题：怎么在 Beamer 的 frame 当中使用 <code>minted</code> 环境？</p><p>这个问题的答案很简单：其实不论是 <code>minted</code> 还是 <code>lstlisting</code> 还是基本的 <code>verbatim</code>，这些「抄录」环境与 <code>frame</code> 联用时，统统都需要给 <code>frame</code> 加上 <code>fragile</code> 参数，形如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;frame&#125;</span><span class="string">[fragile]</span></span></span><br><span class="line"><span class="comment">% verbatim-like environment.</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;frame&#125;</span></span></span><br></pre></td></tr></table></figure><p>但问题是，为啥事情会变成这个样子？这篇文章简单讨论一下。</p><a id="more"></a><h2 id="抄录环境是怎么实现的？"><a href="#抄录环境是怎么实现的？" class="headerlink" title="抄录环境是怎么实现的？"></a>抄录环境是怎么实现的？</h2><p>首先我们要解决的第一个问题是，类似 <code>verbatim</code> 的抄录环境是怎么实现的？</p><p>基本上说，抄录环境有这么一些特征：</p><ul><li>使用等宽字符字族 <code>\ttfamily</code> 排版内容；</li><li>排版所有空格，而非<a href="/2018/01/31/TeX-by-Topic-the-Structure-of-the-TeX-processor/#%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5">让输入处理器进入 S 状态忽略空格</a>；</li><li>在每个回车处换行；</li><li>原样抄录<strong>每一个</strong>字符。</li></ul><p>当然，对于 <code>minted</code> 和 <code>lstlisting</code> 之类的环境，还会有为特定字符、词组渲染颜色的功能。但这些都是「锦上添花」，我们要关注的核心还是上面四条。</p><p>很显然，抄录环境对于输入内容的处理方式与正常内容的处理方式有很大差异。比如，反斜线 <code>\</code> 原本作为 TeX 默认的转义字符，此时却要原样输出。我们知道，TeX 中之所以有诸多特殊用途的字符（<code>\</code>, <code>{</code>, <code>}</code>, <code>$</code> 等等），其原因在于<a href="/2018/05/05/TeX-by-Topic-Category-Codes-and-Internal-States/">输入处理器读入内容时，会为每个字符分配分类码</a>。输入处理器会根据字符和字符的分类码，将输入内容处理成记号流（token stream），交由展开处理器继续处理。显然，抄录环境要改变 TeX 中特殊用途的字符的行为，就必须要改变他们的分类码。实际上，这些字符的分类码，在抄录环境中，都会被设置为 <code>12</code>（other）。</p><p>此外，为了恢复这些特殊用途的字符，TeX 要在合适的位置重新设置这些字符的分类码。对于 LaTeX 使用者来说，很显然这个「时机」就应该是 <code>\end{varbatim}</code> 出现时了。这个论断说对也对，说不对也不完全对。考虑到，进入抄录环境之后，诸如 <code>\</code> 的分类码已经改变，因此 <code>\end{varbatim}</code> 不会像正常的「结束环境」的标志那样被 TeX 识别并处理。于是，为了达到预期效果，你必须把 <code>\end{varbatim}</code> 单独成行，作为恢复分类码的标志。也就是说，<code>\end{varbatim}</code> 在这里起到的是一个纯粹的标志作用，而不是通常意义上「结束环境」的作用。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begingroup</span></span></span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span> `|=0 <span class="tag">\<span class="name">catcode</span></span> `[= 1 <span class="tag">\<span class="name">catcode</span></span>`]=2</span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span> `<span class="tag">\<span class="name">&#123;</span>=<span class="number">12</span></span> <span class="tag">\<span class="name">catcode</span></span> `<span class="tag">\<span class="name">&#125;</span>=<span class="number">12</span></span> <span class="tag">\<span class="name">catcode</span></span>`<span class="tag">\<span class="name">\</span>=<span class="number">12</span></span></span><br><span class="line">|gdef|@xverbatim#1<span class="tag">\<span class="name">end</span><span class="string">&#123;verbatim&#125;</span><span class="string">[#1|end[verbatim]</span></span>]</span><br><span class="line">|gdef|@sxverbatim#1<span class="tag">\<span class="name">end</span><span class="string">&#123;verbatim*&#125;</span><span class="string">[#1|end[verbatim*]</span></span>]</span><br><span class="line">|endgroup</span><br></pre></td></tr></table></figure><p>上面这段代码是 LaTeX2e 中有关抄录环境结束的命令的定义。在由 <code>begingroup</code> 和 <code>endgroup</code> 形成的 semi-group 分组中，我们将 <code>|</code> 定义为转义字符（<code>0</code>），<code>[]</code> 分别定义为分组开始和结束的字符（<code>1</code>, <code>2</code>），然后把 <code>{}\</code> 都定义为「其他字符」（<code>12</code>）。虽有，用 <code>|gdef</code>（相当于平时的 <code>\gdef</code>）超出 semi-group 的范围，定义控制序列 <code>@xverbatim</code>，它接受 1 个参数，这个参数以 <code>\end{verbatim}</code> 这串字符结尾，同时将它的内容替换成实际内容 <code>#1</code>，以及有实际含义的 <code>|end[verbatim]</code>（后者会被展开成 <code>\endverbatim</code> 命令，负责真正的「结束环境」的工作）。</p><p>一顿操作猛如虎，最终还靠分类码。而最最重要的是我们得知道，<strong>分类码是由输入处理器在读入文件时设置的</strong>。</p><h2 id="脆弱命令是怎么回事？"><a href="#脆弱命令是怎么回事？" class="headerlink" title="脆弱命令是怎么回事？"></a>脆弱命令是怎么回事？</h2><p>在输入处理器把文本流变成记号流之后，展开处理器和执行处理器就开始工作啦！通常来说，展开处理器会拼了老命将记号展开成更加底层的记号，直到不可展开，然后执行处理器开始执行各个不可展开的底层记号。</p><p>但某些情况下，这个流程会有问题。其中一个典型的例子，就是所谓的「移动参数」问题。</p><p>考虑 <code>\section{}</code> 命令。它做四件事：</p><ol><li>编号自增 1</li><li>输出章节标题</li><li>处理目录（和 PDF 书签）</li><li>做页眉的章节标记</li></ol><p>其中 (3) 依赖于将标题内容和编号写入 <code>&lt;jobname&gt;.toc</code> 文件，当 TeX 第二遍编译时，从 <code>&lt;jobname&gt;.toc</code> 文件读入内容再去排版目录。也就是说，此类命令的具体含义在两次编译过程中是不一样的，而具体它是什么含义（最终效果），要等排版完成之后才能确定。</p><p>问题在于：</p><ol><li>TeX 在写文件时，会将宏——此处特别注意 <code>\section{}</code> 参数中可能包含的宏——完全展开；</li><li>但完全展开写入文件之后，又要重新为 TeX 所读入，这时可能造成奇怪的错误。</li></ol><blockquote><p>比方说，<code>\(\)</code> 展开后会包含很多带有 <code>@</code> 的内容，如果将这些内容写入文件，再重新读入，就会因为 <code>@</code> 的分类码是 <code>12</code> 而非 <code>11</code> 不能作为控制序列的一部分而报错。</p></blockquote><p>我们将提前展开和延后展开的最终效果不一样的命令，称之为脆弱命令（fragile commands）。与之对应的，就是健壮命令（robust commands）。</p><h2 id="这和-frame-有什么关系？"><a href="#这和-frame-有什么关系？" class="headerlink" title="这和 frame 有什么关系？"></a>这和 <code>frame</code> 有什么关系？</h2><p>为此我们需要查看 Beamer 的文档。文档 12.9 节提到：</p><blockquote><p>If you wish to use a <code>{verbatim}</code> environment in a <code>frame</code>, you have to add the option <code>[fragile]</code> to the <code>{frame}</code> environment. In this case, <code>[...]</code> and the <code>\end{frame}</code> must be alone on a single line. Using this option will cause the frame contents to be written to an external file and the read back.</p></blockquote><p>这段提到了在 <code>frame</code> 当中使用抄录环境，必须制定 <code>fragile</code> 参数。但仍然没有解释「为啥要用」。继续找到文档 8.1 节：</p><blockquote><p>If a frame contains fragile text, different internal mechanisms are used to typeset the frame to ensure that inside the frame the character codes can be reset. The price of switching to another internal mechanism is that either you cannot use overlays or an external file needs to be written and read back (which is not always desirable).</p><p>In detail, the following happens when this option is given for normal (pdf)LaTeX: The contents of the frame is scanned and then written to a special file named <code>⟨jobname⟩.vrb</code> or, if a label has been assigned to the frame, <code>⟨jobname⟩.⟨current frame number⟩.vrb</code>. Then, the frame is started anew and the content of this file is read back. Since, upon reading of a file, the character codes can be modified, this allows you to use both verbatim text and overlays.</p><p>To determine the end of the frame, the following rule is used: The first occurence of a single line containing exactly <code>\end{⟨frame environment name⟩}</code> ends the frame. The <code>⟨environment name⟩</code> is normally <code>frame</code>, but it can be changed using the <code>environment</code> option. This special rule is needed since the frame contents is, after all, not interpreted when it is gathered.</p></blockquote><p>这样我们就明白了。<code>frame</code> 在某种程度上限制了环境内容对分类码的修改。因此，对于抄录环境这样需要修改分类码来实现目的的「脆弱内容」，我们要指定 <code>fragile</code> 参数，然后 Beamer 会将这些内容写入到外部文件（为此 <code>frame</code> 环境变成了脆弱命令）。然后，在再次读入这些内容时，让输入处理器有机会正确处理分类码。如此一来，才能顾全这些「脆弱内容」的渲染，和 Beamer 的 <code>overlay</code> 效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天 &lt;code&gt;@Butui Hu&lt;/code&gt; 在群里问了一个老问题：怎么在 Beamer 的 frame 当中使用 &lt;code&gt;minted&lt;/code&gt; 环境？&lt;/p&gt;
&lt;p&gt;这个问题的答案很简单：其实不论是 &lt;code&gt;minted&lt;/code&gt; 还是 &lt;code&gt;lstlisting&lt;/code&gt; 还是基本的 &lt;code&gt;verbatim&lt;/code&gt;，这些「抄录」环境与 &lt;code&gt;frame&lt;/code&gt; 联用时，统统都需要给 &lt;code&gt;frame&lt;/code&gt; 加上 &lt;code&gt;fragile&lt;/code&gt; 参数，形如：&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;\&lt;span class=&quot;name&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;[fragile]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;% verbatim-like environment.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;\&lt;span class=&quot;name&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但问题是，为啥事情会变成这个样子？这篇文章简单讨论一下。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Beamer" scheme="https://liam.page/tags/Beamer/"/>
    
      <category term="Verbatim" scheme="https://liam.page/tags/Verbatim/"/>
    
      <category term="Fragile" scheme="https://liam.page/tags/Fragile/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 上挂载/卸载磁盘</title>
    <link href="https://liam.page/2019/08/23/mount-and-unmount-disk-in-Linux/"/>
    <id>https://liam.page/2019/08/23/mount-and-unmount-disk-in-Linux/</id>
    <published>2019-08-23T06:30:19.000Z</published>
    <updated>2019-08-27T09:43:08.992Z</updated>
    
    <content type="html"><![CDATA[<p>昨天正在训练线上模型的机器被人误操作，不得不重做系统。万幸模型相关的训练状态保存在另一块磁盘上，没有受到影响。要想恢复训练状态相关数据，就必须把磁盘挂载好。因为这个操作不常用，一时居然都没想起来怎么做。因此这里「烂笔头」记录下来。</p><a id="more"></a><h2 id="查看机器上的磁盘"><a href="#查看机器上的磁盘" class="headerlink" title="查看机器上的磁盘"></a>查看机器上的磁盘</h2><p><code>fdisk</code> 是 Linux 上用来操作磁盘分区表的工具。使用 <code>fdisk -l</code> 命令，可以列出系统识别的所有磁盘及其分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 599.1 GB, 599051206656 bytes, 1170021888 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 262144 bytes / 262144 bytes</span><br><span class="line">Disk label type: # masked</span><br><span class="line">Disk identifier: # masked</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048   204802047   102400000   83  Linux</span><br><span class="line">/dev/sda2       204802048   213190655     4194304   82  Linux swap / Solaris</span><br><span class="line">/dev/sda3   *   213190656  1170020351   478414848   83  Linux</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 6118.5 GB, 6118546079744 bytes, 11950285312 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 262144 bytes / 262144 bytes</span><br></pre></td></tr></table></figure><p><code>/dev</code> 目录下的 <code>sd?</code> 即是物理磁盘。例如 <code>sda</code> 是系统读到的第一块磁盘，<code>sdb</code> 则是第二块磁盘。在较老的 kernel 中，由于没有 ATA 支持，因此物理磁盘可能是 <code>/dev/hd?</code>（IDE）或者是 <code>/dev/sd?</code>（SCSI）。</p><p><code>/dev/sda?</code> 则是 <code>sda</code> 这块物理磁盘上的分区。<code>/dev/sda1</code> 是该磁盘上的第一块分区。</p><p>这里 <code>/dev/sdb</code> 这块磁盘尚未被正确挂载，而正是它保存了所需的数据。</p><h2 id="创建挂载点"><a href="#创建挂载点" class="headerlink" title="创建挂载点"></a>创建挂载点</h2><p>在挂载磁盘之前，首先要为它创建一个挂载点。挂载点说白了是一个目录，在执行 <code>mount</code> 命令挂载前，它必须是已经存在的目录。挂载成功后，访问该目录即可访问相应磁盘的内容。若挂载前挂载点中存在内容，则挂载后这些内容暂不可见，当卸载后这些内容又会变得可见。</p><p>比如我想将磁盘挂载于 <code>/mnt/data</code> 就要创建这样一个空目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/data</span><br></pre></td></tr></table></figure><h2 id="确定磁盘文件系统类型"><a href="#确定磁盘文件系统类型" class="headerlink" title="确定磁盘文件系统类型"></a>确定磁盘文件系统类型</h2><p>在挂载磁盘之前，还需要确定磁盘（分区）的文件系统类型。若不然，挂载时选错文件系统类型可能造成一系列奇怪的现象。为此，我们需要执行 <code>parted -l</code> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> parted -l</span></span><br><span class="line">Model: # masked</span><br><span class="line">Disk /dev/sda: 599GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End    Size    Type     File system     Flags</span><br><span class="line"> 1      1049kB  105GB  105GB   primary  xfs</span><br><span class="line"> 2      105GB   109GB  4295MB  primary  linux-swap(v1)</span><br><span class="line"> 3      109GB   599GB  490GB   primary  xfs             boot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: # masked</span><br><span class="line">Disk /dev/sdb: 6119GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: loop</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start  End     Size    File system  Flags</span><br><span class="line"> 1      0.00B  6119GB  6119GB  ext4</span><br></pre></td></tr></table></figure><p>由此可见，目标磁盘 <code>/dev/sdb</code> 的文件系统类型是 <code>ext4</code>。</p><h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><p>此时，我们就能挂载磁盘了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext4 /dev/sdb /mnt/data</span><br></pre></td></tr></table></figure><p>这里 <code>-t ext4</code> 表示目标磁盘（分区）的文件系统类型是 <code>ext4</code>，<code>/dev/sdb</code> 是待挂载的磁盘（分区），<code>/mnt/data</code> 是目标挂载点。</p><h2 id="卸载磁盘"><a href="#卸载磁盘" class="headerlink" title="卸载磁盘"></a>卸载磁盘</h2><p>与 <code>mount</code> 相对的命令是 <code>umount</code>。注意是 <code>umount</code> 而不是 <code>unmount</code>——没有那个 <code>n</code>。</p><p>卸载时，给 <code>umount</code> 的参数可以是挂载点，也可以是磁盘（分区）的名字。在这里，以下两种操作等价：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sdb</span><br><span class="line">umount /mnt/data</span><br></pre></td></tr></table></figure><p>若是希望挂载的磁盘正在被其他进程读写，则 Linux 会提示 <code>device is busy</code>。此时，可以执行 <code>umount -l</code> 命令，让 Linux 在无其他进程读写目标磁盘时，再行卸载。或者，也可以用 <code>ps</code> 命令查看使用该磁盘的进程有哪些，然后妥当处理后再卸载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天正在训练线上模型的机器被人误操作，不得不重做系统。万幸模型相关的训练状态保存在另一块磁盘上，没有受到影响。要想恢复训练状态相关数据，就必须把磁盘挂载好。因为这个操作不常用，一时居然都没想起来怎么做。因此这里「烂笔头」记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
      <category term="Disk" scheme="https://liam.page/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>找到两个有序数组的中位数</title>
    <link href="https://liam.page/2019/08/22/find-median-of-two-sorted-arrays/"/>
    <id>https://liam.page/2019/08/22/find-median-of-two-sorted-arrays/</id>
    <published>2019-08-22T04:08:21.000Z</published>
    <updated>2019-08-27T09:43:08.991Z</updated>
    
    <content type="html"><![CDATA[<p>这是 LeetCode 的<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">第 4 题</a>，<code>@linjie</code> 问到我说，这题网上的解答看完都迷迷糊糊的，希望我能写篇博客重新讲一下。于是有此篇。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现有不同时为空的非降序排列的数组 <code>A</code> 和 <code>B</code>，其长度分别是 <code>m</code> 和 <code>n</code>。不失一般性，假设 <code>m &lt;= n</code>。记 <code>A</code> 和 <code>B</code> 的中位数为 <code>x</code>。要求写代码实现，在 <code>$\Theta(\log(m + n))$</code> 的时间复杂度内找到 <code>x</code>。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>见到时间复杂度要求中有 <code>$\log$</code>，就肯定要想到二分搜索。</p><p>二分搜索的本质是在一个有序 randomly accessible array 中，寻找一个满足某种跟元素顺序相关的条件的元素的方法。这个「跟元素顺序相关的条件」，在最初的版本里是「等于某个数值」，扩展版本可以是「第一个不小于给定数值的值」之类的（参考<a href="https://liam.page/2018/11/23/binary-search-and-its-variants/">前作</a>）。展开来说，满足以下 4 个要素时，可以用到二分搜索：</p><ul><li>array 只有 1 个，或者可以将多个 array 问题简化成 1 个 array 的问题；</li><li>array 是 randomly accessible 的；</li><li>array 是有序的；</li><li>搜索 array 中的元素时，限制条件是跟元素顺序有关的。</li></ul><p>因此，为了利用二分搜索，我们必须要想办法：</p><ol><li>变两个序列的问题为 1 个序列的问题；</li><li>找到某个「跟元素顺序相关的条件」。</li></ol><p>首先考虑 (1)。</p><p>设 <code>i</code> 是 <code>A</code> 中的下标，而 <code>j</code> 是 <code>B</code> 中的下标：<code>A[i]</code> 是 <code>A</code> 中第一个大于等于中位数 <code>x</code> 的元素；同时 <code>B[j]</code> 是 <code>B</code> 中第一个大于等于中位数 <code>x</code> 的元素。当 <code>A</code> 中元素全部小于 <code>x</code> 时，<code>i = m</code>；同理，当 <code>B</code> 中元素全部小于 <code>x</code> 时，<code>j = n</code>。</p><p>这意味着，<code>A</code> 中小于 <code>x</code> 的元素数量为 <code>i</code>，<code>B</code> 中小于 <code>x</code> 的元素数量为 <code>j</code>；<code>A</code> 中大于等于 <code>x</code> 的元素数量为 <code>m - i</code>，<code>B</code> 中大于等于 <code>x</code> 的元素数量为 <code>n - j</code>。满足条件：</p><ul><li>当 <code>m + n</code> 是偶数：<code>i + j = (m - i) + (n - j)</code>，此时 <code>j = (m + n) / 2 - i</code>。</li><li>当 <code>m + n</code> 是奇数：<code>i + j = (m - i) + (n - j) - 1</code>，此时 <code>j = (m + n - 1) / 2 - i = (m + n) / 2 - i</code>（考虑整数除法除不尽时向零取整）。</li></ul><p>所以 <code>j</code> 有统一的表达式 <code>(m + n) / 2 - i</code>。这样一来，我们就建立了两个序列下标之间的对应关系，从而将两个序列的问题变为了 1 个序列的问题。</p><p>接着考虑 (2)。</p><p>考虑 <code>x</code> 是中位数，而 <code>A[i]</code> 和 <code>B[j]</code> 分别是 <code>A</code> 和 <code>B</code> 两个序列中第一个大于等于中位数 <code>x</code> 的元素。因此有：</p><ol><li><code>A[i - 1] &lt; x &lt;= A[i]</code>；</li><li><code>A[i - 1] &lt; x &lt;= B[j]</code>；</li><li><code>B[j - 1] &lt; x &lt;= A[i]</code>；</li><li><code>B[j - 1] &lt; x &lt;= B[j]</code>。</li></ol><p>其中 (1) 和 (4) 是 trivial 的。考虑 (2) 和 (3)，即得到目标「条件」：<code>(i == 0 or A[i - 1] &lt; x &lt;= B[j]) and (i == m or B[j - 1] &lt; x &lt;= A[i])</code>。</p><p>因此有伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, m + 1):</span><br><span class="line">  bsearch to find i, s.t.:</span><br><span class="line">    (i == 0 or A[i - 1] &lt; x &lt;= B[j]) and (i == m or B[j - 1] &lt; x &lt;= A[i])</span><br><span class="line"></span><br><span class="line">if (m + n) % 2 == 0:</span><br><span class="line">  # carefully handle index out-of-bound</span><br><span class="line">  return static_cast&lt;double&gt;(max(A[i - 1], B[j - 1]) + min(A[i], B[j])) / 2.0</span><br><span class="line">else:</span><br><span class="line">  # carefully handle index out-of-bound</span><br><span class="line">  return min(A[i], B[j])</span><br></pre></td></tr></table></figure><p>算法的时间复杂度是 <code>$\Theta(\log(\min(m, n)))$</code>，空间复杂度是 <code>$\Theta(1)$</code>。</p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h2><p>给一个 C++ 版本的完整实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> findMedianInSortedArray(B);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> findMedianInSortedArray(A);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> bsearchWrapper(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">findMedianInSortedArray</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = v.size();</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v[len / <span class="number">2</span>] + v[len / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> v[len / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">bsearchWrapper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> m = A.size(), n = B.size();</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">return</span> bsearchHelper(A, B);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> bsearchHelper(B, A);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">bsearchHelper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> m = A.size(), n = B.size();</span><br><span class="line">    <span class="keyword">size_t</span> left = <span class="number">0</span>, right = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      i = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      j = (m + n) / <span class="number">2</span> - i;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">not</span>(i == m <span class="keyword">or</span> B[j - <span class="number">1</span>] &lt; A[i])) &#123;</span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">not</span>(i == <span class="number">0</span> <span class="keyword">or</span> A[i - <span class="number">1</span>] &lt; B[j])) &#123;</span><br><span class="line">        right = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">double</span> mx = (i == m) ? B[j] : ((j == n) ? A[i] : <span class="built_in">std</span>::min(A[i], B[j]));</span><br><span class="line">      <span class="keyword">double</span> mn = (i == <span class="number">0</span>) ? B[j - <span class="number">1</span>] : ((j == <span class="number">0</span>) ? A[i - <span class="number">1</span>] : <span class="built_in">std</span>::max(A[i - <span class="number">1</span>], B[j - <span class="number">1</span>]));</span><br><span class="line">      <span class="keyword">return</span> (mn + mx) / <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (i == m) ? B[j] : ((j == n) ? A[i] : <span class="built_in">std</span>::min(A[i], B[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 LeetCode 的&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第 4 题&lt;/a&gt;，&lt;code&gt;@linjie&lt;/code&gt; 问到我说，这题网上的解答看完都迷迷糊糊的，希望我能写篇博客重新讲一下。于是有此篇。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="LeetCode" scheme="https://liam.page/tags/LeetCode/"/>
    
      <category term="bsearch" scheme="https://liam.page/tags/bsearch/"/>
    
  </entry>
  
  <entry>
    <title>使用 vimdiff 时忽略白空格的修改</title>
    <link href="https://liam.page/2019/08/06/ignnore-white-space-differences-when-using-vimdiff/"/>
    <id>https://liam.page/2019/08/06/ignnore-white-space-differences-when-using-vimdiff/</id>
    <published>2019-08-06T14:07:12.000Z</published>
    <updated>2019-08-27T09:43:08.989Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>vimdiff</code> 能够方便地观察多个文件之间的异同。但有时我们会希望 VIM 忽略白空格的变化。比如，对于 Python 脚本，有时我们会修改缩进来对代码进行格式化；此时对比新旧文件之间的差异时，我们更多地是希望看看有没有手误修改了其他不应修改的部分，从而应当忽略白空格的变化。</p><p>这篇文章简单记录一下这个问题的解法。</p><a id="more"></a><p>这个问题其实不难解决，只需在 <code>vimrc</code> 中加入以下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> diffopt+=iwhite</span><br></pre></td></tr></table></figure><p>不过，这样设定也会影响到 VIM 正常编辑时所处的模式。如果希望这一设定只限定在 <code>vimdiff</code> 模式，则可以这样修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &amp;diff</span><br><span class="line">    <span class="built_in">set</span> diffopt+=iwhite</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>若是想要自由切换，则可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &amp;diff</span><br><span class="line">  map gs :call IwhiteToggle()&lt;CR&gt;</span><br><span class="line">  <span class="keyword">function</span>! IwhiteToggle()</span><br><span class="line">    <span class="keyword">if</span> &amp;diffopt =~ <span class="string">'iwhite'</span></span><br><span class="line">      <span class="built_in">set</span> diffopt-=iwhite</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">set</span> diffopt+=iwhite</span><br><span class="line">    endif</span><br><span class="line">  endfunction</span><br><span class="line"> endif</span><br></pre></td></tr></table></figure><p>最后，若不想修改 <code>vimrc</code> 可以在命令行这样启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff -c <span class="string">'set diffopt+=iwhite'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;vimdiff&lt;/code&gt; 能够方便地观察多个文件之间的异同。但有时我们会希望 VIM 忽略白空格的变化。比如，对于 Python 脚本，有时我们会修改缩进来对代码进行格式化；此时对比新旧文件之间的差异时，我们更多地是希望看看有没有手误修改了其他不应修改的部分，从而应当忽略白空格的变化。&lt;/p&gt;
&lt;p&gt;这篇文章简单记录一下这个问题的解法。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="VIM" scheme="https://liam.page/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>科技论文中的图片</title>
    <link href="https://liam.page/2019/07/30/figures-in-scitech-papers/"/>
    <id>https://liam.page/2019/07/30/figures-in-scitech-papers/</id>
    <published>2019-07-30T02:35:07.000Z</published>
    <updated>2019-08-27T09:43:08.978Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说「一图胜千言」。图片带来的信息量往往远超同样面积文字带来的信息量——君不见，「看图说话」这一技能从小学开始一直训练到大学甚至研究生阶段。可见图片是论文写作中很重要的一环。</p><p>另一方面，图片无处不在；普通用户从刚接触计算机开始，就接触了很多的图片。对于司空见惯的事物，人们往往会「自我感觉良好」而忽略了其中的很多细节。这种忽略，造成了论文写作中千奇百怪的图片问题。</p><p>这篇文章受邀就图片的格式和分辨率做一些展开讨论，希望能帮助读者避免一些坑。</p><a id="more"></a><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>图片的格式多种多样，最常见的有 <code>jpg</code>, <code>png</code>, <code>gif</code> 等。在具体讨论这些图片格式之前，首先我们要讨论一下矢量图和位图的区别。</p><table><thead><tr><th></th><th>矢量图</th><th>位图</th></tr></thead><tbody><tr><td>表示图像的方法</td><td>用点、直线、多边形表示</td><td>用像素表示</td></tr><tr><td>保存的信息</td><td>只需要保存点、距离、线条颜色、填充颜色等信息，文件体积小</td><td>需要保存每个像素的颜色信息，文件体积大</td></tr><tr><td>缩放</td><td>放大或缩小不会失真</td><td>放大到一定程度时会失真</td></tr><tr><td>常见格式</td><td><code>ai</code>, <code>eps</code>, <code>pdf</code>, <code>svg</code>, <code>dwg</code>, <code>dxf</code>, <code>cdr</code>, <code>emf</code></td><td><code>bmp</code>, <code>jpg</code>, <code>png</code>, <code>gif</code>, <code>tif(f)</code></td></tr></tbody></table><p>显然，因为矢量图的种种优异特性，在有选择余地时，我们应当优先选择矢量图作为论文插图格式。</p><p>这里需要注意的一点是，虽然诸如 <code>eps</code> 格式的图片支持矢量图，但并不是所有格式为 <code>eps</code> 的图片都是矢量图。这是因为，出于兼容性考虑，往往支持矢量图的格式，也能够用来保存位图。因此，</p><ul><li>位图格式的图片，一定是位图；</li><li>矢量图格式的图片，可能是矢量图，也可能是位图，需要仔细判断。</li></ul><p>对于 LaTeX 用户来说，建议的图片格式顺序如下：</p><ul><li><code>pdf</code>：PDF 格式支持矢量图，并且一般用 LaTeX 输出的就是 PDF 格式的文档，兼容性相对最好。</li><li><code>png</code>：PNG 格式是位图里信息丢失较少的格式，因此推荐。</li><li><code>jpg</code>：对于「照片」类图片资源，使用 JPG 格式也是可以接受的。</li><li><code>eps</code>：EPS 格式可以支持矢量图，但由于历史原因，和 EPS 格式相关的问题很多，因此除非在期刊有要求的情况下，不推荐使用 EPS 格式的图片。</li></ul><h2 id="图片分辨率"><a href="#图片分辨率" class="headerlink" title="图片分辨率"></a>图片分辨率</h2><p><img src="/uploads/images/LaTeX/resolution_illustration.png" alt></p><p>分辨率这个概念用处比较多。对于图片来说有分辨率，对于显示器来说有分辨率，对于打印机、光学鼠标、扫描仪等来说也有分辨率。因此分辨率这个概念，粗看好像很容易理解，细细一想也是蛮让人头疼的。</p><p>要确切地理解分辨率，就要从源头开始，搞清楚为什么会设定这样一个概念。</p><p>抛开量子力学来说，普通人能接触到的自然世界的物体，都可以认为是连续的。但是，在涉及到图像处理时，由于硬件的限制，计算机往往很难用连续的办法描绘、应用图像。这种情况下，人们就发明了「像素」这个概念——用一个像素来描绘像素内的平均图像信息。——这其实是「模拟信号」和「数字信号」的关系。这样一来，当单个像素面积趋向于无穷小时，计算机描绘的整体图像就趋近于真实情况。反过来说，单位面积的像素趋向于无穷大时，计算机描绘的整体图像就趋向于真实情况。</p><p>请注意，这里用了「描绘」这样一个相对来说比较模糊的词。这是为了让这一阐述能够适应多个涉及到图像处理的情况。</p><ul><li>对于位图，「描绘」就简单地指位图所记录的图像信息。显然像素越小，图像信息的细节就越丰富。</li><li>对于显示器，「描绘」指显示器对图像信息的「呈现」。显然像素越小，显示器描绘的图像就越逼真。</li><li>对于打印机，「描绘」侧重打印时对图像细节信息的重现。显然像素越小，打印机的打印结果就越清晰。</li><li>对于光学鼠标、扫描仪、感光设备，「描绘」侧重对图像光学信号的「捕捉」。显然像素越小，光学鼠标、扫描仪、感光设备就越灵敏。</li></ul><p>小结一下，由于计算机很难直接处理模拟信号，因此不得不借用像素这个概念将图像信息转换成数字信号。因此，计算机内部处理的图像数据对真实情况描绘得越精确，就要求像素越小，也就是单位面积像素的数量越高。</p><p>于是，我们将单位长度（通常以英寸计）内像素数量 ppi 作为分辨率的单位。在感光设备上，我们也用单位长度内感光元件（点）的数量 dpi 作为分辨率的单位。值得一提的是，感光元件（点）一般来说最终会一一对应到像素上。因此在不严肃的场合下，ppi 和 dpi 可以认为是同一单位。</p><p>接下来的问题是，在科技论文写作过程中，如果无法提供矢量图——因为矢量图永远是足够清晰的——而只能提供位图，我们提供多高分辨率的图片比较合适呢？与直觉可能相反：图像本身的细节越丰富，则投稿时图像所需的分辨率越低。这是因为，图像本身的细节丰富，意味着图像本身携带信息的冗余度较高。这时因为分辨率下降而带来的信息损失，对于阅读来说不容易造成坏的影响。按照以往经验，推荐的分辨率如下表所示。</p><table><thead><tr><th>图像细节丰富程度</th><th>建议的分辨率</th></tr></thead><tbody><tr><td>细节丰富的彩色、灰度图</td><td>300ppi</td></tr><tr><td>以色块区分的图表</td><td>600ppi</td></tr><tr><td>以单纯线条区分的黑白图表</td><td>1200 ppi</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说「一图胜千言」。图片带来的信息量往往远超同样面积文字带来的信息量——君不见，「看图说话」这一技能从小学开始一直训练到大学甚至研究生阶段。可见图片是论文写作中很重要的一环。&lt;/p&gt;
&lt;p&gt;另一方面，图片无处不在；普通用户从刚接触计算机开始，就接触了很多的图片。对于司空见惯的事物，人们往往会「自我感觉良好」而忽略了其中的很多细节。这种忽略，造成了论文写作中千奇百怪的图片问题。&lt;/p&gt;
&lt;p&gt;这篇文章受邀就图片的格式和分辨率做一些展开讨论，希望能帮助读者避免一些坑。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Graphics" scheme="https://liam.page/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>谈谈红眼睛悖论</title>
    <link href="https://liam.page/2019/07/27/the-paradox-of-red-eyes/"/>
    <id>https://liam.page/2019/07/27/the-paradox-of-red-eyes/</id>
    <published>2019-07-27T09:26:19.000Z</published>
    <updated>2019-08-27T09:43:08.976Z</updated>
    
    <content type="html"><![CDATA[<p>华人数学家陶哲轩曾经设计了这么一个有趣的思维实验：</p><ul><li>一个村子里有 100 聪明人；</li><li>100 人中，有 5 人眼睛是红色的，其余 95 人的眼睛是蓝色的；</li><li>村子里禁止讨论「眼睛颜色」这个话题；</li><li>通过任何方式知道自己眼睛颜色的人，第二天必须在村子中心的广场上公开自杀。</li></ul><p>现在有一个路过的外乡人看到村子之后，公开说了这么一句话：「村子里存在红眼睛的人」。然后，5 天后，村子里红眼睛的人就在村子中心的广场上集体自杀了。</p><p>这篇文章讨论这个有趣的思维实验。</p><a id="more"></a><h2 id="自杀的原因"><a href="#自杀的原因" class="headerlink" title="自杀的原因"></a>自杀的原因</h2><p>这一节里，我们来解惑，为什么外乡人宣布「村子里存在红眼睛的人」之后 5 天，这些人就集体自杀。这里我们要用到曾经用到过的<a href="/2018/11/07/pirates-and-golds-and-president-Trump/#%E9%80%86%E5%90%91%E6%8E%A8%E7%90%86">逆向推理</a>。</p><h3 id="只有-1-人红眼睛"><a href="#只有-1-人红眼睛" class="headerlink" title="只有 1 人红眼睛"></a>只有 1 人红眼睛</h3><p>首先我们假设，村子里有 99 人眼睛是蓝色的，只有 1 人眼睛是红色的。我们记他为 A。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，A 发现村子里其他人的眼睛都不是红色的，那么自己的眼睛肯定是红色的。因此，</li><li>在外乡人离开后的第 1 天，A 自杀了。</li></ul><h3 id="有-2-人红眼睛"><a href="#有-2-人红眼睛" class="headerlink" title="有 2 人红眼睛"></a>有 2 人红眼睛</h3><p>这一次我们假设，村子里有 98 人眼睛是蓝色的，只有 2 人眼睛是红色的。我们记他为 A 和 B。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，以 A 为例：在他看来，如果自己的眼睛不是红色的，那么 B 明天就该自杀了，自己则平安无事。考虑到 A 和 B 地位等同，于是</li><li>在外乡人离开后的第 1 天，平安无事，无人自杀。这回，A 开始犯嘀咕了：B 没有自杀，那么我的假设就错了，那么我的眼睛就是红色的，我明天得自杀了。考虑到 A 和 B 地位等同，因此，</li><li>在外乡人离开后的第 2 天，A 和 B 自杀了。</li></ul><h3 id="有-3-人红眼睛"><a href="#有-3-人红眼睛" class="headerlink" title="有 3 人红眼睛"></a>有 3 人红眼睛</h3><p>这一次我们假设，村子里有 97 人眼睛是蓝色的，只有 3 人眼睛是红色的。我们记他为 A、B 和 C。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，以 A 为例：如果自己的眼睛不是红色，那么村子里有 2 人红眼睛，情况回到了上一小节描述的那样：B 和 C 应该在外乡人离开后的第 2 天自杀，自己则平安无事。考虑到 A、B 和 C 地位等同，于是，</li><li>在外乡人离开后的第 2 天，平安无事，无人自杀。这回，A 开始犯嘀咕了：B 和 C 没有自杀，那么我的假设就错了，那么我的眼睛就是红色的，我明天得自杀了。考虑到 A、B 和 C 地位等同，因此，</li><li>在外乡人离开后的第 3 天，A、B 和 C 自杀了。</li></ul><h3 id="有-k-人红眼睛"><a href="#有-k-人红眼睛" class="headerlink" title="有 $k$ 人红眼睛"></a>有 $k$ 人红眼睛</h3><p>这一次我们假设，村子里有 $100 - k$ 人眼睛是蓝色的，只有 $k$ 人眼睛是红色的。我们记他为 A 和他的红眼睛小伙伴们。在这种情况下，外乡人公开宣布「村子里存在红眼睛的人」。于是：</p><ul><li>在外乡人离开的当天，以 A 为例：如果自己的眼睛不是红色，那么村子里有 <code>$k - 1$</code> 人红眼睛：这些红眼睛的小伙伴们应该在外乡人离开后的第 <code>$k - 1$</code> 天自杀，自己则平安无事。考虑到 A 和他的小伙伴们地位等同，于是，</li><li>在外乡人离开后的第 <code>$k - 1$</code> 天，平安无事，无人自杀。这回，A 开始犯嘀咕了：红眼睛的小伙伴们没有自杀，那么我的假设就错了，那么我的眼睛就是红色的，我明天得自杀了。考虑到 A 和他的小伙伴们地位等同，因此，</li><li>在外乡人离开后的第 <code>$k$</code> 天，A 和他的小伙伴们自杀了。</li></ul><p>当 $k = 5$ 时，就是陶哲轩思维实验中的情况。</p><h2 id="悖论"><a href="#悖论" class="headerlink" title="悖论"></a>悖论</h2><p>藏在这个思维实验中的悖论在于这个外乡人。在外乡人自己看来：这个存在本来就有红眼睛的人，而且每个人都知道这一点；那么自己的言论并没有带来新的信息，因此红眼睛的小伙伴们自杀跟我无关。但是显然，思维实验中的 5 个红眼睛的人自杀，必然经历了「我发现自己的眼睛是红色的」这样的过程。也就是说，他们从外乡人的言论里获得了新的信息。显然，这是一个悖论。</p><p>那么这是怎么一回事呢？</p><h3 id="平凡的情况"><a href="#平凡的情况" class="headerlink" title="平凡的情况"></a>平凡的情况</h3><p>对于平凡的情况，也就是 <code>$k = 1$</code> 的情况，这个悖论很好解释。当 <code>$k = 1$</code> 时，红眼睛的 A 原本是不知道村子里有红眼睛的人的。此时外乡人的言论就给 A 带来了新的信息量。</p><h3 id="非平凡的情况"><a href="#非平凡的情况" class="headerlink" title="非平凡的情况"></a>非平凡的情况</h3><p>对于非平凡的情况，也就是 <code>$k \geq 2$</code> 的情况，这个悖论就不那么好解释了。为了解释这个悖论，这里引入两个概念：</p><ul><li>共有信息：在一个群体里，如果每个人都知道某个信息，那么这个信息就是这个群体的共有信息。</li><li>公共信息：在一个群体里，如果每个人都确定其他所有人知道某个共有信息，那么这个信息就是公共信息。</li></ul><p>对于信息本身来说，从共有信息到公共信息的转变过程中，信息量没有变化。因为信息还是那个信息。但对于持有共有信息的群体来说，一个信息从共有信息到公共信息的转变过程中，群体持有的信息量是增加了的。因为群体从「不知道别人知道」变成了「知道别人知道」。</p><p>如此一来，我们就能解释这个悖论了。</p><p>在外乡人「宣布」之前，「村子中存在红眼睛的人」这个信息，是共有信息。村子里的每个人都知道这个信息，但是村子里的每个人都不确定其他人是否知道这个信息——这是由「禁止讨论眼睛的颜色」这一设定保证的。</p><p>在外乡人「宣布」之后，「村子中存在红眼睛的人」这个信息，就从共有信息变成了公共信息。村子里的每个人都知道这个信息，这一点没有改变。但是，这一次，村子里的每个人都知道其他所有人都知道这个信息。因此，对于村子中的所有村民来说，他们所持有的信息量增加了。这种信息量的增加，最终导致了 <code>$k$</code> 个红眼睛的人将在外乡人宣布这一信息之后的第 <code>$k$</code> 天集体自杀。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="表白"><a href="#表白" class="headerlink" title="表白"></a>表白</h3><p>在学生时代，很多人都经历过「暗恋」这个状态。具体来说，A 和 B 两个人互相喜欢。A 显然知道自己喜欢 B，A 也能从 B 平时的表现猜出 B 喜欢自己。也就是说，A 猜测自己和 B 是「彼此相爱」的。对于 B 来说，也是这样。</p><p>我们也知道，大多数的「暗恋」没有发展成恋人关系。这是为啥咧？因为「彼此相爱」这个信息，是 A 和 B 的共有信息，但不是公共信息。换言之，A 和 B 都不知道对方是否明白「彼此相爱」，于是不敢发展成恋人关系。我们知道，从共有信息转变成公共信息的过程，需要「宣布」这个动作。在恋爱关系中，「宣布」即是「表白」。也就是说，从暗恋状态转变为恋爱状态，需要 A 和 B 之间发生「表白」这个动作。</p><p>然而，由于害羞、父母师长的限制等因素，学生时代的暗恋往往缺少「表白」这个转换为恋爱关系的必要过程。这就是大多数暗恋没有发展成恋人关系的原因。</p><h3 id="垃圾股"><a href="#垃圾股" class="headerlink" title="垃圾股"></a>垃圾股</h3><p>如果一个股票的价格很高，但股票对应的公司业绩很差、不足以支撑股价，那么这种股票称之为垃圾股。现在的问题是，为什么垃圾股的股价能够持续虚高呢？</p><p>垃圾股「股价虚高」这个信息，对于持有该股票的投资人来说是共有信息。这些投资人——或者说投机者——都知道股价虚高，但是他们不确定别人是否知道。于是他们会期待会有「不知情」的人，以同样虚高的价格购入股票——我们称之为他们在等待「接盘侠」。</p><p>这时候，如有负面信息放出，告诉大家：「这公司业绩不行，这是个垃圾股」。这时候共有信息变成公共信息，导致的后果往往就是股价一泻千里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;华人数学家陶哲轩曾经设计了这么一个有趣的思维实验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个村子里有 100 聪明人；&lt;/li&gt;
&lt;li&gt;100 人中，有 5 人眼睛是红色的，其余 95 人的眼睛是蓝色的；&lt;/li&gt;
&lt;li&gt;村子里禁止讨论「眼睛颜色」这个话题；&lt;/li&gt;
&lt;li&gt;通过任何方式知道自己眼睛颜色的人，第二天必须在村子中心的广场上公开自杀。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在有一个路过的外乡人看到村子之后，公开说了这么一句话：「村子里存在红眼睛的人」。然后，5 天后，村子里红眼睛的人就在村子中心的广场上集体自杀了。&lt;/p&gt;
&lt;p&gt;这篇文章讨论这个有趣的思维实验。&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Paradox" scheme="https://liam.page/tags/Paradox/"/>
    
      <category term="Knowledge" scheme="https://liam.page/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统与计算广告差别之我见</title>
    <link href="https://liam.page/2019/07/27/difference-between-recommendation-system-and-computational-advertising/"/>
    <id>https://liam.page/2019/07/27/difference-between-recommendation-system-and-computational-advertising/</id>
    <published>2019-07-27T07:11:29.000Z</published>
    <updated>2019-08-27T09:43:08.975Z</updated>
    
    <content type="html"><![CDATA[<p>这篇谈谈我眼中推荐系统和计算广告之间的差别。</p><p>当然，限于角色和身份，我只能站在算法工程师的角度，去谈一谈两种系统的优化目标之间的差异，以及这种差异引起的一系列不同。</p><a id="more"></a><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>从产品的角度来说，推荐系统一般被理解为是一种用户产品，而计算广告被理解为是一种商业产品。也就是说，推荐系统的终极目标是为了提高、维持、促进用户体验的，而计算广告的终极目标是为了赚钱、赚更多的钱、持续地赚更多的钱。</p><p>这样一来，推荐系统本质上是要处理<strong>用户体验</strong>的问题，而计算广告则复杂一些，需要平衡和协调好广告主、用户和广告平台（媒体）之间的利益。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>因为目标的不同，推荐系统和计算广告的优化方式就必然会有不同。以 CTR 预估模型为例：</p><ul><li>因为推荐系统的终极目标是提高、维持和促进用户体验，因此全部根据用户历史行为进行推荐，无异于是竭泽而渔——这会使用户很快对推荐系统推荐的内容产生倦怠感，从而离开推荐系统，造成用户流失。因此，推荐系统在使用 CTR 预估模型时，不宜全部按照 CTR 预估的结果从高到低排序，而是要兼顾诸如内容多样性、新颖性、时效性、流行度等因素。</li><li>对于计算广告来说，则简单一些。因为计算广告的目标是产生更多收益，因此在使用 CTR 预估的结果时，倾向于从高到低排序，将预估 CTR 较高的结果排在前面。</li></ul><h2 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h2><p>因为目标的不同，推荐系统和计算广告各自又会演化出不同的技术。这里仅举几例。</p><p>对于推荐系统来说，为了维持和促进用户体验，就必须要去挖掘用户的长期兴趣，这就引出了探索与利用（exploitation &amp; exploration）这一技术方向。此外，为了顾全多样性、时效性，推荐系统需要对新物料进行尽可能多且恰当的推荐。这就引出了新物料冷启动的问题。再者，考虑到长尾效应，有用户反馈的物料始终是少数，这必然会导致训练集数据倾斜较重。这就引出了有偏数据的处理相关的技术。</p><p>对于计算广告来说，由于要协调广告主、用户和广告平台（媒体）之间的利益，就会产生很多博弈。对于广告价格来说，广告主之间为了竞争广告位会有博弈，广告主和广告平台因为利益冲突也会有博弈。由此引出了出价策略（bidding strategy）的技术。另外，广告平台在同一时间能够提供的广告位是有限的，为了在获得一段时间内整体收入最高，就有必要对广告主投放的广告进行排期。由此引出了排期优化（yielding optimization）的技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇谈谈我眼中推荐系统和计算广告之间的差别。&lt;/p&gt;
&lt;p&gt;当然，限于角色和身份，我只能站在算法工程师的角度，去谈一谈两种系统的优化目标之间的差异，以及这种差异引起的一系列不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Insightful Thoughts" scheme="https://liam.page/categories/Insightful-Thoughts/"/>
    
    
      <category term="RecSys" scheme="https://liam.page/tags/RecSys/"/>
    
      <category term="CaclAd" scheme="https://liam.page/tags/CaclAd/"/>
    
  </entry>
  
  <entry>
    <title>为网页标题添加「崩溃了」彩蛋</title>
    <link href="https://liam.page/2019/07/22/crash-title-cheat/"/>
    <id>https://liam.page/2019/07/22/crash-title-cheat/</id>
    <published>2019-07-22T03:18:12.000Z</published>
    <updated>2019-08-27T09:43:08.970Z</updated>
    
    <content type="html"><![CDATA[<p>经常浏览<a href="/">「始终」博客</a>的读者很容易会发现，当你在浏览器中切换 tab 页到其它网页时，始终博客的页面会有一定概率「崩溃」。具体来说，tab 页上的标题会变成「╭(°A°`)╮ 页面崩溃啦~」这样子，切换回来之后又会发现页面其实没问题，同时标题会变成「(ฅ&gt;ω&lt;*ฅ) 咦，又好了~」这样子。因为这个彩蛋比较有趣，所以很多朋友回点回来看一看页面发生了什么。想想还是蛮有趣的。</p><p>最近有不少朋友问到这个效果是怎么实现的。这里记录一下。</p><a id="more"></a><p>因为功能十分简单，所以直接放代码出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;      <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> crashSwitched = <span class="literal">false</span>;               <span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="built_in">parseFloat</span>(&#123;&#123; theme.crash_title_cheat.probability &#125;&#125;)) &#123;         <span class="comment">// 3.</span></span><br><span class="line">      crashSwitched = <span class="literal">true</span>;              <span class="comment">// 2.a.</span></span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'&#123;&#123; theme.crash_title_cheat.crash_string &#125;&#125;'</span> + originalTitle;     <span class="comment">// 1.a.</span></span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (crashSwitched == <span class="literal">true</span>) &#123;</span><br><span class="line">      crashSwitched = <span class="literal">false</span>;             <span class="comment">// 2.b.</span></span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'&#123;&#123; theme.crash_title_cheat.recover_string &#125;&#125;'</span> + originalTitle;   <span class="comment">// 1.b.</span></span><br><span class="line">      titleTime = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = originalTitle;  <span class="comment">// 1.c.</span></span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>首先解释一下以下一些 Hexo 变量：</p><ul><li><code>theme.crash_title_cheat.probability</code>：值为 <code>0.25</code>。意味着当用户从博客页面切走时，有 <code>0.25</code> 的概率会触发「页面崩溃」的彩蛋。</li><li><code>theme.crash_title_cheat.crash_string</code>：值为 <code>╭(°A°`)╮ 页面崩溃啦~</code>，这就是「页面崩溃」时你看到的字符串。</li><li><code>theme.crash_title_cheat.recover_string</code>：值为 <code>(ฅ&gt;ω&lt;*ฅ) 咦，又好了~</code>，这就是「页面恢复」时你看到的字符串。</li></ul><p>而后我们看 <code>(1)</code> 处用变量 <code>originalTitle</code> 记录了当前页面的原始标题；<code>(2)</code> 处用变量 <code>crashSwitched</code> 记录当前页面是否有触发该彩蛋。当页面被隐藏切走时，在 <code>(3)</code> 处有一定概率触发页面崩溃的彩蛋。彩蛋被触发时，首先 <code>(2.a)</code> 修改触发标记，然后 <code>(1.a)</code> 修改页面标题。当页面被切回时，则会检查触发标记。若标记触发，则首先 <code>(2.b)</code> 抹掉触发标记，然后 <code>(1.b)</code> 添加「咦，又好了~」这样的字符串，最后在 <code>2000</code> 毫秒之后 <code>(1.c)</code> 恢复为真实标题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常浏览&lt;a href=&quot;/&quot;&gt;「始终」博客&lt;/a&gt;的读者很容易会发现，当你在浏览器中切换 tab 页到其它网页时，始终博客的页面会有一定概率「崩溃」。具体来说，tab 页上的标题会变成「╭(°A°`)╮ 页面崩溃啦~」这样子，切换回来之后又会发现页面其实没问题，同时标题会变成「(ฅ&amp;gt;ω&amp;lt;*ฅ) 咦，又好了~」这样子。因为这个彩蛋比较有趣，所以很多朋友回点回来看一看页面发生了什么。想想还是蛮有趣的。&lt;/p&gt;
&lt;p&gt;最近有不少朋友问到这个效果是怎么实现的。这里记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="JavaScript" scheme="https://liam.page/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中解包 std::vector 作为函数参数</title>
    <link href="https://liam.page/2019/07/04/unpack-vector-as-parameters-for-functions/"/>
    <id>https://liam.page/2019/07/04/unpack-vector-as-parameters-for-functions/</id>
    <published>2019-07-04T01:52:30.000Z</published>
    <updated>2019-08-27T09:43:08.969Z</updated>
    
    <content type="html"><![CDATA[<p>昨天 jsteward 问我，有一个接受若干个同类型参数的函数 <code>template &lt;typename U, typename T&gt; U func(T a, T b, T c)</code>，现在有一个 <code>std::vector&lt;T&gt; args</code>，希望将 <code>std::vector&lt;T&gt;</code> 当中的元素作为函数参数传进去，要怎么办。</p><p>这篇来解决这个问题。</p><a id="more"></a><p>首先，待执行的函数的参数个数，在编译时就能知道；比如这里是 3 个。于是，很自然地，我们最终肯定需要类似这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>现在的问题是，我们希望这种调用代码能够自动生成，而不是手动去写。因为 <code>func</code> 的参数，在实际情况下，可能不止 3 个。C++ 11 引入了参数包（parameter pack）的概念，能够将若干个模板参数，打包在一起，然后再用 <code>...</code> 的方式展开。参数包可以是类型参数包，比如 <code>template &lt;typename... Args&gt;</code>，这样 <code>(*Args)...</code> 就是各个类型的指针；参数包也可以是变量参数包，比如 <code>size_t... I</code>，这样 <code>args[I]...</code> 就是 <code>args[0], args[1], args[2]</code> 这样的展开。后者正是我们要的。</p><p>于是，为了利用参数包，我们首先需要根据函数 <code>func</code> 的参数数量，构建一个参数包，作为索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> next = indices&lt;Indices..., <span class="keyword">sizeof</span>...(Indices)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> build_indices&lt;N - <span class="number">1</span>&gt;::type::next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span>&lt;0&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = indices&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> BuildIndices = <span class="keyword">typename</span> build_indices&lt;N&gt;::type;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br></pre></td></tr></table></figure><p>这里用到了<a href="/2019/02/19/recursive-like-function-template-calling/">前作</a>提到过的技巧。我们看：</p><ul><li><code>BuildIndices&lt;0&gt;</code> 是 <code>build_indices&lt;0&gt;::type</code> 也就是全特化的 <code>indices&lt;&gt;</code>；</li><li><code>BuildIndices&lt;1&gt;</code> 是 <code>build_indices&lt;1&gt;::type</code> 也就是 <code>build_indices&lt;0&gt;::type::next</code> 也就是 <code>indices&lt;&gt;::next</code> 也就是 <code>indices&lt;0&gt;</code>；</li><li>同理，<code>BuildIndices&lt;2&gt;</code> 是 <code>build_indices&lt;2&gt;::type</code> 也就是 <code>build_indices&lt;1&gt;::type::next</code> 也就是 <code>build_indices&lt;0&gt;::type::next::next</code> 也就是 <code>indices&lt;0&gt;::next</code> 也就是 <code>indices&lt;0, 1&gt;</code>；</li><li>以此类推 <code>BuildIndices&lt;N&gt;</code> 是 <code>indices&lt;0, 1, ..., N - 1&gt;</code>。</li></ul><p>于是我们很容易构建出 caller 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> T, <span class="keyword">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Func&amp; func, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; args, indices&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">  f(args[I]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时只需要这样既可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call(func, args, BuildIndices&lt;num_args&gt;());</span><br></pre></td></tr></table></figure><p>我们将整个封装起来，写成一个完整的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> next = indices&lt;Indices..., <span class="keyword">sizeof</span>...(Indices)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> build_indices&lt;N<span class="number">-1</span>&gt;::type::next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span>&lt;0&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = indices&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> BuildIndices = <span class="keyword">typename</span> build_indices&lt;N&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> returnT, <span class="keyword">typename</span> valueT, <span class="keyword">size_t</span> num_args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unpack_caller</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType, <span class="keyword">size_t</span>... I&gt;</span><br><span class="line">  <span class="function">returnT <span class="title">call</span><span class="params">(FuncType&amp; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;valueT&gt;&amp; args, indices&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(args[I]...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType&gt;</span><br><span class="line">  <span class="function">returnT <span class="title">operator</span><span class="params">()</span><span class="params">(FuncType&amp; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;valueT&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> call(f, args, BuildIndices&lt;num_args&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; args = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> i = util::unpack_caller&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="number">3</span>&gt;()(func, args);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样还不是很爽。因为在调用 <code>util::unpack_caller</code> 的时候，我们不得不输入函数相关信息。如果有办法能够获取函数的参数类型、参数量、返回值类型，我们就可以避免这个问题了。为此，我们还要定义一套 <code>function_traits</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_defs</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> arity = <span class="keyword">sizeof</span>...(Args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> result_type = ReturnType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">arg</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V = <span class="keyword">void</span>&gt;</span><br><span class="line">struct function_traits</span><br><span class="line">    : function_traits_impl&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;T, decltype((void)&amp;T::operator())&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_impl&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这里，<code>function_traits_defs</code> 是 traits 的具体定义，<code>function_traits_impl</code> 则是针对各种情况（函数、函数指针、仿函数的各种 cv 修饰符及引用情况）做的实现，<code>function_traits</code> 则是暴露在外面的接口。如此一来，我们可以对 <code>util::unpack_caller</code> 做一些改进。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> details &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">          <span class="keyword">typename</span> VecType,</span><br><span class="line">          <span class="keyword">size_t</span>... I,</span><br><span class="line">          <span class="keyword">typename</span> Traits = function_traits&lt;FuncType&gt;,</span><br><span class="line">          <span class="keyword">typename</span> ReturnT = <span class="keyword">typename</span> Traits::result_type&gt;</span><br><span class="line">ReturnT do_call(FuncType&amp; func,</span><br><span class="line">                VecType&amp; args,</span><br><span class="line">           indices&lt;I...&gt; ) &#123;</span><br><span class="line">  <span class="keyword">return</span> func(args[I]...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">          <span class="keyword">typename</span> VecType,</span><br><span class="line">          <span class="keyword">typename</span> Traits = function_traits&lt;FuncType&gt;,</span><br><span class="line">          <span class="keyword">typename</span> ReturnT = <span class="keyword">typename</span> Traits::result_type&gt;</span><br><span class="line">ReturnT unpack_call(FuncType&amp; func,</span><br><span class="line">                VecType&amp; args) &#123;</span><br><span class="line">  <span class="keyword">return</span> details::do_call(func, args, BuildIndices&lt;Traits::arity&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，完整的示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_defs</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> arity = <span class="keyword">sizeof</span>...(Args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> result_type = ReturnType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">arg</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...)&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits_impl</span>&lt;ReturnType(ClassType::*)(Args...) const volatile&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_defs&lt;ReturnType, Args...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V = <span class="keyword">void</span>&gt;</span><br><span class="line">struct function_traits</span><br><span class="line">    : function_traits_impl&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;T, decltype((void)&amp;T::operator())&gt;</span></span><br><span class="line"><span class="class">    :</span> function_traits_impl&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> next = indices&lt;Indices..., <span class="keyword">sizeof</span>...(Indices)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> build_indices&lt;N - <span class="number">1</span>&gt;::type::next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build_indices</span>&lt;0&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = indices&lt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> BuildIndices = <span class="keyword">typename</span> build_indices&lt;N&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> details &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">          <span class="keyword">typename</span> VecType,</span><br><span class="line">          <span class="keyword">size_t</span>... I,</span><br><span class="line">          <span class="keyword">typename</span> Traits = function_traits&lt;FuncType&gt;,</span><br><span class="line">          <span class="keyword">typename</span> ReturnT = <span class="keyword">typename</span> Traits::result_type&gt;</span><br><span class="line">ReturnT do_call(FuncType&amp; func, VecType&amp; args, indices&lt;I...&gt;) &#123;</span><br><span class="line">  <span class="keyword">return</span> func(args[I]...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> VecType&gt;</span><br><span class="line"><span class="function">ReturnT <span class="title">unpack_caller</span><span class="params">(FuncType&amp; func, VecType&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> details::do_call(func, args, BuildIndices&lt;Traits::arity&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; args = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j = util::unpack_caller(func, args);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天 jsteward 问我，有一个接受若干个同类型参数的函数 &lt;code&gt;template &amp;lt;typename U, typename T&amp;gt; U func(T a, T b, T c)&lt;/code&gt;，现在有一个 &lt;code&gt;std::vector&amp;lt;T&amp;gt; args&lt;/code&gt;，希望将 &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; 当中的元素作为函数参数传进去，要怎么办。&lt;/p&gt;
&lt;p&gt;这篇来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Function" scheme="https://liam.page/tags/Function/"/>
    
      <category term="std::vector" scheme="https://liam.page/tags/std-vector/"/>
    
      <category term="unpack" scheme="https://liam.page/tags/unpack/"/>
    
  </entry>
  
  <entry>
    <title>谈谈因子分解机模型的各种变体</title>
    <link href="https://liam.page/2019/06/28/variants-of-FM/"/>
    <id>https://liam.page/2019/06/28/variants-of-FM/</id>
    <published>2019-06-28T02:56:41.000Z</published>
    <updated>2019-08-27T09:43:08.967Z</updated>
    
    <content type="html"><![CDATA[<p>先前我们从 LR 开始，讨论了<a href="/2019/03/25/Factorization-Machine/">因子分解机（FM）模型</a>。FM 解决了稀疏数据场景下的自动特征组合问题，因而在广告、推荐等具有高维稀疏特征的领域被广泛使用。因其简单、可解释性强、效果好，FM 模型通常会被作为业务初期快速取得收益的首选。</p><p>这里将 FM 模型家族至今为止的演进做一个整理总结。</p><a id="more"></a><h2 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h2><p>首先回顾一下 FM 模型的预测函数。</p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle x_ix_j.$$</code></p><p>这里 $n$ 是特征向量 $\vec x$ 的长度，即特征的维数。<code>$v_i$</code> 是长度为 $k$ 的向量，与特征 id 对应，称为特征的隐向量。特征的隐向量是特征相互作用之后得到的抽象表征。经验来说，一般有 <code>$k = \max\Big\{4, \big\lfloor\sqrt[4]{n}\big\rfloor\Big\}$</code>。</p><h2 id="在特征交叉方向上的改进"><a href="#在特征交叉方向上的改进" class="headerlink" title="在特征交叉方向上的改进"></a>在特征交叉方向上的改进</h2><p>对 FM 的第一个改进方向是在特征交叉方向上去做改进。</p><h3 id="FFM-Field-aware-FM"><a href="#FFM-Field-aware-FM" class="headerlink" title="FFM (Field-aware FM)"></a>FFM (Field-aware FM)</h3><blockquote><p><a href="https://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf" target="_blank" rel="noopener">https://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf</a></p></blockquote><p>FFM 是 NTU（国立台湾大学）的 Yu-Chin Juan（阮毓钦，现在美国 Criteo 工作）与其比赛队员，借鉴了来自 Michael Jahrer 的论文中的 field 概念提出了 FM 的升级版模型。</p><p><code>$$\hat y = w_0 + \sum_{i = 1}^n w_i x_i + \sum_{0 &lt; i &lt; j &lt;= n} \langle \vec {v}_{i, f_j}, \vec {v}_{j, f_i} \rangle x_i x_j.$$</code></p><p>相比 FM，FFM 为每个特征构造的不再是隐向量，而是隐矩阵；具体来说，是一个 $k$ 行 $F$ 列的矩阵。它由 $F$ 个 $k$ 维列向量组成；每个列向量 <code>$\vec v_{i, f}$</code> 表示特征 $i$ 与其他所有第 $f$ 个 field 中的特征相互作用得到的抽象表征。式中 <code>$f_i$</code> 表示第 $i$ 维特征所属 field 的 id。</p><p>从隐向量升级到隐矩阵，一方面带来的是参数量的增长（乘以 $F$ 倍）而在训练、预测时对内存产生更大压力，另一方面是无法如 FM 那样简化计算。因此它训练时的复杂度是非常高的。这使得它在各种竞赛中有所表现，但在实际业界应用有限。</p><h3 id="AFM-Attentional-FM"><a href="#AFM-Attentional-FM" class="headerlink" title="AFM (Attentional FM)"></a>AFM (Attentional FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1708.04617v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1708.04617v1.pdf</a></p></blockquote><p>AFM 是浙大（Jun Xiao, Hao Ye, Fei Wu）和新加坡国大（Xiangnan He, Hanwang Zhang, Tat-Seng Chua）几位同学提出来的模型。AFM 首先对 FM 做了神经网络改造，而后加入了注意力机制，为不同特征的二阶组合分配不同的权重。</p><p><img src="/uploads/images/MachineLearning/attention-fm.png" alt></p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\alpha_{ij}\big\langle \vec p, (\vec v_i \odot \vec v_j)\big\rangle x_ix_j.$$</code></p><p>这里，<code>$\alpha_{ij}$</code> 是通过注意力机制学习得到的特征 $i$ 和特征 $j$ 组合的权重，$\vec p$ 是对隐向量每个维度学习得到的权重，<code>$\vec v_i \odot \vec v_j$</code> 表示向量 <code>$\vec v_i$</code> 和 <code>$\vec v_j$</code> 逐项相乘得到的新向量。显然，当 <code>$\alpha_{ij} \equiv 1$</code> 且 $\vec p = \vec 1$ 时，AFM 退化为标准的 FM 模型。</p><p>AFM 和 FFM 都是从「特征和不同特征进行组合时，表征应该稍有差异」这个点出发，尝试对 FM 进行改进的。FFM 是基于 field 的概念，使得特征对不同 field 里的特征采取不同的表征，同时特征对不同 field 特征里的表征互不关联。AFM 是基于 attention 机制的，对不同特征的表征仅有权重（<code>$\alpha_{ij}$</code>）上的不同。从参数数量来说，AFM 会远小于 FFM。从这个角度说，AFM 在业界的应用前景应该比 FFM 更好。</p><h3 id="FwFM-Field-weighted-FM"><a href="#FwFM-Field-weighted-FM" class="headerlink" title="FwFM (Field-weighted FM)"></a>FwFM (Field-weighted FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1806.03514.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1806.03514.pdf</a></p></blockquote><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}r_{f_if_j}\langle \vec v_i, \vec v_j\rangle x_ix_j.$$</code></p><p>这里 <code>$r_{f_if_j}$</code> 是针对特征 $i$ 所属 field <code>$f_i$</code> 和特征 $j$ 所属 field <code>$f_j$</code> 学习的参数。</p><p>FwFM 改进的出发点与 FFM 和 AFM 相同，但吸取了 FFM 和 AFM 各自的优点。它相当于是 $\vec p = \vec 1$ 且 <code>$\alpha_{ij}$</code> 简化为 <code>$r_{f_if_j}$</code> 的 AFM。相对于 FFM，它改掉了用隐矩阵来 model field 的做法，而是用 <code>$r_{f_if_j}$</code> 捕捉 field 的信息，因而大大降低了参数数量。</p><h2 id="引入深度神经网络"><a href="#引入深度神经网络" class="headerlink" title="引入深度神经网络"></a>引入深度神经网络</h2><p>对 FM 进行改进的第二个方向是引入深度神经网络。</p><h3 id="DeepFM"><a href="#DeepFM" class="headerlink" title="DeepFM"></a>DeepFM</h3><blockquote><p><a href="https://arxiv.org/pdf/1703.04247.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1703.04247.pdf</a></p></blockquote><p>DeepFM 的论文发表在 IJCAI 2017 上。它是在 Wide &amp; Deep 框架上，将 LR 部分替换成了 FM，以增强 wide 部分对二阶交叉特征的捕捉能力。目前来说，它已被业界快速跟进和应用到推荐、广告、搜索等场景。</p><p>其实 Wide &amp; Deep 框架才是这一改进的精髓。不难发现，除了将 FM 与 NN 拼起来得到 DeepFM，我们还可以将 FFM、AFM、FwFM 和 NN 拼起来得到相应的 DeepXFM 版本。但这样难免有水论文的嫌疑了……</p><h3 id="NFM-Neural-FM"><a href="#NFM-Neural-FM" class="headerlink" title="NFM (Neural FM)"></a>NFM (Neural FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1708.05027v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1708.05027v1.pdf</a></p></blockquote><p>DeepFM 是用 Wide &amp; Deep 框架，在 FM 旁边加了一个 NN，最后一并 sigmoid 输出。NFM 的做法则是利用隐向量逐项相乘得到的向量作为 MLP 的输入，构建的 FM + NN 模型。</p><p><img src="/uploads/images/MachineLearning/nfm.png" alt></p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + f(\vec x).$$</code></p><p>如图所示的是上述第三项 $f(\vec x)$ 的结构。Embedding 层中的向量即是传统 FM 模型中的 <code>$x_i\vec v_i$</code>；Bi-interaction 池化层则是将特征两两交叉后，逐项向量相乘再做向量加法，即池化层的输出是一个与隐向量长度相同的向量：</p><p><code>$$\sum_{0 &lt; i &lt; j &lt;= n} x_ix_j(\vec v_i \odot \vec v_j).$$</code></p><p>紧接着再以上述向量作为一个 <code>$L$</code> 层的 MLP 的输入，接一个全链接的 MLP 而后输出。显然，和 AFM 中的情况类似，当 <code>$L = 0$</code> 且输出层参数全为 <code>$1$</code> 时，NFM 退化为原始的 FM 模型。</p><p>NFM 的复杂度是传统 FM 的复杂度与 MLP 的合。因此它与 DeepFM 的复杂度是相同的。</p><h2 id="利用偏序概率，迁移到-rank-任务上"><a href="#利用偏序概率，迁移到-rank-任务上" class="headerlink" title="利用偏序概率，迁移到 rank 任务上"></a>利用偏序概率，迁移到 rank 任务上</h2><p>以前提到过 <a href="/2016/07/10/a-not-so-simple-introduction-to-lambdamart/#RankNet-的创新">RankNet 的创新</a>。通过引入偏序概率，我们可以把任何一个模型转变成 pairwise 的排序模型。</p><p>具体来说，对于待排序的 item <code>$x_i$</code> 和 <code>$x_j$</code>，有模型的打分函数 <code>$f$</code>，从而求得得分 <code>$s_i = f(x_i)$</code>, <code>$s_j = f(x_j)$</code>，而后得到偏序概率</p><p><code>$$P_{ij} = P(x_i \rhd x_j) = \text{sigmoid}(s_i, s_j).$$</code></p><p>这样，我们就将排序问题中的偏序，转换成了二分类问题（<code>$x_i$</code> 是否应该排在 <code>$x_j$</code> 之前）。之后只需要套用二分类问题的解法即可。</p><h3 id="Pairwise-FM"><a href="#Pairwise-FM" class="headerlink" title="Pairwise FM"></a>Pairwise FM</h3><p>Pairwise FM 的做法就是如此。只需要将上述打分函数 <code>$f$</code> 设为 FM 即可。</p><h3 id="LambdaFM"><a href="#LambdaFM" class="headerlink" title="LambdaFM"></a>LambdaFM</h3><p>和 <a href="/2016/07/10/a-not-so-simple-introduction-to-lambdamart/">LambdaMART</a> 中的做法一样，若在 FM 的基础上，将梯度上辅以 <code>$\Delta Z$</code> 作为 pair 的权重，则变成了 listwise 的排序算法。</p><h2 id="其他魔改"><a href="#其他魔改" class="headerlink" title="其他魔改"></a>其他魔改</h2><p>上述三类对 FM 模型的改进，相对来说都有比较明确的方向。还有一些改进，在模型本身的角度没有形成特定的方向。但这些改进也有一些意义，因此罗列如下。</p><h3 id="加入-FTRL-框架"><a href="#加入-FTRL-框架" class="headerlink" title="加入 FTRL 框架"></a>加入 FTRL 框架</h3><blockquote><p><a href="https://www.kdd.org/kdd2018/accepted-papers/view/sketched-follow-the-regularized-leader-for-online-factorization-machine" target="_blank" rel="noopener">https://www.kdd.org/kdd2018/accepted-papers/view/sketched-follow-the-regularized-leader-for-online-factorization-machine</a></p></blockquote><p>FTRL 框架是一个在线学习框架。最早是 Google 提出来应用在 LR 上的。这篇发表在 KDD 2018 的文章将 FTRL 引入了 FM 模型。但这其实不是什么新鲜事，CastellanZhang 早在 2016 年就开源了相应的实现 <a href="https://github.com/CastellanZhang/alphaFM" target="_blank" rel="noopener">alphaFM</a>。</p><h3 id="DFM-Discrete-FM"><a href="#DFM-Discrete-FM" class="headerlink" title="DFM (Discrete FM)"></a>DFM (Discrete FM)</h3><blockquote><p><a href="https://arxiv.org/pdf/1805.02232.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1805.02232.pdf</a></p></blockquote><p>原始 FM 的隐向量是在实数空间的向量。虽然 FM 可经过数学变换将复杂度降低到线性（相对隐向量长度 $k$），但在某些场景，复杂度仍然很高。因此山东大学（Han Liu, Liqiang Nie）、新加坡国大（Xiangnan He, Fuli Feng）、电子科技大学（Rui Liu）和新加坡南洋理工（Hanwang Zhang）的几位同学提出了 DFM 模型。</p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec b_i, \vec b_j\rangle x_ix_j.$$</code></p><p>它和原始 FM 模型唯一的差别是将隐向量从实数空间简化到 <code>$\{-1, +1\}$</code>。不难预见，效果相对 FM 会有一定下降。</p><h3 id="RFM-Robust-FM"><a href="#RFM-Robust-FM" class="headerlink" title="RFM (Robust FM)"></a>RFM (Robust FM)</h3><blockquote><p><a href="http://delivery.acm.org/10.1145/3190000/3186148/p669-punjabi.pdf?ip=202.108.14.240&amp;id=3186148&amp;acc=OPEN&amp;key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;__acm__=1561711947_55e776a6a5f3d314ac25bac873e6196a" target="_blank" rel="noopener">http://delivery.acm.org/10.1145/3190000/3186148/p669-punjabi.pdf?ip=202.108.14.240&amp;id=3186148&amp;acc=OPEN&amp;key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;__acm__=1561711947_55e776a6a5f3d314ac25bac873e6196a</a></p></blockquote><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_i(x_i + \mu_i) + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle (x_ix_j + \Sigma_{jk}).$$</code></p><p>Robust 即是「鲁棒性」的那个英文单词。这一个改进的出发点是 FM 大量用于和用户反馈相关的场景（例如推荐、计算广告），而 FM 模型有一个隐含假设：用户的反馈都是真实的。RFM 认为这些反馈不一定都是真实的，因此加入用于捕捉随机噪声的 <code>$\mu_i$</code> 和 <code>$\Sigma_{ij}$</code> 两项。</p><p>从个人的判断来说，这种改进对 FM 的鲁棒性确实会有提升。但是，（也许是我孤陋寡闻）没有了解到业界有广泛的应用这一改进。猜测可能的原因是 <code>$\Sigma_{ij}$</code> 项的加入破坏了原 FM 的数学变形，使得时间复杂度变成了 <code>$\Theta(kn^2)$</code> 从而降低效率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>近年来，针对原始 FM 的改进主要集中在三个方向：</p><ul><li>细化二阶特征交叉的处理方式，以捕捉更多信息；</li><li>与 NN 结合，利用 NN 捕捉高阶交叉特征；</li><li>利用偏序概率，迁移到 rank 任务上去。</li></ul><p>特别地，也有所谓的 High-order FM 的改进。但个人认为这种接法属于「脱裤子放屁」——NN 是公认地能够较好地捕捉高阶交叉特征的方法，再去魔改 FM 意义不大。</p><p>当然，在其他方向，也有一些改进。但这些改进目前未成体系，看起来也不容易在方向上成为一个流派。因此这些改进在本文中一律归到「魔改」的范畴中了。</p><p>希望本文能够让读者对 FM 的各种变体、改进有一个比较直观的认知。另祝 @turbo0628 同学生日快乐~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先前我们从 LR 开始，讨论了&lt;a href=&quot;/2019/03/25/Factorization-Machine/&quot;&gt;因子分解机（FM）模型&lt;/a&gt;。FM 解决了稀疏数据场景下的自动特征组合问题，因而在广告、推荐等具有高维稀疏特征的领域被广泛使用。因其简单、可解释性强、效果好，FM 模型通常会被作为业务初期快速取得收益的首选。&lt;/p&gt;
&lt;p&gt;这里将 FM 模型家族至今为止的演进做一个整理总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Ranking" scheme="https://liam.page/tags/Ranking/"/>
    
      <category term="Factorization Machine" scheme="https://liam.page/tags/Factorization-Machine/"/>
    
      <category term="CTR" scheme="https://liam.page/tags/CTR/"/>
    
      <category term="Variants" scheme="https://liam.page/tags/Variants/"/>
    
  </entry>
  
  <entry>
    <title>强迫症患者也需要随机梯度下降</title>
    <link href="https://liam.page/2019/06/18/OCD-needs-stochastic-gradient-descent/"/>
    <id>https://liam.page/2019/06/18/OCD-needs-stochastic-gradient-descent/</id>
    <published>2019-06-18T06:52:18.000Z</published>
    <updated>2019-08-27T09:43:08.965Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个强迫症（OCD）患者，曾经我一直对随机梯度下降（Stochastic Gradient Descent）表示怀疑。毕竟，每次只选择少量样本计算梯度，这靠谱吗？强迫症患者心里泛起了浓浓的怀疑。然而经年的实践经验结合理论分析表明，强迫症患者也需要随机梯度下降。</p><p>这篇文章尝试尽可能用少的数学公式，讲一讲这个问题。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这里讨论的梯度下降（Gradient Descent）和随机梯度下降，都是为了解决机器学习/深度学习当中模型训练中的优化问题而设计的。在机器学习/深度学习当中，模型的训练问题往往会被转换成求使得目标函数值最小的参数组合的最优化问题。具体来说是</p><p><code>$$\vec{\theta}^{*} = \mathop{\arg\min}_{\vec{\theta}}\text{Obj}\bigl(h(\vec x;\vec{\theta})\bigr).$$</code></p><p>这里，<code>$h(\vec x;\vec{\theta})$</code> 是目标模型，其中 <code>$\vec x$</code> 是输入特征向量，<code>$\vec{\theta}$</code> 是模型的参数，<code>$\text{Obj}(\cdot)$</code> 是目标函数。</p><p>在样本集给定时，可将 <code>$\text{Obj}\bigl(h(\vec x;\vec{\theta})\bigr)$</code> 看做是 <code>$\vec\theta$</code> 的函数——不妨将其记为 <code>$f(\vec\theta)$</code>，则我们的目标就是要找到该函数等高线中的最低谷位置对应的 <code>$\vec\theta$</code> 的取值。</p><p><img src="/uploads/images/MachineLearning/objective_function.png" alt="只有两维参数时目标函数的图像"></p><!--import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)ax.set_xlabel(r'$\theta_1$', rotation = 90)ax.set_ylabel(r'$\theta_2$')ax.set_zlabel(r'$f(\vec \theta)$', rotation = 90)# X, Y valueX = np.arange(-4, -.5, 0.1)Y = np.arange(-2, 4, 0.1)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = np.sin(np.sin(X)) * np.sin(np.cos(Y)) * 2 + np.sin(X + Y / 4)ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap('rainbow'))plt.show() --><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>既然要找到目标函数的「山谷」，那我们就要想办法「下山」。在数学上，上升最快的方向是函数的梯度方向，于是梯度方向的反方向就是下降最快的方向。于是有参数更新</p><p><code>$$\vec \theta_{n + 1} \gets \vec\theta_{n} - \eta\nabla f(\vec\theta_{n}).$$</code></p><p>这里，<code>$\vec\theta_{n}$</code> 是第 $n$ 轮迭代后的参数；<code>$\nabla f(\vec\theta_{n})$</code> 则是第 $n$ 轮迭代后目标函数的梯度；<code>$\eta$</code> 是学习率，也就是梯度下降的步长。</p><p><img src="/uploads/images/MachineLearning/gradient_descent.png" alt="只有两维参数时目标函数的梯度下降"></p><!--import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport randomfig = plt.figure()ax = Axes3D(fig)ax.set_xlabel(r'$\theta_1$', rotation = 90)ax.set_ylabel(r'$\theta_2$')ax.set_zlabel(r'$f(\vec \theta)$', rotation = 90)# X, Y valueX = np.arange(-4, -.5, 0.1)Y = np.arange(-2, 4, 0.1)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = np.sin(np.sin(X)) * np.sin(np.cos(Y)) * 2 + np.sin(X + Y / 4)ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap('rainbow'))x = np.arange(-3.5, -1.5, 0.2)y = np.arange(-.35, -.15, 0.02)y_noice = np.random.rand(len(y)) * 0.2 - 0.1y = y + y_noicez = np.sin(np.sin(x)) * np.sin(np.cos(y)) * 2 + np.sin(x + y / 4)ax.plot(x, y, z, 'o-')plt.show() --><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>梯度下降优美、清晰、明确。但梯度下降也有它的问题。</p><p>第一个问题是效率低。梯度下降法需要处理计算所有样本，而在工程中我们面对的样本集合往往非常大。这样一来，处理所有样本就会变得效率非常低，缓慢得不可接受。</p><p>第二个问题是缺乏跳出陷阱的能力。这里的陷阱指得是诸如鞍点、局部最优点之类的梯度为零的点。</p><p><img src="/uploads/images/MachineLearning/saddle_point.png" alt="鞍点"></p><!--import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport randomfig = plt.figure()ax = Axes3D(fig)ax.set_xlabel(r'$\theta_1$', rotation = 90)ax.set_ylabel(r'$\theta_2$')ax.set_zlabel(r'$f(\vec \theta)$', rotation = 90)# X, Y valueX = np.arange(-2, 2, 0.1)X_zeros = np.zeros(len(X))Y = np.arange(-2, 2, 0.1)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = X ** 2 - Y ** 2ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap('rainbow'))X = np.arange(-2, 2, 0.1)X_zeros = np.zeros(len(X))ax.plot(X, X_zeros, X ** 2, '-', color = 'cyan', linewidth = 2)ax.plot(X_zeros, X, - X ** 2, '-', color = 'cyan', linewidth = 2)ax.text(-.4, 0, 0.7, "saddle point")plt.show() --><p>这是因为，当目标函数落入陷阱后，梯度为零。于是目标函数的参数再也无法更新，模型实质上收敛在不恰当的位置。</p><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>随机梯度下降（Stochastic Gradient Descent，SGD）的表达式和梯度下降差别不大：</p><p><code>$$\vec \theta_{n + 1} \gets \vec\theta_{n} - \eta_ng_n.$$</code></p><p>这里，<code>$g_n$</code> 是随机梯度。具体来说，它是用单个样本（而非所有样本）计算得到的梯度。在实践中，也可能是使用较小的集合（mini batch）计算得到的梯度。随机梯度满足</p><p><code>$$E[g_n] = \nabla f(\vec\theta_n).$$</code></p><p>这也就是说，尽管由于样本选择带来了一定的随机性，但在期望的角度，随机梯度是等于真实的梯度的。用等高线图来表示，随机梯度下降就像是喝醉了酒的梯度下降：它依稀认得路，最后也能自己走回家，但是走得歪歪扭扭。（黄色的是梯度下降的路线，绿色的是随机梯度下降的路线）</p><!--import numpy as npimport matplotlib.pyplot as pltimport randomfig = plt.figure()plt.xlabel(r'$\theta_1$')plt.ylabel(r'$\theta_2$')# X, Y valueX = np.arange(-4, -.5, 0.01)Y = np.arange(-2, 4, 0.01)X, Y = np.meshgrid(X, Y)    # grid on x-y plane# height valueZ = np.sin(np.sin(X)) * np.sin(np.cos(Y)) * 2 + np.sin(X + Y / 4)plt.contour(X, Y, Z, 16)plt.contourf(X, Y, Z, 16)x = np.arange(-3.5, -1.5, 0.2)y = np.arange(-.35, -.15, 0.02)y_noice = np.random.rand(len(y)) * 0.2 - 0.1y = y + y_noicex[0]  = -3.5x[-1] = -1.5y[0]  = -.35y[-1] = -.15plt.plot(x, y, 'o-', color = "yellow")x = np.arange(-3.5, -1.5, 0.05)y = np.arange(-.35, -.15, 0.005)x_noice = np.random.rand(len(x)) - 0.5y_noice = np.random.rand(len(y)) - 0.5x = x + x_noicey = y + y_noicex[0]  = -3.5x[-1] = -1.5y[0]  = -.35y[-1] = -.15plt.plot(x, y, 'o-', color = 'green')plt.show() --><p><img src="/uploads/images/MachineLearning/stochastic_gradient_descent.png" alt></p><h3 id="效率的提升"><a href="#效率的提升" class="headerlink" title="效率的提升"></a>效率的提升</h3><p>显而易见，随机梯度下降想要收敛，需要更多的迭代步骤。但是，由于每次只需要少量样本来计算随机梯度，实际上的效率会提升很多。试想，若训练数据集有 100 万个样本点，每次我们取其中的 100 个计算随机梯度。这样，在计算梯度的时候，效率就提升了 1 万倍。如此一来，哪怕多迭代几倍甚至十几倍，总体来说效率也是提升了。</p><h3 id="效果的提升"><a href="#效果的提升" class="headerlink" title="效果的提升"></a>效果的提升</h3><p>虽然强迫症肯定会怀疑，随机梯度下降每次只用部分样本，这样的随机性和噪声靠谱吗？但实际上，哪怕梯度下降的训练时间比随机梯度下降多千百倍，但实际效果却远不如随机梯度下降得到的模型。</p><p>这里蕴含着两层含义：</p><ol><li>随机梯度下降能很好地收敛；</li><li>随机梯度下降能收敛到更好的最优点上。</li></ol><p>关于 (1)，这里不打算展开来讲。但有大量的理论工作证明，在 $f$ 是凸函数的情况下，只要噪声不离谱，随机梯度下降都能很好地收敛。(2) 的性质实际上是在说 SGD 能够较好地逃离鞍点这类「陷阱」。为了说明这一点，首先要引入一个概念：strict saddle 函数。它是说，对于函数定义域内的任意一个点 $x$，满足：</p><ul><li>函数在 $x$ 点的导数比较大（因而能够做梯度下降）；或者，</li><li>函数在 $x$ 点附近有最小值（因而已接近完成优化任务）；或者，</li><li>函数在 $x$ 点的二阶偏导组成的 Hessian 矩阵至少含有一个负的特征值（因而沿着这个方向能够滑下去，降低函数值）。</li></ul><p>在机器学习/深度学习任务中，大多数用到的函数都满足（或者近似满足，虽然我不知道怎么证……）strict saddle 函数的定义。对于 strict saddle 函数，如果梯度下降遇到了鞍点，只需要在鞍点加扰动，能够顺着负的特征值方向滑下去降低函数值了。金驰菊苣 17 年的论文（<a href="https://arxiv.org/abs/1703.00887" target="_blank" rel="noopener">How to Escape Saddle Points Efficiently</a>）就说明了这一点：SGD 引入的扰动，能够在较大概率下逃离鞍点。文章证明的思路很巧妙，它首先证明了任意两个点在负特征值方向上的投影距离大于 $u / 2$，则其中至少有一个点能够通过有限步的 GD 迭代逃离鞍点。接下来，只需要通过 $u$ 计算出落入这一区间的概率下界，说明它足够小，就能说明 SGD 引入的扰动，能够在较大概率下逃离鞍点了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OCD 患者也需要 SGD，因为相对于 GD，它：</p><ul><li>效率较高；</li><li>能够收敛；</li><li>能够收敛到更好的最优点上。</li></ul><blockquote><p>因最近工作较忙，这篇文章有些「虎头蛇尾」。实际上，这篇文章从三月中旬动笔至此已经两个多月了，可见其中受了多少打扰。拖延至今实不愿继续拖沓下去，因此本着「烂尾好过无尾」的想法（真不要脸），就这样草草结尾了。望各位看官见谅。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个强迫症（OCD）患者，曾经我一直对随机梯度下降（Stochastic Gradient Descent）表示怀疑。毕竟，每次只选择少量样本计算梯度，这靠谱吗？强迫症患者心里泛起了浓浓的怀疑。然而经年的实践经验结合理论分析表明，强迫症患者也需要随机梯度下降。&lt;/p&gt;
&lt;p&gt;这篇文章尝试尽可能用少的数学公式，讲一讲这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Optimizer" scheme="https://liam.page/tags/Optimizer/"/>
    
      <category term="Gradient Descent" scheme="https://liam.page/tags/Gradient-Descent/"/>
    
      <category term="Stochastic Gradient Descent" scheme="https://liam.page/tags/Stochastic-Gradient-Descent/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 下批量将 Markdown 文档转为 Word 文档</title>
    <link href="https://liam.page/2019/05/17/markdown-convert-to-docx-batch/"/>
    <id>https://liam.page/2019/05/17/markdown-convert-to-docx-batch/</id>
    <published>2019-05-17T10:34:52.000Z</published>
    <updated>2019-08-27T09:43:08.961Z</updated>
    
    <content type="html"><![CDATA[<p>转换本身需要通过开源的 Pandoc 来进行。因此，你首先需要<a href="https://pandoc.org/installing.html" target="_blank" rel="noopener">安装 Pandoc</a>。</p><p>而后，可以仿照<a href="/2014/08/21/bitmap-convert-to-eps-batch/">前作</a>的做法，批量转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">for /f &quot;tokens=* delims=&quot; %%i in (&apos;dir /b *.md&apos;) do (</span><br><span class="line">  @echo %%i</span><br><span class="line">  pandoc -f markdown -t docx -o &quot;%%~ni.docx&quot; &quot;%%i&quot;</span><br><span class="line">  @echo Finished</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>具体操作路径：</p><ul><li><a href="https://pandoc.org/installing.html" target="_blank" rel="noopener">安装 Pandoc</a>（按需）。</li><li>将<a href="https://tar.cat/uploads/bat_scripts/md2docx.bat" target="_blank" rel="noopener">脚本</a>保存在某个目录（例如桌面）。</li><li>将需要转换的 Markdown 文件也保存在该目录。</li><li>双击执行脚本。</li><li>收获一堆 Word 文档。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转换本身需要通过开源的 Pandoc 来进行。因此，你首先需要&lt;a href=&quot;https://pandoc.org/installing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装 Pandoc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而后，可以仿照&lt;
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Markdown" scheme="https://liam.page/tags/Markdown/"/>
    
      <category term="Pandoc" scheme="https://liam.page/tags/Pandoc/"/>
    
      <category term="Word" scheme="https://liam.page/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>修复 Win10 变更默认浏览器时设置 App 崩溃的问题</title>
    <link href="https://liam.page/2019/05/10/Setting-App-crash-when-changing-default-browswer-to-Chrome-due-to-Edge/"/>
    <id>https://liam.page/2019/05/10/Setting-App-crash-when-changing-default-browswer-to-Chrome-due-to-Edge/</id>
    <published>2019-05-10T03:18:36.000Z</published>
    <updated>2019-08-27T09:43:08.960Z</updated>
    
    <content type="html"><![CDATA[<p>单位配发的电脑问题比较多。昨天提交 IT 修复电脑时，出现了更多问题，不得不重装系统并升级为 Windows 10。初次接触 Windows 10 的我，又遇到了不少问题。所幸，大多数问题都经由 Google 帮助解决。但仍有一个问题始终无法解决：</p><ol><li>Microsoft Edge 闪退；</li><li>退而求其次使用 Google Chrome，但尝试将 Chrome 设置为默认浏览器时，设置 App 崩溃，设置失败。</li></ol><a id="more"></a><p>显而易见，本质上是 Edge 有问题，连累了设置 App。Google 搜索的结果千篇一律，无非是删除当前用户 <code>AppData</code> 目录下 Edge 的相关文件后在 Powershell 中重新注册 Edge。但反复试验之后都无法解决问题。</p><p>最后在英文版 Microsoft Community 上找到了解决办法：</p><ol><li>设置 -&gt; 应用 -&gt; 应用和功能</li><li>搜索 Edge -&gt; 单击 -&gt; 高级选项</li><li>重置 -&gt; 修复 -&gt; 重置</li></ol><p>这样一路操作会把 Edge 整个重置掉。此后再去设置当中修改默认浏览器就能绕过 Edge 崩溃的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位配发的电脑问题比较多。昨天提交 IT 修复电脑时，出现了更多问题，不得不重装系统并升级为 Windows 10。初次接触 Windows 10 的我，又遇到了不少问题。所幸，大多数问题都经由 Google 帮助解决。但仍有一个问题始终无法解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Microsoft Edge 闪退；&lt;/li&gt;
&lt;li&gt;退而求其次使用 Google Chrome，但尝试将 Chrome 设置为默认浏览器时，设置 App 崩溃，设置失败。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Edge" scheme="https://liam.page/tags/Edge/"/>
    
      <category term="Chrome" scheme="https://liam.page/tags/Chrome/"/>
    
      <category term="Windows 10" scheme="https://liam.page/tags/Windows-10/"/>
    
  </entry>
  
  <entry>
    <title>在 SumatraPDF 反向搜索时复用 VSCode 窗口</title>
    <link href="https://liam.page/2019/03/27/reuse-active-window-for-inverse-search-SumatraPDF-and-LaTeXworkshop-on-VSCode/"/>
    <id>https://liam.page/2019/03/27/reuse-active-window-for-inverse-search-SumatraPDF-and-LaTeXworkshop-on-VSCode/</id>
    <published>2019-03-27T08:03:41.000Z</published>
    <updated>2019-08-27T09:43:08.957Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇简单的记录。</p><p>最近升级 VSCode 之后发现 SumatraPDF 的反向搜索出了些问题。具体来说，反向搜索能够定位到 VSCode 里的代码位置，但是每次反向搜索都会打开新的 VSCode 窗口。烦不胜烦。</p><p>遂上网检索，找到 <a href="https://code.visualstudio.com/docs/editor/command-line" target="_blank" rel="noopener">VSCode 的命令行参数文档</a>。原来，默认情况下，使用命令行打开 VSCode 会打开新的窗口。为了重用上一个活动窗口，需要在命令行参数上加上 <code>-r</code> 或者完整版本 <code>--reuse-window</code>。</p><p>于是，LaTeXworkshop 的配置变成了这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">"latex-workshop.view.pdf.external.synctex": &#123;</span><br><span class="line">  "command": "C:\\Program Files (x86)\\SumatraPDF\\SumatraPDF.exe",</span><br><span class="line">  "args": [</span><br><span class="line">    "-forward-search",</span><br><span class="line">    "%TEX%",</span><br><span class="line">    "%LINE%",</span><br><span class="line">    "-reuse-instance",</span><br><span class="line">    "-inverse-search",</span><br><span class="line">    "\"C:\\Users\\UserName\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\" \"C:\\Users\\UserName\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\cli.js\" -r -g \"%f:%l\"",</span><br><span class="line">    <span class="string">"%PDF%"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>注意，其中的「UserName」需要改为你自己的用户名。（感谢 GoneKuei）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇简单的记录。&lt;/p&gt;
&lt;p&gt;最近升级 VSCode 之后发现 SumatraPDF 的反向搜索出了些问题。具体来说，反向搜索能够定位到 VSCode 里的代码位置，但是每次反向搜索都会打开新的 VSCode 窗口。烦不胜烦。&lt;/p&gt;
&lt;p&gt;遂上网检索，找到 &lt;a h
      
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="SumatraPDF" scheme="https://liam.page/tags/SumatraPDF/"/>
    
      <category term="Inverse Search" scheme="https://liam.page/tags/Inverse-Search/"/>
    
  </entry>
  
  <entry>
    <title>谈谈因子分解机模型（FM）</title>
    <link href="https://liam.page/2019/03/25/Factorization-Machine/"/>
    <id>https://liam.page/2019/03/25/Factorization-Machine/</id>
    <published>2019-03-25T02:56:24.000Z</published>
    <updated>2019-08-27T09:43:08.955Z</updated>
    
    <content type="html"><![CDATA[<p>先前我们讨论过<a href="/2018/10/10/logistic-regression/">逻辑回归</a>。作为线性模型，它最大的优势是简单，于是可以以很高的效率去学习和预测，因而在很多领域都被广泛应用。但「成也萧何败萧何」，由于 LR 只能捕捉关于特征的线性信息，而无法捕捉非线性信息——特别是交叉特征信息，人们对 LR 进行了各种升级改造。</p><p>此篇介绍因子分解机模型（Factorization Machine）。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先我们介绍一下在实际工程中模型的使用背景。</p><h3 id="特征稀疏性"><a href="#特征稀疏性" class="headerlink" title="特征稀疏性"></a>特征稀疏性</h3><p>在诸如 CTR 预估、推荐或搜索 ranking 的场景中，特征是非常稀疏的。特征的稀疏性往往来自分类特征的 one-hot 编码。举例来说，我们有以下数据集。数据集中的「点击」是 label，而性别、地区、频道则是特征。</p><table><thead><tr><th>点击</th><th>性别</th><th>地区</th><th>频道</th></tr></thead><tbody><tr><td>1</td><td>男</td><td>天津</td><td>相声</td></tr><tr><td>0</td><td>女</td><td>甘肃</td><td>体育</td></tr><tr><td>1</td><td>女</td><td>云南</td><td>电视剧</td></tr></tbody></table><p>不难发现，在这个场景下，性别、地区、频道都是分类特征。其中性别有 2 个取值；地区按省级行政单位划分全中国有 30 余个取值；频道则可能更多，可能有上百个取值。由于类别特征的不同取址之间，在数值上是不可比较和不可计算的——例如我们没法说「天津与甘肃哪个更大」，或者去计算「云南 * 3 是多少」——因此我们通常会对这些分类特征进行 one-hot 编码。</p><table><thead><tr><th>点击</th><th>性别 = 男</th><th>性别 = 女</th><th>地区 = 天津</th><th>地区 = 甘肃</th><th>地区 = 云南</th><th>频道 = 相声</th><th>频道 = 体育</th><th>频道 = 电视剧</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>这里仅列出了 8 维特征。但实际上，如前所述，实际上由性别、地区、频道 one-hot 编码之后，特征维度会升高到 100+ 维。但对于每一条样本，这 100+ 维特征中，大多数的取值都是 0。具体来说，由于它们来自三个原始的分类特征，因此这 100+ 维特征中只有 3 维取值为 1，其余都是 0。</p><p>由此可见其稀疏性。</p><h3 id="交叉特征"><a href="#交叉特征" class="headerlink" title="交叉特征"></a>交叉特征</h3><p>用户是否会点击某个 item，往往与不同特征的组合高度相关。例如，地处天津的用户点击相声类 item 的概率可能显著高于全国用户的平均水平。因此，若一条样本的 <code>地区 = 天津</code> 和 <code>频道 = 相声</code> 同时出现，则其 CTR 应该相对较高。</p><p>对于这些特征，对产品形态和策略较熟悉的工程师，可以根据这些先验知识，进行人工的特征组合，作为新的组合特征交付给模型使用。使用 LR 作为 CTR 预估模型/ranking 模型时，往往会需要工程师进行大量的特征工程操作，以便提升模型的预测性能。</p><p>不过，当分类特征增多，特别是取值多的分类特征越来越多，进行人工特征交叉的工作量会越来越大。此外，全凭经验的特征工程，可能无法完全捕捉到特征中蕴含的规律，从而降低模型预测性能的天花板。这是这类做法的主要缺陷之一。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如此一来，我们就会希望设计一些模型，使得它们</p><ul><li>能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）；</li><li>同时，我们还要求这些模型能够自动地学习到特征交叉带来的信息。</li></ul><h2 id="模型演进的背后"><a href="#模型演进的背后" class="headerlink" title="模型演进的背后"></a>模型演进的背后</h2><p>讲清楚了背景情况和总结了问题之后，我们就能分析模型演进背后的原理了。</p><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p>这里说的线性模型指的是线性回归和逻辑回归模型。假设模型的输入是特征向量 <code>$\vec x$</code>，则它们的预测函数分别是：</p><ul><li>线性回归：<code>$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i$</code>；</li><li>逻辑回归：<code>$\hat y = f(\vec x) = \sigma(\vec w\vec x) = \frac{1}{1 + \exp{\{w_0 + \sum_{i = 1}^{n}w_ix_i\}}}$</code>。</li></ul><p>线性模型的优势是简单可解释易扩展易并行。因此，逻辑回归模型是 CTR 预估领域早期最成功的模型。并且时至今日，仍有工业级的系统仍然采用逻辑回归模型。</p><p>不过，如前所述，由于线性模型无法捕获交叉特征带来的信息，因此其预测效果依赖大量的人工特征工程。随着特征量和样本量的增加，人工特征工程的成本越来越高，考虑让模型自动学习特征组合是必然的模型演进方向。</p><h3 id="二阶多项式核-SVM"><a href="#二阶多项式核-SVM" class="headerlink" title="二阶多项式核 SVM"></a>二阶多项式核 SVM</h3><p>既然单纯的线性模型无法捕获交叉特征。那么，最简单直接的做法就是为两两的特征组合分配一个权重参数。这些新的权重参数和原始特征对应的参数一样，交给模型去在训练阶段学习。如此一来就形成了如下的预测函数：</p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}w_{i, j}x_ix_j.$$</code></p><blockquote><p>这实际上就是核函数选择为二阶多项式核的 SVM 模型。</p></blockquote><p>这样设计的模型看起来能够学习到特征两两交叉带来的信息了。但这只是理论上的改进，别忘了我们从工程背景中抽象出来的问题中的第一条要求：</p><ul><li>能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）。</li></ul><p>由于 <code>$w_{i, j}$</code> 的取值<strong>完全取决于 <code>$x_i$</code> 和 <code>$x_j$</code> 的乘积</strong>，在数据稀疏的场景下，可能存在训练集中 <code>$x_ix_j$</code> 始终为零的情况。这样一来，模型就无法有效地更新权重 <code>$w_{i, j}$</code> 了；更进一步，在预测阶段，模型遇到 <code>$x_ix_j$</code> 不为零的情况可能就很难有效地泛化。</p><h3 id="因子分解机模型"><a href="#因子分解机模型" class="headerlink" title="因子分解机模型"></a>因子分解机模型</h3><p>既然二阶多项式核 SVM 泛化性能不足的原因是「<code>$w_{i, j}$</code> 的取值<strong>完全取决于 <code>$x_i$</code> 和 <code>$x_j$</code> 的乘积</strong>」，那么最直接的办法就是突破这一限制了。</p><p>FM 模型的解决办法是为每个维度的特征（<code>$x_i$</code>）学习一个表征向量（<code>$v_i$</code>，其实可以理解为是特征 ID 的 embedding 向量）。而后将 <code>$x_i$</code> 和 <code>$x_j$</code> 的乘积的权重设定为各自表征向量的点积。也就是有如下形式的预测函数：</p><p><code>$$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle x_ix_j.$$</code></p><p>显然，FM 模型也具有二阶多项式核 SVM 的优点：能够学习到特征两两交叉带来的信息。那么现在的问题是，为什么相对二阶多项式核 SVM 做出的改进能够提高模型的泛化性能？</p><p>如果你熟悉现在深度学习中各种对 item 的 embedding 操作，那么这个问题就不难理解了。FM 模型的表征向量相比深度学习中各种 embedding 其实是一回事——只是少了若干层 MLP，而是直接对交叉特征的组合进行建模。</p><p>我们回到上一小节举的例子：训练集中 <code>$x_ix_j$</code> 始终为零。在二阶多项式核 SVM 中，由于参数权重 <code>$w_{i, j}$</code> 得不到更新，模型无法学到 <code>$x_i$</code> 和 <code>$x_j$</code> 交叉带来的信息。但是在 FM 中，<code>$x_i$</code> 和 <code>$x_j$</code> 的参数并不完全由 <code>$x_i$</code> 和 <code>$x_j$</code> 的乘积决定。具体来说，每一维特征的表征向量由该维特征与其它所有维度特征的交叉共同决定。于是，只要存在某个 <code>$k$</code> 使得 <code>$x_i$</code> 和 <code>$x_k$</code> 的乘积不总是为零，那么第 <code>$i$</code> 维特征的表征向量 <code>$\vec v_i$</code> 就能够学到有效的信息——同理对 <code>$\vec v_j$</code> 也有同样的结论。于是乎，哪怕在训练集中，<code>$x_ix_j$</code> 始终为零，其参数 <code>$\langle \vec v_i, \vec v_j\rangle$</code> 也是经过了学习更新的，因此能够表现出很好的泛化性能。</p><p>也许有人会说，如果不存在这样的 <code>$k$</code> 使得 <code>$x_i$</code> 和 <code>$x_k$</code> 的乘积不总是为零，会怎么样呢？好吧，这就意味着这一维特征的取值永远是零——那它还有什么意义？从特征列表中删掉它就好啦！</p><h2 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h2><p>在文章开篇，我们提到「LR 可以以很高的效率去学习和预测，因而在很多领域都被广泛应用」。那么 FM 模型如何呢？如果 FM 模型训练和预测都死慢死慢地，那么工程师迭代模型的效率会非常低，上线后 serving 的开销也会很大。这样一来，等待 FM 模型的最终结果必然是被抛弃……</p><p>考虑到 FM 模型会对特征进行二阶组合，在有 $n$ 个原始特征时，交叉特征就会有 <code>$\frac{n ^ 2 - n}{2}$</code> 个。因此，如果不做任何优化，FM 模型的复杂度会是 <code>$O(n^2)$</code>，具体来说是 <code>$O(kn^2)$</code>（其中 <code>$k$</code> 是表征向量的长度）。在特征规模非常大的场景中，这是不可接受的。</p><p>那么问题来了，是否有办法将复杂度降低到 <code>$O(kn)$</code> 呢？答案是可以的，我们来看针对特征交叉项的一系列变换。</p><p><code>$$\begin{aligned}\sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle x_ix_j    &amp;{} = \sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n} \langle \vec v_i, \vec v_j\rangle x_ix_j \\    &amp;{} = \frac{1}{2}\sum_{i = 1}^{n}\sum_{j = 1}^{n}\langle \vec v_i, \vec v_j\rangle x_ix_j - \frac{1}{2}\sum_{i = 1}^{n}\langle \vec v_i, \vec v_i\rangle x_ix_i \\    &amp;{} = \frac{1}{2}\biggl(\sum_{i = 1}^{n}\sum_{j = 1}^{n}\sum_{d = 1}^{k}\vec v_{i, d}\vec v_{j, d}x_ix_j - \sum_{i = 1}^{n}\sum_{d = 1}^{k}\vec v_{i, d}^2x_i^2\biggr) \\    &amp;{} = \frac{1}{2}\sum_{d = 1}^{k}\biggl(\sum_{i = 1}^{n}\sum_{j = 1}^{n}\vec v_{i, d}\vec v_{j, d}x_ix_j - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr) \\    &amp;{} = \frac{1}{2}\sum_{d = 1}^{k}\biggl(\Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)\Bigl(\sum_{j = 1}^{n}\vec v_{j, d}x_j\Bigr) - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr) \\    &amp;{} = \frac{1}{2}\sum_{d = 1}^{k}\biggl(\Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)^2 - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr).\end{aligned}$$</code></p><p>等式第一行是一个平凡的变换，很容易理解。</p><p>等式第二行修改了求和符号的范围。原本的求和符号中有 <code>$\frac{n ^ 2 - n}{2}$</code> 项；变换之后第一项中的求和符号有 <code>$n^2$</code> 项，第二项中的求和符号有 <code>$n$</code> 项。因此两式恰好相等。</p><p>等式第三行是对向量内积的展开，很容易理解。</p><p>等式第四行是运用了加法的结合律，将 <code>$\sum_{d = 1}^{k}$</code> 抽到外面，这步容易理解。</p><p>等式第五行是连续两次逆向使用了乘法对加法的分配率（提取公因子），这一步可能稍微难理解一些。简便起见，我们将 <code>$\vec v_{i, d}x_i$</code> 记作 <code>$a_i$</code>；将 <code>$\vec v_{j, d}x_j$</code> 记作 <code>$a_j$</code>。则变换前的公式记作 <code>$\sum_{i = 1}^{n}\sum_{j = 1}^{n}a_ia_j$</code>。将它展开是：</p><p><code>$$\begin{aligned}\sum_{i = 1}^{n}\sum_{j = 1}^{n}a_ia_j   = {}&amp; a_1a_1 + a_1a_2 + \cdots + a_1a_n + \\     {}&amp; a_2a_1 + a_2a_2 + \cdots + a_2a_n + \\     {}&amp; \cdots + \\     {}&amp; a_na_1 + a_na_2 + \cdots + a_na_n \\   = {}&amp; a_1\bigl(a_1 + a_2 + \cdots + a_n\bigr) + \\     {}&amp; a_2\bigl(a_1 + a_2 + \cdots + a_n\bigr) + \\     {}&amp; \cdots + \\     {}&amp; a_n\bigl(a_1 + a_2 + \cdots + a_n\bigr) \\   = {}&amp; a_1\Bigl(\sum_{j = 1}^{n}a_j\Bigr) + a_2\Bigl(\sum_{j = 1}^{n}a_j\Bigr) + \cdots + a_n\Bigl(\sum_{j = 1}^{n}a_j\Bigr) \\   = {}&amp; \sum_{i = 1}^{n}a_i\sum_{j = 1}^{n}a_j \\   = {}&amp; \Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)\Bigl(\sum_{j = 1}^{n}\vec v_{j, d}x_j\Bigr).\end{aligned}$$</code></p><p>等式第六行也很明显。第五行的结果中的两个求和项仅仅是下标不同，实际上完全是一回事，因此直接平方就好了。</p><p>如此一来，FM 的预测公式变成了下面这样</p><p><code>$$\begin{aligned}\hat y  &amp;{} = f(\vec x) \\  &amp;{} = w_0 + \sum_{i = 1}^{n}w_ix_i + \frac{1}{2}\sum_{d = 1}^{k}\biggl(\Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)^2 - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr).\end{aligned}$$</code></p><p>显然，它的复杂度是 <code>$O(kn)$</code>。考虑到特征的稀疏性，尽管 <code>$n$</code> 可能很大，但很多 <code>$x_i$</code> 都是零。因此其实际复杂度应该是 <code>$O(k\bar n)$</code>——其中 <code>$\bar n$</code> 表示样本不为零的特征维度数量的平均值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下。FM 模型不仅在模型本身能够满足下列两个特性，还保证了训练和预测的效率为 <code>$O(k\bar n)$</code>，因而是非常优秀的模型、被广泛运用：</p><ul><li>能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）；</li><li>同时，能够自动地学习到特征交叉带来的信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先前我们讨论过&lt;a href=&quot;/2018/10/10/logistic-regression/&quot;&gt;逻辑回归&lt;/a&gt;。作为线性模型，它最大的优势是简单，于是可以以很高的效率去学习和预测，因而在很多领域都被广泛应用。但「成也萧何败萧何」，由于 LR 只能捕捉关于特征的线性信息，而无法捕捉非线性信息——特别是交叉特征信息，人们对 LR 进行了各种升级改造。&lt;/p&gt;
&lt;p&gt;此篇介绍因子分解机模型（Factorization Machine）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Logistic Regression" scheme="https://liam.page/tags/Logistic-Regression/"/>
    
      <category term="Ranking" scheme="https://liam.page/tags/Ranking/"/>
    
      <category term="Factorization Machine" scheme="https://liam.page/tags/Factorization-Machine/"/>
    
      <category term="SVM" scheme="https://liam.page/tags/SVM/"/>
    
      <category term="CTR" scheme="https://liam.page/tags/CTR/"/>
    
  </entry>
  
  <entry>
    <title>于 CentOS 7 上编译安装 Python 3.7.2</title>
    <link href="https://liam.page/2019/03/19/compile-and-install-Python-3-7-2-on-CentOS-7/"/>
    <id>https://liam.page/2019/03/19/compile-and-install-Python-3-7-2-on-CentOS-7/</id>
    <published>2019-03-19T08:59:02.000Z</published>
    <updated>2019-08-27T09:43:08.954Z</updated>
    
    <content type="html"><![CDATA[<p>又到了愉悦地配置系统的时间……今日的任务是在 CentOS 7 上安装最新版本的 Python 3.7.2。</p><p>由于前些日子，蛤力橙表示 Anaconda 是 some what 邪恶的，所以这次不打算偷懒用 Anaconda 了，而是选择从源码编译安装。这里记录一些踩过的坑。</p><a id="more"></a><h2 id="安装完成后-yum-等脚本挂掉"><a href="#安装完成后-yum-等脚本挂掉" class="headerlink" title="安装完成后 yum 等脚本挂掉"></a>安装完成后 <code>yum</code> 等脚本挂掉</h2><p>原因：<code>yum</code> 等脚本依赖 Python2 而非 Python3。这次跨大版本升级，会破坏 <code>yum</code> 等脚本 shebang 头部的指令。</p><p>解决办法：使 <code>yum</code> 等脚本显式依赖 Python2。</p><p>具体：修改 <code>/usr/bin</code> 下 <code>yum</code> 相关脚本的 shebang 头，将 <code>python</code> 修改为 <code>python2</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">$ ls -al yum*</span><br><span class="line">-rwxr-xr-x. 1 root root   801 11月 15 2016 yum</span><br><span class="line">-rwxr-xr-x. 1 root root  9429 11月  6 2016 yum-builddep</span><br><span class="line">-rwxr-xr-x. 1 root root  8582 11月  6 2016 yum-config-manager</span><br><span class="line">-rwxr-xr-x. 1 root root  7609 11月  6 2016 yum-debug-dump</span><br><span class="line">-rwxr-xr-x. 1 root root  7903 11月  6 2016 yum-debug-restore</span><br><span class="line">-rwxr-xr-x. 1 root root 10999 11月  6 2016 yumdownloader</span><br><span class="line">-rwxr-xr-x. 1 root root 11031 11月  6 2016 yum-groups-manager</span><br></pre></td></tr></table></figure><h2 id="安装过程中缺胳膊少腿"><a href="#安装过程中缺胳膊少腿" class="headerlink" title="安装过程中缺胳膊少腿"></a>安装过程中缺胳膊少腿</h2><p>原因：Python 依赖其他第三方库，而这些库在系统内没有安装，或者安装的位置不在 Python 安装脚本默认搜索的范围内。</p><p>解决办法：使用 <code>yum</code> 一口气安装就好了。</p><p>具体：执行下列 <code>yum</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y ncurses-libs zlib-devel mysql-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</span><br></pre></td></tr></table></figure><h2 id="安装完成后-pip-提示没有可用的-SSL，以至于无法访问-https-协议的源"><a href="#安装完成后-pip-提示没有可用的-SSL，以至于无法访问-https-协议的源" class="headerlink" title="安装完成后 pip 提示没有可用的 SSL，以至于无法访问 https 协议的源"></a>安装完成后 <code>pip</code> 提示没有可用的 SSL，以至于无法访问 <code>https</code> 协议的源</h2><p>原因：Python 编译时没有将 SSL 编译进去。</p><p>解决办法：安装符合要求的 OpenSSL 版本，并在 <code>./configure</code> 时添加 <code>--with-ssl</code> 参数。</p><p>具体：执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/downloads</span><br><span class="line">$ wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.1b.tar.gz</span><br><span class="line">$ tar zvxf openssl-1.1.1b.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> openssl-1.1.1b</span><br><span class="line">$ ./config -fPIC --prefix=/usr/ --openssldir=/usr/openssl <span class="built_in">enable</span>-shared shared zlib</span><br><span class="line">$ make -j24</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><blockquote><p>注意：必须安装 1.0.2 以上版本的 OpenSSL，故而 <code>yum</code> 源当中的 1.0.1 版本不可用。</p></blockquote><h2 id="依赖-SSL-之后提示-UUID-编译失败"><a href="#依赖-SSL-之后提示-UUID-编译失败" class="headerlink" title="依赖 SSL 之后提示 UUID 编译失败"></a>依赖 SSL 之后提示 UUID 编译失败</h2><p>原因：Python 的 UUID 相关扩展的代码有 bug；无法正确载入 <code>uuid.h</code> 头文件或者载入了两个版本的头文件。</p><p>解决办法：修改相应头文件。</p><p>具体：在 Python 源码根目录，编辑 <code>./Modules/_uuidmodule.c</code> 文件，修改头部 <code>#include</code> 部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PY_SSIZE_T_CLEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Python.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_UUID_UUID_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uuid/uuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下编译安装 Python 3.7.2 时用到的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ncurses-libs zlib-devel mysql-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel uuid-devel libuuid-devel libffi-devel</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path/to/downloads</span><br><span class="line">wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.1b.tar.gz</span><br><span class="line">tar zvxf openssl-1.1.1b.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1b</span><br><span class="line">./config -fPIC --prefix=/usr/ --openssldir=/usr/openssl <span class="built_in">enable</span>-shared shared zlib</span><br><span class="line">make -j24</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path/to/downloads</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz</span><br><span class="line">tar zvxf Python-3.7.2.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.7.2</span><br><span class="line">sed -i <span class="string">"6s/endif/else/"</span> ./Modules/_uuidmodule.c</span><br><span class="line">sed -i <span class="string">"7d"</span> ./Modules/_uuidmodule.c</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3.7.2 --<span class="built_in">enable</span>-optimizations --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-profiling --with-ssl</span><br><span class="line">make -j24</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> $(ls /usr/<span class="built_in">local</span>/python3.7.2/bin/); <span class="keyword">do</span> ln -sf /usr/<span class="built_in">local</span>/python3.7.2/bin/<span class="variable">$&#123;fname&#125;</span> ./<span class="variable">$&#123;fname&#125;</span>; <span class="keyword">done</span></span><br><span class="line">ln -sf pydoc3 pydoc</span><br><span class="line">ln -sf python3 python</span><br><span class="line">ln -sf python3-config python-config</span><br><span class="line">ln -sf pip3 pip</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又到了愉悦地配置系统的时间……今日的任务是在 CentOS 7 上安装最新版本的 Python 3.7.2。&lt;/p&gt;
&lt;p&gt;由于前些日子，蛤力橙表示 Anaconda 是 some what 邪恶的，所以这次不打算偷懒用 Anaconda 了，而是选择从源码编译安装。这里记录一些踩过的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="OpenSSL" scheme="https://liam.page/tags/OpenSSL/"/>
    
      <category term="UUID" scheme="https://liam.page/tags/UUID/"/>
    
      <category term="yum" scheme="https://liam.page/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>到底什么是「内容与样式分离」</title>
    <link href="https://liam.page/2019/03/18/separation-of-content-and-presentation/"/>
    <id>https://liam.page/2019/03/18/separation-of-content-and-presentation/</id>
    <published>2019-03-18T06:18:21.000Z</published>
    <updated>2019-08-27T09:43:08.952Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的原因有两个。</p><ol><li>时至今日仍然有很多人在按「这一行要缩进两个字符、加粗」的方式来使用 LaTeX；</li><li>市面上关于 LaTeX 的资料大都宣称「LaTeX 是内容与样式分离的」，却不对此做进一步解释，含混而过。</li></ol><p>我认为有必要对此稍作解释（或者是重新解释），形成一篇短文，填上这一空白。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内容与样式分离在英文环境中，更多地被称作：内容与表现分离（separation of content and presentation）。这里的「表现」指的是内容呈现出来的状态，即英文：「the state of being presented」。这一原则的本意是一篇文档的实际内容和逻辑结构与这篇文档呈现给读者看到的样式是相互独立的。举个栗子。<code>em</code> 是 <code>emphasis</code> 的缩写。于是 HTML 语法中的 <code>&lt;em&gt;</code> 标签和 LaTeX 语法中的 <code>\emph{}</code> 命令，都是用来强调文档中的一部分内容使用的。通常，被强调的内容的样式是「倾斜体」。但请注意，「被强调的内容」与「倾斜体」之间的关系，既不充分也不必要。这也就是说，被强调的内容既可以是倾斜体，也可以不是倾斜体——例如可以用增加下划线或者用更高的字重（即用粗体）；另一方面，倾斜体也不一定是被强调的内容——排版诗歌时，一般就会用到倾斜体。</p><blockquote><p>由此也可见得，「内容与样式分离」这一原则并非只属于 LaTeX。它是一种通用的原则，并非 LaTeX 家专属。</p></blockquote><h2 id="思维流"><a href="#思维流" class="headerlink" title="思维流"></a>思维流</h2><p>基于这些对「内容与样式分离」的理解，我们可以看看在内容与样式分离这一原则之下，写作时的思维流应该是怎样的。思维流是我自创的概念；在我的理解中</p><p>$$ \text{思维流} = \text{思考方式} + \text{思考的内容}. $$</p><p>这里我们以下面的内容为例，看一看思维流是怎样的。</p><blockquote><p><strong>定理 1 (勾股定理).</strong> <em>设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立.</em></p></blockquote><h3 id="内容与样式不分离"><a href="#内容与样式不分离" class="headerlink" title="内容与样式不分离"></a>内容与样式不分离</h3><p>对于内容与样式不分离的思维流，书写这段文字的时候大概是这样的：</p><ul><li>加粗</li><li><code>定理</code></li><li><code>空格</code></li><li>数字 <code>1</code></li><li>左括号 <code>(</code></li><li><code>勾股定理</code></li><li>右括号 <code>)</code></li><li>句点 <code>.</code></li><li>空格 <code></code></li><li>结束加粗</li><li>倾斜体</li><li><code>设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立.</code></li><li>结束倾斜</li></ul><p>翻译成 LaTeX 代码大概会是这样：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">textbf</span><span class="string">&#123;定理 1 (勾股定理).&#125;</span></span> <span class="tag">\<span class="name">textsl</span><span class="string">&#123;设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立.&#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>不遵守内容与样式分离的原则时，作者的思维是非结构化的。作者思考的是「这一小块内容应该是加粗还是倾斜，是多大字号」这些问题。然后，作者在书写内容时，不得不边写边调整格式。</strong></p><h3 id="内容与样式分离"><a href="#内容与样式分离" class="headerlink" title="内容与样式分离"></a>内容与样式分离</h3><p>对于内容与样式分离的思维流，书写这段文字的时候大概是这样：</p><ul><li>这是一个 <code>定理</code></li><li>它的编号是 <code>1</code></li><li>它的名字是 <code>勾股定理</code></li><li>它的内容是 <code>设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立.</code></li><li>把它们分别放在恰当的标记中（在 LaTeX 中是定理环境）</li></ul><p>翻译成 LaTeX 代码大概会是这样：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;theorem&#125;</span><span class="string">[勾股定理]</span></span></span><br><span class="line">设直角三角形的三条边长分别是 <span class="formula">$a$</span>, <span class="formula">$b$</span> 和 <span class="formula">$c$</span>，其中 <span class="formula">$c$</span> 是斜边边长，则有 <span class="formula">$a^2 + b^2 = c^2$</span> 成立.</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;theorem&#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>在内容与样式分离的原则下，作者的思维流是结构化的。具体来说，作者会思考：「这一小块内容起到了什么作用，属于什么结构」，然后相应地标记（在 LaTeX 中是命令或者控制序列）这些内容。例如，在这个例子中，作者用 <code>theorem</code> 环境把定理的各个方面标记起来。这种情况下，作者无需边写边调整格式，只需在撰写文档开始前或者结束后，统一定义各个标记的具体样式即可。</strong></p><h2 id="一个问答"><a href="#一个问答" class="headerlink" title="一个问答"></a>一个问答</h2><p>很多人使用 LaTeX 时往往会有这种疑惑：不是说 LaTeX 是内容与样式分离的吗？为什么为用 LaTeX 写文章的时候，还要不停去调整格式？</p><p>对此，我的回答如下：</p><ol><li>LaTeX 是按照「内容与样式分离」的原则设计的没错，但是具体能不能遵循这一原则，还要看具体使用的人。事实上，从 Office 2003 开始，Microsoft Word 也引入了样式的功能，可以在这一原则下写作。这一点与 LaTeX 是一样的。但是有多少人会「正确地使用 Word」呢？</li><li>如果写作的过程中会需要你不停调整格式，说明你没有完全遵循内容与样式分离的思维流。你需要做的事情是切换思维流：<ul><li>遇到一段内容，比如 <code>foo bar baz</code>，你打算将其加粗并将字体放大。比如使用 <code>\textbf{\LARGE foo bar baz}</code>；</li><li>你需要做的是停下，然后去思考这一段内容究竟起到什么作用？属于什么结构？比如，你发现它是练习题的名字，接下来还会有练习题的内容。</li><li>那么你需要在导言区定义一个命令或者环境，用于标记练习题。比如定义一个带有一个参数的环境 <code>MyExercise</code>。此时你可以不去设计这个环境的具体格式，只需要有一个框架即可。</li><li>然后，你应该在恰当的位置使用该环境。</li><li>最后，当你文章写完之后，如果还有尚未确定样式的命令或环境，再去慢慢设计就好了。</li></ul></li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;MyExercise&#125;</span><span class="string">[1]</span><span class="string">&#123;#1\par&#125;</span><span class="string">&#123;\par&#125;</span></span></span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;MyExercise&#125;</span><span class="string">&#123;foo bar baz&#125;</span></span></span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;MyExercise&#125;</span></span></span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的原因有两个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时至今日仍然有很多人在按「这一行要缩进两个字符、加粗」的方式来使用 LaTeX；&lt;/li&gt;
&lt;li&gt;市面上关于 LaTeX 的资料大都宣称「LaTeX 是内容与样式分离的」，却不对此做进一步解释，含混而过。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我认为有必要对此稍作解释（或者是重新解释），形成一篇短文，填上这一空白。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Content" scheme="https://liam.page/tags/Content/"/>
    
      <category term="Presentation" scheme="https://liam.page/tags/Presentation/"/>
    
      <category term="Style" scheme="https://liam.page/tags/Style/"/>
    
  </entry>
  
  <entry>
    <title>在 Tmux 创建 window 或 pane 之后执行命令</title>
    <link href="https://liam.page/2019/03/07/execute-command-after-create-new-window-or-pane-in-Tmux/"/>
    <id>https://liam.page/2019/03/07/execute-command-after-create-new-window-or-pane-in-Tmux/</id>
    <published>2019-03-07T07:19:32.000Z</published>
    <updated>2019-08-27T09:43:08.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇简单的记录。</p></blockquote><p>最近在服务器上安装 Tmux，但每次新建 window 或 pane 之后，不会加载 <code>.bashrc</code> 中的内容。这大概与机器上默认的 login shell 的配置有关。一瞬间，脑海里想到的有两种解法。</p><ul><li>修改 Tmux 默认启动的 shell；</li><li>在 Tmux 创建 window 或 pane 之后执行命令，<code>source ~/.bashrc</code>。</li></ul><a id="more"></a><p>前一种解法不难，但只有这单一的用处。修改 <code>~/.tmux.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>-option -g default-shell <span class="string">"/bin/bash"</span></span><br></pre></td></tr></table></figure><p>后一种解法就灵活多了。具体就是在 <code>split-window</code> 或者 <code>new-window</code> 之后向 shell 发送命令。修改 <code>~/.tmux.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> c new-window \; send-keys <span class="string">"source ~/.bashrc; clear"</span> Enter</span><br><span class="line"><span class="built_in">bind</span> - splitw -v \; send-keys <span class="string">"source ~/.bashrc; clear"</span> Enter</span><br><span class="line"><span class="built_in">bind</span> | splitw -h \; send-keys <span class="string">"source ~/.bashrc; clear"</span> Enter</span><br></pre></td></tr></table></figure><p>此处我将 <code>prefix + c</code> 绑定为产生新 window 的快捷键，而后向 shell 发送 <code>source ~/.bashrc; clear</code> 的命令并回车。<code>prefix + -</code> 和 <code>prefox + |</code> 则分别被设置为纵向和横向分割 window 产生新的 pane，同样会发送相关命令到 shell。如此一来，前述问题就解决了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一篇简单的记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在服务器上安装 Tmux，但每次新建 window 或 pane 之后，不会加载 &lt;code&gt;.bashrc&lt;/code&gt; 中的内容。这大概与机器上默认的 login shell 的配置有关。一瞬间，脑海里想到的有两种解法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改 Tmux 默认启动的 shell；&lt;/li&gt;
&lt;li&gt;在 Tmux 创建 window 或 pane 之后执行命令，&lt;code&gt;source ~/.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Tmux" scheme="https://liam.page/tags/Tmux/"/>
    
  </entry>
  
  <entry>
    <title>古诗词文赏析：鹊桥仙·纤云弄巧</title>
    <link href="https://liam.page/2019/03/03/Queqiaoxian-Xianyunnongqiao/"/>
    <id>https://liam.page/2019/03/03/Queqiaoxian-Xianyunnongqiao/</id>
    <published>2019-03-03T07:50:32.000Z</published>
    <updated>2019-08-27T09:43:08.949Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个纯正的理工科学生，虽然在读书时代语文成绩不好，却在这些年随着阅历的增长，慢慢地能够感受到古诗词文传递的情绪、情感、力量甚至中国古代士子的精神追求。每次读到横渠四句，也会忍不住想要「为天地立心，为生民立命，为往圣继绝学，为万世开太平」。这大概是与中国人的文化血脉分不开的什么东西——说不清道不明，但又确实存在。于是，就这么带着不少冲动，决定开启古诗词文赏析这个系列的大坑，试着要去填一填。——哪怕填不好，哪怕会贻笑大方。但我写的是我自己的理解，希望能带给读者一些以前未有过的感受。</p><p>此篇谈谈秦观的佳作：鹊桥仙·纤云弄巧。</p><blockquote><p>纤云弄巧，飞星传恨，银汉迢迢暗渡。金风玉露一相逢，便胜却人间无数。<br>柔情似水，佳期如梦，忍顾鹊桥归路。两情若是久长时，又岂在朝朝暮暮？</p></blockquote><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这首鹊桥仙的背景，作为中国人大概再熟悉不过了。这是一首七夕词，说的是牛郎和织女的故事。</p><p>作为中国最著名的爱情故事——可能没有之一，牛郎和织女的故事不一定是一个悲剧，但一定是充满了<strong>遗憾</strong>色彩的故事。而遗憾，正是男女情感之间，最令人感怀的一种情绪。正因如此，在中国古代，有不少诗词曲以七夕和牛郎织女的故事为题，寄托诗词作者自己的情感。其中传唱最久远的，大概是汉乐府的一首古诗：</p><blockquote><p>汉乐府·古诗十九首之一<br>迢迢牵牛星，皎皎河汉女。<br>纤纤擢素手，札札弄机杼。<br>终日不成章，泣涕零如雨。<br>河汉清且浅，相去复几许。<br>盈盈一水间，脉脉不得语。</p></blockquote><p>也许是因为牛郎织女故事中的遗憾，七夕诗词曲大多逃不开「痴男怨女」的基调。例如此处汉乐府的古诗就细致地描写了织女因相似而不成章、泣涕如雨的样子，又讲银河就那么清浅，却与情郎不得相见叙说的苦闷。</p><p>秦观的鹊桥仙却别出机杼，堪称七夕诗词之最。</p><h2 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h2><blockquote><p>纤云弄巧，飞星传恨，银汉迢迢暗渡。</p></blockquote><p>上阙开头的第一句极其巧妙。</p><p>首先，牛郎织女是两颗星星。于是讲七夕的故事，肯定是晚上天空里的事情。写「纤云弄巧」，描写天上云彩的变化，就必须要「抬头看天」；写「飞星传恨」，描写一闪而逝的流星，就暗示了「夜晚」的场景。其次，牛郎织女一年一会，分开之后相会之前，肯定有数不尽的思绪要说，说不出来就变成恨。思绪万千就如同天上的云朵变换，思绪不得传达，就恨不得能如流星那样快点传达给对方。最后，「迢迢」和「暗渡」又体现了爱人相见之前的情绪。迢迢是「悄悄地」的意思：爱人相会自然是悄悄地私会，又要避开「王母」。暗渡中的「暗」字承接了「迢迢」悄悄的义项，「渡」字又承接「弄巧」、「传恨」，透出急迫的心情。</p><p>不过，上阙第一句巧妙有余，但其余不足。第一句仅仅是叙事，传达出的作者的情感态度却很少。若凭此就能成为七夕词之最，未免名不副实。我们接下来看第二句。</p><blockquote><p>金风玉露一相逢，便胜却人间无数。</p></blockquote><p>上阙第二句乃是一绝。这句没有七夕之哀愁，化恨为惜、化恨为喜。秋风秋露原本是平平一见的事物，但到了七夕这一天，在牛郎织女的眼里，那便是金风玉露。足以衬托出牛郎织女相见的不易。爱人之间，一年才能见一次，见到了难道不珍惜？悲了一年，难道不喜？如此难道不胜过人间万事？</p><blockquote><p>柔情似水，佳期如梦，忍顾鹊桥归路。</p></blockquote><p>下阙第一句写两人相见时互诉情深，其柔情似水，又写这短暂相会的「假期」如梦一样短暂，离开时不敢看鹊桥。这似乎又回到了悲恨交织的轨道了，看起来大煞风景。要知道，描写这种情绪，再怎么也妙不过「盈盈一水间，脉脉不得语」的画面感。但是，秦观在下一句却峰回路转、神来之笔，传唱天下。</p><blockquote><p>两情若是久长时，尤其在朝朝暮暮？</p></blockquote><p>人人都知道牛郎织女感情深，但这么多七夕诗词却摆脱不了怨憎的窠臼。整首词写牛郎织女：见前恨，见时喜，离别悲。而后在最后一句又看破离别苦恨难分难舍，讲「有情人不怕千山万水之隔」。这句饱含的感情至真至善，一举超越千万七夕诗词，传唱天下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个纯正的理工科学生，虽然在读书时代语文成绩不好，却在这些年随着阅历的增长，慢慢地能够感受到古诗词文传递的情绪、情感、力量甚至中国古代士子的精神追求。每次读到横渠四句，也会忍不住想要「为天地立心，为生民立命，为往圣继绝学，为万世开太平」。这大概是与中国人的文化血脉分不开的什么东西——说不清道不明，但又确实存在。于是，就这么带着不少冲动，决定开启古诗词文赏析这个系列的大坑，试着要去填一填。——哪怕填不好，哪怕会贻笑大方。但我写的是我自己的理解，希望能带给读者一些以前未有过的感受。&lt;/p&gt;
&lt;p&gt;此篇谈谈秦观的佳作：鹊桥仙·纤云弄巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;纤云弄巧，飞星传恨，银汉迢迢暗渡。金风玉露一相逢，便胜却人间无数。&lt;br&gt;柔情似水，佳期如梦，忍顾鹊桥归路。两情若是久长时，又岂在朝朝暮暮？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Literature and Social Sciences" scheme="https://liam.page/categories/Literature-and-Social-Sciences/"/>
    
    
      <category term="Poetry" scheme="https://liam.page/tags/Poetry/"/>
    
  </entry>
  
</feed>
