<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2020-03-29T13:10:50.486Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语听力之五步精听法</title>
    <link href="https://liam.page/2020/03/29/five-step-training-method-for-English-listening/"/>
    <id>https://liam.page/2020/03/29/five-step-training-method-for-English-listening/</id>
    <published>2020-03-29T13:06:10.000Z</published>
    <updated>2020-03-29T13:10:50.486Z</updated>
    
    <content type="html"><![CDATA[<p>这里是凭回忆记录的赵东坡老师的「五步精听法」。这个方法是我很多年前在上 TOEFL iBT 培训时，从赵东坡老师处习得。</p><p>本文先讲怎么训练，然后解释为什么要这样训练。</p><a id="more"></a><h2 id="五步精听法"><a href="#五步精听法" class="headerlink" title="五步精听法"></a>五步精听法</h2><p>训练分为 5 步，需要的内容有两个：听力材料，听力材料对应的准确原文。</p><ol><li>播放一遍听力材料，不看原文，认真听；</li><li>打开听力原文，查找不认识的词和短语；</li><li>逐字句地翻译原文——必须成文，可以写在纸上或者打字放在电脑里，但不能口头翻译（「大概是这样就行了」是不行的）；</li><li>对照原文和译文，播放听力材料，落后听力原文三个单词做「影子跟读」，直到可以不看原文脱稿跟读；</li><li>在当天时间内（不一定要即时，但是要当天完成），认真听材料 20 遍，尝试根据听到的声音直接反应出对应的含义。</li></ol><h2 id="方法背后的原理"><a href="#方法背后的原理" class="headerlink" title="方法背后的原理"></a>方法背后的原理</h2><p>听力的最终目的是「听到声音就知道意思」。这就包括了两个步骤。首先是听到声音直到对方在说什么（英语，目标语言），这属于「听得清」的范畴；其次是知道对方说什么之后反应出对应的意思（中文，母语，思维语言）。</p><p>此外，因为听力是一个连续的过程，对这两个步骤还有「快」的要求。因为如果不够快，对方哗啦啦已经说到下一个话题了，可能我们还在反应上一个话题的内容。而「快」就要求对应于有一个比较大块的「意义反应单元」。什么意思呢？先以中文举例：当我们听到「我今天要去游泳」，我们理解的是整个句子，而不是逐词地理解「我、今天、要、去、游泳」。而放在英文中，非母语学生如果不经特别的训练，理解听力中说话人的语义往往是逐词进行的——就像后面那个例子一样。可以想见，这样去理解意思，是怎么都快不起来的。</p><p>可见，如果只是做听写练习，或者以美剧或者 VOA 之类的材料做泛听，是不够的。前者只解决了「辨音」的问题，而且效率低下；后者只是在不断地重复强化熟悉的句式和表达方式在脑海中的印象，不熟悉的内容还是不行。</p><p>这五步的精听练习中，第一步是模拟实际的环境（因为实际情况我们就只能听对方说一遍），第二步是辅助，第三步是建立英语到汉语的对应，第四步解决辨音的问题，第五步是在强化「声音 - 语义」的直接连接。这就是五步精听法背后的原理。</p><h2 id="推荐材料"><a href="#推荐材料" class="headerlink" title="推荐材料"></a>推荐材料</h2><ul><li>老托 93 篇听力练习</li><li>推荐的材料是科学美国人节目的「一分钟科学（Sixty Second Science）」</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是凭回忆记录的赵东坡老师的「五步精听法」。这个方法是我很多年前在上 TOEFL iBT 培训时，从赵东坡老师处习得。&lt;/p&gt;
&lt;p&gt;本文先讲怎么训练，然后解释为什么要这样训练。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="English" scheme="https://liam.page/tags/English/"/>
    
      <category term="Listening" scheme="https://liam.page/tags/Listening/"/>
    
  </entry>
  
  <entry>
    <title>使用 WITH ... AS ... 语句增强 SQL 查询的可读性</title>
    <link href="https://liam.page/2020/03/13/the-WITH-AS-clause-in-Hive-SQL/"/>
    <id>https://liam.page/2020/03/13/the-WITH-AS-clause-in-Hive-SQL/</id>
    <published>2020-03-13T10:36:46.000Z</published>
    <updated>2020-03-13T10:54:30.503Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读各种 Hive SQL，发现一个可读性问题，让我很无奈。这里记录一下，希望看到的读者能够写出可读性更好的代码。</p><p>因为业务比较复杂，所以大家经常会用到各种子查询（sub-query）。于是会写成类似这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  t1.foo,</span><br><span class="line">  t2.bar,</span><br><span class="line">  t3.baz</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      foo,</span><br><span class="line">      bar</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      tb1</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      &lt;conds&gt;</span><br><span class="line">  ) <span class="keyword">AS</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      baz</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      tb2</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      &lt;conds&gt;</span><br><span class="line">  ) <span class="keyword">AS</span> t2 <span class="keyword">ON</span> &lt;conds&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt;conds&gt;;</span><br></pre></td></tr></table></figure><p>这样写子查询会有两个问题。一是子查询的结果如果要在多个不同地方用到，那么就要复制粘贴多次，实际执行的时候也可能执行多次。二是当子查询或/和 JOIN 特别多的时候，整个查询就会变得无比复杂，可读性极差。为解决问题，可用视图（VIEW）解决，也可用 <code>WITH ... AS ...</code> 子句来解决。</p><a id="more"></a><p><code>WITH &lt;temprary_table_name&gt; AS (SELECT ... FROM &lt;table_name&gt; WHERE &lt;conds&gt;)</code>  和视图类似，可以创建一个临时表，供之后使用。按上述例子，改用 <code>WITH ... AS ...</code> 子句可以写成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> t1 <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    foo,</span><br><span class="line">    bar</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    tb1</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    &lt;conds&gt;</span><br><span class="line">),</span><br><span class="line">t2 <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    baz</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    tb2</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    &lt;conds&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  t1.foo,</span><br><span class="line">  t2.bar,</span><br><span class="line">  t3.baz</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> &lt;conds&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt;conds&gt;;</span><br></pre></td></tr></table></figure><p>很明显，这样写起来可读性会强很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读各种 Hive SQL，发现一个可读性问题，让我很无奈。这里记录一下，希望看到的读者能够写出可读性更好的代码。&lt;/p&gt;
&lt;p&gt;因为业务比较复杂，所以大家经常会用到各种子查询（sub-query）。于是会写成类似这样：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t1.foo,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t2.bar,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t3.baz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      foo,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      bar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      tb1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;conds&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ) &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; t1 &lt;span class=&quot;keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      baz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      tb2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;conds&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ) &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; t2 &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; &amp;lt;conds&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;conds&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样写子查询会有两个问题。一是子查询的结果如果要在多个不同地方用到，那么就要复制粘贴多次，实际执行的时候也可能执行多次。二是当子查询或/和 JOIN 特别多的时候，整个查询就会变得无比复杂，可读性极差。为解决问题，可用视图（VIEW）解决，也可用 &lt;code&gt;WITH ... AS ...&lt;/code&gt; 子句来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
      <category term="SQL" scheme="https://liam.page/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Hive SQL 中的 LATERAL VIEW</title>
    <link href="https://liam.page/2020/03/09/LATERAL-VIEW-in-Hive-SQL/"/>
    <id>https://liam.page/2020/03/09/LATERAL-VIEW-in-Hive-SQL/</id>
    <published>2020-03-09T03:04:13.000Z</published>
    <updated>2020-03-09T09:36:03.996Z</updated>
    
    <content type="html"><![CDATA[<p>这些天使用 Hive 的过程中遇到了新的知识点，于是将 <code>LATERAL VIEW</code> 的使用方法记录下来。</p><a id="more"></a><h2 id="UDTF"><a href="#UDTF" class="headerlink" title="UDTF"></a>UDTF</h2><p>UDTF 是 User-Defined Table-Generating Functions 的缩写，即用户定义的表生成函数。UDTF 用来解决从原始表中的一行生成多行数据的问题。典型的 UDTF 有 <code>EXPLODE</code> 函数，它能将 <code>array</code> 或者 <code>map</code> 展开。例如：</p><p>考虑以下名为 <code>pageAds</code> 的原始表，它有两列：<code>pageid</code>（网页名称）和 <code>adid_list</code>（网页上显示的广告数组）：</p><table><thead><tr><th>名称</th><th>类型</th></tr></thead><tbody><tr><td><code>pageid</code></td><td><code>STRING</code></td></tr><tr><td><code>adid_list</code></td><td><code>Array&lt;int&gt;</code></td></tr></tbody></table><p>假设其中有以下两行：</p><table><thead><tr><th><code>pageid</code></th><th><code>adid_list</code></th></tr></thead><tbody><tr><td><code>contact_page</code></td><td><code>[3, 4, 5]</code></td></tr><tr><td><code>front_page</code></td><td><code>[1, 2, 3]</code></td></tr></tbody></table><p>使用 <code>EXPLODE</code> 函数可以展开 <code>adid_list</code> 这一列，也就是说，SQL 语句的结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  EXPLODE(adid_list)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  pageAds;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- possible result:</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 4</span></span><br><span class="line"><span class="comment">-- 5</span></span><br></pre></td></tr></table></figure><p>不过，UDTF 有一个限制，它出现在 <code>SELECT</code> 子句中的时候，不能与其它列共同出现。也就是说下列 SQL 语句会报语法错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  pageid, EXPLODE(adid_list) <span class="keyword">AS</span> adid</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  pageAds;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们就需要引入 <code>LATERAL VIEW</code>。</p><h2 id="LATERAL-VIEW"><a href="#LATERAL-VIEW" class="headerlink" title="LATERAL VIEW"></a><code>LATERAL VIEW</code></h2><p><code>LATERAL VIEW</code> 的语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lateralView:</span></span><br><span class="line">LATERAL VIEW udtf(expression) tableAlias AS columnAlias (',' columnAlias)*</span><br><span class="line"><span class="comment">--fromClause:</span></span><br><span class="line">FROM baseTable (lateralView)*  -- 允许联用多个 LATERAL VIEW 子句</span><br></pre></td></tr></table></figure><p>这里，<code>udtf(expression)</code> 表示诸如 <code>EXPLODE</code> 之类的 UDTF 的表达式。<code>LATERAL VIEW</code> 对遇到的每一行，首先会按 UDTF 表达式进行处理，展开成若干行（可能是零行），然后将这些输出行与输入行 <code>INNER JOIN</code>。如果要保留输出为零的行，则需使用 <code>LATERAL VIEW OUTER</code> 执行 <code>OUTER JOIN</code>。</p><p>继续以上述名为 <code>pageAds</code> 的原始表为例，为了同时 <code>SELECT</code> 出 <code>pageid</code> 和 <code>adid</code>，我们需要使用 <code>LATERAL VIEW</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  pageid, adid</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  pageAds</span><br><span class="line">  LATERAL <span class="keyword">VIEW</span></span><br><span class="line">    EXPLODE(adid_list) tmp <span class="keyword">AS</span> adid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- possible result:</span></span><br><span class="line"><span class="comment">-- front_page1</span></span><br><span class="line"><span class="comment">-- front_page2</span></span><br><span class="line"><span class="comment">-- front_page3</span></span><br><span class="line"><span class="comment">-- contact_page3</span></span><br><span class="line"><span class="comment">-- contact_page4</span></span><br><span class="line"><span class="comment">-- contact_page5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天使用 Hive 的过程中遇到了新的知识点，于是将 &lt;code&gt;LATERAL VIEW&lt;/code&gt; 的使用方法记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
      <category term="SQL" scheme="https://liam.page/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之五：非谓语动词</title>
    <link href="https://liam.page/2020/02/27/nonfinite-verb/"/>
    <id>https://liam.page/2020/02/27/nonfinite-verb/</id>
    <published>2020-02-27T14:28:12.000Z</published>
    <updated>2020-02-27T14:23:15.100Z</updated>
    
    <content type="html"><![CDATA[<p>在很早的<a href="/2016/07/31/tense-selection/">上一篇</a>文章中，我们讲了英语当中的时态选择。时态选择涉及到的主要是谓语动词的形态变化。此篇继续讲动词，不过话题转向非谓语动词。</p><a id="more"></a><h2 id="独立子句与主谓结构"><a href="#独立子句与主谓结构" class="headerlink" title="独立子句与主谓结构"></a>独立子句与主谓结构</h2><p>任何一个独立子句（independent clause）都有且只有一套主谓结构。</p><p>什么叫独立子句呢？我们知道，英文当中的句子是有主句和（可选的若干个）从句之分。在不考虑并列的情况下，主句和（各个）从句就都分别是独立子句。如果存在并列，那么并列的若干分句又分别是独立子句。其中，既没有从句又没有并列的主句，称为简单句。在英语中，简单句有五种基本句型。这一点，我们在<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>中已经处理过了。</p><p>什么叫主谓结构呢？引用<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>中的表述如下：</p><blockquote><p>从意思上说，一个完整句子表达的无非是「一个人/一个东西怎么样了」。这里「一个人/一个东西」称为主语部分（subject），告诉人们「这个句子讨论的是『一个人或者一个东西』」；「怎么样了」称为谓语部分（predicate，也称「述语部分」），它可以是「做了什么事情」或者「具有某种特性」。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。<br>不过，不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。因此讨论基本句型就有必要讨论谓语动词。</p></blockquote><p>因此，独立子句都有且只有一套主谓结构这个命题可以理解成，在一个独立子句中，你可以说「一个人/一个东西怎么样了」，但不能说成「一个人/一个东西怎么样了怎么样了[怎么样了……]」。不然，句子就成病句了。</p><h2 id="谓语动词与非谓语动词"><a href="#谓语动词与非谓语动词" class="headerlink" title="谓语动词与非谓语动词"></a>谓语动词与非谓语动词</h2><p>由于谓语部分总是以动词起头，我们就把这个动词称之为谓语动词（predicate verb）。谓语动词又叫限定动词（finite verb）；这是因为：谓语动词会受到主语的人称、数量、时态和情态的限制。（这会引出主谓一致的话题，后表。）</p><blockquote><p>这里还有一点需要澄清的地方。<br>在中文教学中，常用「主谓宾」这样的表述来描述句子结构，似乎谓语和宾语是相互分开独立的部分。但实际上，宾语是谓语的一部分。「主谓宾」里的「谓」实际上指的是「谓语动词」的意思。这一点，在<a href="/2014/06/21/basic-sentence-and-the-complement/">基本句型</a>的讲解中也有体现：我们写 S(ubject) + V(erb) + O(bject) 而非是 S(ubject) + P(redicate) + O(bject)。</p></blockquote><p>一个独立子句都有且只有一套主谓结构的直接推论就是：一个独立子句都有且只有一个谓语动词或者并列的多个谓语动词。</p><blockquote><p>后者的例子比如：「I <strong>put</strong> the book on the desk and <strong>leave</strong> the room.」其中 put 和 leave 是并列的两个谓语动词，但整个句子只有一套主谓结构。不过，若写成「I <strong>put</strong> the book on the desk, and I <strong>leave</strong> the room.」就是两个并列子句了。这是因为，and 并列的是 I put 和 I leave 两套主谓结构。</p></blockquote><p>在这个规则限定之下，若是要在句子中独立于谓语动词之外表达动作的含义，就必须使用非谓语动词。由于它不受主语的限制，所以也称为非限定动词（nonfinite verb）。在英语中，非谓语动词主要有以下三类：不定式（infinitives），分词（participles，包括现在分词（present participles）和过去分词（past participles））和 动名词（gerunds）。后二者又统称为动状词（verbals）。</p><blockquote><p>除了这三种非谓语动词之外，在其他语言中还有动形词（gerundive，拉丁语）、动名词（supine，拉丁语，和 gerunds 的区别主要在「格」上）、动副词（converb，突厥语、蒙古语等）。</p></blockquote><h2 id="为什么需要非谓语动词"><a href="#为什么需要非谓语动词" class="headerlink" title="为什么需要非谓语动词"></a>为什么需要非谓语动词</h2><p>为什么需要非谓语动词，这一问题等价于，为什么人们会要在句子中独立于谓语动词之外表达动作的含义。</p><p>这个问题看起来有点傻，但我认为其实还是蛮重要的。因为这影响着我们能否用统一的方式来处理英语中的四种非谓语动词而不需要记忆额外的规则。对这个问题，我有以下朴素的思考：</p><ul><li>因为，每个动词作为谓语动词，都能「撑」起一个独立子句。</li><li>所以，非谓语动词及其宾语（表语）或其他附属结构摘出来能够和适当的主语组成一个独立子句，它通常可以作为原句的从句存在。</li><li>再然后，反过来，从句子简化的角度看待问题，如果将从句的关联词/引导词省略，再将可能重复的主语省略，再将可能存在的情态动词、助动词去掉或者变形，最后从句动词有实际意义不能直接省略，就只好变成非谓语动词了。</li></ul><p>在经过仔细观察之后，我发现从句子简化的角度，可以比较一贯地处理英语中的四种非谓语动词组成的短语；当然，对于动名词和分词单独使用分别充当名词和形容词的时候，直接将它们视作是对应词性的单词即可，不需要额外的处理。</p><h2 id="不定式（infinitives）"><a href="#不定式（infinitives）" class="headerlink" title="不定式（infinitives）"></a>不定式（infinitives）</h2><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p>英语当中的不定式（infinitives）的基本形式是 <em>to + V</em>，即以不变词（particle）<em>to</em> 引导的动词原形。举例来说，下列句子中，斜体标示的是不定式。</p><ul><li>I&#39;m glad <em>to know</em> you. | 很高兴认识你。</li><li>I want <em>to play</em> computer game. | 我想玩电脑游戏。</li><li>I asked Sophia <em>to help</em> me in English. | 我请 Sophia 帮我提升英语。</li></ul><p>不定式的不变词 <em>to</em> 在某些情况下可以省略，形成无修饰不定式（bald infinitives）；也就是说，光秃秃的动词原形，可能也是不定式。在使役动词和感官动词之后，往往不定式的不变词 <em>to</em> 需要省略。（原因后表）同样，下列句子中，斜体标示的是不定式。</p><ul><li>He made us <em>wash</em> his car. | 他令我们为他洗车。</li><li>I heard her <em>cry</em> out in pain. | 我听见她疼得大哭出声。</li></ul><p>在句子当中，视不同情况，不定式可以当做名词、形容词、副词的角色来使用。</p><h3 id="不定式的句子简化"><a href="#不定式的句子简化" class="headerlink" title="不定式的句子简化"></a>不定式的句子简化</h3><p>我们来看几个用到动词不定式的场景中，不定式都起到了什么成分的作用，以及它可以怎样的从句简化而来。在这部分，我们暂不处理无修饰不定式的情形。</p><p><strong>I&#39;m glad <em>to know</em> you.</strong></p><p>句子的主干是「I&#39;m glad.」，即「我很高兴」，「to know you」是高兴的原因状语，也就是不定式作为副词结构。因此原句如果以很重的翻译腔来翻译的话，应该是：「我很高兴因为我能认识你」。于是很容易得到它的原句：</p><blockquote><p>I&#39;m glad because I can know you.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语均为「I」，因此可以省略；原句变为：I&#39;m glad <del>because I</del> can know you.</li><li>主句谓语动词 <em>am</em> 和从句谓语动词 <em>can</em> 不能同时出现，且从句表意动词是 <em>know</em> 而非 <em>can</em>，因此<strong>将 <em>can</em> 改为 <em>to</em> 以保留「不确定的语气」</strong>；原句变为：I&#39;m glad <del>because I can</del> to know you.</li><li>简化完成。</li></ul><p><strong>I want <em>to play</em> computer game.</strong></p><p>句子的主干是「I want <em>sth.</em>」，即「我想要 sth」。显然，「to play computer game」是想要的动词宾语，也就是不定式作为名词结构。于是很容易得到它的原句：</p><blockquote><p>I want that I will play computer game.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语均为「I」，因此可以省略；原句变为：I want <del>that I</del> will play computer game.</li><li>主句谓语动词 <em>want</em> 和从句谓语动词 <em>will</em> 不能同时出现，且从句表意动词是 <em>play</em> 而非 <em>will</em>，因此<strong>将 <em>will</em> 改为 <em>to</em> 以保留「不确定的语气」</strong>；原句变为：I want <del>that I will ~</del> to play computer game.</li><li>简化完成。</li></ul><p><strong>I asked Sophia <em>to help</em> me in English.</strong></p><p>句子的主干是「I asked Sophia.」，即「我请求 Sophia」。「to help me in English」是 Sophia 的宾语补足语，也就是不定式做名词/形容词结构。于是很容易得到它的原句：</p><blockquote><p>I asked Sophia whether she will help me in English.</p></blockquote><p>简化流程：</p><ul><li>主句宾语和从句主语均为「Sophia」，因此可以省略；原句变为：I asked Sophia <del>whether she</del> will help me in English.</li><li>主句谓语动词 <em>asked</em> 和从句谓语动词 <em>will</em> 不能同时出现，且从句表意动词是 <em>help</em> 而非 <em>will</em>，因此<strong>将 <em>will</em> 改为 <em>to</em> 以保留「不确定的语气」</strong>；原句变为：I asked Sophia <del>whether she will</del> to help me in English.</li><li>简化完成。</li></ul><h3 id="不定式的特点"><a href="#不定式的特点" class="headerlink" title="不定式的特点"></a>不定式的特点</h3><p>从以上三例可以看到，不定式和助动词关系密切，从句子简化的角度来看，不定式可以视作是助动词的变形。在这个过程中，不定式的不变词 <em>to</em> 一方面承担了语法功能，一方面<strong>表达不确定的语气</strong>。下表更详细地描述了助动词和不定式（的不变词）之间的相似性。</p><table><thead><tr><th></th><th>助动词</th><th>不定式（的不变词）</th></tr></thead><tbody><tr><td>都要接动词原形</td><td>I will go.</td><td>I want to go.</td></tr><tr><td>都表达不确定语气</td><td>He is right. -&gt; He may be right.</td><td>He is right. -&gt; He seems to be right.</td></tr><tr><td>都需要借完成式表达过去时间</td><td>It might have rained last night.</td><td>It seems to have rained last night.</td></tr></tbody></table><blockquote><p>助动词缺少表达过去时间的能力。一般理解上，could 是 can 的过去式，而 might 是 may 的过去式。但实际上，它们在实际表意中，只能表示比 can/may 更弱的猜测力度，而不能表示对过去的猜测。比如「It may rain (in minutes).」和「It might rain (in minutes).」都表示「可能要下雨了」，都表示对现在/将来的猜测。若是要表达对过去的猜测，必须借助完成式，写成 It may/might have rain last night.</p></blockquote><p>此外，很容易发现常见助动词和不定式表达之间的对应关系。</p><table><thead><tr><th>助动词</th><th>不定式</th></tr></thead><tbody><tr><td>must</td><td>have to</td></tr><tr><td>shall/should</td><td>ought to / be responsible to</td></tr><tr><td>will/would</td><td>be going to</td></tr><tr><td>can/could</td><td>be able to</td></tr><tr><td>may/might</td><td>be likely to</td></tr></tbody></table><h3 id="无修饰不定式"><a href="#无修饰不定式" class="headerlink" title="无修饰不定式"></a>无修饰不定式</h3><p>在处理通常形式的不定式时，我们注意到不定式的不变词 <em>to</em> 可以视作是助动词的变化。在表意上，它表达了不确定性。据此，我们可分析看看何种情况下不定式应省略不变词，成为无修饰不定式。——当必须使用不定式，但又不能表达不确定性时，就应该省略不变词，变成无修饰不定式。</p><p>我们对比以下两例：</p><ul><li>He made us <em>wash</em> his car.</li><li>He asked us <em>to wash</em> his car.</li></ul><p>在这里，<em>made</em> 是使役动词而 <em>asked</em> 是普通动词。使役动词和普通动词的区别就在于，使役动词后的动作是具有强制性的，换言之也就是没有不确定性。这就是传统语法书里写的「使役动词后需要使用动词原形」的原因。</p><p>继续观察以下两例：</p><ul><li>I heard her <em>cry</em> out in pain.</li><li>I see the boy <em>play</em> on the playground.</li></ul><p>在这里，<em>heard</em> 和 <em>see</em> 都是感官动词。感官动词与普通动词的区别就在于，感官动词是「感受到的真相」。真相当然就没有不确定性，因此其后不能用 <em>to</em> 引导的不定式来表达不确定性。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>不定式的基本形态是 <em>to + V</em>；其中 <em>to</em> 是不变词，可视作助动词的变形，承担语法功能，同时表达「不确定性」。当不定式所处的上下文没有不确定性时，就要省略不变词，变成单纯的动词原形 <em>V</em>，此时称作无修饰不定式。</p><p>不定式在句子中可以承担名词、形容词、副词的功能。</p><h2 id="动名词（gerunds）"><a href="#动名词（gerunds）" class="headerlink" title="动名词（gerunds）"></a>动名词（gerunds）</h2><p>上一节介绍了不定式，不定式可以用来充作名词。这一节讲同样可以充作名词的动名词。</p><h3 id="基本形式-1"><a href="#基本形式-1" class="headerlink" title="基本形式"></a>基本形式</h3><p>在英语中，动名词的基本形式是 <em>V-ing</em>，即，在动词原形之后，加上 <code>ing</code> 作为后缀。举例来说，下列句子中，斜体标示的是动名词。</p><ul><li><em>Swiming</em> is my favorite sport. | 游泳是我最喜欢的运动。</li><li>I really enjoyed <em>playing</em> computer game with my brother that night. | 我着实享受那晚与哥哥一起玩电脑游戏。</li></ul><h3 id="动名词与名词——单独使用"><a href="#动名词与名词——单独使用" class="headerlink" title="动名词与名词——单独使用"></a>动名词与名词——单独使用</h3><p>在第一个例句中，<em>Swiming</em> 是<u>动名词单独使用</u>的例子。单独使用的动名词与普通名词没有太大的区别，都可以充当主语、动词宾语或者介词等需要名词填充的语法成分。</p><ul><li><em>Swiming</em> is my favorite sport. | 主语</li><li>My favorite sport is <em>swiming</em>. | 动词宾语做主语补语</li><li>I enjoy <em>swiming</em> daily. | 动词宾语做句子宾语</li><li>I&#39;m not afraid of death, but I&#39;m afraid of <em>dying</em>. | 介词宾语</li></ul><p>不过，动名词涉及到的动作通常带有<strong>延续性</strong>的意味。比如</p><ul><li><em>swiming</em> 总要多划几下才叫游泳，不然只能叫扑腾；</li><li><em>climbing</em> 总要持续地爬才叫攀登，不然只能叫小童学步；</li><li><em>dancing</em> 总要连续一串动作才叫跳舞，不然只能叫抽风；</li><li><em>drinking</em> 总要喝几口才能叫喝酒，不然只能叫酒精中毒。</li></ul><p>此外，因为动名词含有动作的意味，所以它通常是看不见摸不着的抽象名词。因此，动名词通常都是不可数名词。但也有少许例外，比如</p><ul><li>There will be two <em>weddings</em> at the auditorium tomorrow night.</li></ul><h3 id="名词从句简化——动名词短语"><a href="#名词从句简化——动名词短语" class="headerlink" title="名词从句简化——动名词短语"></a>名词从句简化——动名词短语</h3><p>处理完了动名词单独使用的情形，接下来处理所谓的<u>动名词短语</u>。</p><p><strong>I really enjoyed <em>playing</em> computer game with my brother that night.</strong></p><p>句子主干是「I enjoyed <code>object</code>」，即「我享受 <code>object</code>」。「playing computer game with my brother that night」是 enjoyed 的宾语。于是很容易得到它的原句：</p><blockquote><p>I really enjoyed that I played computer game with my brother that night.</p></blockquote><p>简化流程：</p><ul><li>主句宾语和从句主语均为「I」，因此可以省略；原句变为：I really enjoyed <del>that I</del> played computer game with my brother that night.</li><li>主句谓语动词 <em>enjoyed</em> 和从句谓语动词 <em>played</em> 不能同时出现，因此需将从句谓语动词修改为非谓语动词。由于充当名词成分，候选项有 <em>to play</em> 和 <em>playing</em>。考虑到此处无不确定语气，因此选择动名词；原句变为：I really enjoyed <del>that I played</del> playing computer game with my brother that night.</li><li>简化完成。</li></ul><p><strong><em>Killing</em> enemies on battlefield is glory of soldiers.</strong></p><p>句子主干是「<code>subject</code> is glory」，即「<code>subject</code> 是荣耀」。「Killing enemies on battlefield」是句子主语。于是很容易得到它的原句：</p><blockquote><p>That soldiers kill enemies on battlefield is glory of soldiers.</p></blockquote><p>简化流程：</p><ul><li>主句补语的所有格与从句主语都是「soldiers」，因此可以省略；原句变为：<del>That soldiers</del> kills enemies on battlefield is glory of soldiers.</li><li>主句谓语动词 <em>is</em> 和从句谓语动词 <em>kills</em> 不能同时出现，因此需将从句谓语动词修改为非谓语动词。由于充当名词成分，候选项有 <em>to kill</em> 和 <em>killing</em>。考虑到此处无不确定语气，因此选择动名词；原句变为：Killing enemies on battlefield is glory of soldiers.</li><li>简化完成。</li></ul><p><strong><em>Being</em> invited here is my honor.</strong></p><p>句子主干是「<code>subject</code> is honor.」，即「<code>subject</code> 是荣耀」。「Being invited here」是句子主语。于是很容易得到它的原句：</p><blockquote><p>That I was invited here is my honor.</p></blockquote><p>简化流程：</p><ul><li>主句补语所有格与从句主语都是「I」，因此可以省略；原句变为：<del>That I</del> was invited here is my honor.</li><li>主句谓语动词 <em>is</em> 和从句谓语动词 <em>was</em> 不能同时出现，因此需将从句谓语动词修改为非谓语动词。由于充当名词成分，候选项有 <em>to be</em> 和 <em>being</em>。考虑到此处无不确定语气，因此选择动名词；原句变为：Being invited here is my honor.</li><li>简化完成。</li></ul><p>注意，这里 <em>being invited</em> 是动名词的被动形式。其中 <em>being</em> 当中的 <em>be</em> 是不表意的，真正起到作用的是后缀 <em>-ing</em> 形成动名词。对于动名词的被动形式，和我们在<a href="/2015/05/03/tense-of-verb/">动词时态</a>中处理被动语态中一样，将 be-动词当成正常的动词，而后取其动名词形式。</p><p><strong>I don&#39;t like John&#39;s <em>calling</em> my girlfriend day after day.</strong></p><p>句子主干是「I don&#39;t like <code>object</code>」，即「我不喜欢 <code>object</code>」。「John&#39;s calling my girlfriend day after day」是句子宾语。注意到，动名词 <em>calling</em> 和普通名词一样，可以被所有格限定。而所有格的人称，即是动名词对应动作的逻辑主语。于是很容易得到它的原句：</p><blockquote><p>I don&#39;t like that John is calling my girlfriend day after day.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语不同，因此从句主语不能直接省略，而应当变为所有格；原句变为：I don&#39;t like <del>that John</del> John&#39;s is calling my girlfriend day after day.</li><li>主句谓语动词 <em>do</em> 和从句谓语动词 <em>is</em> 冲突，且从句谓语中实际承担表意的是 <em>calling</em>，因此可以直接删除从句谓语动词 <em>is</em>；原句变为：I don&#39;t like <del>that John</del> John&#39;s <del>is</del> calling my girlfriend day after day.</li><li>简化完成。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>动名词的基本形式是 <em>V-ing</em>。动名词可以单独使用，也可以组成动名词短语。不论是单独使用还是组成动名词短语，动名词都在句子当中充当名词成分。</p><p>单独使用的动名词和普通名词差异不大，但有以下一些特点：</p><ul><li>表达的动作带有延续性（后缀 <code>-ing</code> 的功能）；</li><li>通常是不可数名词。</li></ul><p>组成动名词短语时，动名词短语可看做是名词从句的简化。具体是何种名词性从句，取决于动名词短语在原句中的地位。在简化名词性从句时，若从句谓语动词不带有不确定性且主句不表达不确定性，则需使用动名词，组成动名词短语。在遇到从句主语与主句主语或所有格不重合时，在组成动名词短语时需将从句主语变成所有格。</p><p>在英语中，非谓语动词里的动名词和不定式都可以在句子当中充当名词成分。不同的是，<strong>不定式带有不确定性</strong>，而<strong>动名词带有延续性</strong>。</p><h2 id="分词（participles）"><a href="#分词（participles）" class="headerlink" title="分词（participles）"></a>分词（participles）</h2><h3 id="基本形式-2"><a href="#基本形式-2" class="headerlink" title="基本形式"></a>基本形式</h3><p>英语里的分词包括现在分词（present participles）和过去分词（past participles）。</p><ul><li>现在分词的基本形式是 <em>V-ing</em>，与动名词完全相同。</li><li>过去分词的基本形式是 <em>V-ed</em>。</li></ul><p>分词可以<strong>单独使用，类似形容词</strong>。举例来说，下列斜体标示的是现在分词：</p><ul><li>The <em>flying</em> bird is cute. | 那只正在飞的小鸟很可爱。（现在分词作形容词，修饰主语）</li><li>I love the <em>flying</em> bird. | 我喜欢那只正在飞的小鸟。（现在分词作形容词，修饰宾语）</li><li>The bird is <em>flying</em>. | 那只小鸟正在飞。（现在分词做形容词，作为主语补足语修饰主语）</li></ul><p>下列斜体标示的，则是过去分词：</p><ul><li>The <em>boiled</em> water is safe to drink. | 开水喝起来安全。（过去分词作形容词，修饰主语）</li><li>Please give me a bottle of <em>boiled</em> water. | 请给我来一杯开水。（过去分词做形容词，修饰宾语）</li><li>The water is <em>boiled</em>. | 水开了。（过去分词做形容词，作为主语补足语修饰主语）</li></ul><p>分词可以组成<strong>分词短语，充当形容词成分</strong>。举例来说，下列斜体标示的是现在分词短语和过去分词短语：</p><ul><li>Children <em>studying in school</em> make lots of friends. | 在学校读书的孩子们交了很多朋友。（现在分词短语做后置定语，修饰主语）</li><li>Soldiers <em>wounded in war</em> are sent home. | 在战场上受伤的士兵们被送回家了。（过去分词短语做后置定语，修饰主语）</li><li>Soldiers <em>being sent home</em> are wounded. | 正被送回家的士兵们受伤了。（现在分词短语，被动式，做后置定语，修饰主语）</li></ul><p>分词可以有特别的<strong>分词构句，充当副词成分</strong>。因为分词通常意义上被理解成形容词，不能充当副词成分。因此，对这种特别的语法现象，人们称之为分词构句。举例来说，下列斜体标示的是分词构句：</p><ul><li><em>Wounded in war</em>, the soldiers are sent home. | 因为在战场上受了伤，士兵们被送回了家。（过去分词构句，做原因状语）</li><li><em>Running for four hours</em>, John is exhausted. | 跑步 4 小时后，约翰筋疲力尽。（现在分词构句，做时间状语）</li><li><em>Having been treated unfairly</em>, Lisa quits her work. | 因为被不公平地对待，丽莎辞职了。（现在分词构句，完成式，做原因状语）</li></ul><p>下面分别就几种分词的使用方法讨论。</p><h3 id="分词与形容词——单独使用"><a href="#分词与形容词——单独使用" class="headerlink" title="分词与形容词——单独使用"></a>分词与形容词——单独使用</h3><p>在传统语法里，分词是形容词。分词可以做定语修饰主语或者宾语，也可以作为主语补足语（表语）修饰主语。在这个意义上，分词与形容词完全一样。</p><ul><li>The <em>black</em> dog is pitiful. | 黑狗很可怜。（形容词作定语修饰主语）</li><li>The <em>barking</em> dog is pitiful. | 汪汪叫的狗很可怜。（现在分词做定语修饰主语）</li><li>The <em>wounded</em> dog is pitiful. | 受伤的狗很可怜。（过去分词做定语修饰主语）</li><li>I see a <em>black</em> dog. | 我看见一只黑狗。（形容词做定语修饰宾语）</li><li>I see a <em>barking</em> dog. | 我看见一只汪汪叫的狗。（现在分词做定语修饰宾语）</li><li>I see a <em>wounded</em> dog. | 我看见一只受伤的狗。（过去分词做定语修饰宾语）</li><li>The dog is <em>black</em>. | 这狗是黑的。（形容词做主语补足语，修饰主语）</li><li>The dog is <em>barking</em>. | 这狗正在叫。（现在分词做主语补足语，修饰主语）</li><li>The dog is <em>wounded</em>. | 这狗受伤了。（过去分词做主语补足语，修饰主语）</li></ul><p>很显然，我们得到分词的第一个特点：<strong>现在分词和过去分词都能如普通形容词一样，用于定语和主语补足语</strong>。</p><p>此外，仿照之前处理不定式和分词的时候，我们可以将 <code>-ing</code> 和 <code>-ed</code> 视作是形容词后缀，和 <code>-ful</code>, <code>-able</code>, <code>-less</code> 之类的一样，表达一种特定的含义。<code>-ing</code> 暗示「持续」或者「正在发生」的含义；<code>-ed</code> 暗示「被动」或者「完成」的含义。</p><p>有了这一认识，<a href="/2015/05/03/tense-of-verb/">动词时态</a>及<a href="/2016/07/31/tense-selection/">时态选择</a>中处理进行式和被动语态的表述就很好理解了。而且，这一认识可能比 <code>be + V-ing</code> 表示进行以及 <code>be + V-ed</code> 表示被动的公式更好。比如说：</p><ul><li>「The dog is <em>barking</em>.」意思是「这狗正在叫」，看似是 <code>be + V-ing</code> 的功劳。但实际上「The barking dog」里没有 be-动词，也表示「正在汪汪叫的狗」。可见，表达「持续」或者「正在发生」的含义的是 <code>-ing</code> 后缀，而非 <code>be + V-ing</code> 这一结构。</li><li>被动语态也有类似处理，而且，<code>be + V-ed</code> 有时候也不表示被动。比如「The leaves are all fallen.」译作「叶子掉光了」。这里的翻译，取过去分词的「完成」意味，而不能套用 <code>be + V-ed</code> 表示被动语态。</li><li>又比如进行式和被动式的混合「The case is being investigated by police.」，如果以「背公式」的方法来学习，那就又要背下「Be + being + V-ed」表示进行式的被动语态。但如果按我们这里的认识就很简单了。<em>is</em> 无需翻译，<em>being</em> 中 <em>be</em> 无意义而 <code>-ing</code> 表示「正在」，<code>-ed</code> 表示被动翻译为被调查。于是译文就脱口而出：「案件正在被警察调查」。</li></ul><h3 id="形容词性从句简化——分词短语"><a href="#形容词性从句简化——分词短语" class="headerlink" title="形容词性从句简化——分词短语"></a>形容词性从句简化——分词短语</h3><p>处理完了分词单独使用的问题，接下来我们看看分词短语。形容词性从句简化后，往往留下分词短语。</p><p><strong>Children <em>studying in school</em> make lots of friends.</strong></p><p>句子的主干是「Children make lots of friends.」，即「孩子们交了很多朋友」。「studying in school」是修饰主语的定语。因此很容易得到原句：</p><blockquote><p>Children who are studing in school make lots of friends.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语（先行词 <em>who</em>）相同，因此可以省略；原句变为：Children <del>who</del> are studing in school make lots of friends.</li><li>主句谓语动词 <em>make</em> 与从句谓语动词 <em>are</em> 冲突，而从句谓语中实际承担表意的是 <em>studing</em>。因此，可以直接去掉从句谓语动词 <em>are</em>；原句变为：Children <del>who are</del> studing in school make lots of friends.</li><li>简化完成。</li></ul><p><strong>Soldiers <em>wounded in war</em> are sent home.</strong></p><p>句子的主干是「Soldiers are sent home.」，即「士兵们被送回了家」。「wounded in war」是修饰主语的定语。因此很容易得到原句：</p><blockquote><p>Soldiers who were wounded in war are sent home.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语（先行词 <em>who</em>）相同，因此可以省略；原句变为：Soldiers <del>who</del> were wounded in war are sent home.</li><li>主句谓语动词 <em>are</em> 与从句谓语动词 <em>were</em> 冲突，而从句谓语中实际承担表意的是 <em>wounded</em>。因此，可以直接去掉从句谓语动词 <em>were</em>；原句变为：Soldiers <del>who were</del> wounded in war are sent home.</li><li>简化完成。</li></ul><p><strong>Soldiers <em>being sent home</em> are wounded.</strong></p><p>句子的主干是「Soldiers are wounded.」，即「士兵们受伤了」。「being sent home」是修饰主语的定语。因此很容易得到原句：</p><blockquote><p>Soldiers who are being sent home are wounded.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语（先行词 <em>who</em>）相同，因此可以省略；原句变为：Soldiers <del>who</del> are being sent home are wounded.</li><li>主句谓语动词 <em>make</em> 与从句谓语动词 <em>are</em> 冲突，而从句谓语中实际承担表意的是 <em>sent</em>。因此，可以直接去掉从句谓语动词 <em>are</em>；原句变为：Soldiers <del>who are</del> being sent home are wounded.</li><li>简化完成。</li></ul><h3 id="副性从句简化——分词构句和独立主格"><a href="#副性从句简化——分词构句和独立主格" class="headerlink" title="副性从句简化——分词构句和独立主格"></a>副性从句简化——分词构句和独立主格</h3><p>接下来我们来处理分词构句和独立主格。</p><p><strong><em>Wounded in war</em>, the soldiers are sent home.</strong></p><p>句子的主干是「The soldiers are sent home.」，即「士兵们被送回了家」。「Wounded in war」是句子的原因状语。因此很容易得到原句：</p><blockquote><p>Because they were wounded in war, the soldiers are sent home.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语相同，因此可以省略；原句变为：<del>Because they</del> were wounded in war, the soldiers are sent home.</li><li>主句谓语动词 <em>are</em> 与从句谓语动词 <em>were</em> 冲突，而从句谓语中实际承担表意的是 <em>wounded</em>。因此，可以直接去掉从句谓语动词 <em>were</em>；原句变为：<del>Because they were</del> wounded in war, the soldiers are sent home.</li><li>简化完成。</li></ul><p><strong><em>Running for four hours</em>, John is exhausted.</strong></p><p>句子的主干是「John is exhausted.」，即「约翰筋疲力尽」。「Running for four hours」是句子的时间状语。因此很容易得到原句：</p><blockquote><p>After he was running for four hours, John is exhausted.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语相同，因此可以省略；原句变为：<del>After he</del> was running for four hours, John is exhausted.</li><li>主句谓语动词 <em>is</em> 与从句谓语动词 <em>was</em> 冲突，而从句谓语中实际承担表意的是 <em>running</em>。因此，可以直接去掉从句谓语动词 <em>was</em>；原句变为：<del>After he was</del> running for four hours, John is exhausted.</li><li>简化完成。</li></ul><p><strong><em>Having been treated unfairly</em>, Lisa quits her work.</strong></p><p>句子的主干是「Lisa quits her work.」，即「丽莎辞职了」。「Having been treated unfairly」是句子的原因状语。因此很容易得到原句：</p><blockquote><p>Because she has been treated unfairly, Lisa quits her work.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语相同，因此可以省略；原句变为：<del>Because she</del> has been treated unfairly, Lisa quits her work.</li><li>主句谓语动词 <em>quits</em> 与从句谓语动词 <em>has</em> 冲突，因此要将 <em>has</em> 转化为非谓语动词。利用分词构句，可选项有 <em>having</em> 及 <em>had*。考虑到此处没有被动的意味，而完成的意味已由完成式承担。因此，将 *has</em> 变为现在分词 <em>having</em>；原句变为：<del>Because she has</del> Having been treated unfairly, Lisa quits her work.</li><li>简化完成。</li></ul><p>观察不难得到分词构句的一般规律：</p><ul><li>现有两个句子，主语相同。</li><li>其中一个句子可以充当另一个句子的状语。这个状语可以是条件状语、原因状语、让步状语、时间状语等各种状语。</li><li>将充当状语的句子的主语去掉，将状语里的谓语动词变化：<ul><li>如果状语是一般式主动语态，则用现在分词构句。</li><li>如果状语是一般式被动语态，则用过去分词构句。</li><li>如果状语是完成式，则用现在分词构句。</li></ul></li></ul><p>特别地，如果两个句子的主语不同，则需要保留充当状语的句子中的主语。此时形成的结构叫独立主格结构。仅举一例：</p><ul><li>The condition is favorable. He might succeed. | 两个句子，主语不同。</li><li>前句可以充当后句的条件状语。</li><li>保留状语从句的主语，而后用现在分词构句，得到：The condition being favorable, he might succeed.</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>分词分为现在分词和过去分词，他们的基本形态是 <em>V-ing</em> 和 <em>V-ed</em>，</p><p>分词可以单独使用，与形容词相似，可以充当定语、补语。在分词单独使用时，可将 <code>-ing</code> 视作表达「正在」或「进行」的形容词后缀，可将 <code>-ed</code> 视作表达「被动」或「完成」的形容词后缀。</p><p>分词可组成分词短语，可视作是形容词性从句的简化。</p><p>分词相关短语也可以从副词从句简化而来。但由于分词是形容词性，所以专门起了名字叫做「分词构句」和「独立主格结构」。前者用于主从主语一致的情况，后者用于主从主语不一致的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很早的&lt;a href=&quot;/2016/07/31/tense-selection/&quot;&gt;上一篇&lt;/a&gt;文章中，我们讲了英语当中的时态选择。时态选择涉及到的主要是谓语动词的形态变化。此篇继续讲动词，不过话题转向非谓语动词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Verb" scheme="https://liam.page/tags/Verb/"/>
    
      <category term="Grammer" scheme="https://liam.page/tags/Grammer/"/>
    
      <category term="Nonfinte" scheme="https://liam.page/tags/Nonfinte/"/>
    
      <category term="Infinitives" scheme="https://liam.page/tags/Infinitives/"/>
    
      <category term="Gerunds" scheme="https://liam.page/tags/Gerunds/"/>
    
      <category term="Participles" scheme="https://liam.page/tags/Participles/"/>
    
  </entry>
  
  <entry>
    <title>SARS-CoV-2 莫自牢，千病万疫避白袍</title>
    <link href="https://liam.page/2020/02/12/pray-for-the-nation-against-COVID-19/"/>
    <id>https://liam.page/2020/02/12/pray-for-the-nation-against-COVID-19/</id>
    <published>2020-02-12T13:29:47.000Z</published>
    <updated>2020-02-12T13:49:11.012Z</updated>
    
    <content type="html"><![CDATA[<p>希望若干年后的史书，会这样记载 2020 年初的疫情。</p><a id="more"></a><blockquote><p>己亥末庚子初，荆楚大疫。又一旬，波及全国，染者以万计。一时间，举国闭户，风烟四起。<br>有国士者，南山也。衣白袍者，医护也。辛劳不辞，艰险不畏。又有商贾布衣无算，捐千金货，出万分力，立雷火于华胥。<br>月余，疫去而风烟定。时人记之，曰：SARS-CoV-2 莫自牢，千病万疫避白袍。</p><p>Liam Huang, 2020-02-12 于北京</p></blockquote><p>🙏</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望若干年后的史书，会这样记载 2020 年初的疫情。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="2019-nCoV" scheme="https://liam.page/tags/2019-nCoV/"/>
    
      <category term="SARS-CoV-2" scheme="https://liam.page/tags/SARS-CoV-2/"/>
    
      <category term="COVID-19" scheme="https://liam.page/tags/COVID-19/"/>
    
  </entry>
  
  <entry>
    <title>泥潭挣扎记：Linuxbrew 里的 Glibc</title>
    <link href="https://liam.page/2020/01/19/struggle-with-Glibc-and-Linuxbrew/"/>
    <id>https://liam.page/2020/01/19/struggle-with-Glibc-and-Linuxbrew/</id>
    <published>2020-01-19T10:10:52.000Z</published>
    <updated>2020-02-04T07:57:06.016Z</updated>
    
    <content type="html"><![CDATA[<p>本着 Homebrew 真香的原则，我尝试在 CentOS 上安装 Linuxbrew。至于不用 Yum 的原因，请看刚才提到的真香原则。</p><p>但随即，我就陷入到了 Glibc 的泥潭。这个泥潭是一个需要自举（bootstrap）的循环依赖；这个泥潭长这样：</p><ul><li>Linuxbrew 安装任何东西都依赖 <code>curl</code> 和 <code>git</code>，而且它不想用系统中自带的 <code>curl</code> 和 <code>git</code>。</li><li><code>curl</code> 和 <code>git</code> 都直接或间接依赖 Glibc。</li><li>Linuxbrew 里的 Glibc 版本比较高，目前是 2.23，因此依赖高版本的 GCC（<code>&gt;= 4.7</code>），以及因为 Linuxbrew 的缘故依赖 <code>curl</code> 和 <code>git</code>。</li><li>系统里的 GCC 版本较低，因此 Linuxbrew 安装 Glibc 失败；而通过 Linuxbrew 安装高版本的 GCC 又再次依赖 Glibc。</li></ul><p>泥潭里有两个循环依赖：</p><ul><li>Glibc 和 <code>curl</code> 及 <code>git</code> 等基础工具相互依赖；</li><li>Glibc 和 GCC 相互依赖。</li></ul><a id="more"></a><h2 id="寻找突破口，解决-Glibc-的存在性问题"><a href="#寻找突破口，解决-Glibc-的存在性问题" class="headerlink" title="寻找突破口，解决 Glibc 的存在性问题"></a>寻找突破口，解决 Glibc 的存在性问题</h2><p>两个循环都涉及到 Glibc，因此必须想办法从 Glibc 这里突破。考虑到 Glibc 基础库的地位，很多依赖它的模块，都是硬编码 Glibc 的位置。因此 Glibc 必须从源码编译安装，无法直接服用编译好的二进制文件。所以 Glibc 无论如何都得依赖 GCC。既然高版本的 Glibc 依赖高版本的 GCC，那么就只能想办法安装较低版本的 Glibc——首先解决有没有（Linuxbrew 中的）Glibc 的问题，再去解决 Glibc 版本的问题。</p><p>为了安装低版本的 Glibc，我们要用到 <code>brew</code> 直接从 <code>tap</code> 中安装的特性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAKEFLAGS=<span class="string">""</span> \</span><br><span class="line">HOMEBREW_MAKE_JOBS=<span class="string">"1"</span> \</span><br><span class="line">brew install --verbose --ignore-dependencies https://raw.githubusercontent.com/Linuxbrew/homebrew-core/6fb5dfd50895416bea3d00628b8d3b41fa1f4f32/Formula/glibc.rb  <span class="comment"># Glibc 2.20</span></span><br></pre></td></tr></table></figure><p>讲一下这里的黑魔法。</p><p><code>MAKEFLAGS</code> 和 <code>HOMEBREW_MAKE_JOBS</code> 的设定，都是为了让编译 Glibc 的过程中使用非并行编译。这是因为并行编译 Glibc 2.20 时，因为 Makefile 依赖没写好，会产生一些问题。</p><p><code>--verbose</code> 参数的意义是让 <code>brew</code> 打印尽可能多的调试信息。<code>--ignore-dependencies</code> 则是无奈之举，因为 Glibc 依赖的东西反过来又会依赖 Glibc，于是 Linuxbrew 会尝试去安装高版本 Glibc，这就毁了。</p><p>执行这条命令，Linuxbrew 首先还是会去尝试安装 <code>curl</code> 和 <code>git</code>。而它们又依赖 Glibc，所以又会尝试安装高版本的 Glibc，依然会失败。这没办法，由着他们失败去。等它们失败之后，就会尝试安装 Glibc 2.20。</p><h2 id="解决-GCC-的问题"><a href="#解决-GCC-的问题" class="headerlink" title="解决 GCC 的问题"></a>解决 GCC 的问题</h2><p>接下来要解决的是 GCC 的问题。因为但凡碰到要编译的，都离不开它。于是我们有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --verbose --ignore-dependencies xz gmp mpfr libmpc isl gcc</span><br></pre></td></tr></table></figure><p>这里安装 <code>xz</code>, <code>gmp</code>, <code>mpfr</code>, <code>libmpc</code>, <code>isl</code> 的原因是 GCC 自身就依赖他们——哪怕你不使用 Linuxbrew，手动编译 GCC 时，你也得安装它们。</p><h2 id="安装-curl-和-git"><a href="#安装-curl-和-git" class="headerlink" title="安装 curl 和 git"></a>安装 <code>curl</code> 和 <code>git</code></h2><p>有了 Glibc 和 GCC，安装 <code>curl</code> 和 <code>git</code> 就不成问题了。我们有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install --verbose curl git</span><br><span class="line">brew update  --verbose --force</span><br></pre></td></tr></table></figure><h2 id="升级-Glibc"><a href="#升级-Glibc" class="headerlink" title="升级 Glibc"></a>升级 Glibc</h2><p>之前我们安装的是 Glibc 2.20，现在我们来升级它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAKEFLAGS=<span class="string">""</span> \</span><br><span class="line">HOMEBREW_MAKE_JOBS=<span class="string">"1"</span> \</span><br><span class="line">brew upgrade glibc --verbose</span><br></pre></td></tr></table></figure><h2 id="重新安装-GCC"><a href="#重新安装-GCC" class="headerlink" title="重新安装 GCC"></a>重新安装 GCC</h2><p>因为 GCC 依赖的 Glibc 发生了变化，这导致 GCC 不可用。因此我们要做一些调整。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew postinstall gcc</span><br></pre></td></tr></table></figure><p>如此，万事 okay~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本着 Homebrew 真香的原则，我尝试在 CentOS 上安装 Linuxbrew。至于不用 Yum 的原因，请看刚才提到的真香原则。&lt;/p&gt;
&lt;p&gt;但随即，我就陷入到了 Glibc 的泥潭。这个泥潭是一个需要自举（bootstrap）的循环依赖；这个泥潭长这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linuxbrew 安装任何东西都依赖 &lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;，而且它不想用系统中自带的 &lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt; 都直接或间接依赖 Glibc。&lt;/li&gt;
&lt;li&gt;Linuxbrew 里的 Glibc 版本比较高，目前是 2.23，因此依赖高版本的 GCC（&lt;code&gt;&amp;gt;= 4.7&lt;/code&gt;），以及因为 Linuxbrew 的缘故依赖 &lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;系统里的 GCC 版本较低，因此 Linuxbrew 安装 Glibc 失败；而通过 Linuxbrew 安装高版本的 GCC 又再次依赖 Glibc。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;泥潭里有两个循环依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Glibc 和 &lt;code&gt;curl&lt;/code&gt; 及 &lt;code&gt;git&lt;/code&gt; 等基础工具相互依赖；&lt;/li&gt;
&lt;li&gt;Glibc 和 GCC 相互依赖。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Homebrew" scheme="https://liam.page/tags/Homebrew/"/>
    
      <category term="Linuxbrew" scheme="https://liam.page/tags/Linuxbrew/"/>
    
      <category term="brwe" scheme="https://liam.page/tags/brwe/"/>
    
      <category term="Glibc" scheme="https://liam.page/tags/Glibc/"/>
    
  </entry>
  
  <entry>
    <title>USB 3.0 射频噪声对 2.4GHz 无线设备的干扰</title>
    <link href="https://liam.page/2020/01/19/USB-3-0-Radio-Frequency-Interference-Impact-on-2-4-GHz-Wireless-Devices/"/>
    <id>https://liam.page/2020/01/19/USB-3-0-Radio-Frequency-Interference-Impact-on-2-4-GHz-Wireless-Devices/</id>
    <published>2020-01-19T02:34:48.000Z</published>
    <updated>2020-02-12T09:53:30.611Z</updated>
    
    <content type="html"><![CDATA[<p>早些年，第一次使用 USB 3.0 硬盘的时候，我就发现了它对 Wi-Fi 网络信号的影响。为了解决这个问题，当时投资几百块，换了 NetGear 的路由器，并启用其 5GHz 的 Wi-Fi 信号。最近，在结合 rMBP 使用无线鼠标时，我发现鼠标经常出现跳帧的现象。因为距离上一次踩坑的时间已经过去六七年的时间，一时完全没想到可能是 USB 3.0 带来的问题。在经历了一系列折腾之后，才突然想起这个坑。特此记录。</p><a id="more"></a><h2 id="向外辐射的电磁波"><a href="#向外辐射的电磁波" class="headerlink" title="向外辐射的电磁波"></a>向外辐射的电磁波</h2><p>有高中物理电磁知识的人都应该知道一个基本事实：任何未经完全屏蔽的非直流电流，都会向外辐射电磁波。在高中物理中，它的基本形式就是 <a href="https://zh.wikipedia.org/wiki/LC%E7%94%B5%E8%B7%AF" target="_blank" rel="noopener">LC 谐振电路</a>。但另一方面，向外辐射电磁波的另一个条件是电路开路。也就是说，在连续的电路中，一般来说很难产生足以干扰其他设备的射频信号。此外，线缆通常也会考虑屏蔽电磁辐射。因此，一般来说，产生电磁射频噪声的干扰源，通常是电路的连接点，例如接头、引脚处。</p><h2 id="USB-3-0-的射频噪声"><a href="#USB-3-0-的射频噪声" class="headerlink" title="USB 3.0 的射频噪声"></a>USB 3.0 的射频噪声</h2><p>根据 Intel 于 2012 年发布的<a href="https://usb.org/sites/default/files/327216.pdf" target="_blank" rel="noopener">白皮书</a>，从 USB 3.0 的 <a href="https://zh.wikipedia.org/wiki/Sinc%E5%87%BD%E6%95%B0" target="_blank" rel="noopener"><code>sinc</code> 函数</a>来看，USB 3.0 的频谱很宽，从直流一直到 5GHz 都有所涉及。</p><p><img data-src="/uploads/images/computer-skills/usb3-sinc.jpg" alt></p><p>直接在笔记本上测量 USB 3.0 线对（transmit-pair）上的频谱则有如下分布。</p><p><img data-src="/uploads/images/computer-skills/usb3-noise-power-over-frequence.jpg" alt></p><p>于是，不难想见，USB 3.0 的接头处，在非常广的频谱上，都会向外辐射无线电干扰。那么射频干扰主要集中在什么频段呢？Intel 以实验说话，发现射频干扰主要集中在 2.4GHz -- 2.5GHz 之间。</p><p><img data-src="/uploads/images/computer-skills/usb3-noise-HDD.jpg" alt></p><p>那么为什么射频干扰主要集中在 2.4GHz -- 2.5GHz 之间呢？USB 3.0 是以 NRZ-I 方式进行编码的。因此，在一个时钟周期里，随着电平的两次翻转，可以传递出 2bit 的信息。考虑到 USB 3.0 的比特率是 5Gbps，即，每秒传输 5Gb。因此，它的电平周期是 2.5GHz。这就是 USB 3.0 设备产生的射频干扰集中在 2.5GHz 附近的原因。</p><h2 id="信噪比与干扰"><a href="#信噪比与干扰" class="headerlink" title="信噪比与干扰"></a>信噪比与干扰</h2><p>无线信号接收器是否能够正确解析无线信号，不仅取决于无线信号的强度，还取决于接收器所处环境的无线噪声强度。并不是说无线信号强度大，就一定能正确解析无线信号。假设有一个 -20 dBm（分贝毫瓦，对数能量单位）的信号，已经算很强了；但若环境中有一个 -20dBm 的同频率干扰信号，则原信号依然是不可辨别的。</p><p>因此，人们定义了信噪比（Signal-to-Noise ratio）这个概念。信噪比的单位也是分贝（dB）。</p><p><code>$$\text{SNR} = 10 \log_{10}\Bigl(\frac{P_{\text{signal}}}{P_{\text{noise}}}\Bigr).$$</code></p><p>为了能够正确解调无线信号，无线信号接收器都会有一个最低限度的信噪比要求。当无线信号过于衰弱，或是无线噪声过于强大时，信噪比就可能低于无线信号接收器所需的最低信噪比。如此一来，无线信号接收器就无法正常工作了。</p><h2 id="2-4GHz"><a href="#2-4GHz" class="headerlink" title="2.4GHz"></a>2.4GHz</h2><p>无线电信号频段是有限的资源。在大多数主要国家，都有相应的法律法规，来约束和限制无线电信号频段的使用。2.4GHz 是国际通用的不受约束的频段（当然，这里的不受约束，指的是你可以使用，但功率不能太大）。因此，大多数无线设备，都在这一频段工作。常见的有 Wi-Fi、无线鼠标、无线键盘、蓝牙等外设。</p><p>不巧的是，USB 3.0 的射频干扰主要集中在 2.4GHz 和 2.5GHz 之间，正好与这一通用频段重合。于是，USB 3.0 设备干扰 Wi-Fi、无线鼠标等，也就不奇怪了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法很简单。</p><ol><li>屏蔽：使用金属箔纸，将 USB 3.0 的连接处和电缆包裹起来，起到无线屏蔽的作用。当然，这对动手能力要求很高。</li><li>远离：由于无线信号强度随着信号源的距离的增加而快速衰减（平方衰减），因此，使用 USB 2.0 延长线，将无线信号接收器（如果有）远离 USB 3.0 的设备和借口，即可避免这一问题。</li><li>换频：由于 USB 3.0 的射频干扰主要集中在 2.4GHz 至 2.5GHz 之间，那么换成不在 2.4GHz 频段工作的设备即可。例如，可以更换成 5(.8) GHz 的设备。</li><li>有线：开历史倒车，从无线设备切换回到有线设备，彻底绕开无线干扰这个问题。<code>XD</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早些年，第一次使用 USB 3.0 硬盘的时候，我就发现了它对 Wi-Fi 网络信号的影响。为了解决这个问题，当时投资几百块，换了 NetGear 的路由器，并启用其 5GHz 的 Wi-Fi 信号。最近，在结合 rMBP 使用无线鼠标时，我发现鼠标经常出现跳帧的现象。因为距离上一次踩坑的时间已经过去六七年的时间，一时完全没想到可能是 USB 3.0 带来的问题。在经历了一系列折腾之后，才突然想起这个坑。特此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="USB" scheme="https://liam.page/tags/USB/"/>
    
      <category term="USB3.0" scheme="https://liam.page/tags/USB3-0/"/>
    
      <category term="Wireless" scheme="https://liam.page/tags/Wireless/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑨）：Linux 系统里的进程状态</title>
    <link href="https://liam.page/2020/01/10/the-states-of-processes-on-Linux/"/>
    <id>https://liam.page/2020/01/10/the-states-of-processes-on-Linux/</id>
    <published>2020-01-10T07:22:34.000Z</published>
    <updated>2020-02-04T07:57:06.015Z</updated>
    
    <content type="html"><![CDATA[<p>今天有同事问到 <code>top</code> 命令里的 <code>running</code>, <code>sleep</code>, <code>stop</code>, <code>zombie</code> 等进程状态分别是什么意思。于是借这个机会写一下 Linux 系统里的进程状态。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>进程（Process）即当前正在运行的计算机程序之实例。每个进程都有一些属性变量，这些变量决定了进程所能使用的计算机资源。进程执行过程中，会处在不同状态；正如人会处在不同的人生状态一样。</p><p>和人一样，进程也是进程它妈生的。进程从其父进程当中 <em>fork</em> 出来。而后，程在执行（running）的过程中，会用到一些可用的资源；这一点，和人也是一样的。如果把精力当成是一种资源，那么人睡觉就是等待精力这一资源的过程；进程也是一样，当进程执行所需的资源暂时不可用时，进程就会进入睡眠（sleeping）状态。当然，和人一样，进程也会死。一个进程可能会正常结束，相当于人的寿终正寝；也可能被杀死（kill a process）。</p><h2 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h2><p>Linux 系统里有几种不同类型的进程：用户进程（User processes）、守护进程（Deamon processes）和内核进程（Kernel processes）。</p><h3 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h3><p>系统里大多数进程都是用户进程。用户进程由通常的用户账户启动，并在用户空间（user space）当中执行。在没有获得额外许可的情况下，通常用户进程无法对处理器进行特殊访问，或是访问启动进程的用户无权访问的文件。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程通常是后台程序，它们往往由一些持续运行的服务来管理。守护进程可以用来监听请求，而后访问某些服务。举例来说，<code>httpd</code> 这一守护进程监听访问网络页面的请求。守护进程也可以用来自行启动一些任务。例如，<code>crond</code> 这一守护进程会在预设的时间点启动计划任务。</p><p>尽管用于管理守护进程的服务通常是 <code>root</code> 用户启动的，但守护进程本身往往以非 <code>root</code> 用户启动。这种启动方式，符合「只赋予进程运行所必须的权限」之要求，因而能使系统免于一些攻击。举例来说，若是黑客骇入了 <code>httpd</code> 这一由 <code>Apache</code> 用户启动的守护进程，黑客仍然无法访问包括 <code>root</code> 用户在内的其他用户的文件，或是影响其他用户启动的守护进程。</p><p>守护进程通常由系统在启动时拉起，而后一直运行到系统关闭。当然，守护进程也可以按需启动和终止，以及让守护进程在特定的系统运行级别上执行，或是在运行过程中触发重新加载配置信息。</p><h3 id="内核进程"><a href="#内核进程" class="headerlink" title="内核进程"></a>内核进程</h3><p>内核进程仅在内核空间（kernel space）当中执行。内核进程与守护进程有些相似；它们之间主要的不同在于：内核进程对内核数据结构拥有完全的访问权限。此外，内核进程不如守护进程灵活：修改配置文件并触发重载即可修改守护进程的行为；但对于内核进程来说，修改行为则需要重新编译内核本身。</p><h2 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h2><p>系统在进程启动时会赋予其状态。进程的状态由该进程的状态描述符来描述。设置进程状态，通常对应了一个简单的赋值操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><p>这里，<code>p</code> 代表进程，<code>state</code> 是其状态标识，<code>TASK_RUNNING</code> 表示该进程正在运行或可以执行。</p><p>进程通常处于以下两种状态之一：</p><ul><li>在 CPU 上执行（此时，进程正在运行）</li><li>不在 CPU 上执行（此时，进程未在运行）</li></ul><p>同一时间同一 CPU 上只能运行一个进程，其他进程就只能等待，或处于其他状态。也就是说，未在运行的进程可能处于不同状态：</p><ul><li>可运行状态</li><li>可中断之睡眠状态</li><li>不可中断之睡眠状态</li><li>僵死状态</li></ul><p>接下来，详细说说不同状态。</p><h3 id="P-之初（人之初）"><a href="#P-之初（人之初）" class="headerlink" title="P 之初（人之初）"></a>P 之初（人之初）</h3><p>按 <code>fork(2)</code> 的手册页（执行 <code>man 2 fork</code> 可打开），<code>fork</code> 这一系统调用创建一个与调用 <code>fork</code> 的进程几乎完全相同的进程。这里，前者称为父进程，后者称为子进程。子进程与父进程几乎完全相同，但有以下一些差别：</p><ul><li>子进程拥有全局唯一的进程 ID（见 <code>setpgid(2)</code> 的手册页）</li><li>子进程的父进程 ID 是父进程的进程 ID</li><li>子进程不继承父进程的内存锁（见 <code>mlock(2)</code> 和 <code>mlockall(2)</code> 的手册页）</li><li>子进程的资源使用计数及 CPU 时间计数（见 <code>getrusage(2)</code> 和 <code>times(2)</code> 的手册页）重置为零</li><li>子进程未处理的信号队列重置为空（见 <code>sigpending(2)</code> 的手册页）</li><li>子进程不继承父进程的信号量修正（见 <code>semop(2)</code> 的手册页）</li><li>子进程不继承父进程的文件区域锁（record lock / file-region lock，见 <code>fcntl(2)</code> 的手册页）</li><li>子进程不继承父进程的计时器（见 <code>setitimer(2)</code>, <code>alarm(2)</code> 和 <code>timer_create(2)</code> 的手册页）</li><li>子进程不继承父进程未完成的异步输入输出操作（outstanding asynchronous I/O operations）（见 <code>aio_read(3)</code> 和 <code>aio_write(3)</code> 的手册页）</li><li>子进程不继承父进程的异步输入输出上下文（asynchronous I/O contexts）（见 <code>io_setup(2)</code> 的手册页）</li></ul><h3 id="正在运行状态"><a href="#正在运行状态" class="headerlink" title="正在运行状态"></a>正在运行状态</h3><p>系统中最珍贵的资源是 CPU。正使用 CPU 的进程处于「正在运行状态」。在 <code>ps</code> 或是 <code>top</code> 中，状态标识为 <code>R</code> 的进程，即处于正在运行状态。</p><p>接下来，我们看看进程是怎么进入「正在运行状态」的。比方说，你在 Shell（以 <code>bash</code> 为例）中执行 <code>ls</code> 命令时，Shell 会在环境变量 <code>PATH</code> 记录的搜索路径里寻找 <code>ls</code> 命令对应的可执行文件。找到后，Shell 使用 <code>fork</code> 克隆自身进程，而后在子进程中，使用 <code>ls</code> 的可执行文件替换虚存空间中 Shell 的内容。</p><p>此时，系统会设置子进程的运行状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><p>CPU 即可在内核模式运行，又可在用户模式运行。当用户初始化一个进程，进程在用户空间运行，对应 CPU 在用户模式运行。在用户空间运行的进程无权访问内核数据结构和算法。各型号的 CPU 都会提供一些特定的指令，以便在内核模式和用户模式之间切换。如果一个用户级的进程需要访问内核数据结构或算法，则它需要使用系统调用来与文件子系统或是进程控制子系统之间进行交互。部分系统调用罗列如下：</p><ul><li>文件子系统对应的系统调用：<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>chmod()</code> 以及 <code>chown()</code></li><li>进程控制子系统对应的系统调用：<code>fork()</code>, <code>exec()</code>, <code>exit()</code>, <code>wait()</code>, <code>brk()</code> 以及 <code>signal()</code></li></ul><p>当内核开始处理来自用户级进程的请求，相应进程就进入了内核空间，对应 CPU 就在内核模式运行。<code>/proc/&lt;pid&gt;/stat</code> 中的第 14 和 15 项，分别记录了进程在用户空间和内核空间执行的时间。摘录部分 <code>proc(5)</code> 的手册页内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">utime %lu</span><br><span class="line">  Amount of time that this process has been scheduled in user mode,</span><br><span class="line">  measured in clock ticks (divide by sysconf(_SC_CLK_TCK). This</span><br><span class="line">  includes guest time, guest_time (time spent running a virtual CPU, see</span><br><span class="line">  below), so that applications that are not aware of the guest time field do</span><br><span class="line">  not lose that time from their calculations.</span><br><span class="line"></span><br><span class="line">stime %lu</span><br><span class="line">  Amount of time that this process has been scheduled in kernel mode,</span><br><span class="line">  measured in clock ticks (divide by sysconf(_SC_CLK_TCK).</span><br></pre></td></tr></table></figure><p><code>top</code> 命令的 CPU 统计行，则展示了 CPU 位于用户模式和内核模式的时间占比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top - 12:27:25 up 2:51, 4 users, load average: 4.37, 3.64, 3.44</span><br><span class="line">Tasks: 194 total, 2 running, 192 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 57.0%us, 1.3%sy, 0.0%ni, 41.1%id, 0.0%wa, 0.4%hi, 0.1%si, 0.0%st</span><br></pre></td></tr></table></figure><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>进程获取了所有所需资源，正等待 CPU 时，就会进入可运行状态。处于可运行状态的进程在 <code>ps</code> 的输出中，也已 <code>R</code> 标识。</p><p>举例来说，一个正在 I/O 的进程并不立即需要 CPU。当进程完成 I/O 操作后，就会触发一个信号，通知 CPU 和调度器将该进程置于运行队列（由内核维护的可运行进程的列表）。当 CPU 可用时，该进程就会进入正在运行状态。</p><p>和正在运行状态一样，进程的状态被设置为 <code>TASK_RUNNING</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><h3 id="睡眠状态"><a href="#睡眠状态" class="headerlink" title="睡眠状态"></a>睡眠状态</h3><p>当进程所需的资源暂不可用时，就会进入睡眠状态。此时，进程要么主动进入睡眠状态，要么被内核置于睡眠状态（不管你想不想睡，反正内核会让你睡；因此，后者又称为「进程被内核睡了」）。进入睡眠状态的进程，会立即交出 CPU 的使用权。</p><p>当进程所需的资源可用时，CPU 会收到一个信号。于是，当调度器下次调度该进程时，会将它置为正在运行或可以运行状态。</p><p>以 login shell 进程为例，它</p><ul><li>在你键入命令时进入睡眠状态，同时等待一个特定的事件（取决与你键入执行的命令）；</li><li>Shell 进程睡眠时，会进入一个特定的等待通道（<code>WCHAN</code>, wait channel，同样取决于你键入执行的命令）；</li><li>当 Shell 进程等待的事件发生时（例如，收到一个来自键盘的中断 <code>^C</code>），在该等待通道的所有进程都会苏醒。</li></ul><p>执行 <code>ps -l</code> 可看到与当前 shell 关联的进程，执行 <code>ps -el</code> 则可看到系统上所有进程。如果进程处于睡眠状态，<code>ps</code> 输出中的 <code>WCHAN</code> 字段会显示进程在等待什么系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -l | more</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R   867 12085 27779  0  80   0 - 27029 -      pts/480  00:00:00 ps</span><br><span class="line">0 S   867 12086 27779  0  80   0 - 25779 pipe_w pts/480  00:00:00 more</span><br><span class="line">0 S   867 27779 35146  0  80   0 - 27721 do_wai pts/480  00:00:01 bash</span><br></pre></td></tr></table></figure><p>例如，在这里，我们执行了 <code>ps -l | more</code> 这个命令。输出中，<code>more</code> 和 <code>bash</code> 都处于睡眠状态。前者是在等待管道输入，即 <code>pipe_wait</code>，因为 <code>ps</code> 输出时，<code>more</code> 还没有接到内容。后者是在 等待 <code>ps -l | more</code> 执行完毕，即等待 <code>do_wait</code> 系统调用。</p><p>除了等待资源之外，进程也可以主动进入睡眠状态并持续一段时间。例如，<code>sleep()</code> 函数接收一个时间长度（以秒为单位，比如 10 秒）的参数，然后调用该函数的进程就会进入睡眠状态，并持续 10 秒。当睡眠时间结束后，调度器再次调度到该进程时，会将其设置为可运行状态。之后，当 CPU 空闲时，进程会重新进入正在运行状态。</p><blockquote><p>由此可见，<code>sleep(10)</code> 并不能保证「恰好」睡眠 10 秒，它只保证睡眠时间不少于 10 秒。</p></blockquote><p>部分进程永远不会终止，而是不断地在睡眠、唤醒干活的状态中循环。每次循环开始时，进程进入睡眠状态，然后等待某个特定的事件。当事件发生时，进程被唤醒（进入正在运行或者可以运行状态），然后处理任务。</p><p>睡眠状态也分可中断之睡眠状态和不可中断之睡眠状态。</p><h4 id="可中断之睡眠状态"><a href="#可中断之睡眠状态" class="headerlink" title="可中断之睡眠状态"></a>可中断之睡眠状态</h4><p>可中断之睡眠状态表示进程在等待时间片段或者某个特定的事件。一旦事件发生，进程会从可中断之睡眠状态中退出。<code>ps</code> 命令的输出中，可中断之睡眠状态标识为 <code>S</code>。</p><p>系统会为可中断之睡眠状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_INTERRUPTABLE;</span><br></pre></td></tr></table></figure><h4 id="不可中断之睡眠状态"><a href="#不可中断之睡眠状态" class="headerlink" title="不可中断之睡眠状态"></a>不可中断之睡眠状态</h4><p>不可中断之睡眠状态的进程不会处理任何信号，而仅在其等待的资源可用或超时时退出（前提是设置了超时时间）。</p><p>不可中断之睡眠状态通常和设备驱动等待磁盘或网络 I/O 有关。在内核源码 <code>fs/proc/array.c</code> 中，其文字定义为 <code>&quot;D (disk sleep)&quot;, /* 2 */</code>。当进程进入不可中断之睡眠状态时，进程不会处理信号，而是将信号都积累起来，等进程唤醒之后再处理。在 Linux 中，<code>ps</code> 命令使用 <code>D</code> 来标识处于不可中断之睡眠状态的进程。</p><p>系统会为不可中断之睡眠状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_UNINTERRUPTABLE;</span><br></pre></td></tr></table></figure><p>由于处于不可中断之睡眠状态的进程不会处理任何信号，所以 <code>kill -9</code> 也杀不掉它。解决此类进程的办法只有两个:</p><ul><li>对于怨妇，你还能怎么办，只能满足它啊：搞定不可中断之睡眠状态进程所等待的资源，使资源可用。</li><li>如果满足不了它，那就只能 kill the world——重启系统。</li></ul><h3 id="进程的终止和僵尸状态"><a href="#进程的终止和僵尸状态" class="headerlink" title="进程的终止和僵尸状态"></a>进程的终止和僵尸状态</h3><p>进程可以主动调用 <code>exit</code> 系统调用来终止，或者接受信号来由信号处理函数来调用 <code>exit</code> 系统调用来终止。</p><p>当进程执行 <code>exit</code> 系统调用后，进程会释放相应的数据结构；此时，进程本身已经终止。不过，此时操作系统还没有释放进程表中该进程的槽位（可以形象地理解为，「父进程还没有替子进程收尸」）；为解决这个问题，终止前，进程会向父进程发送 <code>SIGCHLD</code> 信号，通知父进程来释放子进程在操作系统进程表中的槽位。这个设计是为了让父进程知道子进程退出时所处的状态。</p><p>子进程终止后到父进程释放进程表中子进程所占槽位的过程，子进程进入僵尸状态（zombie state）。如果在父进程因为各种原因，在释放子进程槽位之前就挂掉了，也就是，父进程来不及为子进程收尸。那么，子进程就会一直处于僵尸状态。而考虑到，处于僵尸状态的进程本身已经终止，无法再处理任何信号，所以它就只能是孤魂野鬼，飘在操作系统进程表里，直到系统重启。</p><p>在 <code>ps</code> 命令的输出中，僵尸状态的进程标识为 <code>Z</code>。系统会为僵尸状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_ZOMBIE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有同事问到 &lt;code&gt;top&lt;/code&gt; 命令里的 &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;zombie&lt;/code&gt; 等进程状态分别是什么意思。于是借这个机会写一下 Linux 系统里的进程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Process" scheme="https://liam.page/tags/Process/"/>
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>向 non-bare 仓库的检出分支推送提交</title>
    <link href="https://liam.page/2020/01/09/git-push-to-a-non-bare-repository-with-checked-out-branch/"/>
    <id>https://liam.page/2020/01/09/git-push-to-a-non-bare-repository-with-checked-out-branch/</id>
    <published>2020-01-09T12:59:13.000Z</published>
    <updated>2020-02-04T07:57:06.017Z</updated>
    
    <content type="html"><![CDATA[<p>假设有本地 Git 仓库 A，而后在本地自 A 克隆仓库 B（即，在 B 的视角，A 是远程仓库，只不过物理位置在本机）。若从 B 向 A 推送提交，则 Git 可能会报错。这是因为，A 默认是 non-bare 的仓库，粗略理解即是工作区不为空；此时，从 B 向 A 推送的话，A 仓库中的内容可能和 A 工作区内容不一致。</p><a id="more"></a><p>解决该问题的办法之一，是将 A 设置为 bare 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line">mv .git ../repo.git <span class="comment"># renaming just for clarity</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -fr repo</span><br><span class="line"><span class="built_in">cd</span> repo.git</span><br><span class="line">git config --bool core.bare <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但若 A 是 <code>git svn</code> 桥接的仓库，则 Git 不允许我们将其设置为 bare 仓库。此时，应在仓库 A 执行下列代码，告知 Git 在仓库 A 接受检出分支推送时，同步修改工作区的内容。不过这样的话，我们要保证仓库 A 的工作区没有未提交的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config receive.denyCurrentBranch updateInstead</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有本地 Git 仓库 A，而后在本地自 A 克隆仓库 B（即，在 B 的视角，A 是远程仓库，只不过物理位置在本机）。若从 B 向 A 推送提交，则 Git 可能会报错。这是因为，A 默认是 non-bare 的仓库，粗略理解即是工作区不为空；此时，从 B 向 A 推送的话，A 仓库中的内容可能和 A 工作区内容不一致。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="SVN" scheme="https://liam.page/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>跳过冗余 revisions 以加速 git svn fetch</title>
    <link href="https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/"/>
    <id>https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/</id>
    <published>2020-01-09T11:41:55.000Z</published>
    <updated>2020-02-04T07:57:06.017Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 <code>git clone</code> 会消耗很长时间。使用 <code>git svn</code> 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 <code>git svn fetch</code> 会花费很长时间（可能超过 24 hours）。</p><p>如果你觉得，<code>git svn fetch</code> 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。</p><a id="more"></a><p>SVN 相较 Git 的一个优势在于它可以针对仓库里的各个子路径进行权限设置。于是，我们可以假设这样一种场景：</p><ul><li>SVN 仓库中，有例如 100,000 次修订。</li><li>你使用 <code>git svn clone -s &lt;uri of svn repository&gt;</code> 将这 10 万次修订都下载到本地，行程了一个 Git 本地仓库。</li><li>在开发的过程中，你发现你缺少某些子路径的权限，于是你找到 SVN 管理员，为你授权了这些子路径。</li><li>而后，你会使用 <code>git svn fetch</code> 来更新你的本地仓库。这时，你会发现报错 <code>&lt;file&gt; was not found in commit &lt;hash&gt;</code>。其原因在于，由于之前你的权限缺失，导致前次 <code>git svn clone</code> 以及历次 <code>git svn fetch</code> 的过程中，这些路径在 <code>git-svn</code> 看来是「空的」；但在这次 <code>git svn fetch</code> 时，这些路径突然有了东西，但是缺少相应的历史。</li><li>为了修正这个问题，有以下一些解决办法：<ul><li>干掉整个本地仓库，从头再 <code>git svn clone -s &lt;uri of svn repository&gt;</code> 一次。这相当于从 <code>r1</code> 开始重新 <code>git svn fetch</code> 一次。</li><li>使用 <code>git svn reset -p &lt;revision&gt;</code> 将本地仓库回退到一个早先的版本，然后从该版本 <code>git svn fetch</code>。需要注意的是，涉及到权限缺失的路径，必须在该 <code>&lt;revision&gt;</code> 之后创建。定位这个 <code>&lt;revision&gt;</code> 本身就很困难，更不用说若是这些路径有过移动的话，又会有一系列的问题。因此，虽然该方案相当于从 <code>&lt;revision&gt;</code> 开始重新 <code>git svn fetch</code>；能省下 <code>r1 -- &lt;revision&gt;</code> 之间的修订，但仍然十分麻烦。</li></ul></li></ul><p>在这种情况下，从头再来，似乎是唯一的选择了。而后，你终于不得不承认曾经的自己「太年轻」。</p><p>为了解决这个困局，我们不得不做一次 trade-off。既然问题的根源在于 Git 会将所有历史信息下载到本地，若是我们能舍弃一些过早的历史信息，只下载较近的历史，就能够绕过这个问题。为此，我们需要：</p><ul><li><code>rm -rf &lt;local repo&gt;</code>：删掉已经「失真」的本地仓库。</li><li><code>mkdir &lt;local repo&gt;</code>：建立一个空的目录。</li><li><code>cd &lt;local repo&gt;</code>：进入刚创立的目录。</li><li><code>git svn init -s &lt;uri of svn repository&gt;</code>：以 <code>git svn</code> 初始化该仓库，但不立即 <code>clone</code>。</li><li><code>git svn fetch -r &lt;revision&gt;</code>：从 <code>&lt;revision&gt;</code> 开始，拉取仓库版本信息；即舍弃从 <code>r1</code> 开始到 <code>&lt;revision&gt;</code> 结束的所有历史信息。</li></ul><p>唯独需要注意的是，如果涉及到分支操作，你必须保证你会用到的分支，都在上述 <code>&lt;revision&gt;</code> 之后创建。</p><p>如此一来，只要 <code>&lt;revision&gt;</code> 选得好，代码开始写的早。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 &lt;code&gt;git clone&lt;/code&gt; 会消耗很长时间。使用 &lt;code&gt;git svn&lt;/code&gt; 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 &lt;code&gt;git svn fetch&lt;/code&gt; 会花费很长时间（可能超过 24 hours）。&lt;/p&gt;
&lt;p&gt;如果你觉得，&lt;code&gt;git svn fetch&lt;/code&gt; 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="SVN" scheme="https://liam.page/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>解决 Git 2.24.1 与 OpenSSL 1.1.1b 的冲突</title>
    <link href="https://liam.page/2020/01/07/fix-incompatiblities-between-git-2-24-1-and-openssl-1-1-1b/"/>
    <id>https://liam.page/2020/01/07/fix-incompatiblities-between-git-2-24-1-and-openssl-1-1-1b/</id>
    <published>2020-01-07T08:58:52.000Z</published>
    <updated>2020-02-04T07:57:06.017Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为工作需要处理一些 SVN 仓库，但我还是偏好 Git。早些年就知道 Git 提供了 <code>git svn</code> 可以桥接 SVN。但今天发现公司开发机上的 Git 没有把 <code>git svn</code> 编译进来，也就是会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git svn</span><br><span class="line">git: <span class="string">'svn'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.</span><br><span class="line"></span><br><span class="line">Did you mean one of these?</span><br><span class="line">        fsck</span><br><span class="line">        mv</span><br><span class="line">        show</span><br><span class="line">        spop</span><br><span class="line">        st</span><br></pre></td></tr></table></figure><p>又因为开发机上我没有 <code>root</code> 权限，所以不得已只能自己从源码编译安装 Git。</p><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>首先是下载、解包、<code>configure</code>、<code>make</code> 一波流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.1.tar.gz</span><br><span class="line">$ tar zvxf git-2.24.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> git-2.24.1</span><br><span class="line">$ ./configure --prefix=~/.<span class="built_in">local</span> --with-libpcre1 --with-curl --with-openssl=~/.<span class="built_in">local</span>/include</span><br><span class="line">$ make -j32</span><br></pre></td></tr></table></figure><p>但在链接阶段报错，提示 <code>SSLv23_method</code>, <code>SSL_library_init</code>, <code>SSL_load_error_strings</code>, <code>sk_num</code>, <code>sk_value</code>, <code>sk_pop_free</code> 等符号不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imap-send.o: In function `verify_hostname&apos;:</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:252: undefined reference to `sk_num&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:254: undefined reference to `sk_value&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:260: undefined reference to `sk_pop_free&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:260: undefined reference to `sk_pop_free&apos;</span><br><span class="line">imap-send.o: In function `ssl_socket_connect&apos;:</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:287: undefined reference to `SSL_library_init&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:288: undefined reference to `SSL_load_error_strings&apos;</span><br><span class="line">~/downloads/git-2.24.1/imap-send.c:290: undefined reference to `SSLv23_method&apos;</span><br><span class="line">collect2: ld returned 1 exit status</span><br><span class="line">make: *** [git-imap-send] Error 1</span><br></pre></td></tr></table></figure><p>我第一反应是 OpenSSL 没安装，或是没有正确配置。但随即发现，早先在安装别的工具的时候，已经安装了 OpenSSL 1.1.1b；并且已经修改了 <code>LD_PATH</code> 和 <code>LD_LIBRARY_PATH</code> 两个环境变量，确保链接器能够正确找到相应的共享对象（动态链接库）。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>在确定 OpenSSL 已安装且能够被编译器、链接器正确找到之后，就只能去检查一下相应符号在共享对象中是否存在了。</p><p><code>SSLv23_method</code>, <code>SSL_library_init</code> 和 <code>SSL_load_error_strings</code> 显然属于 OpenSSL 当中的 <code>libssl.so</code>。于是执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nm libssl.so | grep SSL_library_init</span><br><span class="line">$ nm libssl.so | grep SSL_load_error_strings</span><br><span class="line">$ nm libssl.so | grep SSLv23_method</span><br></pre></td></tr></table></figure><p>返现返回均为空。这说明在 <code>libssl.so</code> 当中确实不存在这三个符号。<code>sk_num</code>, <code>sk_value</code> 和 <code>sk_pop_free</code> 应当位于 <code>libcrypto.so</code> 当中，检查也有同样结果。</p><p>这就令人「满头大汉」了。难道是我下载 OpenSSL 的姿势不对？经过一番检索，在一个与 Git 无关的版本库的 commit log 中，发现了这么一段话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># https://cbi-dev.igbmc.fr/niveale/tap-formatter/commit/b67a118e7a438009e5d44d0701c21d030c92aa94</span><br><span class="line">Fix: OpenSSL 1.1.0 renamed some symbols</span><br><span class="line"></span><br><span class="line">- sk_free =&gt; OPENSSL_sk_free</span><br><span class="line">- sk_num =&gt; OPENSSL_sk_num</span><br><span class="line">- sk_pop_free =&gt; OPENSSL_sk_pop_free</span><br><span class="line">- sk_value =&gt; OPENSSL_sk_value</span><br><span class="line">- evp_md_ctx_create =&gt; evp_md_ctx_new</span><br><span class="line">- evp_md_ctx_destroy =&gt; evp_md_ctx_free</span><br></pre></td></tr></table></figure><p>原来，OpenSSL 自 1.1.0 开始，修改了部分 API 的名称，导致部分符号名发生了变化。此时，大胆猜想：<code>SSL_*</code> 等三个未定义的符号也是因为类似原因导致的。小心求证如下：</p><ul><li>首先，在 <code>libssl.so</code> 当中检索含有 <code>init</code> 的符号，发现有名为 <code>OPENSSL_init_ssl</code> 的符号。看名字，其作用应该与 <code>SSL_library_init</code> 相近。</li><li>而后，在 Google 上检索 <code>SSL_library_init OPENSSL_init_ssl</code>，发现果然，也是在 1.1.0 版本中，该 API 发生了修改；并且 <code>OPENSSL_init_ssl</code> 包括了原先 <code>SSL_library_init</code> 和 <code>SSL_load_error_strings</code> 二者的功能。</li><li>最后，需要确定 <code>SSLv23_method</code> 的对应是什么。在 Google 上检索 <code>SSLv23_method deprecated</code>，发现在 <a href="https://www.openssl.org/docs/man1.1.0/man3/SSLv23_method.html" target="_blank" rel="noopener">OpenSSL 官方文档</a>有提到，它已为 <code>TLS_method</code> 所代替。</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是检索 Git 代码中所有用到这些过时符号的代码，将他们分别修改为对应的新版本。之后编译、链接正常。最后，再顺手提交<a href="https://github.com/gitgitgadget/git/pull/516" target="_blank" rel="noopener">一个 patch</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为工作需要处理一些 SVN 仓库，但我还是偏好 Git。早些年就知道 Git 提供了 &lt;code&gt;git svn&lt;/code&gt; 可以桥接 SVN。但今天发现公司开发机上的 Git 没有把 &lt;code&gt;git svn&lt;/code&gt; 编译进来，也就是会报错：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git svn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git: &lt;span class=&quot;string&quot;&gt;&#39;svn&#39;&lt;/span&gt; is not a git &lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;. See &lt;span class=&quot;string&quot;&gt;&#39;git --help&#39;&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Did you mean one of these?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fsck&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        show&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        spop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;又因为开发机上我没有 &lt;code&gt;root&lt;/code&gt; 权限，所以不得已只能自己从源码编译安装 Git。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Git" scheme="https://liam.page/tags/Git/"/>
    
      <category term="OpenSSL" scheme="https://liam.page/tags/OpenSSL/"/>
    
      <category term="Imcompatibilities" scheme="https://liam.page/tags/Imcompatibilities/"/>
    
      <category term="Symbol" scheme="https://liam.page/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 记录键盘事件</title>
    <link href="https://liam.page/2019/12/06/record-keyboard-events-by-python/"/>
    <id>https://liam.page/2019/12/06/record-keyboard-events-by-python/</id>
    <published>2019-12-06T09:25:10.000Z</published>
    <updated>2020-02-04T07:57:06.014Z</updated>
    
    <content type="html"><![CDATA[<p>今天也不知道是想了什么，突然就想要试试看我有效击键时的手速到底有多快。为此，需要记录下来击键的记录。于是找到了 Python 的 <code>keyboard</code> 库。</p><a id="more"></a><p>安装非常简单，只需执行 <code>pip install keyboard</code> 即可。而后保存并执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyboard</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">keyboard.hook(<span class="keyword">lambda</span> e: print(e, time.clock()))</span><br><span class="line">keyboard.wait(<span class="string">'Ctrl'</span>)</span><br></pre></td></tr></table></figure><p>这里，我们利用 <code>keyboard.hook</code> 为每个键盘事件下钩子，并且执行其中的 <code>lambda</code> 函数。<code>keyboard.wait()</code> 的作用是阻塞进程，直到按下 <code>Ctrl</code> 键。</p><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">KeyboardEvent(g down) 4.450576466</span><br><span class="line">KeyboardEvent(g up) 4.505627652</span><br><span class="line">KeyboardEvent(i down) 4.510628277</span><br><span class="line">KeyboardEvent(t down) 4.570555791</span><br><span class="line">KeyboardEvent(i up) 4.580582066</span><br><span class="line">KeyboardEvent(space down) 4.581583136</span><br><span class="line">KeyboardEvent(p down) 4.630656009</span><br><span class="line">KeyboardEvent(t up) 4.671189791</span><br><span class="line">KeyboardEvent(space up) 4.693182730</span><br><span class="line">KeyboardEvent(p up) 4.705543556</span><br><span class="line">KeyboardEvent(u down) 4.705867633</span><br><span class="line">KeyboardEvent(s down) 4.730623806</span><br><span class="line">KeyboardEvent(u up) 4.750832241</span><br><span class="line">KeyboardEvent(s up) 4.795770594</span><br><span class="line">KeyboardEvent(h down) 4.810543976</span><br><span class="line">KeyboardEvent(h up) 4.86056459</span><br><span class="line">KeyboardEvent(enter down) 4.920739469</span><br><span class="line">KeyboardEvent(enter up) 4.930514276</span><br><span class="line">KeyboardEvent(ctrl down) 7.030813124</span><br></pre></td></tr></table></figure><p>从中可见，在敲下 <code>git push&lt;enter&gt;</code> 这条命令的过程中，发生了多次击键交错的现象（即上一个按键还未完全弹起，下一个按键就已经触发）。这是在高速击键时很常见的现象。此外，输入到执行这条命令，总共花费了不到 <code>0.5 s</code> 的时间，不愧曾经单身多年 <code>←_←</code>。</p><blockquote><p>你的手速如何呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天也不知道是想了什么，突然就想要试试看我有效击键时的手速到底有多快。为此，需要记录下来击键的记录。于是找到了 Python 的 &lt;code&gt;keyboard&lt;/code&gt; 库。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="Keyboard" scheme="https://liam.page/tags/Keyboard/"/>
    
  </entry>
  
  <entry>
    <title>二分类的评价指标</title>
    <link href="https://liam.page/2019/12/05/evaluation-of-binary-classification/"/>
    <id>https://liam.page/2019/12/05/evaluation-of-binary-classification/</id>
    <published>2019-12-05T12:34:14.000Z</published>
    <updated>2020-02-04T07:57:06.013Z</updated>
    
    <content type="html"><![CDATA[<p>分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。</p><a id="more"></a><h2 id="混淆矩阵（confusion-matrix）"><a href="#混淆矩阵（confusion-matrix）" class="headerlink" title="混淆矩阵（confusion matrix）"></a>混淆矩阵（confusion matrix）</h2><p>二分类模型的基本工作是这样的：</p><ul><li>将样本 <code>$\{\vec x, y\}$</code> 输入二分类模型 <code>$\mathcal C$</code>，得到模型输出得分 <code>$s$</code>；</li><li>将模型输出得分 <code>$s$</code> 映射为最终结果 <code>$\hat y = M(s)$</code>。</li></ul><p>对于给定的模型 <code>$\mathcal C$</code> 和映射函数 <code>$M(\cdot)$</code>，根据样本真实分类 <code>$y$</code> 和模型预测分类 <code>$\hat y$</code> 的组合，定义如下四种情况：</p><ul><li>真阳性（True Positive，简称：TP）：表示样本是阳性 <code>$y = 1$</code>，并且模型也预测为阳性 <code>$\hat y = 1$</code>。</li><li>假阳性（False Positive，简称：FP）：表示样本是阴性 <code>$y = 0$</code>，但模型预测为阳性 <code>$\hat y = 1$</code>。</li><li>真阴性（True Negative，简称：TN）：表示样本是阴性 <code>$y = 0$</code>，并且模型也预测为阴性 <code>$\hat y = 0$</code>。</li><li>假阴性（False Negative，简称：FN）：表示样本是阳性 <code>$y = 1$</code>，但模型预测为阴性 <code>$\hat y = 0$</code>。</li></ul><p>又根据样本真实分类 <code>$y$</code> 和模型预测分类 <code>$\hat y$</code> 的实际情况，定义如下四个变量：</p><ul><li><code>$P = TP + FN$</code>：表示所有真实分类为阳性的样本的数量。</li><li><code>$N = FP + TN$</code>：表示所有真实分类为阴性的样本的数量。</li><li><code>$P&#39; = TP + FP$</code>：表示所有预测分类为阳性的样本的数量。</li><li><code>$N&#39; = TN + FN$</code>：表示所有预测分类为阴性的样本的数量。</li></ul><p>于是可绘制如下混淆矩阵：</p><table align="center"><tbody><tr><th colspan="2" rowspan="2">&nbsp;</th><th colspan="2" align="center">真实值</th><th rowspan="2">总<br>数</th></tr><tr><th><i>1</i></th><th><i>0</i></th></tr><tr><th rowspan="2" valign="middle">预<br>测<br>输<br>出</th><th valign="middle" style="padding:0.5em;"><i>1</i></th><th style="padding:0.5em;">真阳性<br>(TP)</th><th style="padding:0.5em;">假阳性<br>(FP)</th><th style="padding:0.5em;">P'</th></tr><tr><th valign="middle" style="padding:0.5em;"><i>0</i></th><th style="padding: 0.5em;">假阴性<br>(FN)</th><th style="padding:0.5em;">真阴性<br>(TN)</th><th style="padding:0.5em;">N'</th></tr><tr><th colspan="2" style="padding:0.5em;">总数</th><th align="center">P</th><th align="center">N</th><th></th></tr></tbody></table><h2 id="由混淆矩阵衍生的指标"><a href="#由混淆矩阵衍生的指标" class="headerlink" title="由混淆矩阵衍生的指标"></a>由混淆矩阵衍生的指标</h2><p>混淆矩阵是二分类模型与其数据相互作用得到的最基本的结果。建立在混淆矩阵之上，我们可以定义出一系列的指标，来衡量二分类模型的性能。这里对常见的指标及需要关注的要点罗列如下。</p><ul><li><strong>真阳性率</strong>（true positive rate，TPR）/<strong>敏感度</strong>（sensitivity）/<strong>召回率</strong>（recall rate）：在二分类问题中，真阳性率、敏感度和召回率三个名词对应着同一个概念；它表示正样本中被预测为正样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$TPR = TP / P = TP / (TP + FN).$</code></li><li><strong>真阴性率</strong>（true negative rate，TNR）/<strong>特异度</strong>（specificity）：在二分类问题中，真阴性率和特异度对应着同一个概念；它表示负样本中被预测为负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$TNR = TN / N = TN / (TN + FP).$</code></li><li><strong>假阳性率</strong>（false positive rate，FPR）：它表示负样本中被错误地预测为正样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FPR = FP / N = FP / (TN + FP) = 1 - TNR.$</code></li><li><strong>假阴性率</strong>（false negative rate，FNR）：它表示正样本中被错误滴预测为负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FNR = FN / P = FN / (TP + FN) = 1 - TPR.$</code></li><li><strong>阳性预测值</strong>（positive predictive value，PPV）/<strong>精确率</strong>（percision）：它表示被预测为正的样本中正样本的占比。在二分类问题中，阳性预测值和精确率对应着同一个概念；一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$PPV = TP / (TP + FP) = TP / P&#39;.$</code></li><li><strong>阴性预测值</strong>（negative predictive value，NPV）：它表示被预测为负的样本中负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$NPV = TN / (TN + FN) = TN / N&#39;.$</code></li><li><strong>假发现率</strong>（false detective rate，FDR）：它表示被预测为正的样本中负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 <code>$FDR = FP / (TP + FP) = FP / P&#39; = 1 - PPV.$</code></li><li><strong>准确率</strong>（accuracy，ACC）：它表示全体样本中预测正确的样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$ACC = (TP + TN) / (P + N).$</code></li><li><strong>F1 值</strong>（F1-score）：它是召回率（真阳性率）和精确率（阳性预测值）的调和平均。一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$F1 = 2TP / (P + P&#39;).$</code></li><li><strong>约登指数</strong>（Youden&#39;s J statistic）：一般而言，它的值越大意味着模型性能越好。其计算公式是 <code>$J = TPR + TNR - 1.$</code></li></ul><h3 id="准确率悖论（Accuracy-Paradox）"><a href="#准确率悖论（Accuracy-Paradox）" class="headerlink" title="准确率悖论（Accuracy Paradox）"></a>准确率悖论（Accuracy Paradox）</h3><p>准确率表示全体样本中，模型预测正确的样本之占比。这是一个非常 intuitive 的指标，和我们一般的认知很相符。但准确率有一个很大的问题：当正负例极不平衡时，即当 <code>$P \gg N$</code> 或 <code>$N \gg P$</code> 时，准确率会被样本量占优的类别主导从而失真。一般我们认为正例是重要的，于是这个问题在负例数量远多于正例数量时，显得尤为严重。欺诈检测、癌症检测等场合，均属于这种情况。</p><p>举个栗子。假设验证集中共有 100 个样本，其中有 95 个负例和 5 个正例。若模型对所有输入都认定为负例，则这种情况下有 <code>$ACC = (TP + TN) / (P + N) = (0 + 95) / (5 +95) = 0.95$</code>。看起来准确率很高，但这个模型一个正例都分辨不出来，没有实际价值。</p><p>单独用 TPR、TNR、FPR、FNR、PPV、NPV、FDR 这些指标，也会遇到类似的困难。</p><h3 id="召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值"><a href="#召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值" class="headerlink" title="召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值"></a>召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值</h3><p>计算召回率和精确率时的分子都是 TP，不同在于分母。召回率的分母是 <code>$P$</code>，而精确率的分母是 <code>$P&#39;$</code>。这也就是说，召回率是相对真实样本而言的，精确率是相对模型预测为正例的样本而言的。</p><p>举个栗子。</p><ul><li>假设验证集当中有 100 个正例，你的模型将这 100 个正例中的 40 个预测为正例，则你的模型的召回率是 40%。</li><li>假设你的模型一共预测了 50 个正例，其中 40 个确实是正例（还有 10 个是负例，即 FP 的情形），则你的模型精确率是 80%。</li></ul><p>显然，若要提高召回率，则模型会变得「贪婪」，于是犯错的可能性就会变大，也就是精确率下降；若要提高精确率，则模型会变得「保守」，此时模型能够覆盖的正例就少，于是召回率下降。考虑到召回率和精确率之间「跷跷板」的关系，人们发明了 F1 值这个指标，并将其定义为召回率和精确率的调和平均数，从而能够比较容易地在召回率和精确率方面取得平衡：</p><p><code>$$F1 = \frac{2}{\frac{1}{TPR} + \frac{1}{PPV}} = \frac{2TP}{P + P&#39;}.$$</code></p><h3 id="敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数"><a href="#敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数" class="headerlink" title="敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数"></a>敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数</h3><p>从数学上将，召回率和精确率之间跷跷板一般的关系来自于精确率计算的分母是 <code>$P&#39;$</code> 而非 <code>$P$</code>。因为当模型发生变化的时候，<code>$P&#39;$</code> 就会发生变化。所以你无法在提升召回率的时候，保证精确率不变；反之亦然。</p><p>既然如此，我们寻找分母为 <code>$P$</code> 或 <code>$N$</code> 的指标，是否就能解决这个问题了呢？按照这个思路，人们定义了敏感度和特异度的概念。</p><ul><li>敏感度就是召回率，它是真阳性率的有一个马甲。</li><li>特异度是模型在负例上的召回率，因此它是真阴性率的马甲。</li></ul><p>因为敏感度和特异度分别是以验证集中正例数量和负例数量为分母的，所以它们：</p><ul><li>不存在必然的跷跷板关系；</li><li>不受不平衡数据的影响。</li></ul><p>这就「很<del>理中客</del>」了嘛。为了统一考量模型的敏感度和特异度，即为了统一考量模型在正负例上的召回率，人们又定义了约登指数。</p><p><code>$$J = TPR + TNR - 1.$$</code></p><h2 id="曲线及其-AUC（Area-under-Curve，曲线下面积）"><a href="#曲线及其-AUC（Area-under-Curve，曲线下面积）" class="headerlink" title="曲线及其 AUC（Area under Curve，曲线下面积）"></a>曲线及其 AUC（Area under Curve，曲线下面积）</h2><p>上面的讨论都基于一个假设，即映射函数 <code>$M(\cdot)$</code> 是确定的。如果映射函数发生变化，模型对样本的最终预测 <code>$\hat y$</code> 就会发生变化，进而影响到混淆矩阵，最终影响到各个评价指标。因此，在这个意义下，对于确定的模型，各个指标将是映射函数的函数。</p><p>一般来说，对于二分类问题，映射函数是一个简单的分段函数。于是，各个指标将是分段阈值 <code>$t$</code> 的函数。</p><p><code>$$M(s) = \begin{cases} 1 &amp; s &gt; t, \\ 0 &amp; \text{otherwise}. \end{cases}$$</code></p><p>对于需要取舍的指标对，我们可以做如下操作，得到一条曲线（折线）：</p><ul><li>逐渐改变阈值 <code>$t$</code>，得到序列 <code>$\bigl\{\bigl(A(t), B(t)\bigr)\bigr\}$</code>。</li><li>将指标 A 和指标 B 分别作为平面直角坐标系的横轴和纵轴。</li><li>将序列对应的点，绘制在平面直角坐标系中。</li><li>顺序连接这些点。</li></ul><p>对于真阳性率（敏感度，召回率）和假阳性率（1 - 特异度），这条曲线是接收者操作特征曲线（receiver operating characteristic curve）。对于召回率和精确率，这条曲线是精确率-召回率曲线（PR-Curve）。</p><h3 id="接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）"><a href="#接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）" class="headerlink" title="接收者操作特征曲线（receiver operating characteristic curve, ROC）"></a>接收者操作特征曲线（receiver operating characteristic curve, ROC）</h3><p>一条典型的 ROC 如下图所示。</p><p><img data-src="/uploads/images/MachineLearning/roc.png" alt="ROC"></p><p>这里，横坐标代表假阳性率 FPR，它是阈值 <code>$t$</code> 的函数，我们记作 <code>$F(t)$</code>；纵坐标代表真阳性率 TPR，它也是阈值 <code>$t$</code> 的函数，我们记作 <code>$T(t)$</code>。从图中很明显能看出 FPR 和 TPR 之间「鱼和熊掌不可兼得」的关系。曲线下面积（AUC）越大，也就是曲线约接近左上角，说明模型就越理想。那么 ROC 的 AUC 是什么含义呢？</p><p>我们将 FPR 看做是一个累积分布函数，即</p><p><code>$$F(t) = P(\hat y \geqslant t \mid y = 0),$$</code></p><p>因此 FPR 相对 <code>$t$</code> 的偏导数应当是一个概率密度函数，即</p><p><code>$$\frac{\partial F(t)}{\partial t} = P(\hat y = t \mid y = 0).$$</code></p><p>我们将 TPR 看做是 FPR 的函数，即 <code>$T(t) = T(F) = T(F^{-1}(F(t)))$</code>。因此有</p><p><code>$$\begin{aligned}\text{AUC} = {}&amp; \int_{0}^{1} T(F)\,\mathop{}\mathrm{d}F \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \mid y = 1)\cdot\frac{\partial F(t)}{\partial t}\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \mid y = 1)\cdot P(\hat y&#39; = t \mid y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; t \wedge \hat y&#39; = t \mid y = 1 \wedge y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; \int_{0}^{1} P(\hat y &gt; \hat y&#39; \wedge \hat y&#39; = t \mid y = 1 \wedge y&#39; = 0)\,\mathop{}\mathrm{d}t \\           = {}&amp; P(\hat y &gt; \hat y&#39; \mid y = 1 \wedge y&#39; = 0). \\\end{aligned}$$</code></p><p>于是我们知道，ROC 的 AUC 表示任选正负例对 <code>$\bigl((\vec x_1, y_1 = 1), (\vec x_2, y_2 = 0)\bigr)$</code>，模型输出得分中，正例得分大于负例得分的概率 <code>$P\bigl(\mathcal C(\vec x_1) &gt; \mathcal C(\vec x_2)\bigr)$</code>。换言之，ROC 的 AUC 反映了模型的排序能力。这在 CTR 预估排序的场景下，非常有用。</p><blockquote><p>关于这一点，<a href="https://madrury.github.io/jekyll/update/statistics/2017/06/21/auc-proof.html" target="_blank" rel="noopener">这里</a>有一个有趣的集合解释。<br>另外，值得一提的是，一般默认的 AUC 指的是 AUC of ROC。</p></blockquote><h3 id="精确率-召回率曲线（precision-recall-curve-PR-Curve）"><a href="#精确率-召回率曲线（precision-recall-curve-PR-Curve）" class="headerlink" title="精确率-召回率曲线（precision-recall curve, PR-Curve）"></a>精确率-召回率曲线（precision-recall curve, PR-Curve）</h3><p>一条典型的 PR-Curve 如下图所示。</p><p><img data-src="/uploads/images/MachineLearning/pr-curve.jpg" alt="PR-Curve"></p><p>从中很明显能看出来之前说的「跷跷板」关系。曲线下面积（AUC）越大，也就是曲线约接近右上角，说明模型就越理想。但这种情况，在实际工作中基本是不可能出现的。因此我们需要根据实际问题进行取舍（确定一个合适的 <code>$t$</code>）。</p><p>对于正例显著少于负例的情况，人们往往追求尽可能高的召回率。因此，可以预先设定一个精确率下限，然后在这个下限之上，寻找召回率最高的点。比如在上图中，若设定可接受的最低精确率是 0.8，则召回率最高大约是 0.55；若设定可接受的最低精确率是 0.6，则召回率最高大约是 0.92。对于正例显著多于负例的情况，人们往往追求尽可能高的精确率。此时可以反向操作，选取合适的 <code>$t$</code>。</p><p>同样的问题：那么 PR-Curve 的 AUC 是什么含义呢？利用类似的思路可得：PR-Curve 的 AUC 表示任选一个正例 <code>$(\vec x_1, y_1 = 1)$</code>，而后任选一个满足 <code>$\mathcal C(\vec x_2) &gt; \mathcal C(\vec x_1)$</code> 的样本 <code>$(\vec x_2, y_2)$</code>，该样本为正样本的概率 <code>$P\bigl(y_2 = 1 \mid y_1 = 1 \wedge \mathcal C(\vec x_2) &gt; \mathcal C(\vec x_1)\bigr)$</code>。</p><h3 id="ROC-与-PR-Curve-的比较"><a href="#ROC-与-PR-Curve-的比较" class="headerlink" title="ROC 与 PR-Curve 的比较"></a>ROC 与 PR-Curve 的比较</h3><p><img data-src="/uploads/images/MachineLearning/roc-imbalanced.webp" alt="ROC in skewed datasets"></p><p>由于 ROC 的横纵坐标分别表示 FPR 和 TPR，二者的分母完全隔开，从而使得 AUC of ROC 不受正负样本比例的影响（如上图所示）。这看起来是个好事，因为它在倾斜的数据集上依然保持了稳定的物理意义（类似准确率）。但是，另一方面，这说明在负例数量远大于正例数量的极度倾斜的数据集上，AUC of ROC 可能失真。在这种情况下，PR-Curve 能够更好地反映出模型的性能。</p><h2 id="点击率预估模型中的-AUC-与-gAUC（grouped-AUC）"><a href="#点击率预估模型中的-AUC-与-gAUC（grouped-AUC）" class="headerlink" title="点击率预估模型中的 AUC 与 gAUC（grouped AUC）"></a>点击率预估模型中的 AUC 与 gAUC（grouped AUC）</h2><p>在个性化推荐、广告中，用作 rank 的模型，通常是点击率预估模型。此类模型将问题抽象为一个二分类问题，用模型预测用户是否会点击一个物品（推荐的内容或者广告）。由于该场景的目标是对物品进行排序，所以天然适合使用 AUC 作为评价指标。</p><p>但这有一个问题，我们通过例子来说明。</p><p>假设样本集中有 A 和 B 两个用户，分别都有 10 个物品。在这分别的 10 个物品当中，又分别有 5 个正例和 5 个负例。我们将这些正例和负例记为 A+/B+/A-/B-。假设将点击率预估模型的输出从高到低排序，结果是 A+/A-/B+/B-。此时，将两个用户的正负例混合起来看，AUC 不会很高。因为模型将部分负例（A-）排在了部分正例（B+）之前。但是，对于 A 和 B 分别来说，他们能观察到的正例均排在负例之前。也就是说，此时 AUC 不高，但实际效果很好。</p><p>这个问题可以这样解释：在模型预测分数越集中的区域，用户之间的细微差异导致的正负样本差异的影响就越大。因此，AUC 在这些区域可能会失真。此时，引入分组 AUC（grouped AUC, gAUC）可以缓解这一问题。</p><p><code>$$\text{gAUC} := \frac{\sum_{i = 1}^{n}(\omega_{i}\cdot\text{AUC}_{i})}{\sum_{i = 1}^{n}\omega_{i}}.$$</code></p><p>这里，<code>$\text{AUC}_{i}$</code> 表示第 <code>$i$</code> 个分组内的 AUC；<code>$\omega_{i}$</code> 则表示该组权重。对于点击率预估的场景，每个用户对应一个分组，该用户的权重可设为该用户在样本集当中可见的曝光数量。即有</p><p><code>$$\text{gAUC} := \frac{\sum_{i = 1}^{n}(\#\text{impression}_{i}\cdot\text{AUC}_{i})}{\sum_{i = 1}^{n}\#\text{impression}_{i}}.$$</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Classification" scheme="https://liam.page/tags/Classification/"/>
    
      <category term="Binary" scheme="https://liam.page/tags/Binary/"/>
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>Alias Method: 在常数时间复杂度内非均匀地随机抽取元素</title>
    <link href="https://liam.page/2019/12/02/non-uniform-random-choice-in-constant-time-complexity/"/>
    <id>https://liam.page/2019/12/02/non-uniform-random-choice-in-constant-time-complexity/</id>
    <published>2019-12-02T04:54:56.000Z</published>
    <updated>2020-02-04T07:57:06.014Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章要讨论的问题很简单：给定一个集合，要你在常数时间复杂度内，从中以给定的概率分布随机抽取其中的元素。</p><a id="more"></a><h2 id="问题的抽象"><a href="#问题的抽象" class="headerlink" title="问题的抽象"></a>问题的抽象</h2><p>这里我们以 C++ 语言描述，我们需要实现这样一个可调用的类模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values_;</span><br><span class="line">  <span class="comment">// other internal assets</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob);</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，构造函数完成初始化工作，函数调用运算符完成随机抽取元素的工作。</p><h2 id="Trival-版本"><a href="#Trival-版本" class="headerlink" title="Trival 版本"></a>Trival 版本</h2><p>最平凡的想法可以是：</p><ol><li>根据概率分布计算累积分布，将 $[0, 1]$ 分成若干段；</li><li>然后通过一个 $[0, 1]$ 之间的均匀随机生成器，随机生成一个 $[0, 1]$ 之间的浮点数；</li><li>最后通过<strong>判断</strong>随机数落在哪一个分段中，输出相应的元素。</li></ol><p>这里的 (1) 和 (2) 都可以在常数时间内完成，(3) 最快可以用二分或者二叉搜索树的方法在对数时间内完成。这里实现一版利用二分查找的方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;         values_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;    cumulative_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::random_device   rd_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mt19937         gen_&#123;rd_()&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; dis_&#123;<span class="number">0.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob) :</span><br><span class="line">      values_(val), cumulative_(generate_cumulative(prob)) &#123;</span><br><span class="line">    assert(val.size() == prob.size());</span><br><span class="line">    assert(<span class="built_in">std</span>::<span class="built_in">fabs</span>(<span class="number">1.0</span> - cumulative_.back()) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon());  <span class="comment">// *</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> rand = dis_(gen_);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> idx  = bsearch_last_not_greater_than(cumulative_.begin(), cumulative_.end(), rand);</span><br><span class="line">    assert(idx &lt; values_.size());</span><br><span class="line">    <span class="keyword">return</span> values_[idx];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; generate_cumulative(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; prob) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; cumulative;</span><br><span class="line">    cumulative.reserve(prob.size() + <span class="number">1</span>);</span><br><span class="line">    cumulative.emplace_back(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::transform(prob.begin(), prob.end(), <span class="built_in">std</span>::back_inserter(cumulative),</span><br><span class="line">        [&amp;](<span class="keyword">const</span> <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> p + cumulative.back(); &#125; );</span><br><span class="line">    <span class="keyword">return</span> cumulative;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">iter_t</span>,</span><br><span class="line">            <span class="keyword">typename</span> <span class="keyword">value_t</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;<span class="keyword">iter_t</span>&gt;::value_type,</span><br><span class="line">            <span class="keyword">typename</span> <span class="keyword">binpred_t</span> = <span class="built_in">std</span>::less&lt;<span class="keyword">value_t</span>&gt;&gt;</span><br><span class="line">  <span class="keyword">size_t</span> bsearch_last_not_greater_than(<span class="keyword">const</span> <span class="keyword">iter_t</span> begin,</span><br><span class="line">                                       <span class="keyword">const</span> <span class="keyword">iter_t</span> end,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="keyword">value_t</span> target,</span><br><span class="line">                                          <span class="keyword">binpred_t</span> binpred = <span class="keyword">binpred_t</span>()) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">iter_t</span> first = begin, last = end;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      <span class="keyword">iter_t</span> mid = first + <span class="built_in">std</span>::distance(first, last) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">not</span>(binpred(target, *mid)) <span class="keyword">and</span></span><br><span class="line">            (<span class="built_in">std</span>::next(mid) == last <span class="keyword">or</span> binpred(target, *(<span class="built_in">std</span>::next(mid))))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::distance(begin, mid);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binpred(target, *mid)) &#123;</span><br><span class="line">        last = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first = <span class="built_in">std</span>::next(mid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probs&#123;<span class="number">0.05</span>, <span class="number">0.25</span>, <span class="number">0.35</span>, <span class="number">0.35</span>&#125;;</span><br><span class="line"></span><br><span class="line">  discrete_random_variable&lt;<span class="keyword">int</span>&gt; drv&#123;values, probs&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">400000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = drv();</span><br><span class="line">    assert(<span class="built_in">std</span>::find(values.begin(), values.end(), x) != values.end());</span><br><span class="line">    ++counter[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> pair : counter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">"["</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">": \t"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != pair.second / <span class="number">2500</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Walker-Vose-Alias-Method"><a href="#Walker-Vose-Alias-Method" class="headerlink" title="Walker-Vose Alias Method"></a>Walker-Vose Alias Method</h2><p>平凡的解法，效率最高也只能做到对数时间复杂度。不过，既然目标很明确，希望能在「常数时间」内完成任务；那我们就思考一下，有什么类似的场景，可以在常数时间内解决的。显而易见，在标准库设施 <code>std::uniform_int_distribution</code> 的帮助下，对于均匀随机采样，我们可以在常数时间内完成任务。因此，若能在常数时间内，完成均匀和到非均匀的映射，我们就可以借助它来完成任务。</p><p>回过头来看「效率最高也只能做到对数时间复杂度」这句话。在目前用到的信息的条件下，这句话是正确的。也就是，在第 (3) 步在没有其他辅助的情况下，对数时间复杂度已经是最优解。因此，若想要继续优化，就必须「找其他辅助」。</p><p>我们注意用 <code>*</code> 标注出来的断言。在平凡的解法中，概率分布加和为 1 这一性质，我们只是用来验证概率分布合法，而没有用到它来辅助计算。为了用到这一性质，我们需要注意到以下一些事实：</p><ul><li>虽然非均匀分布的平凡解法最好能做到对数时间复杂度，但对于非均匀的伯努利实验（随机变量可能取值只有 2 种），我们仍能在<strong>常数时间</strong>内解决问题。</li><li>若随机变量的取值可能有 $k$ 个，那必然有部分取值的概率小于 $\frac{1}{k}$，同时有另一些不小于 $\frac{1}{k}$。</li><li>我们可以通过<strong>拆借</strong>的方法，把概率大于 $\frac{1}{k}$ 的部分借给概率小于 $\frac{1}{k}$ 的部分，使得所有取值上的概率都恰好等于 $\frac{1}{k}$；从而使非均匀采样问题变成均匀采样问题。</li></ul><p>经过上网查询，这个算法已经被发明过了，它叫做 <a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">Walker-Vose Alias Method</a>。下面给出它的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discrete_random_variable</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; alias_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::random_device   rd_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mt19937         gen_&#123;rd_()&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; real_dis_&#123;<span class="number">0.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">size_t</span>&gt;  int_dis_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  discrete_random_variable(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; vals, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; probs) :</span><br><span class="line">      values_(vals), alias_(generate_alias_table(probs)), int_dis_(<span class="number">0</span>, probs.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    assert(vals.size() == probs.size());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> sum = <span class="built_in">std</span>::accumulate(probs.begin(), probs.end(), <span class="number">0.0</span>);</span><br><span class="line">    assert(<span class="built_in">std</span>::<span class="built_in">fabs</span>(<span class="number">1.0</span> - sum) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> idx  = int_dis_(gen_);</span><br><span class="line">    <span class="keyword">if</span> (real_dis_(gen_) &gt;= alias_[idx].first <span class="keyword">and</span></span><br><span class="line">          alias_[idx].second != <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max()) &#123;</span><br><span class="line">      <span class="keyword">return</span> values_[alias_[idx].second];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> values_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; generate_alias_table(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; probs) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> sz = probs.size();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">size_t</span>&gt;&gt; alias(sz, &#123;<span class="number">0.0</span>, <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max()&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">size_t</span>&gt;  small, large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != sz; ++i) &#123;</span><br><span class="line">      alias[i].first = sz * probs[i];</span><br><span class="line">      <span class="keyword">if</span> (alias[i].first &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        small.push(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span>(small.empty()) <span class="keyword">and</span> <span class="keyword">not</span>(large.empty())) &#123;</span><br><span class="line">      <span class="keyword">auto</span> s = small.front(), l = large.front();</span><br><span class="line">      small.pop(), large.pop();</span><br><span class="line">      alias[s].second = l;</span><br><span class="line">      alias[l].first -= (<span class="number">1.0</span> - alias[s].first);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (alias[l].first &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        small.push(l);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large.push(l);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> alias;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probs&#123;<span class="number">0.05</span>, <span class="number">0.25</span>, <span class="number">0.35</span>, <span class="number">0.35</span>&#125;;</span><br><span class="line"></span><br><span class="line">  discrete_random_variable&lt;<span class="keyword">int</span>&gt; drv&#123;values, probs&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">400000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = drv();</span><br><span class="line">    assert(<span class="built_in">std</span>::find(values.begin(), values.end(), x) != values.end());</span><br><span class="line">    ++counter[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> pair : counter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">"["</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">": \t"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != pair.second / <span class="number">2500</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章要讨论的问题很简单：给定一个集合，要你在常数时间复杂度内，从中以给定的概率分布随机抽取其中的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Random" scheme="https://liam.page/tags/Random/"/>
    
      <category term="Choice" scheme="https://liam.page/tags/Choice/"/>
    
  </entry>
  
  <entry>
    <title>期权和风险对冲</title>
    <link href="https://liam.page/2019/11/24/option-and-hedge/"/>
    <id>https://liam.page/2019/11/24/option-and-hedge/</id>
    <published>2019-11-24T07:49:36.000Z</published>
    <updated>2020-02-04T07:57:05.992Z</updated>
    
    <content type="html"><![CDATA[<p>最近在<a href="https://www.youtube.com/channel/UC5RtC9dKUJ9noJ4C6N4XnmQ" target="_blank" rel="noopener">跟我一起来谈钱</a>这个频道里学了不少知识，特别感谢薇姐姐在繁忙工作之余还给我们科普金融经济基本常识，让我受益良多。</p><p>这里把学习到的关于期权和对冲的知识记录下来。</p><a id="more"></a><h2 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h2><p>期权（option）是一种金融衍生品。其英文 option 的意思就是「选择」，于是，顾名思义期权是一种选择交易与否的权利。期权分为两大类，买权（call option；又称：看涨期权、认购期权）和卖权（put option；又称：看空期权、认沽期权）。对期权的买卖分别称之为 long 和 short。例如，买入卖权称之为 long a put option；卖出买权称之为 short a call option。</p><p>期权的核心要素有以下一些：</p><ul><li>标的物（underlying）：即选择是否交易的东西。通常是有价证券（security；例如：股票）。</li><li>行权价（exercise price / strike price）：即交易标的物时的价格。</li><li>履约日期（maturity date / expiration date）：即指定的交易日期（European Option）或指定的期权失效日期（American Option）。对于欧式期权来说，交易只能选择发生在履约日；对于美式期权来说，交易可以发生在不晚于履约日的任何一天。</li></ul><p>以买权为例。假设你看好一只股票（现价 100），认为该股票在未来一段时间内会涨。那么你可以：</p><ul><li>买入该股票，待涨后（比如涨到 110）卖出（净赚 10）；</li><li>买入该股票的期权（花费 3，行权价 110），当股票在履约日之前（针对美式期权）超过 break-even price（113）之后买入该股票（净赚 <code>price - 103</code>）。</li></ul><p>那么现在问题来了。既然你看好一只股票，那为什么不直接买，还要多此一举先买期权再购入呢？最常见的就是为了对冲（hedge，接下来要讲）而不是为了拥有（exposure）。另外，对于资金有限制、有合规及避税方面的需求等情形，购买期权而非直接购买也是有利的。</p><p>对于资金有限制的情况，比如你手头只有 300 美元，立即买入只能买入 3 股；但能够买入 100 股的期权（行权价 110）。当股价涨到 120 时，立即买入的收益率是 20%；而买入期权的做法，只需再借入 10,000 美元（可能要为此承担借款利息）买入 100 股并立即卖出，收益率可达 230%。这时，long call 成为杠杆投机的工具。——当然，若股价没有超过 break-even price，则会产生亏损。</p><h2 id="对冲"><a href="#对冲" class="headerlink" title="对冲"></a>对冲</h2><p>对冲（hedge）的本质是损失一定利益或者付出一定成本，来控制风险的手段。英文 hedge 的原意是「栅栏」，相当于 barrier，引申义是保护或防御的手段。</p><p>举个栗子来说。</p><p>如果一只股票现价 100，你看好这只股票将来的表现，因此买入股票。为了获取股票将来可能的涨幅带来的收益，你就必须承担股价下跌的风险。这种风险最大可以是 100% 的本金，即在极端情况下，股价跌至接近零。显然，你是不想承担这种风险的。于是你可以选择买入卖权。比如，你花费 3 元，买入在未来某一时间段内以 100 元卖出该股票的卖权（long a put option）。此时，你持有该股票的成本变成了 103 元。</p><p>如果股价未来上涨，超过 103 元，卖出股票你就能获利。但如果股价下跌，比如跌到了 90 元甚至 50 元、20 元，你可以选择行权，以 100 元的价格将股票卖出。在后一种情况下，你只亏损了 3 元，有效地控制了风险。</p><p>卖权的定价一般和以下一些因素有关：</p><ul><li>标的物当前价格和行权价。行权价相对标的物价格越高，卖权价格越高。</li><li>履约日期限。履约日距今时间越长，卖权价格越高。</li><li>标的物价格的波动幅度。波动幅度越大，卖权价格越高。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在&lt;a href=&quot;https://www.youtube.com/channel/UC5RtC9dKUJ9noJ4C6N4XnmQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跟我一起来谈钱&lt;/a&gt;这个频道里学了不少知识，特别感谢薇姐姐在繁忙工作之余还给我们科普金融经济基本常识，让我受益良多。&lt;/p&gt;
&lt;p&gt;这里把学习到的关于期权和对冲的知识记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Hedge" scheme="https://liam.page/tags/Hedge/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上跨版本更新 TeX Live</title>
    <link href="https://liam.page/2019/11/11/cross-release-update-TeX-Live-on-macOS/"/>
    <id>https://liam.page/2019/11/11/cross-release-update-TeX-Live-on-macOS/</id>
    <published>2019-11-11T11:24:38.000Z</published>
    <updated>2020-02-04T07:57:05.990Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写 LaTeX 了。嗯……原因是因为我很久没用 LaTeX 了。</p><p>因为很久没用 LaTeX，所以 Mac 上的 macTeX 也很久没更新。这不，目前版本还是 macTeX 2018，而 macTeX 2019 都出来很久了。另一方面，因为系统版本有升级，导致与 macTeX 2018 有些不兼容。于是，升级到 2019 版本变得势在必行。</p><a id="more"></a><h2 id="升级-macTeX-还是升级-TeX-Live"><a href="#升级-macTeX-还是升级-TeX-Live" class="headerlink" title="升级 macTeX 还是升级 TeX Live"></a>升级 macTeX 还是升级 TeX Live</h2><p>本质上 macTeX 是对 TeX Live 的打包封装。里面当中实际执行的，还是 TeX Live。因此，升级 TeX Live 而不升级 macTeX 可以避免下载巨大的 <code>macTeX.pkg</code>。</p><h2 id="update-tlmgr-latest"><a href="#update-tlmgr-latest" class="headerlink" title="update-tlmgr-latest"></a><code>update-tlmgr-latest</code></h2><p>一般升级，用到的命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tlmgr update --self --all --reinstall-forcibly-removed</span><br></pre></td></tr></table></figure><p>但是，跨版本升级时，它会报错。不过，它会有提示，让你下载 <code>update-tlmgr-latest</code> 来将 <code>tlmgr</code> 更新到最新版本，从而可以跨版本更新。于是我们有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh</span><br><span class="line">bash update-tlmgr-latest.sh</span><br><span class="line">tlmgr update --self --all --reinstall-forcibly-removed</span><br></pre></td></tr></table></figure><h2 id="更新语言配置"><a href="#更新语言配置" class="headerlink" title="更新语言配置"></a>更新语言配置</h2><p>上述 <code>tlmgr update</code> 在执行到最后，构建 <code>fmt</code> 文件时会报错。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I can&apos;t find file `dehypht-x-2018-03-31.tex`!</span><br></pre></td></tr></table></figure><p>检查发现，构建 <code>fmt</code> 文件时，会读取 <code>/usr/local/texlive/2018/texmf-var/tex/generic/config/language.def</code> 文件，它提到了：<code>\addlanguage{german-x-latest}{dehypht-x-2018-03-30.tex}{}{2}{2}</code>。</p><p>上网检查发现，可以用 <code>tlmgr generate language</code> 更新语言定义文件。遂执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tlmgr generate language</span><br><span class="line">fmtutil -sys --all</span><br></pre></td></tr></table></figure><p>至此，万事 OK~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没写 LaTeX 了。嗯……原因是因为我很久没用 LaTeX 了。&lt;/p&gt;
&lt;p&gt;因为很久没用 LaTeX，所以 Mac 上的 macTeX 也很久没更新。这不，目前版本还是 macTeX 2018，而 macTeX 2019 都出来很久了。另一方面，因为系统版本有升级，导致与 macTeX 2018 有些不兼容。于是，升级到 2019 版本变得势在必行。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="TeX Live" scheme="https://liam.page/tags/TeX-Live/"/>
    
  </entry>
  
  <entry>
    <title>踩坑：value to great for base</title>
    <link href="https://liam.page/2019/11/11/value-too-great-for-base-in-shell/"/>
    <id>https://liam.page/2019/11/11/value-too-great-for-base-in-shell/</id>
    <published>2019-11-11T01:57:34.000Z</published>
    <updated>2020-02-04T07:57:05.989Z</updated>
    
    <content type="html"><![CDATA[<p>前几天启动的定时任务，有几个实例挂掉了。报错提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value too great for base (error token is "08")</span><br></pre></td></tr></table></figure><a id="more"></a><p>出错的相关代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $(($&#123;hour_s&#125; + $&#123;hour_diff&#125;)) -gt 23 ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> foo bar</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这里 <code>${hour_s}</code> 是当前标定时间的小时数。形如 <code>00</code>, <code>01</code>, <code>02</code>, ..., <code>08</code>, <code>09</code>, ..., <code>23</code>。<code>${hour_diff}</code> 是需要向后处理的小时数。这段代码的意图，是判断二者相加是否大于 <code>23</code>。若大于 <code>23</code>，则需要在日期上 <code>+1</code>，否则只需要操作小时即可限定数据范围。</p><p>关键就在于 <code>08</code> 和 <code>09</code> 的意思。这里 <code>08</code> 是上午八点的意思，为了保持格式一致，在 <code>8</code> 的前面填充了 <code>0</code>。但 Shell 把它当成是八进制（base is 8）。这样一来，怪不得 Shell 认为 <code>08</code> 是不合法的八进制数。为解决这个问题，我们需要告知 Shell 这是个前面填充了 0 的十进制数。于是我们需要改成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $((10#$&#123;hour_s&#125; + $&#123;hour_diff&#125;)) -gt 23 ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> foo bar</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天启动的定时任务，有几个实例挂掉了。报错提示：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;value too great for base (error token is &quot;08&quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="Integer" scheme="https://liam.page/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>梨花又开放</title>
    <link href="https://liam.page/2019/11/07/another-blossom-of-pear-flower/"/>
    <id>https://liam.page/2019/11/07/another-blossom-of-pear-flower/</id>
    <published>2019-11-07T06:16:53.000Z</published>
    <updated>2020-02-04T07:57:05.990Z</updated>
    
    <content type="html"><![CDATA[<p>今天说点不一样的，聊聊「梨花又开放」这首歌的歌词。</p><a id="more"></a><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>「梨花又开放」是周峰根据谭咏麟的经典粤语歌曲「迟来的春天」重新填词而作，谭咏麟的「迟来的春天」则根据因幡晃的「夏にありがとう」重新填词。</p><p>另有香港已故巨星张国荣英文版本「Good Morning Sorrow」，收录于1978年发行的专辑「Daydreaming」中。</p><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><blockquote><p>梨花又开放<br>原唱：周峰<br>作词：丁小齐<br>作曲：因幡晃（日）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=175391&auto=1&height=32"></iframe><p>忘不了故乡 年年梨花放<br>染白了山岗 我的小村庄<br>妈妈坐在梨树下 纺车嗡嗡响<br>我爬上梨树枝 闻那梨花香<br>摇摇啊洁白的树枝 花雨漫天飞扬<br>落在妈妈头上 飘在纺车上<br>给我幸福的故乡 永生难忘<br>永生永世我不能忘</p><p>重返了故乡 梨花又开放<br>找到了我的梦 我一腔衷肠<br>小村一切都依然 树下空荡荡<br>开满梨花的树下 纺车不再响<br>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p><p>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p><p>摇摇啊洁白的树枝 花雨漫天飞扬<br>两行滚滚泪水 流在树下<br>给我血肉的故乡 永生难忘<br>永生永世我不能忘</p></blockquote><h2 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h2><p>梨花又开放的歌词，可以说是纸短情长的典范。</p><p>歌词共分上下两阙，上阙是回忆歌者的童年，下阙则是重返故乡的所见所想。上下两阙共同出现的意象是：梨花（梨树）、村庄（故乡、山岗）；只在上阙中出现的意象是：妈妈、纺车。共同出现的意象是触景生情的基础，只在回忆中出现的意象则是触景生情的情感寄托所在。</p><p>两阙中 A 段的故乡、梨树一切都依然，甚至梨花开得都一样茂盛。这勾起了「我」的回忆，从而构成了触景深情的基础。但是梨树下空荡荡、纺车不再响。为什么纺车不再响了？因为妈妈已经走了。由纺车作为牵线：纺车不再了，也就是妈妈不在了。哀而不伤的情绪，由此喷薄而出。</p><p>B 段里，「我」摇动梨树枝，花雨同样的漫天飞扬。但不同的是，回忆中梨花飘在妈妈头上和纺车上，现在却只有我一个人孤零零呆立树下。回忆中的妈妈操作纺车会是什么神情？想必是问题又宠溺的表情，看着调皮的「我」吧！然而，妈妈走了，不再了。如今还能摇动梨树的我，只能任凭梨花飘落，想要见妈妈，却只能在想象当中。妈妈已经不在，能够寄托思绪的，就只能是依然还在的故乡、村庄。此时，故乡村庄已经变成了妈妈的化身——妈妈给我幸福、给我血肉，那我当然永生难忘！永生难忘的，不是明面上的故乡，而是妈妈。</p><p>全歌词只说难忘，不说想念；只说故乡，不说已经离去的母亲。但是，对母亲的想念思念却跃然纸上，让人动容。此等的触景生情，只在归有光的「项脊轩志」中见到过：庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。后人评价项脊轩志，讲「此意境人人所有，此笔妙人人所无」，又讲「盖古今来事无巨细，唯此可歌可涕之精神，长留天壤」。想来把这些用在评价这首歌词中，也是恰如其分的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天说点不一样的，聊聊「梨花又开放」这首歌的歌词。&lt;/p&gt;
    
    </summary>
    
      <category term="Music" scheme="https://liam.page/categories/Music/"/>
    
    
      <category term="Lyrics" scheme="https://liam.page/tags/Lyrics/"/>
    
  </entry>
  
  <entry>
    <title>利用穷人乐理论撰写精准营销类文章</title>
    <link href="https://liam.page/2019/11/06/writing-marketing-articles-based-on-the-theory-of-poor-but-happy/"/>
    <id>https://liam.page/2019/11/06/writing-marketing-articles-based-on-the-theory-of-poor-but-happy/</id>
    <published>2019-11-06T09:47:12.000Z</published>
    <updated>2020-02-04T07:57:05.992Z</updated>
    
    <content type="html"><![CDATA[<p>中国互联网历史中，要论最成功的精准营销类文章写手，咪蒙必在其中无疑。咪蒙本名马凌，说起来还是我山东大学的校友。2015 年时，马凌注册了名为咪蒙的微信公众号。该微信公众号以发表精准定位现代女性的营销类文章而出名，一度有超过千万的关注量和阅读量。</p><p>时至今日，<a href="https://www.zhihu.com/question/318167756" target="_blank" rel="noopener">咪蒙已经「毕业」</a>，但互联网江湖上一直流传着咪蒙的传说。大家乐此不疲地讨论和思考，咪蒙为什么会成功？咪蒙的文章为什么会有这种奇怪的魔力，让无数具有良好教育的现代女性为之着魔。</p><p>此篇讲一讲我的一些思考。</p><a id="more"></a><h2 id="人穷但快乐"><a href="#人穷但快乐" class="headerlink" title="人穷但快乐"></a>人穷但快乐</h2><p>世界上有一种奇怪的现象。</p><p>有一些人，生活水平和物质基础低于平均水平，我们称之为穷人。在追逐更高生活水平和物质基础的过程中，穷人往往会凭着自己的想象，设想出心目中富人的样子。这些穷人为了平衡自己落后的物质基础，会认为富人的精神世界是单调的、空洞的、乏味的。也就是说：这部分穷人承认自己穷，但是认为自己活得开心快乐；认为富人虽然富，但是富人精神空虚。</p><p>我们说，在这个过程中，这些穷人不仅会表现出物质上的穷，还会表现了精神世界层面的穷。我们把这种现象称之为「人穷但快乐」，简称「穷人乐」。</p><h2 id="分裂的人性"><a href="#分裂的人性" class="headerlink" title="分裂的人性"></a>分裂的人性</h2><p>读完上面这一段，如果你很穷，你大概会很生气；如果你比较富裕，你大概心里长处一口气。但别着急，读完这一段，可能不论你穷困还是富裕，你可能都会胸有愤愤。</p><p>上面这一段说的穷人，主要说的是经济实力上问题。但实际上，这种穷，可以扩展到很多方面。穷人的穷，实际上说的是经济实力上的「不如人意」。于是，我们可以把这种现象，扩展到任何层面上的不如人意上。</p><p>比如：</p><ul><li>谢顶者可能会心想：你虽然头发浓密，但是你肯定学习不用功。</li><li>学习差者可能会心想：你虽然学习好，但你将来也就是个打工者。</li><li>打工者可能会心想：你虽然当老板，但是你老婆肯定会背叛你。</li><li>夫妻不和睦的人可能会心想：你虽然家庭幸福，但你肯定每天精疲力尽。（<code>←_←</code>）</li></ul><p>看！多么分裂的人性！</p><p>顺着这个思路往下走，你猜给下面这些文章点赞的人，是处于什么感情状态：</p><ul><li>我一个人活得好好的，为什么要结婚？</li><li>女人好好打扮就是为了取悦男人？瞎扯！</li><li>对不起，你的病，爱情治不了</li></ul><h2 id="精准营销"><a href="#精准营销" class="headerlink" title="精准营销"></a>精准营销</h2><p>好了，所以你大概已经想明白了。如果你要瞄准一个在某方面过得不如意的人，撰写一篇精准营销文章应该怎么写呢？</p><p>首先，你得有一个抓住这些人眼球的标题。怎样才能抓住这些人的眼球呢？答案很简单：如果这个人在某方面过得不如意，就批判贬低这方面过得如意的人，或者力挺这方面过得不如意的人。</p><p>比如对于在感情中受过伤，再也不相信爱情的女性：</p><ul><li>我一个人活得好好的，为什么要结婚？——力挺在感情中不如意的人</li><li>女人好好打扮就是为了取悦男人？瞎扯！——批判感情中如意的人（有男人可取悦）</li><li>有一种礼物，叫男朋友送的礼物——男朋友送的礼物肯定都是狗屁不通的呗，这是在贬低有男朋友的女的也收不到什么像样的礼物</li></ul><p>还有其他一些例子：</p><ul><li>我，一个矮子的史诗——你看，都「史诗」了，这不就是力挺矮子么</li><li>如何把大牌穿成地摊货？——你看，那些有钱人居然能把大牌穿成地摊货，这不就是批判有钱人么</li></ul><p>而后，你得编造一个故事，核心还是：批判如意者，发现不如意者其他方面的闪光点。总而言之，一大碗毒鸡汤就这么狠狠灌下去。</p><p>最后，如果你要营销带货，最好在文章的末尾来一个反转。比如，对于「我，一个矮子的史诗」这篇文章，如果要带货卖增高鞋垫，我会在大篇幅批判那些高个子人之后来这么一句：</p><blockquote><p>后来，我才知道，XX 看起来高，实际上只不过是在鞋子中悄悄放了一块 XX 品牌 3cm 的增高鞋垫罢了。</p></blockquote><p>你看，情绪上还是对高个子人的嘲讽鄙视，但不经意间，一个反转，点出了需要营销的东西。</p><p><code>o(*￣︶￣*)o</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国互联网历史中，要论最成功的精准营销类文章写手，咪蒙必在其中无疑。咪蒙本名马凌，说起来还是我山东大学的校友。2015 年时，马凌注册了名为咪蒙的微信公众号。该微信公众号以发表精准定位现代女性的营销类文章而出名，一度有超过千万的关注量和阅读量。&lt;/p&gt;
&lt;p&gt;时至今日，&lt;a href=&quot;https://www.zhihu.com/question/318167756&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咪蒙已经「毕业」&lt;/a&gt;，但互联网江湖上一直流传着咪蒙的传说。大家乐此不疲地讨论和思考，咪蒙为什么会成功？咪蒙的文章为什么会有这种奇怪的魔力，让无数具有良好教育的现代女性为之着魔。&lt;/p&gt;
&lt;p&gt;此篇讲一讲我的一些思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Writing" scheme="https://liam.page/tags/Writing/"/>
    
      <category term="Marketing Articles" scheme="https://liam.page/tags/Marketing-Articles/"/>
    
      <category term="Poor but Happy" scheme="https://liam.page/tags/Poor-but-Happy/"/>
    
  </entry>
  
  <entry>
    <title>一种基于 Beta 分布的推荐方法示例</title>
    <link href="https://liam.page/2019/11/06/a-Beta-Distribution-based-recommendation-realia-method/"/>
    <id>https://liam.page/2019/11/06/a-Beta-Distribution-based-recommendation-realia-method/</id>
    <published>2019-11-06T08:05:19.000Z</published>
    <updated>2020-02-04T07:57:05.991Z</updated>
    
    <content type="html"><![CDATA[<p>因为一直在做推荐系统和点击率预估排序相关工作，所以一直想用一种粗糙但直观的方式来做一个推荐系统的示例，如果能有一定的工程实现价值就更好。最近突然有了这样一个基于 Beta 分布的想法，所以记录下来。当然，这个想法可能不是我的专利，可能已经有人想到过了。</p><a id="more"></a><h2 id="Beta-分布的直观理解"><a href="#Beta-分布的直观理解" class="headerlink" title="Beta 分布的直观理解"></a>Beta 分布的直观理解</h2><p><a href="https://zh.wikipedia.org/wiki/%CE%92%E5%88%86%E5%B8%83" target="_blank" rel="noopener">Beta 分布</a> 是一组定义在 $(0, 1)$ 之间的连续概率分布，有两个参数 <code>$\alpha, \beta &gt; 0$</code>。随机变量 <code>$X$</code> 服从参数为 <code>$\alpha$</code>, <code>$\beta$</code> 的 Beta 分布通常记作 <code>$X \sim \text{Be}(\alpha, \beta)$</code>。</p><p>在理解 Beta 分布之前，我们先回顾一下二项分布。</p><p>二项分布说的是 $n$ 个 i.i.d 的二项伯努利试验中成功次数的离散概率分布。根据二项分布，我们可以用似然的办法，通过有限次的实验，推断伯努利实验成功的概率。比如有一枚多少有些不均匀的硬币，我们多次抛硬币，将硬币呈现正面记为成功，要求成功的概率，就可以用似然的办法结合二项分布来求解。现在的问题是，在只有很少次数的实验时，利用二项分布估计的概率可能会很不准。一个极端的例子，如果我们只做了一次实验，硬币落下后呈现正面。那么根据二项分布估计出来的概率将会是 <code>$P = 1$</code>。这显然是不对的。</p><p>这时候，Beta 分布就该出场了。Beta 分布可以看做是二项分布概率的概率分布。怎么理解呢？我们来继续看抛硬币的例子。</p><p>我们知道，虽然每一枚硬币都多少有些不均匀，但是总体上，硬币落下呈现正面的概率是 <code>$0.5$</code> 左右。因此，不论如何，一枚多少有些不均匀的硬币，抛硬币得到正面的概率应该和 <code>$0.5$</code> 相去不远。具体到多次 i.i.d 的二项伯努利试验上，就是当 <code>$N$</code> 足够大时，<code>$2N$</code> 次二项伯努利试验中，得到正面的次数应该接近 <code>$N$</code>。我们假设 <code>$N = 1000$</code>，这意味着，在 <code>$2000$</code> 次二项伯努利试验中，大约会获得 <code>$A = 1000$</code> 次正面和 <code>$B = 1000$</code> 次反面。于是，我们初始化 Beta 分布 <code>$\text{Be}(A, B) = \text{Be}(1000, 1000)$</code>。接着，我们用这枚多少有些不均匀的硬币开始若干次二项伯努利试验，比如说 50 次。在 50 次试验中，我们得到了 <code>$a = 19$</code> 次正面，<code>$b = 31$</code> 次反面。于是我们更新 Beta 分布的参数 <code>$\alpha \gets A + a$</code> 以及 <code>$\beta \gets B + b$</code>，于是得到新的 Beta 分布 <code>$\text{Be}(1019, 1031)$</code>。该 Beta 分布的均值是</p><p><code>$$ \frac{\alpha}{\alpha + \beta} = \frac{1019}{1019 + 1031} = \frac{1019}{2050} \approx 0.497. $$</code></p><p>于是我们说，这枚多少有些不均匀的硬币在二项伯努利试验中得到正面的概率是 <code>$P = 0.497$</code>；与此同时，就这 50 次试验，根据二项分布推算出来的概率是 <code>$P = 0.38$</code>。显然，根据 Beta 分布均值推算出来的概率相对根据二项分布推算出来的概率要显著接近 <code>$P = 0.5$</code> 的先验值。</p><p>总结一下，Beta 分布可以看做是二项分布概率的概率分布。当我们对二项分布概率已经有一个相对比较靠谱的先验知识的时候，我们可以据此设定 Beta 的参数，然后在后续 i.i.d 的二项伯努利试验过程中，依赖 Beta 分布共轭先验的特性，对 Beta 分布的参数进行更新，最后以 Beta 分布均值作为二项分布概率的估计。</p><h2 id="基于-Beta-分布的用户画像"><a href="#基于-Beta-分布的用户画像" class="headerlink" title="基于 Beta 分布的用户画像"></a>基于 Beta 分布的用户画像</h2><p>推荐系统的一侧是用户，描述用户的方法是用户画像。我们可以用 Beta 用户来做基于 Tag 的用户画像。在这里，对于某个用户来说：</p><ul><li>Beta 分布中的 <code>$\alpha_i$</code> 是用户在编号为 <code>$i$</code> 的 Tag 下的点击次数的反映；</li><li>相应地，<code>$\beta_i$</code> 则是用户在编号为 <code>$i$</code> 的 Tag 下展示未点击次数的反应。</li></ul><p>于是，用户画像的策略可以简单叙述如下：</p><ul><li>对于某个用户，使用先验知识（比如，全体用户的平均兴趣），对 <code>$\{(\alpha_i, \beta_i)\}$</code> 序列进行初始化。</li><li>根据用户的行为（展示和点击），更新该序列<ul><li>用户点击了具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> Tag 的物品进行了点击，则对 <code>$\alpha_i$</code>, <code>$\alpha_j$</code>, <code>$\alpha_k$</code> 分别自增 1；</li><li>用户展示未点击具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> Tag 的物品进行了点击，则对 <code>$\beta_i$</code>, <code>$\beta_j$</code>, <code>$\beta_k$</code> 分别自增 1。</li></ul></li></ul><h2 id="基于-Beta-分布的点击率预估"><a href="#基于-Beta-分布的点击率预估" class="headerlink" title="基于 Beta 分布的点击率预估"></a>基于 Beta 分布的点击率预估</h2><p>对于具有画像 <code>$\{(\alpha_i, \beta_i)\}$</code> 的用户进行推荐时，我们要对待推荐的物品进行点击率预估。假设某物品同时具有编号为 <code>$i$</code>, <code>$j$</code>, <code>$k$</code> 的 Tag，假设各个 Tag 对点击行为的贡献都相同——这是一个很强的假设，但对于示例方案来说无关紧要，则用户对该物品的点击概率可以预估为：</p><p><code>$$P_{\text{click}} = 1 - \frac{\beta_i}{\alpha_i + \beta_i} \times \frac{\beta_j}{\alpha_j + \beta_j} \times \frac{\beta_k}{\alpha_k + \beta_k}.$$</code></p><p>而后，我们可以根据各个物品的预估点击率对物品进行排序，然后推荐给用户。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个近乎「儿戏」的推荐方案，但在实践上并非完全无用。说它儿戏，是因为它只考虑了单个用户的历史行为，而没有考虑其他所有对推荐有帮助的因素——比如其他用户的行为（可做协同过滤），比如推荐结果多样性。但是，在没有这些其他因素的情况下，这种方案可以起到过渡方案的作用。对，我说的就是在新用户、新物品冷启动的时候，这种方案简单易实现，值得一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直在做推荐系统和点击率预估排序相关工作，所以一直想用一种粗糙但直观的方式来做一个推荐系统的示例，如果能有一定的工程实现价值就更好。最近突然有了这样一个基于 Beta 分布的想法，所以记录下来。当然，这个想法可能不是我的专利，可能已经有人想到过了。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Beta Distribution" scheme="https://liam.page/tags/Beta-Distribution/"/>
    
      <category term="Recommendation System" scheme="https://liam.page/tags/Recommendation-System/"/>
    
      <category term="Realia" scheme="https://liam.page/tags/Realia/"/>
    
  </entry>
  
</feed>
