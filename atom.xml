<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2020-04-29T05:10:35.425Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 minted 构建 example 环境</title>
    <link href="https://liam.page/2020/04/29/combine-minted-and-its-layout-as-example/"/>
    <id>https://liam.page/2020/04/29/combine-minted-and-its-layout-as-example/</id>
    <published>2020-04-29T03:41:32.000Z</published>
    <updated>2020-04-29T05:10:35.425Z</updated>
    
    <content type="html"><![CDATA[<p>在 LaTeX 中排版代码的环境有很多，在普通用户里最出名的当属 listings 和 minted。前者在纯粹的 LaTeX 环境中就能使用，后者则需要开启 <code>--shell-escape</code> 标记调用外部 Pygmentize 来美化代码。对于 listings 来说，配置一个美观的输出还是比较麻烦的，于是越来越多的人开始使用 minted。</p><p>此次要解决的问题，是构造一个 <code>example</code> 环境。其中包含 LaTeX 代码，然后输出分两部分。左侧是代码本身，用 minted 排版输出；右侧是代码的输出效果。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为我们要「一码两用」，所以就必然牵扯到将代码暂存，然后由两部分输出代码分别调用的问题。在 TeX 里暂存代码，要不然暂存到一个文件当中，要不然暂存到一个宏当中。考虑到我们之后要使用 minted 将代码原样输出，若是将代码暂存到一个宏当中，之后的展开控制会变得非常复杂。所以方案基本就确定了：我们要将代码暂存到外部文件当中。</p><p>代码既存，我们接下来就要考虑输出。对于 minted 来说，它有 <code>\inputminted</code> 可读入外部文件进行排版。对于输出代码效果来说，因为暂存的代码本就是 LaTeX 的代码，所以只需 <code>\input</code> 进来即可。我们需要做的工作，就只有将两部分输出安排的明明白白。</p><h2 id="暂存代码"><a href="#暂存代码" class="headerlink" title="暂存代码"></a>暂存代码</h2><p>minted 宏包会将需要排版的代码内容交给 Pygmentize 来美化，而 Pygmentize 美化的输入当然也是文件。所以，这样推论下去，minted 宏包必然会将需要排版的代码内容临时输出到文件。因此，我们要将代码暂存到外部文件，就可以借助 minted 宏包已经实现的内部宏来实现。我们现在需要找到这段代码，然后做可能必要的修改。</p><p>首先打开 <code>minted.sty</code>，找到定义 <code>minted</code> 环境的地方。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">ifthenelse</span><span class="string">&#123;\boolean&#123;minted@draft&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;minted&#125;</span><span class="string">[2]</span><span class="string">[]</span></span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@configlang&#123;#2&#125;<span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">setkeys</span><span class="string">&#123;minted@opt@cmd&#125;</span><span class="string">&#123;#1&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@fvset</span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@langlinenoson</span><br><span class="line">      <span class="tag">\<span class="name">begin</span><span class="string">&#123;Verbatim&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">end</span><span class="string">&#123;Verbatim&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@langlinenosoff&#125;&#125;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;minted&#125;</span><span class="string">[2]</span><span class="string">[]</span></span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVB</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut</span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVE</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@configlang&#123;#2&#125;<span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">setkeys</span><span class="string">&#123;minted@opt@cmd&#125;</span><span class="string">&#123;#1&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@fvset</span><br><span class="line">      <span class="tag">\<span class="name">begin</span><span class="string">&#123;VerbatimOut&#125;</span><span class="string">[codes=&#123;\catcode`\^^I=12&#125;,firstline,lastline]</span><span class="string">&#123;\minted@jobname.pyg&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">end</span><span class="string">&#123;VerbatimOut&#125;</span></span><span class="comment">%</span></span><br><span class="line">        <span class="tag">\<span class="name">minted</span></span>@langlinenoson</span><br><span class="line">        <span class="tag">\<span class="name">minted</span></span>@pygmentize&#123;<span class="tag">\<span class="name">minted</span></span>@lang&#125;<span class="comment">%</span></span><br><span class="line">        <span class="tag">\<span class="name">minted</span></span>@langlinenosoff&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们显然应该看非 draft 的版本。注意到环境定义前半截的最后有：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;VerbatimOut&#125;</span><span class="string">[codes=&#123;\catcode`\^^I=12&#125;,firstline,lastline]</span><span class="string">&#123;\minted@jobname.pyg&#125;</span></span>&#125;</span><br></pre></td></tr></table></figure><p><code>\minted@jobname.pyg</code> 这显然是一个外部文件，而且，看文件扩展名这应该是一个已经经由 Pygmentize 美化好的结果了。因此，将代码暂存外部的实现一定在这之前。从命名来看，下列两行代码就变得非常可疑：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVB</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut</span><br><span class="line"><span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVE</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br></pre></td></tr></table></figure><p>我们来看看这两个命令是怎么定义的。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\minted@FVB@VerbatimOut&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \setcounter&#123;minted@FancyVerbLineTemp&#125;</span><span class="string">&#123;\value&#123;FancyVerbLine&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">@</span></span>bsphack</span><br><span class="line">  <span class="tag">\<span class="name">begingroup</span></span></span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@UseKeyValues</span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@DefineWhiteSpace</span><br><span class="line">    <span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@Space&#123;<span class="tag">\<span class="name">space</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@DefineTabOut</span><br><span class="line">    <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@ProcessLine<span class="tag">\<span class="name">minted</span></span>@write@detok</span><br><span class="line">    <span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile #1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">    <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@FontScanPrep<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">    <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">@</span></span>noligs<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@Scan&#125;</span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\minted@FVE@VerbatimOut&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \immediate\closeout\FV@OutFile\endgroup\@esphack</span></span></span><br><span class="line"><span class="tag"><span class="string">  \setcounter&#123;FancyVerbLine&#125;</span><span class="string">&#123;\value&#123;minted@FancyVerbLineTemp&#125;</span></span>&#125;&#125;<span class="comment">%</span></span><br></pre></td></tr></table></figure><p>我们先不出去处理那一堆 <code>\FV@</code> 开头的宏，把目光集中在以下几行：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile #1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line"><span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">closeout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile</span><br></pre></td></tr></table></figure><p>这是 TeX 中与文件交互的经典命令。其中</p><ul><li><code>\immediate</code> 表示立即执行。这是因为大多数 TeX 和文件相关的命令都会延后执行，等到命令所在位置被真正排版完成后再执行。</li><li><code>\openout</code> 和 <code>\closeout</code> 相当于 C 语言当中的 <code>fopen</code> 和 <code>fclose</code>。</li><li><code>\FV@OutFile</code> 则相当于 C 语言当中的 <code>FILE</code> 指针，对应一个实际的外部文件。</li><li>这里的 <code>#1</code> 就是外部文件的文件名，它是 <code>\minted@FVB@VerbatimOut</code> 的参数。</li></ul><p>由此可见，我们确实已经找到了 minted 宏包暂存代码的位置。接下来，我们逐行来看这两个宏都干了啥。</p><ul><li><p><code>\setcounter{minted@FancyVerbLineTemp}{\value{FancyVerbLine}}</code>/<code>\setcounter{FancyVerbLine}{\value{minted@FancyVerbLineTemp}}</code> 这是在设置行号相关的计数器。我们用不着。</p></li><li><p><code>\@bsphack</code>/<code>\@esphack</code> 这是 LaTeX 定义的内部宏，作用是使他们界定的范围内的代码，当被用在一串文字中间时，不出现额外的空格。这个我们照旧保留。</p></li><li><p><code>\FV@DefineWhiteSpace</code> 定义在 fancyvrb 宏包（为 minted 宏包所调用）内的宏，它将空格和制表符定义为活动字符，并将他们分别定义为 <code>\FV@Space</code> 和 <code>\FV@Tab</code>。其定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begingroup</span></span></span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span>`<span class="tag">\<span class="name"> </span>=</span><span class="tag">\<span class="name">active</span></span></span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span>`<span class="tag">\<span class="name">^</span></span>^I=<span class="tag">\<span class="name">active</span></span></span><br><span class="line"><span class="tag">\<span class="name">gdef</span></span><span class="tag">\<span class="name">FV</span></span>@DefineWhiteSpace&#123;<span class="tag">\<span class="name">def</span></span> &#123;<span class="tag">\<span class="name">FV</span></span>@Space&#125;<span class="tag">\<span class="name">def</span></span>^^I&#123;<span class="tag">\<span class="name">FV</span></span>@Tab&#125;&#125;<span class="comment">%</span></span><br><span class="line"><span class="tag">\<span class="name">endgroup</span></span></span><br></pre></td></tr></table></figure><p>我们照旧保留。</p></li><li><p><code>\def\FV@Space{\space}</code> 和上面的 <code>\FV@DefineWhiteSpace</code> 的定义相对应可知其意。我们照旧保留。</p></li><li><p><code>\FV@DefineTabOut</code> 也是定义在 fancyvrb 宏包内的宏，它将制表符定义为连续多个空格。其定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@DefineTabOut&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@Tab&#123;&#125;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">@</span></span>tempcnta=<span class="tag">\<span class="name">FancyVerbTabSize</span></span><span class="tag">\<span class="name">relax</span></span></span><br><span class="line">  <span class="tag">\<span class="name">loop</span></span><span class="tag">\<span class="name">ifnum</span></span><span class="tag">\<span class="name">@</span></span>tempcnta&gt;<span class="tag">\<span class="name">z</span></span>@</span><br><span class="line">    <span class="tag">\<span class="name">edef</span></span><span class="tag">\<span class="name">FV</span></span>@Tab&#123;<span class="tag">\<span class="name">FV</span></span>@Tab<span class="tag">\<span class="name">space</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">advance</span></span><span class="tag">\<span class="name">@</span></span>tempcnta<span class="tag">\<span class="name">m</span></span>@ne</span><br><span class="line">  <span class="tag">\<span class="name">repeat</span></span>&#125;</span><br></pre></td></tr></table></figure><p>我们照旧保留。</p></li><li><p><code>\let\FV@ProcessLine\minted@write@detok</code> 看名字是用来处理一行代码的宏，后者的定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\minted@write@detok&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \immediate\write\FV@OutFile&#123;\detokenize&#123;#1&#125;</span></span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>显然，它就是将一行内容去记号化之后写入文件。这正是我们要的东西，照旧保留。</p></li><li><p><code>\FV@Scan</code> 也是定义在 fancyvrb 宏包内的宏，其定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@Scan&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">FV</span></span>@CatCodes</span><br><span class="line">  <span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line">  <span class="tag">\<span class="name">FV</span></span>@DefineCheckEnd</span><br><span class="line">  <span class="tag">\<span class="name">FV</span></span>@BeginScanning&#125;</span><br></pre></td></tr></table></figure><p>可知其意是开始逐行扫描内容。照旧保留。</p></li></ul><p>既然已知 <code>\minted@FVB@VerbatimOut</code> 和 <code>\minted@FVE@VerbatimOut</code> 都做了什么，自然就知道应如何重定义他们了。我们有：</p><figure class="highlight tex"><figcaption><span>foo.tex</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;minted&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">makeatletter</span></span></span><br><span class="line"><span class="tag">\<span class="name">edef</span></span><span class="tag">\<span class="name">example</span></span>@name&#123;<span class="tag">\<span class="name">jobname</span></span>-example.aux&#125;</span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;example&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \renewcommand&#123;\minted@FVB@VerbatimOut&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \@bsphack</span></span></span><br><span class="line"><span class="tag"><span class="string">    \begingroup</span></span></span><br><span class="line"><span class="tag"><span class="string">      \FV@DefineWhiteSpace</span></span></span><br><span class="line"><span class="tag"><span class="string">      \def\FV@Space&#123;\space&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@DefineTabOut</span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@ProcessLine<span class="tag">\<span class="name">minted</span></span>@write@detok</span><br><span class="line">      <span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile ##1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@FontScanPrep<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">@</span></span>noligs<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@Scan&#125;</span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut&#123;<span class="tag">\<span class="name">example</span></span>@name&#125;<span class="comment">%</span></span><br><span class="line">&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\minted@FVE@VerbatimOut&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \immediate\closeout\FV@OutFile\endgroup\@esphack&#125;</span></span><span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">makeatother</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">Hello <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>.</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">[</span></span> E = mc^2. <span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>至此，我们的 <code>example</code> 环境会将环境内容原样输出到 <code>\jobname-example.aux</code> 这个文件里面了。若文件保存为 <code>foo.tex</code>，则我们在 <code>foo-example.aux</code> 当中能看到质能方程的内容。</p><figure class="highlight tex"><figcaption><span>foo-example.aux</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">[</span></span> E = mc^2. <span class="tag">\<span class="name">]</span></span></span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>解决了代码暂存的问题，接下来就是排版了。这里我们实现一个最简单的排版效果：左代码，右效果，上下加两条横线以示区分。读者有兴趣可以扩充其效果。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;minted&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">makeatletter</span></span></span><br><span class="line"><span class="tag">\<span class="name">edef</span></span><span class="tag">\<span class="name">example</span></span>@name&#123;<span class="tag">\<span class="name">jobname</span></span>-example.aux&#125;</span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;example&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \renewcommand&#123;\minted@FVB@VerbatimOut&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \@bsphack</span></span></span><br><span class="line"><span class="tag"><span class="string">    \begingroup</span></span></span><br><span class="line"><span class="tag"><span class="string">      \FV@DefineWhiteSpace</span></span></span><br><span class="line"><span class="tag"><span class="string">      \def\FV@Space&#123;\space&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@DefineTabOut</span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@ProcessLine<span class="tag">\<span class="name">minted</span></span>@write@detok</span><br><span class="line">      <span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile ##1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@FontScanPrep<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">@</span></span>noligs<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@Scan&#125;</span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut&#123;<span class="tag">\<span class="name">example</span></span>@name&#125;<span class="comment">%</span></span><br><span class="line">&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\minted@FVE@VerbatimOut&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \immediate\closeout\FV@OutFile\endgroup\@esphack&#125;</span></span><span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br><span class="line">  <span class="tag">\<span class="name">setlength</span><span class="string">&#123;\parindent&#125;</span><span class="string">&#123;0pt&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">hrulefill</span></span><span class="tag">\<span class="name">par</span></span><span class="tag">\<span class="name">vspace</span><span class="string">&#123;1em&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[c]</span><span class="string">&#123;0.45\linewidth&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">inputminted</span><span class="string">&#123;latex&#125;</span><span class="string">&#123;\example@name&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span><span class="tag">\<span class="name">hfill</span></span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[c]</span><span class="string">&#123;0.45\linewidth&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">input</span><span class="string">&#123;\example@name&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span><span class="tag">\<span class="name">par</span></span><span class="tag">\<span class="name">vspace</span><span class="string">&#123;1em&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">hrulefill</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">makeatother</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">Hello <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>.</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">[</span></span> E = mc^2. <span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/example-demo.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 LaTeX 中排版代码的环境有很多，在普通用户里最出名的当属 listings 和 minted。前者在纯粹的 LaTeX 环境中就能使用，后者则需要开启 &lt;code&gt;--shell-escape&lt;/code&gt; 标记调用外部 Pygmentize 来美化代码。对于 listings 来说，配置一个美观的输出还是比较麻烦的，于是越来越多的人开始使用 minted。&lt;/p&gt;
&lt;p&gt;此次要解决的问题，是构造一个 &lt;code&gt;example&lt;/code&gt; 环境。其中包含 LaTeX 代码，然后输出分两部分。左侧是代码本身，用 minted 排版输出；右侧是代码的输出效果。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="minted" scheme="https://liam.page/tags/minted/"/>
    
      <category term="example" scheme="https://liam.page/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>嘿嘿嘿使 TeX 爆炸</title>
    <link href="https://liam.page/2020/04/28/hhh-explodes-TeX/"/>
    <id>https://liam.page/2020/04/28/hhh-explodes-TeX/</id>
    <published>2020-04-28T11:48:31.000Z</published>
    <updated>2020-04-29T04:35:48.456Z</updated>
    
    <content type="html"><![CDATA[<p>TeX 里有 <code>\leavevmode</code> 用来从竖直模式中切出去，那么有没有 <code>\leavehmode</code> 呢？一定会有好奇宝宝好奇这个奇怪的问题的。</p><p>答案是：<del>嘿嘿嘿使 TeX 爆炸</del>不存在。</p><a id="more"></a><p>TeX 总是从竖直模式开始，然后一旦遇到水平命令时，就会离开竖直模式，然后开始构建段落。除非结束这个段落，TeX 是不会离开水平模式的。</p><p>怎么结束这个段落？当然是你熟知的 <code>\par</code> 命令。实际上，任何会导致 TeX 离开水平模式的命令，都会调用 <code>\par</code> 这个命令——这里的 <code>\par</code> 是最原始到那个 <code>\par</code> 原语。如果你把 <code>\par</code> 定义成了一个不包含原语版的 <code>\par</code> 的时候，所有导致 TeX 离开水平模式的命令都会导致死循环。比如下面代码：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">par</span><span class="string">&#123;&#125;</span></span></span><br><span class="line">x<span class="tag">\<span class="name">vskip</span></span> 1pt</span><br></pre></td></tr></table></figure><p>（你看，让 TeX 死循环就这么简单）</p><p>所以，不存在 <code>\leavehmode</code> 这种东西。能让 TeX 离开水平模式的只有 <code>\par</code>。</p><p>不过，存在一种情况下，TeX 可以部分地离开模式——<code>\vadjust</code> 命令。在水平模式中遇到 <code>\vadjust</code> 时，TeX 会把它的参数中的所有竖直元素打包在一起暂存，然后等到断行成段之后，TeX 再把 <code>\vadjust</code> 里的内容插入到 <code>\vadjust</code> 存在的那一行之后。比如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;zhlipsum&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">嘿嘿嘿<span class="tag">\<span class="name">vadjust</span><span class="string">&#123;\vskip 3ex&#125;</span></span><span class="tag">\<span class="name">zhlipsum</span><span class="string">[3]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/vadjust.jpg" alt></p><hr><p>那么为什么「嘿嘿嘿使 TeX 爆炸」呢？因为当你把 <code>\par</code> 定义成「嘿嘿嘿」的时候，TeX 就会因为陷入死循环而不断地把「嘿嘿嘿」塞入内存，然后就炸掉了。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">par</span><span class="string">&#123;嘿嘿嘿&#125;</span></span></span><br><span class="line">x<span class="tag">\<span class="name">vskip</span></span> 1pt</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(./ltxtest.aux) ABD: EverySelectfont initializing macros</span><br><span class="line">! TeX capacity exceeded, sorry [main memory size=5000000].</span><br><span class="line">&lt;to be read again&gt;</span><br><span class="line">                   \vskip</span><br><span class="line">l.4 x\vskip</span><br><span class="line">            1pt</span><br><span class="line">No pages of output.</span><br><span class="line">Transcript written on ltxtest.log.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TeX 里有 &lt;code&gt;\leavevmode&lt;/code&gt; 用来从竖直模式中切出去，那么有没有 &lt;code&gt;\leavehmode&lt;/code&gt; 呢？一定会有好奇宝宝好奇这个奇怪的问题的。&lt;/p&gt;
&lt;p&gt;答案是：&lt;del&gt;嘿嘿嘿使 TeX 爆炸&lt;/del&gt;不存在。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Mode" scheme="https://liam.page/tags/Mode/"/>
    
  </entry>
  
  <entry>
    <title>macOS 上 Bash 中的主机名</title>
    <link href="https://liam.page/2020/04/27/hostname-on-BASH-in-macOS/"/>
    <id>https://liam.page/2020/04/27/hostname-on-BASH-in-macOS/</id>
    <published>2020-04-27T09:27:29.000Z</published>
    <updated>2020-04-29T04:35:48.455Z</updated>
    
    <content type="html"><![CDATA[<p>今天被问到我的 macOS 中 Terminal.app 里的主机名为什么是一颗红心「❤️」。因为设置这个主机名的时间太过久远我也忘记了。于是顺手查了查，得到 <a href="https://superuser.com/a/346722" target="_blank" rel="noopener">superuser 上的回答</a>。于是这篇文章做一个翻译、记录和扩展。</p><a id="more"></a><p>如果你没有覆盖默认设置的话，Bash 里的环境变量 <code>HOSTNAME</code> 保存的是 BSD 主机名的第一个标签（第一个句点前的内容）。于是，若你主机名是 <code>foo.bar.baz</code>，那么 Bash 里的环境变量 <code>HOSTNAME</code> 的值就会被预设为 <code>foo</code>。</p><p>那么，BSD 主机名来自哪呢？macOS 会按如下顺序寻找：</p><ol><li><code>/etc/hostconfig</code> 当中</li><li><code>/Library/Preferences/SystemConfiguration/preferences.plist</code> 当中的 <code>System ▸ System ▸ HostName</code></li><li>通过 DNS 反查你的 IP 得到的主机名</li><li><code>/Library/Preferences/SystemConfiguration/preferences.plist</code> 当中的 <code>System ▸ Network ▸ HostNames ▸ LocalHostName</code></li><li>如果上述所有方案都没有取得主机名，那就简单地设置为 <code>localhost</code></li></ol><p>这里：</p><ul><li>上述 (1) 不建议修改。</li><li>上述 (2) 需要通过命令行工具 <code>sudo scutil --set HostName FooBar</code> 来设置。</li><li>上述 (3) 由不得普通用户设置。</li><li>上述 (4) 可在 System Preferences ▸ Sharing 当中设置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天被问到我的 macOS 中 Terminal.app 里的主机名为什么是一颗红心「❤️」。因为设置这个主机名的时间太过久远我也忘记了。于是顺手查了查，得到 &lt;a href=&quot;https://superuser.com/a/346722&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;superuser 上的回答&lt;/a&gt;。于是这篇文章做一个翻译、记录和扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Bash" scheme="https://liam.page/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>在 VSCode 的 LaTeXworkshop 插件中使用 LaTeXmk</title>
    <link href="https://liam.page/2020/04/24/using-LaTeXmk-with-LaTeXworkshop-with-VSCode/"/>
    <id>https://liam.page/2020/04/24/using-LaTeXmk-with-LaTeXworkshop-with-VSCode/</id>
    <published>2020-04-24T05:14:02.000Z</published>
    <updated>2020-04-25T14:07:51.377Z</updated>
    
    <content type="html"><![CDATA[<p>之前，东升介绍了<a href="http://ddswhu.me/posts/2018-04/vs-code-for-latex/" target="_blank" rel="noopener">如何将 VSCode 配置为 LaTeX 编辑器</a>，我介绍了<a href="/2018/04/24/Working-with-VSCode-on-macOS-configuration-LaTeX-workshop-and-Skim/">如何在 macOS 上配置 VSCode 与 Skim 的 LaTeX 正反跳转</a>。按东升的配置，为解决交叉引用，我们需要在 <code>recipes</code> 当中多次调用编译工具，一则稍显麻烦，二则对于源文件无变动的情况会进行不必要的编译。</p><p>LaTeXmk 是为了解决这些问题而设计的。阅读其文档之后，针对以下几条编译路径，我写好了 LaTeXworkshop 的配置，供后来人参考。</p><ul><li>XeLaTeX - BibTeX</li><li>pdfLaTeX - BibTeX</li><li>LuaLaTeX - BibTeX</li><li>LaTeX - DVIPDFMx - BibTeX</li><li>upLaTeX - DVIPDFMx - BibTeX</li></ul><a id="more"></a><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"latex-workshop.latex.tools"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"XeLaTeXmk"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-xelatex"</span>,</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-shell-escape"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"pdfLaTeXmk"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-pdflatex"</span>,</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-shell-escape"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"LuaLaTeXmk"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-lualatex"</span>,</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-shell-escape"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"LaTeXmk-DVIPDFMx"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-e"</span>,</span><br><span class="line">        <span class="string">"$dvipdf='dvipdfmx %O -o %D %S'"</span>,</span><br><span class="line">        <span class="string">"-latex"</span>,</span><br><span class="line">        <span class="string">"-pdfdvi"</span>,</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-shell-escape"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"upLaTeXmk-DVIPDFMx"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-e"</span>,</span><br><span class="line">        <span class="string">"$dvipdf='dvipdfmx %O -o %D %S'"</span>,</span><br><span class="line">        <span class="string">"-latex=uplatex"</span>,</span><br><span class="line">        <span class="string">"-pdfdvi"</span>,</span><br><span class="line">        <span class="string">"-synctex=1"</span>,</span><br><span class="line">        <span class="string">"-shell-escape"</span>,</span><br><span class="line">        <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">        <span class="string">"-file-line-error"</span>,</span><br><span class="line">        <span class="string">"%DOC%"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"latex-workshop.latex.recipes"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"XeLaTeXmk"</span>,</span><br><span class="line">      <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"XeLaTeXmk"</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"pdfLaTeXmk"</span>,</span><br><span class="line">      <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"pdfLaTeXmk"</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"LuaLaTeXmk"</span>,</span><br><span class="line">      <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"LuaLaTeXmk"</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"LaTeXmk-DVIPDFMx"</span>,</span><br><span class="line">      <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"LaTeXmk-DVIPDFMx"</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"upLaTeXmk-DVIPDFMx"</span>,</span><br><span class="line">      <span class="attr">"tools"</span>: [</span><br><span class="line">        <span class="string">"upLaTeXmk-DVIPDFMx"</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，针对 LaTeX 和 upLaTeX 的情形，为了使用 DVIPDFMx 覆盖 LaTeXmk 默认的 dvipdf，使用 <code>-e</code> 参数，将设定 <code>dvipdf</code> 命令的 Perl 代码作为参数传给 LaTeXmk。这样免去了修改 <code>.latexmkrc</code> 配置文件的麻烦。类似地，如果要使用 BibLaTeX 代替 BibTeX，则可以修改名为 <code>$bibtex</code> 的 Perl 变量。</p><p>此外，这里默认打开了 <code>-shell-escape</code> 标记。如果你不知道它意味着什么，那可以就这么保留，它会在将来给你省下一些麻烦。如果你知道它意味着什么，可以按需保留或删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前，东升介绍了&lt;a href=&quot;http://ddswhu.me/posts/2018-04/vs-code-for-latex/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何将 VSCode 配置为 LaTeX 编辑器&lt;/a&gt;，我介绍了&lt;a href=&quot;/2018/04/24/Working-with-VSCode-on-macOS-configuration-LaTeX-workshop-and-Skim/&quot;&gt;如何在 macOS 上配置 VSCode 与 Skim 的 LaTeX 正反跳转&lt;/a&gt;。按东升的配置，为解决交叉引用，我们需要在 &lt;code&gt;recipes&lt;/code&gt; 当中多次调用编译工具，一则稍显麻烦，二则对于源文件无变动的情况会进行不必要的编译。&lt;/p&gt;
&lt;p&gt;LaTeXmk 是为了解决这些问题而设计的。阅读其文档之后，针对以下几条编译路径，我写好了 LaTeXworkshop 的配置，供后来人参考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XeLaTeX - BibTeX&lt;/li&gt;
&lt;li&gt;pdfLaTeX - BibTeX&lt;/li&gt;
&lt;li&gt;LuaLaTeX - BibTeX&lt;/li&gt;
&lt;li&gt;LaTeX - DVIPDFMx - BibTeX&lt;/li&gt;
&lt;li&gt;upLaTeX - DVIPDFMx - BibTeX&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="LaTeXmk" scheme="https://liam.page/tags/LaTeXmk/"/>
    
      <category term="LaTeXworkshop" scheme="https://liam.page/tags/LaTeXworkshop/"/>
    
  </entry>
  
  <entry>
    <title>在 Finder 的右键菜单中添加「Open in VSCode」</title>
    <link href="https://liam.page/2020/04/22/Open-in-VSCode-on-macOS/"/>
    <id>https://liam.page/2020/04/22/Open-in-VSCode-on-macOS/</id>
    <published>2020-04-22T13:21:17.000Z</published>
    <updated>2020-04-23T13:24:31.163Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录如何利用 macOS 的「自动操作」，在 Finder 右键菜单中添加「Open in VSCode」功能。</p><a id="more"></a><p>操作步骤如下：</p><ul><li>打开 Automator.app（自动操作）</li><li>选择 Quick Action（快速操作）<br><img data-src="/uploads/images/computer-skills/quick-action.jpg" alt></li><li>配置工作流<ul><li>Workflow recieves current（工作流接受当前），选择 files or folders（文件或文件夹）</li><li>in（位于），选择 Finder（访达）<br><img data-src="/uploads/images/computer-skills/workflow-recieves.jpg" alt></li></ul></li><li>新增一个 Open Finder Items（打开访达项目）的操作<ul><li>open with（打开方式），选择 Visual Studio Code.app<br><img data-src="/uploads/images/computer-skills/open-finder-items.jpg" alt></li></ul></li><li>保存为 <code>Open in VSCode</code><br><img data-src="/uploads/images/computer-skills/save-open-in-vscode.jpg" alt></li></ul><p>此时，在 Finder 中选中任意目录，而后右键 -&gt; Quick Actions（快速操作）-&gt; <code>Open in VSCode</code> 即可用 VSCode 打开选中的目录。</p><p><img data-src="/uploads/images/computer-skills/open-in-vscode.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录如何利用 macOS 的「自动操作」，在 Finder 右键菜单中添加「Open in VSCode」功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="Automator" scheme="https://liam.page/tags/Automator/"/>
    
  </entry>
  
  <entry>
    <title>使用 std::unique_ptr 管理 FILE 指针</title>
    <link href="https://liam.page/2020/04/21/managing-FILE-pointer-by-std-unique-ptr/"/>
    <id>https://liam.page/2020/04/21/managing-FILE-pointer-by-std-unique-ptr/</id>
    <published>2020-04-21T06:44:54.000Z</published>
    <updated>2020-04-29T04:35:48.455Z</updated>
    
    <content type="html"><![CDATA[<p>尽管 C++ 提供了 <code>fstream</code> 文件流来读写文件，但对操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 的重载令很多 C++ 程序员不爽。因而这些程序员还会使用 C 风格的文件流 <code>FILE</code> 来读写文件。</p><p>不过，C++ 的好处也是显而易见的。<a href="/2017/04/09/Foundations-of-Cpp/">RAII 的出现让资源的管理</a>变得简单。文件流对于程序来说，也是一种资源。本文的目的是让 C 风格的文件流 <code>FILE</code> 可以更方便地享受 RAII 带来的便利。</p><a id="more"></a><h2 id="自己造轮子"><a href="#自己造轮子" class="headerlink" title="自己造轮子"></a>自己造轮子</h2><p><a href="/2017/04/09/Foundations-of-Cpp/">前作</a>为了解释 RAII，自己造了一个文件句柄类来实现文件流指针的 RAII 容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandle</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FILE* p;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FileHandle(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* r) : p&#123;<span class="literal">nullptr</span>&#125; &#123;</span><br><span class="line">    p = fopen(path, r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">      <span class="keyword">throw</span> file_error&#123;path, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  FileHandle(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, <span class="keyword">const</span> <span class="keyword">char</span>* r) : p&#123;<span class="literal">nullptr</span>&#125; &#123;</span><br><span class="line">    p = fopen(path.c_str(), r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">      <span class="keyword">throw</span> file_error&#123;path.c_str(), r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  FileHandle(FileHandle&amp;&amp; orig) <span class="keyword">noexcept</span> : p&#123;orig.p&#125; &#123;</span><br><span class="line">    orig.p = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FileHandle&amp; <span class="keyword">operator</span>=(FileHandle&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = rhs.p;</span><br><span class="line">    rhs.p = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~FileHandle() &#123;</span><br><span class="line">    fclose(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">FILE <span class="keyword">const</span>* <span class="title">p</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FileHandle(<span class="keyword">const</span> FileHandle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  FileHandle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> FileHandle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，我们在构造函数里通过调用 <code>fopen</code> 打开文件，而在析构函数里调用 <code>fclose</code> 关闭文件释放资源。同时，通过禁用拷贝构造及拷贝赋值，避免文件流指针被多个对象持有（这样能避免一些奇怪的错误）；然后实现了移动构造和移动赋值。</p><p>若要使用针对 <code>FILE*</code> 设计的 C 函数，只需要做类似 <code>fgetc(file_handle())</code> 这样的操作即可。</p><h2 id="用-std-unique-ptr-实现"><a href="#用-std-unique-ptr-实现" class="headerlink" title="用 std::unique_ptr 实现"></a>用 <code>std::unique_ptr</code> 实现</h2><p>熟悉 <code>std::unique_ptr</code> 的读者不难发现，这其实就是一个经典的适合独占类型的智能指针发挥作用的场景。不过，<code>std::unique_ptr</code> 的默认删除函数是销毁其占有的指针指向的对象，亦即执行 <code>delete p_</code>。但是，对于文件流来说，我们需要在智能指针完成使命之后关闭文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Deleter</span> = <span class="title">std</span>:</span>:default_delete&lt;T&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>;</span></span><br></pre></td></tr></table></figure><p>为此，我们需要使用自定义的删除函数。也就是说，我们要给模板参数 <code>Deleter</code> 传入一个合适的参数。这个参数应当是以下三者之一：</p><ul><li>接受 <code>std::unique_ptr&lt;T, Deleter&gt;::pointer</code> 作为参数的函数对象；</li><li>接受 <code>std::unique_ptr&lt;T, Deleter&gt;::pointer</code> 作为参数的函数对象的左值引用；</li><li>接受 <code>std::unique_ptr&lt;T, Deleter&gt;::pointer</code> 作为参数的函数。</li></ul><p>换言之，我们得给 <code>Deleter</code> 传这么个东西进去：<code>std::function&lt;void(typename std::unique_ptr&lt;T, Deleter&gt;::pointer)&gt;</code>。于是有代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_file</span><span class="params">(FILE* fp)</span> </span>&#123;</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FileHandler = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FILE, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(FILE*)&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ofstream(<span class="string">"demo.txt"</span>) &lt;&lt; <span class="string">'x'</span>;  <span class="comment">// ensure the file does exist</span></span><br><span class="line"></span><br><span class="line">  <span class="function">FileHandler <span class="title">fp</span><span class="params">(fopen(<span class="string">"demo.txt"</span>, <span class="string">"r"</span>), close_file)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != fp) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(fgetc(fp.get())) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>UPDATE: 2020-04-23</strong></p><p>这样的代码能用，但是有三处不大不小的问题。</p><ol><li><code>close_file</code> 这个函数既然是 RAII 的一部分，那么最好不要暴露给普通用户。因此要么将它包在一个 <code>__detail</code> 之类的名字空间里，要么用匿名函数。</li><li>如果 <code>close_file</code> 不暴露给普通用户，那么在构造 <code>FileHandler</code> 的时候，就应当避免传递 <code>close_file</code>。因此我们还需要一层封装。</li><li>每次使用时，需要 <code>fp.get()</code>。相比不封装时候的 <code>fp</code>，稍显麻烦了点。</li></ol><p>显然，我们需要对 <code>FileHandler</code> 做进一步封装——通过继承 <code>std::unique_ptr&lt;FILE, std::function&lt;void(FILE*)&gt;&gt;</code> 而非持有 <code>std::unique_ptr&lt;FILE, std::function&lt;void(FILE*)&gt;&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> __detail &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_file</span><span class="params">(FILE* fp)</span> </span>&#123;</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> file_wrapper = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FILE, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(FILE*)&gt;&gt;;</span><br><span class="line">&#125;  <span class="comment">// namespace __detail</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> :</span> <span class="keyword">public</span> __detail::file_wrapper &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FileHandler(<span class="keyword">const</span> <span class="keyword">char</span>* fname, <span class="keyword">const</span> <span class="keyword">char</span>* mode) :</span><br><span class="line">    __detail::file_wrapper(fopen(fname, mode), __detail::close_file) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FILE* <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  <span class="comment">// class FileHandler</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ofstream(<span class="string">"demo.txt"</span>) &lt;&lt; <span class="string">'x'</span>;  <span class="comment">// ensure the file does exist</span></span><br><span class="line"></span><br><span class="line">  <span class="function">FileHandler <span class="title">fp</span><span class="params">(<span class="string">"demo.txt"</span>, <span class="string">"r"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != fp) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(fgetc(fp())) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，通过实现 <code>FileHandler::operator()</code>，我们把 <code>FileHandler</code> 的对象变成了可调用的对象。于是，可以使用 <code>fgetc(fp())</code> 来使用。这样，使用起来就方便多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管 C++ 提供了 &lt;code&gt;fstream&lt;/code&gt; 文件流来读写文件，但对操作符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 的重载令很多 C++ 程序员不爽。因而这些程序员还会使用 C 风格的文件流 &lt;code&gt;FILE&lt;/code&gt; 来读写文件。&lt;/p&gt;
&lt;p&gt;不过，C++ 的好处也是显而易见的。&lt;a href=&quot;/2017/04/09/Foundations-of-Cpp/&quot;&gt;RAII 的出现让资源的管理&lt;/a&gt;变得简单。文件流对于程序来说，也是一种资源。本文的目的是让 C 风格的文件流 &lt;code&gt;FILE&lt;/code&gt; 可以更方便地享受 RAII 带来的便利。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C" scheme="https://liam.page/tags/C/"/>
    
      <category term="Cpp" scheme="https://liam.page/tags/Cpp/"/>
    
      <category term="unique_ptr" scheme="https://liam.page/tags/unique-ptr/"/>
    
      <category term="FILE" scheme="https://liam.page/tags/FILE/"/>
    
  </entry>
  
  <entry>
    <title>利用 markdown 宏包实现手稿的双线发布</title>
    <link href="https://liam.page/2020/04/18/dual-distribution-by-the-markdown-package/"/>
    <id>https://liam.page/2020/04/18/dual-distribution-by-the-markdown-package/</id>
    <published>2020-04-18T03:10:15.000Z</published>
    <updated>2020-04-18T03:45:46.041Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2020/03/30/writing-manuscript-in-Markdown-and-typesetting-with-LaTeX/">前作</a>介绍了「你喜爱的 Markdown 写作，现更以 LaTeX 呈现」。</p><p>至此，Markdown 手稿在 <code>markdown</code> 宏包的帮助下，能被 LaTeX 解析，而它自身也能被很多其他的引擎解析。例如，可以被解析成 HTML 页面，而后发布成为网页。（如 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>）那么，一个很自然的引申就来了：是否可以通过巧妙的设定，实现双线发布呢？</p><p>本文为解决这个问题提供一些思路。</p><a id="more"></a><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>从抽象的角度来说，事物 A 若要在环境 I 下存在，需遵循环境 I 带给事物 A 的限制（称之为限制 I）；同样，事物 A 若要在环境 II 下存在，也需遵循环境 II 带给事物 A 的限制（称之为限制 II）。若限制 I 和限制 II 没有冲突，则 A 可同时在两个环境下存在；反之，若冲突，则不能同时存在。</p><p>对于后者的情况，要么放弃共存，要么想办法消除冲突。</p><p>对于本文的任务来说，我们需要：</p><ol><li>理顺 Markdown 手稿在 LaTeX 下发布的限制条件；</li><li>理顺 Markdown 在 GitHub Pages 的 Jekyll 下发布的限制条件；</li><li>解决上述两部分限制的冲突。</li></ol><h3 id="LaTeX-带来的限制条件"><a href="#LaTeX-带来的限制条件" class="headerlink" title="LaTeX 带来的限制条件"></a>LaTeX 带来的限制条件</h3><p>要使 Markdown 手稿在 LaTeX 下发布，整理后可知有以下限制条件：</p><ol><li>需要 LaTeX，并且需要开启 <code>--shell-escape</code>。</li><li>允许出现 LaTeX 宏（当开启 <code>hybrid</code> 时）。</li><li>允许使用行内脚注标记（当开启 <code>inlineFootnotes</code> 时）。</li><li>插入图片时，图片路径若以 <code>/</code> 开始，则系统会从根目录开始搜索目标图片；不以 <code>/</code> 开始时，系统会从当前目录开始搜索目标图片。</li></ol><p>这里，(1) 是使用 LaTeX 时才会出现的限制，与其它 Markdown 解析过程不会冲突；(2) 和 (3) 可视作使用 LaTeX 解析 Markdown 时对 Markdown 语法的增强，如果冲突，可以选择禁用这些增强语法；(4) 是由 LaTeX 插图时的行为决定的，最可能与其它解析方式产生冲突。</p><h3 id="Jekyll-带来的限制条件"><a href="#Jekyll-带来的限制条件" class="headerlink" title="Jekyll 带来的限制条件"></a>Jekyll 带来的限制条件</h3><p>要使 Markdown 手稿在 Jekyll 下发布，整理后可知有以下限制条件：</p><ol><li>需要一个支持 Jekyll 的服务器，并按 Jekyll 的规则进行一些配置。</li><li>不允许使用行内脚注标记（取决于使用的 Markdown 解析器）。</li><li>插入图片时，图片路径若以 <code>/</code> 开始，则浏览器会从域名的根目录开始搜索目标图片；不以 <code>/</code> 开始时，系统会从当前 HTML 文档所在的目录开始搜索目标图片。</li><li>使用 Jekyll 时，需在 Markdown 文件的前部以 <code>---</code> 包裹，记录一些标记。</li></ol><p>这里，(1) 是使用 Jekyll 时才会出现的限制，与其它 Markdown 解析过程不会冲突；(2)/(3)/(4) 容易与其它解析方式产生冲突。</p><h2 id="冲突事项"><a href="#冲突事项" class="headerlink" title="冲突事项"></a>冲突事项</h2><ul><li>显然 LaTeX(2) 允许出现的 LaTeX 宏会与 Jekyll 冲突，因此禁用。即，在 Markdown 中我们不能时候用 LaTeX 宏。</li><li>LaTeX(3) 与 Jekyll(2) 冲突，因此禁用行内脚注标记（类似 <code>^[脚注内容]</code> 这样的写法），换用类似 LaTeX 中 <code>\footnotemark</code> 和 <code>\footnotetext</code> 的做法（<code>[^1]</code> 和 <code>[^1]: 脚注内容</code>）。</li><li>LaTeX(4) 与 Jekyll(3) 冲突。此项冲突的根源在于图片路径以 <code>/</code> 开始时，搜索图片的起始位置不同。因此，需要巧妙地放置 Markdown 文件和图片文件的位置，并在 LaTeX 中利用 <code>\graphicspath</code> 解决相对路径的冲突。</li><li>Jekyll(4) 带来的 <code>---</code> 标记，在 LaTeX 中会被解析成奇怪的东西。因此，必须想办法绕过这一点。Jekyll 中有 <code>include</code> 和 <code>include_relative</code> 标记，可以在一个 Markdown 文件中引用其他 Markdown 文件中的内容。于是，我们可在 <code>post.md</code> 中使用 <code>---</code> 标记，并引用 <code>post-internal.md</code> 的内容；而后用 LaTeX 解析 <code>post-internal.md</code> 的内容。</li></ul><p>解决这些问题，即可用 LaTeX 和 Jekyll 双线发布 Markdown 手稿的内容了。若要在其他地方发布 Markdown 手稿的内容，可用类似的方法分析冲突并解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2020/03/30/writing-manuscript-in-Markdown-and-typesetting-with-LaTeX/&quot;&gt;前作&lt;/a&gt;介绍了「你喜爱的 Markdown 写作，现更以 LaTeX 呈现」。&lt;/p&gt;
&lt;p&gt;至此，Markdown 手稿在 &lt;code&gt;markdown&lt;/code&gt; 宏包的帮助下，能被 LaTeX 解析，而它自身也能被很多其他的引擎解析。例如，可以被解析成 HTML 页面，而后发布成为网页。（如 &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub Pages&lt;/a&gt;）那么，一个很自然的引申就来了：是否可以通过巧妙的设定，实现双线发布呢？&lt;/p&gt;
&lt;p&gt;本文为解决这个问题提供一些思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="PDF" scheme="https://liam.page/tags/PDF/"/>
    
      <category term="Markdown" scheme="https://liam.page/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你在 MacTeX 上使用 CJK</title>
    <link href="https://liam.page/2020/04/17/using-CJK-on-macTeX-step-by-step/"/>
    <id>https://liam.page/2020/04/17/using-CJK-on-macTeX-step-by-step/</id>
    <published>2020-04-17T03:59:31.000Z</published>
    <updated>2020-04-20T16:02:13.511Z</updated>
    
    <content type="html"><![CDATA[<p>时至今日，劝说用户不使用 CJK 已磨破了无数张嘴皮。然而，因为各种各样的历史原因，仍然有很多用户因各种理由需要继续使用 CJK。当然，这些理由大多数是不充分的（在我看来），但仍有一些站在普通用户的角度是充分的。因此，如果你因为如下原因使用 CJK，我表示愿意提供一定的协助：</p><ul><li>需要投稿某些中文期刊，但这些期刊的模板使用了 CJK 作为中文支持方式的；</li><li>与他人协作时，群体意志决定使用 CJK 而你无法反抗的。</li></ul><p>对于 Windows 用户，出于上述原因需要使用 CJK 时，可在 TeX Live 中搭配王越、吴凌云等人提供的 <code>zhwinfonts.tex</code>，借助 <code>zhmetrics</code> 技术使用 CJK。但对于 macOS 用户，<code>zhwinfonts.tex</code> 则不好用。因为 <code>zhwinfonts.tex</code> 是为 Windows 上的中易字体编写的。</p><p>我曾经写过一篇文章<a href="/2015/04/14/using-chinese-templates-in-mactex/">在 MacTeX 中使用中文模板</a>详细阐述这一系列问题。但其中关于 CJK 的部分，仍有用户反馈无法使用。于是有这篇文章——不介绍详细原理，只说详细步骤。</p><a id="more"></a><h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>因为技术上的原因，macOS 自带的字体无法搭配 <code>zhmetrics</code> 技术。因此，你需要下载支持该技术的字体。</p><ol><li>下载下列字体（因涉及到版权，请自行搜索下载）<ul><li>方正书宋 GBK：FZSSK.TTF</li><li>方正楷体 GBK：FZKTK.TTF</li><li>方正黑体 GBK：FZHTK.TTF</li><li>方正仿宋 GBK：FZFSK.TTF</li><li>华文隶体：STLITI.ttf（安装 Office 之后自带）</li><li>华文琥珀：STHUPO.TTF（安装 Office 之后自带）</li></ul></li><li>安装字体（以 <code>FZSSK.TTF</code> 为例）<br> <img data-src="/uploads/images/LaTeX/installing_fzssk.jpg" alt></li><li>安装成功后，在 <code>Font Book.app</code> 当中应当可见相应字体（以 <code>FZSSK.TTF</code> 为例）安装在 <code>~/Library/Fonts/FZSSK.TTF</code><br> <img data-src="/uploads/images/LaTeX/installed_fzssk.jpg" alt></li></ol><h2 id="修改-TeX-Live-配置文件"><a href="#修改-TeX-Live-配置文件" class="headerlink" title="修改 TeX Live 配置文件"></a>修改 TeX Live 配置文件</h2><ol><li>打开 <code>Finder.app</code></li><li>按下快捷键 <code>Command + Shift + G</code>，输入 <code>/usr/local/texlive</code> 而后点击「Go」（如果目录不存在，说明你没有将 macTeX 安装在默认位置，请自行调整）<br> <img data-src="/uploads/images/LaTeX/modifying_texmf.cnf.jpg" alt></li><li>进入相应的年份目录（我这里是 <code>2020</code>），而后用 <code>TextEdit.app</code> 打开 <code>texmf.cnf</code></li><li>检查文件中是否有 <code>OSFONTDIR</code> 变量<ul><li>若无，则在文件最后新增一行，内容为：<code>OSFONTDIR = ~/Library/Fonts//:/Library/Fonts//:/System/Library/Fonts//</code></li><li>若有，则确保其中包含 <code>~/Library/Fonts</code> 这个目录<br><img data-src="/uploads/images/LaTeX/modified_texmf.cnf.jpg" alt></li></ul></li></ol><h2 id="安装-zhfzfonts-tex"><a href="#安装-zhfzfonts-tex" class="headerlink" title="安装 zhfzfonts.tex"></a>安装 <code>zhfzfonts.tex</code></h2><p>打开 <code>Terminal.app</code>，依次执行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/<span class="built_in">local</span>/texlive/texmf-local <span class="comment"># 确认目录存在（如果不存在，说明你没有将 macTeX 安装在默认位置，请自行调整）</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/texlive/texmf-local/tex/generic/zhmetrics/ <span class="comment"># 新建目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/texlive/texmf-local/tex/generic/zhmetrics/ <span class="comment"># 进入刚才新建的目录</span></span><br><span class="line">wget https://liam.page/attachment/attachment/LaTeX-useful-tools/zhfzfonts.tex <span class="comment"># 下载 `zhfzfonts.tex`</span></span><br><span class="line">texhash <span class="comment"># 刷新 ls-R 数据库，可能需要 `root` 权限</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/installing_zhfzfonts.jpg" alt></p><h2 id="试用-CJK"><a href="#试用-CJK" class="headerlink" title="试用 CJK"></a>试用 CJK</h2><p>至此，你可以如常使用 <code>CJK</code> 宏包支持中文，只需要在导言区额外新增一行即可：<code>\AtBeginDvi{\input{zhfzfonts}}</code>。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;CJK&#125;</span></span>  <span class="comment">% CJKutf8</span></span><br><span class="line"><span class="tag">\<span class="name">AtBeginDvi</span><span class="string">&#123;\input&#123;zhfzfonts&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;CJK*&#125;</span><span class="string">&#123;UTF8&#125;</span><span class="string">&#123;song&#125;</span></span></span><br><span class="line">中文。</span><br><span class="line"><span class="tag">\<span class="name">clearpage</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;CJK*&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>你可以使用 PDFLaTeX 编译，也可以使用 LaTeX - DVIPDFMx 编译。得到结果如下图所示。</p><p><img data-src="/uploads/images/LaTeX/CJK_macOS.jpg" alt></p><p>注意，<code>CJK</code> 支持 GBK，也支持 UTF-8。因此，你需要将文档编码保存为与 <code>CJK</code> 环境相同的编码格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时至今日，劝说用户不使用 CJK 已磨破了无数张嘴皮。然而，因为各种各样的历史原因，仍然有很多用户因各种理由需要继续使用 CJK。当然，这些理由大多数是不充分的（在我看来），但仍有一些站在普通用户的角度是充分的。因此，如果你因为如下原因使用 CJK，我表示愿意提供一定的协助：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要投稿某些中文期刊，但这些期刊的模板使用了 CJK 作为中文支持方式的；&lt;/li&gt;
&lt;li&gt;与他人协作时，群体意志决定使用 CJK 而你无法反抗的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Windows 用户，出于上述原因需要使用 CJK 时，可在 TeX Live 中搭配王越、吴凌云等人提供的 &lt;code&gt;zhwinfonts.tex&lt;/code&gt;，借助 &lt;code&gt;zhmetrics&lt;/code&gt; 技术使用 CJK。但对于 macOS 用户，&lt;code&gt;zhwinfonts.tex&lt;/code&gt; 则不好用。因为 &lt;code&gt;zhwinfonts.tex&lt;/code&gt; 是为 Windows 上的中易字体编写的。&lt;/p&gt;
&lt;p&gt;我曾经写过一篇文章&lt;a href=&quot;/2015/04/14/using-chinese-templates-in-mactex/&quot;&gt;在 MacTeX 中使用中文模板&lt;/a&gt;详细阐述这一系列问题。但其中关于 CJK 的部分，仍有用户反馈无法使用。于是有这篇文章——不介绍详细原理，只说详细步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="CJK" scheme="https://liam.page/tags/CJK/"/>
    
      <category term="step-by-step" scheme="https://liam.page/tags/step-by-step/"/>
    
      <category term="macTeX" scheme="https://liam.page/tags/macTeX/"/>
    
  </entry>
  
  <entry>
    <title>利用 Excel 当中的 MATCH 和 XLOOKUP 函数实现集合与字典（映射）访问</title>
    <link href="https://liam.page/2020/04/09/match-and-xlookup-in-excel/"/>
    <id>https://liam.page/2020/04/09/match-and-xlookup-in-excel/</id>
    <published>2020-04-09T07:39:09.000Z</published>
    <updated>2020-04-16T14:07:46.141Z</updated>
    
    <content type="html"><![CDATA[<p>集合与字典（映射）是程序设计当中常见的两种容器类型。在 C++ 的标准模板库中，它们的实现分别是 <code>std::set</code>/<code>std::multiset</code> 与 <code>std::map</code>/<code>std::multimap</code>。（分别还有利用哈希表实现的 <code>unordered</code> 版本）其中，字典（映射）的键（Keys）可视作组成一个相应类型的集合。</p><p>对于集合或字典的读取，经典操作有两个：判断目标元素是否在集合当中、根据目标键获取相应值。</p><p>这篇文章讲讲在 Excel 中如何实现这两个功能。</p><a id="more"></a><h2 id="MATCH-函数"><a href="#MATCH-函数" class="headerlink" title="MATCH 函数"></a><code>MATCH</code> 函数</h2><p>Excel 中的 <code>MATCH</code> 函数原型是 <code>MATCH(lookup_value, lookup_array, [match_type])</code>。函数可接受 3 个参数，其中前两个为必选参数，第三个为可选参数。第一个参数表示要被查找的值，第二个参数表示要在哪个范围查找，第三个参数表示如何匹配（<code>0</code> 表示相等，<code>-1</code> 表示小于，<code>1</code> 表示大于）。如果匹配成功，则函数返回目标值在范围内的索引，否则报错。</p><p>假设有下图所示的 <code>namebook</code> 表。</p><p><img data-src="/uploads/images/Excel/namebook.jpg" alt></p><p>现在我们要看看下列人物是否登记在册。</p><p><img data-src="/uploads/images/Excel/register-question.jpg" alt></p><p>对于 B2 单元格，我们可以用这样的函数 <code>=NOT(ISERROR(MATCH(A2,namebook!$A$2:$A$4,0)))</code>。这里核心是刚才介绍的 <code>MATCH</code> 函数。我们利用 <code>ISERROR</code> 函数判断 <code>MATCH</code> 函数是否报错——若报错说明查无此人，否则说明登记在册。最后，再用 <code>NOT</code> 函数反转上述真值。如此则有如下图所示的结果。</p><p><img data-src="/uploads/images/Excel/register-answer.jpg" alt></p><p>如此，我们就利用 <code>MATCH</code> 函数（搭配 <code>ISERROR</code> 和 <code>NOT</code> 两个函数）实现了判断目标元素是否在集合当中的功能。</p><h2 id="XLOOKUP-函数"><a href="#XLOOKUP-函数" class="headerlink" title="XLOOKUP 函数"></a><code>XLOOKUP</code> 函数</h2><p>Excel 中的 <code>XLOOKUP</code> 函数原型是 <code>XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])</code>。函数可接受 6 个参数，其中前 3 个为必选参数，后 3 个为可选参数。第一个参数表示要被查找的值，第二个参数表示要在哪个范围（数组）查找，第三个参数表示返回的值在哪个范围（数组），第四个参数表示若未找到返回什么。最后两个参数是高级功能，参见<a href="https://support.office.com/en-us/article/xlookup-function-b7fd680e-6d10-43e6-84f9-88eae8bf5929" target="_blank" rel="noopener">微软的文档</a>。如果匹配成功，假设目标值在待查数组中的索引为 <code>i</code>，则函数返回返回值数组下标 <code>i</code> 的单元格内容，否则报错或填入 <code>if_not_found</code> 内容。</p><p>还是看刚才的 <code>namebook</code> 表。</p><p><img data-src="/uploads/images/Excel/namebook.jpg" alt></p><p>现在我们要看看下列人物是否登记在册，若登记在册的话登记身高是多少。对于 B2 单元格，我们可以用这样的函数 <code>=XLOOKUP(A2,namebook!$A$2:$A$4,namebook!$B$2:$B$4,&quot;未登记在册&quot;)</code>。</p><p><img data-src="/uploads/images/Excel/height-solution.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合与字典（映射）是程序设计当中常见的两种容器类型。在 C++ 的标准模板库中，它们的实现分别是 &lt;code&gt;std::set&lt;/code&gt;/&lt;code&gt;std::multiset&lt;/code&gt; 与 &lt;code&gt;std::map&lt;/code&gt;/&lt;code&gt;std::multimap&lt;/code&gt;。（分别还有利用哈希表实现的 &lt;code&gt;unordered&lt;/code&gt; 版本）其中，字典（映射）的键（Keys）可视作组成一个相应类型的集合。&lt;/p&gt;
&lt;p&gt;对于集合或字典的读取，经典操作有两个：判断目标元素是否在集合当中、根据目标键获取相应值。&lt;/p&gt;
&lt;p&gt;这篇文章讲讲在 Excel 中如何实现这两个功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Excel" scheme="https://liam.page/tags/Excel/"/>
    
      <category term="MATCH" scheme="https://liam.page/tags/MATCH/"/>
    
      <category term="XLOOKUP" scheme="https://liam.page/tags/XLOOKUP/"/>
    
  </entry>
  
  <entry>
    <title>使用 NTFS-3G 在 macOS 上激活对 NTFS 磁盘的读写功能</title>
    <link href="https://liam.page/2020/04/08/enable-NTFS-writing-access-by-NTFS-3G/"/>
    <id>https://liam.page/2020/04/08/enable-NTFS-writing-access-by-NTFS-3G/</id>
    <published>2020-04-08T03:24:41.000Z</published>
    <updated>2020-04-16T14:07:46.140Z</updated>
    
    <content type="html"><![CDATA[<p>NTFS 是微软的 Windows NT 文件系统。在 macOS 上，默认只支持对 NTFS 磁盘的读，但不支持对 NTFS 磁盘的写。这无疑是很不方便的。</p><p>为解决这个问题，在我近几年的 macOS 使用经历中，先后试用了 <a href="http://www.tuxera.com/products/tuxera-ntfs-for-mac/" target="_blank" rel="noopener">Tuxera</a> 及 <a href="http://www.paragon-software.com/home/ntfs-mac/" target="_blank" rel="noopener">Paragon</a> 这样的付费软件，也试用了免费但需要手动挂载的 <a href="http://enjoygineering.com/mounty/" target="_blank" rel="noopener">Mounty</a>。但这些工具多少都有些不令我满意。</p><p>前几天检索到 NTFS-3G 这个开源工具，发现结合 FUSE for macOS 可以很方便地挂载 NTFS 磁盘并读写。所以记录下来。</p><a id="more"></a><h2 id="行前准备"><a href="#行前准备" class="headerlink" title="行前准备"></a>行前准备</h2><p>首先，你需要在 macOS 上安装 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>。按照官网的介绍，你只需要在 Terminal 中执行下列命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="安装-FUSE-for-macOS"><a href="#安装-FUSE-for-macOS" class="headerlink" title="安装 FUSE for macOS"></a>安装 FUSE for macOS</h2><p>接下来，使用 Homebrew 安装 FUSE for macOS。你需要在 Terminal 下执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install osxfuse</span><br></pre></td></tr></table></figure><h2 id="安装-NTFS-3G"><a href="#安装-NTFS-3G" class="headerlink" title="安装 NTFS-3G"></a>安装 NTFS-3G</h2><p>接下来，使用 Homebrew 安装 NTFS-3G。你需要在 Terminal 下执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ntfs-3g</span><br></pre></td></tr></table></figure><h2 id="切换-mount-ntfs"><a href="#切换-mount-ntfs" class="headerlink" title="切换 mount_ntfs"></a>切换 <code>mount_ntfs</code></h2><p>接下来，需要使用 NTFS-3G 提供的 <code>mount_ntfs</code> 来替代系统自带的 <code>mount_ntfs</code>。后者位于 <code>/sbin/mount_ntfs</code>。</p><p>由于 macOS 自 10.11 起，启用了系统完整性保护（System Integrity Protection）功能，导致在包括 <code>/sbin</code> 目录在内的一些目录下，即便有 <code>root</code> 权限，也无法修改目录下文件。你可以在 Terminal 中执行下列命令，查看 SIP 的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ csrutil status</span><br><span class="line">System Integrity Protection status: enabled.</span><br></pre></td></tr></table></figure><p>为此，我们需要暂时关闭 SIP，请参考下列操作步骤：</p><ol><li><p>重启电脑；</p></li><li><p>按住 <code>command + R</code>，进入恢复模式；</p></li><li><p>选择你习惯的语言；</p></li><li><p>在顶部菜单栏，依次进入「Utilities -&gt; Terminal」；</p></li><li><p>执行命令 <code>csrutil disable</code>，命令预期返回：「Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.」；</p></li><li><p>重启电脑，正常引导进入系统；</p></li><li><p>启动 Terminal；</p></li><li><p>执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sbin</span><br><span class="line">sudo mv mount_ntfs mount_ntfs.sys_orig <span class="comment"># 备份系统版本的 mount_ntfs</span></span><br><span class="line">sudo ln -sf /usr/<span class="built_in">local</span>/sbin/mount_ntfs mount_ntfs <span class="comment"># 将 NTFS-3G 提供的 mount_ntfs 链接到目标位置</span></span><br></pre></td></tr></table></figure></li><li><p>重启电脑；</p></li><li><p>按住 <code>command + R</code>，进入恢复模式；</p></li><li><p>选择你习惯的语言；</p></li><li><p>在顶部菜单栏，依次进入「Utilities -&gt; Terminal」；</p></li><li><p>执行命令 <code>csrutil enable</code>，命令预期返回：「Successfully enabled System Integrity Protection. Please restart the machine for the changes to take effect.」；</p></li><li><p>重启电脑，正常引导进入系统；</p></li><li><p>插入文件系统格式为 NTFS 的外部磁盘；</p></li><li><p>按照 FUSE for macOS 的提示，进入「System Preferences -&gt; Security and Privacy」；</p></li><li><p>在「General」标签允许 FUSE for macOS 相关的权限；</p></li><li><p>拔出文件系统格式为 NTFS 的外部磁盘，再重新插入；</p></li><li><p>此后，macOS 即可正常读写文件系统格式为 NTFS 的外部磁盘。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NTFS 是微软的 Windows NT 文件系统。在 macOS 上，默认只支持对 NTFS 磁盘的读，但不支持对 NTFS 磁盘的写。这无疑是很不方便的。&lt;/p&gt;
&lt;p&gt;为解决这个问题，在我近几年的 macOS 使用经历中，先后试用了 &lt;a href=&quot;http://www.tuxera.com/products/tuxera-ntfs-for-mac/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tuxera&lt;/a&gt; 及 &lt;a href=&quot;http://www.paragon-software.com/home/ntfs-mac/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Paragon&lt;/a&gt; 这样的付费软件，也试用了免费但需要手动挂载的 &lt;a href=&quot;http://enjoygineering.com/mounty/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mounty&lt;/a&gt;。但这些工具多少都有些不令我满意。&lt;/p&gt;
&lt;p&gt;前几天检索到 NTFS-3G 这个开源工具，发现结合 FUSE for macOS 可以很方便地挂载 NTFS 磁盘并读写。所以记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="NTFS" scheme="https://liam.page/tags/NTFS/"/>
    
      <category term="NTFS-3G" scheme="https://liam.page/tags/NTFS-3G/"/>
    
  </entry>
  
  <entry>
    <title>关于劳动剩余的一些思考</title>
    <link href="https://liam.page/2020/04/04/thoughts-on-work-surplus/"/>
    <id>https://liam.page/2020/04/04/thoughts-on-work-surplus/</id>
    <published>2020-04-04T11:55:12.000Z</published>
    <updated>2020-04-04T14:41:12.079Z</updated>
    
    <content type="html"><![CDATA[<p>最近在思考一些经济问题的时候，对剩余劳动有一些思考，所以记录下来。</p><p>这些思考不一定对，因为我对这些东西实在是门外汉，所以阅读时务必审慎。</p><a id="more"></a><h2 id="剩余劳动和剩余价值"><a href="#剩余劳动和剩余价值" class="headerlink" title="剩余劳动和剩余价值"></a>剩余劳动和剩余价值</h2><p>首先要说的是剩余劳动和剩余价值是两个概念。</p><p>在马克思的《资本论》中，剩余价值的计算是「劳动生产商品价值 - 固定成本（包括员工工资） - 可变成本」。在马克思的理论中，由于资方不参加劳动，因而剩余价值是对劳方的剥削。当然，马克思的理论有一个前提假设：资方不参与劳动。在这个假设的基础上，因为资方没有参加劳动，所以不应获得报酬。这个假设忽略了资方在生产过程中承担不确定性带来的风险这一无形劳动，因此曾被奥地利经济学派的学者批评。若承认资方的无形劳动，则剩余价值的计算公式应修正为：「劳动生产商品价值 - 固定成本（包括员工工资） - 可变成本 - 资方承担的风险成本」。但不论是否修正，在马克思经济理论中，资方都无偿占有了部分劳方创造的价值，而这部分价值即是所谓的剩余价值。</p><p>由此可见，剩余价值是站在劳方没有获得足额报酬的角度思考问题得到的结果。与之相对，剩余劳动是站在劳方是否有需求的角度讨论问题得到的结果。</p><p>劳动者有维持自身与他所赡养的家庭成员的生活的需求。付出劳动并获得报酬可以满足这一需求。站在这个角度，满足这一需求所必须付出的劳动就是所谓的「必要劳动」；超出这一限度的劳动就是「剩余劳动」。剩余劳动产出的即是剩余产品。剩余产品的利润，其中一部分成为劳方的非必须工资（可以用于储蓄或者改善生活条件等），另一部分成为资方的报酬（承担风险的无形劳动对应的报酬，如果承认有的话），剩余部分我们称之为「劳动剩余」，则要风情况讨论。在资本主义制度下，劳动剩余即是劳动者被资本家剥削的剩余价值。剩余价值部分为资本家所挥霍，另一部分被投入扩大再生产，进行资本积累，以利于继续剥削劳动者。在社会主义制度下，劳动剩余为劳动者共同占有，是社会主义扩大再生产的先决条件、储备和保证资金。</p><p>于是，总结一下。劳方的必要劳动获得的报酬，用于维持自身与他所赡养的家庭成员的生活的需求。劳方超出这一需求的劳动，即剩余劳动，产生的价值，一部分为劳方所得的额外报酬，一部分为资方所得的报酬（如果承认有的话），剩下的部分称为劳动剩余，则视社会形态和用途的不同而不同。但无论如何，剩余劳动是必须存在的（这一点马克思也承认，见《马克思恩格斯全集》第 25 卷，第 925 页）。因为只有剩余劳动的不断增长，才能使社会主义生产不断扩大，从而生产出越来越多的产品，来满足人民日益增长的物质和文化生活的需要，并为逐步过渡到共产主义创造必要的物质条件。不过，在社会主义制度下，剩余部分为所有劳动者共同占有，而不被资本家剥削。</p><p>再引申讨论一下。在劳动剩余的角度，资本主义和社会主义的主要不同在于：</p><ol><li>劳动剩余为何人所有。资本主义下，劳动剩余为资本家占有，是为剥削；社会主义下，劳动剩余为劳动者共同占有，再由社会主义政权统一调配。</li><li>劳动剩余的使用方式。资本主义下，劳动剩余一方面为资本家挥霍，一方面被用于投资扩大再生产；社会主义下，被用于投资扩大再生产。</li><li>扩大再生产的目的不同。资本主义下，扩大再生产是为了让资本家更好地剥削劳动者；社会主义下，扩大再生产是为了满足人民日益增长的物质和文化生活的需要，以及为了逐步过渡到共产主义创造必要的物质条件。</li></ol><blockquote><p>重申一下，这些思考不一定对，因为我对这些东西实在是门外汉，所以阅读时务必审慎。</p></blockquote><h2 id="经济发展与劳动剩余"><a href="#经济发展与劳动剩余" class="headerlink" title="经济发展与劳动剩余"></a>经济发展与劳动剩余</h2><p>经济发展社会福利才会增长，人民日益增长的物质和文化生活需求才能得到满足，日子才会越来越好。而经济要发展，前提条件之一就是经济要增长。经济增长要不然扩大劳动人口，要不然提升生产效率。在劳动人口对经济增长的提升基本是线性的，但生产效率对经济增长的提升则可能是爆炸式的。因此，生产效率的提升某种意义上更加重要。</p><p>提升生产效率取决于科研和对应科研成果的生产工具。科研是有周期的，因而可能在很长一段时间内没有有价值的产出，因而需要资金支持。科研的成果转化为切实的生产效率的提升，需要购入生产工具，这也需要资金的支持。资金从哪里来呢？答案显而易见，资金要从劳动剩余中来——不论是资本主义还是社会主义。于是，我们可以抛开意识形态来讨论劳动剩余的问题。</p><blockquote><p>再次重申，这些思考不一定对，因为我对这些东西实在是门外汉，所以阅读时务必审慎。</p></blockquote><!-- ## 原始积累 --><!-- 关于资本主义原始积累和社会主义原始积累，可见[马克思主义文库](https://www.marxists.org/chinese/)删的[文章](https://www.marxists.org/chinese/preobrazhensky/a009.htm)（或其[存档](https://web.archive.org/web/20180717062134/https://www.marxists.org/chinese/preobrazhensky/a009.htm)）。 --><!-- 殖民掠夺资本主义原始积累的方式之一。殖民掠夺的本质，是资本主义国家利用军事暴力掠夺被殖民国家劳动人民的劳动剩余。其余的方式，也能找到类似的影子：利用暴力对劳动剩余进行掠夺。社会主义原始积累则有所不同。摘一段上文的叙述如下。 --><!-- > 社会主义原始积累时期同资本主义原始积累时期的区别在于，第一、社会主义积累不仅应该靠小生产的剩余产品进行，而且应当靠资本主义经济形式的剩余价值进行。第二、无产阶级的国营经济在历史上是在垄断资本主义的基础上产生的，因而拥有用经济办法来调节整个经济的手段和重新分配国民收入的方法，这些手段和方法是资本主义在其发展的初期所不能具有的。 --><!-- 回顾我国建国初期的历史，可以与这段叙述相互印证。 --><!-- 我国建国初期的重点方向放到了如何提高企业利润上面来，企业有利润才能完成积累，才能再投资，才能不断发展壮大。如何提高利润呢？1）提高收入；2）降低成本。 --><!-- 如何提高收入？国家直接赋予企业垄断地位，而为了确保企业有了利润之后能够继续再投资而不是挥霍掉，并且防止投资的方向不是国家想要的，于是国家全面接管各大企业。这就是垄断国企的来源。这里与文献第二点印证。 --><!-- 如何降低成本？大幅压低员工的工资。但是员工总要生存对吧，与此同时就要压低员工的生活成本。于是乎，生活必需品开始全面管控。因为人为扭曲价格必然造成短缺（因为生产者无法获利，所以生产积极性下降，导致短缺），而短缺就必然带来管控，粮票等票证制度随之诞生。 --><!-- 对农民来说，由于管控，由于统购统销，意思就是国家要你种什么你就要种什么，你的产出只能卖给国家，而价格是由国家来定。而国家这么做的目的是为了能够压低城市工人的生活成本。所以本质上，相当于通过这样的方式把全国农民的劳动剩余转移到了城市企业。这就是历史上所谓的剪刀差——农产品价格低于价值、工业产品价格高于价值。同样的道理，人为的扭曲必然造成短缺，什么短缺呢？城市的位置，于是农民纷纷想要进城当工人，但是岗位是不足的，于是，大家都知道的，户口制度诞生。 --><!-- 农民积极性下降怎么办，基本无解，因为你无法同时满足既要大幅积累劳动剩余还要维系农民的积极性。最后折中的办法——农村合作社诞生，用规模效应来解决。 --><h2 id="广义的劳动剩余"><a href="#广义的劳动剩余" class="headerlink" title="广义的劳动剩余"></a>广义的劳动剩余</h2><p>狭义的劳动剩余就是前面介绍的，由剩余劳动带来的利润中刨除劳方、资方合理报酬的部分。但是站在提升生产效率所需资金的角度，可以这样广义地理解劳动剩余：劳动剩余是不用向劳动者兑现或者暂时不用兑现的劳动产出。</p><p>为了更好地发展经济，社会主义国家就必须在一定程度上获取劳动剩余，用以满足人民日益增长的物质和文化生活的需要，以及为逐步过渡到共产主义创造必要的物质条件。因此，在广义的劳动剩余的意义上，税收可以理解成是劳动者向国家让渡劳动所得成为劳动剩余的一种方式。另外，注意这里「暂时不用兑现」的说法。涉及到时间的资金，就会涉及到各种金融工具。简单推演就不难理解，你存入银行的工资，虽然是你的工资，但也可以理解成是广义的劳动剩余。那么，也就不难理解，发行国债，也是一种劳动者向国家让渡劳动所得成为广义劳动剩余的一种方式。</p><p>站在这个角度，理解一些政策和金融经济现象，就不会显得特别困难了。</p><!-- 房地产某种意义上可以理解成是国家获取劳动剩余的一种方式，并且由于通常人们需要贷款买房，所以在这个过程中国家不仅获取了现在的劳动剩余，还获取了将来的劳动剩余。 --><!-- 中国的房地产什么时候真正的结束，什么时候有替代房地产的劳动剩余积累方式出现的时候。也许是高度发达的所得税征收体系，也许是人民币收割其他国家。在此之前，不可能房地产会出问题。而在此之后，没有了房地产，也会有其他的东西来继续完成劳动剩余积累的使命。 --><blockquote><p>再一次重申，这些思考不一定对，因为我对这些东西实在是门外汉，所以阅读时务必审慎。</p></blockquote><!-- 参考阅读：<https://www.zhihu.com/question/376871453/answer/1123684250> -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在思考一些经济问题的时候，对剩余劳动有一些思考，所以记录下来。&lt;/p&gt;
&lt;p&gt;这些思考不一定对，因为我对这些东西实在是门外汉，所以阅读时务必审慎。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Thoughts" scheme="https://liam.page/tags/Thoughts/"/>
    
      <category term="Work-Surplus" scheme="https://liam.page/tags/Work-Surplus/"/>
    
  </entry>
  
  <entry>
    <title>以 Markdown 撰写文稿，以 LaTeX 排版</title>
    <link href="https://liam.page/2020/03/30/writing-manuscript-in-Markdown-and-typesetting-with-LaTeX/"/>
    <id>https://liam.page/2020/03/30/writing-manuscript-in-Markdown-and-typesetting-with-LaTeX/</id>
    <published>2020-03-30T09:14:45.000Z</published>
    <updated>2020-04-02T04:08:29.517Z</updated>
    
    <content type="html"><![CDATA[<p>回顾我学习和使用 LaTeX 的经历，有几个时间节点让我感触颇深：</p><ul><li>初次接触 LaTeX 时，感受到它对样式强大的控制能力和对数学公式的排版能力，心中对 Microsoft Word 颇有愤懑。</li><li>熟练使用 LaTeX 后，困于 LaTeX 中过于强大的样式控制能力带来的复杂性与笔记等需要速记的场景之间难以调和的矛盾。</li><li>初次接触 Markdown 时，感受到它在内容和样式之间取得了比较好的平衡。它的样式可以用 CSS 来控制。</li><li>折腾 Sphinx、Pandoc 等工具尝试将 Markdown 文稿转换为 LaTeX 文稿时，对这些工具的转换效果和细节问题感到崩溃。</li></ul><p>在这之后很多年里，我一直期待能有一个工具，能够更好地平衡 Markdown 的便捷性和 LaTeX 对样式的控制能力和对数学公式的排版能力。前几天，我发现了 <code>markdown</code> 宏包。我认为已找到了这样梦想中的工具。并且，我认为在熟练使用它之后，可以更好地实现 LaTeX 设计之初的愿望：<a href="/2019/03/18/separation-of-content-and-presentation/">内容与样式分离</a>。</p><blockquote><p>本文又名：「你喜爱的 Markdown 写作，现更以 LaTeX 呈现」。<br>——来自 <a href="https://harrychen.xyz/" target="_blank" rel="noopener">Harry Chen</a> 的 Apple 风格标题。</p></blockquote><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://ctan.org/pkg/markdown" target="_blank" rel="noopener"><code>markdown</code> 宏包</a>是 Vít Novotný 维护的一个宏包。它的核心机制使用 Lua 编写，同时提供了针对 Plain TeX/LaTeX/ConTeXt 等格式的接口。由于现代 TeX 发行版（TeX Live、MiKTeX 等）通常都包含了 Lua 解释器，因而使用 <code>markdown</code> 宏包通常无需额外安装其他工具，只需打开 <code>--shell-escape</code> 标记即可（LuaLaTeX 除外）。相对 Sphinx、Pandoc 等第三方工具以及之前社区实现的其他类似功能的宏包，这算是一个飞跃式的进步。</p><p><code>markdown</code> 宏包提供了名为 <code>markdown</code> 的环境和 <code>\markdownInput</code> 的命令。前者用于在 LaTeX 文稿中直接书写 Markdown 标记内容，后者用于从 Markdown 文件中读入内容。<code>markdown</code> 宏包会在遇到 <code>markdown</code> 环境或者 <code>\markdownInput</code> 命令时，将相应内容交由 Lua 解释器处理，从而将内容翻译成一堆预定义好的 LaTeX 宏。由于这个步骤需要调用 Lua 解释器，故而需要打开 <code>--shell-escape</code> 标记；当然，如果使用 LuaLaTeX 的话，因为直接能交给 Lua 解释器处理，故而不需要打开 <code>--shell-escape</code>。而后，TeX 引擎会读入这些翻译得到的 LaTeX 宏，进行正常的 LaTeX 处理。</p><p>对于常见的 Markdown 功能，<code>markdown</code> 宏包都预设了 LaTeX 宏相应的实现。例如 <code>\markdownRendererImage</code> 是用来渲染图片的宏，当解析到 <code>![imagelabel](imagepath &quot;image caption&quot;)</code> 时，Lua 解释器就会使用这个宏来拼接得到翻译结果：<code>\markdownRendererImage{imagelabel}{imagepath}{imagepath}{image caption}</code>。而后，根据 <code>\markdownRendererImage</code> 的定义，TeX 引擎会在后续步骤展开这个宏，再去排版得到相应的结果。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>在 LaTeX 中，使用 <code>markdown</code> 宏包和其他宏包没有太大的区别，只需要使用 <code>\usepackage{markdown}</code> 即可引入该宏包。例如，我们在 <code>ctexart</code> 文档类下结合 <code>markdown</code> 宏包使用看看。</p><figure class="highlight tex"><figcaption><span>example.tex</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"># 我是 Markdown</span><br><span class="line"></span><br><span class="line">这里可以用 Markdown 语法，撰写各种内容。例如，我可以*强调*，也可以**加粗**，当然也可以***加粗并强调***。</span><br><span class="line"></span><br><span class="line">## 这里是二级标题</span><br><span class="line"></span><br><span class="line">&gt; 幸福的获得，在极大的程度上却是由于消除了对自我的过分关注。</span><br><span class="line">&gt; ---Bertrand Arthur William Russell</span><br><span class="line"></span><br><span class="line">你看，我还可以使用引用↑。</span><br><span class="line"></span><br><span class="line">## 关于 dash, en-dash 和 em-dash</span><br><span class="line"></span><br><span class="line">LaTeX 使用者都应该知道 dash, en-dash 和 em-dash。dash 是普通的连字符，举例如：「five-year-old boy」。en-dash 是表示范围的稍长的横线，举例如：「以下章节是重点：12--15」。em-dash 则是英文中的破折号，举例如：「---Bertrand Arthur William Russell」</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>因为使用了 <code>markdown</code> 宏包，所以在编译时需要打开 <code>--shell-escape</code> 标记。又因为使用了 <code>ctexart</code> 文档类，所以这里选用 XeLaTeX 来编译。假设上述内容被保存为 <code>example.tex</code>，则编译用的命令行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xelatex --shell-escape example.tex</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你使用 TeXworks!/TeXshop/TeXstudio/WinEdt/VSCode/Atom 等 IDE/Editor，则你可能需要将 <code>--shell-escape</code> 这一标记配置到你的编译工具当中去。具体如何配置，请参考你使用的 IDE/Editor 的文档。</p></blockquote><p>得到结果如下图所示。</p><p><img data-src="/uploads/images/LaTeX/markdown_hello_world.jpg" alt></p><p>是不是感觉「效果拔群」？别激动，这里还是要做进一步的解释。</p><p>首先是关于 Markdown 中的章节标题（sectioning）。在 Markdown 中，章节标题通常使用井号 <code>#</code> 来标记。一个井号表示一级标题，两个井号表示二级标题，以此类推。在 LaTeX 中，章节标题的样式和含义随所使用的文档类的不同而有所区别。例如，<code>book</code> 及其衍生文档类中，最高级别的标题是 <code>\chapter</code>；<code>article</code> 及其衍生文档类中，最高级别的标题是 <code>\section</code>。为此，<code>markdown</code> 宏包在代码中做了适配。当有 <code>\chapter</code> 定义时，<code># 这里是标题</code> 被翻译成 <code>\chapter</code>，<code>## 这里是标题</code> 被翻译成 <code>\section</code>，以此类推。当没有 <code>\chapter</code> 定义时，<code># 这里是标题</code> 被翻译成 <code>\section</code>，<code>## 这里是标题</code> 被翻译成 <code>\subsection</code>，以此类推。</p><p>而后是关于强调、加粗、加粗强调、引用等 Markdown 中的经典格式标记。这些格式标记会被 <code>markdown</code> 宏包翻译成特定的 LaTeX 宏，这些宏又有预先的定义。例如强调被翻译成 <code>\markdownRendererEmphasis</code>，它被预定义成 <code>\emph</code>，因此有相应的效果。</p><p>最后是关于 dash, en-dash 和 em-dash。在 <code>markdown</code> 宏包中的用法和在普通的 LaTeX 文稿中的用法完全相同：一个短横线 <code>-</code> 表示连字符，两个短横线 <code>--</code> 表示 en-dash，三个短横线 <code>---</code> 表示 em-dash。</p><h3 id="关于省略号——markdown-宏包参数初体验"><a href="#关于省略号——markdown-宏包参数初体验" class="headerlink" title="关于省略号——markdown 宏包参数初体验"></a>关于省略号——<code>markdown</code> 宏包参数初体验</h3><p><code>markdown</code> 宏包还提供了一系列由参数控制的功能。这里用英文的省略号来引出 <code>markdown</code> 宏包的参数之一：<code>smartEllipses</code>。它表示 <code>markdown</code> 宏包会将 Markdown 文稿中连续的三个英文句点 <code>...</code> 自动转换成英文的省略号。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;smartEllipses = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">I like apple, banana, orange...</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_smartEllipses.jpg" alt></p><p>我们注意到，宏包参数通过 <code>\markdownSetup</code> 宏由 key-value 的形式给出。</p><h3 id="列表及其增强"><a href="#列表及其增强" class="headerlink" title="列表及其增强"></a>列表及其增强</h3><p>Markdown 中有有序列表和无序列表，分别对应 LaTeX 中的 <code>enumerate</code> 和 <code>itemize</code> 环境。<code>markdown</code> 对有序列表的语法做了一定的增强，它允许用户使用 <code>#. foobar</code> 的形式撰写有序列表。这一特性需要通过 <code>hashEnumerators</code> 参数打开。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;hashEnumerators = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">* apple</span><br><span class="line">* banana</span><br><span class="line">* orange</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">1. 张三</span><br><span class="line">2. 李四</span><br><span class="line">3. 王五</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#. 北京</span><br><span class="line">#. 上海</span><br><span class="line">#. 广州</span><br><span class="line">#. 深圳</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_hashEnumerators.jpg" alt></p><p>我们注意到，单独占据一行的连续的多个短横线，可以形成一条横向的分割线。</p><h3 id="超链接和脚注"><a href="#超链接和脚注" class="headerlink" title="超链接和脚注"></a>超链接和脚注</h3><p>在 Markdown 中，人们可用 <code>[anchor](uri)</code> 形成带锚文本的超链接，也可使用 <code>&lt;uri&gt;</code> 形成不带锚文本的超链接。在扩展的 Markdown 中，还可以使用 <code>^[footnote text]</code> 生成尾注。<code>markdown</code> 宏包也支持这些功能，不过，这需要打开 <code>inlineFootnotes</code> 参数。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;inlineFootnotes = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">欢迎查阅[Liam Huang 的博客](https://liam.page)，希望你会喜欢。^[这里有很多好东西哦！]</span><br><span class="line"></span><br><span class="line">如果你想看到更多 LaTeX 知识，欢迎前往 &lt;http://www.latexstudio.net/&gt;。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_inlineFootnotes.jpg" alt></p><p>可见，Markdown 中的尾注变成了 LaTeX 中的脚注。另外，超链接的默认效果不太好，可借助 <code>hyperref</code> 宏包做进一步定制。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;hyperref&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  inlineFootnotes = true,</span></span></span><br><span class="line"><span class="tag"><span class="string">  renderers = &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    link = &#123;\href&#123;#2&#125;</span><span class="string">&#123;#1&#125;</span></span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">欢迎查阅[Liam Huang 的博客](https://liam.page)，希望你会喜欢。^[这里有很多好东西哦！]</span><br><span class="line"></span><br><span class="line">如果你想看到更多 LaTeX 知识，欢迎前往 &lt;http://www.latexstudio.net/&gt;。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_inlineFootnotes_links.jpg" alt></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在 Markdown 中插入代码是很方便的事情。在行内插入代码只需要在两个反引号直接插入内容即可，例如 <code>`\LaTeX`</code>。对于插入多行代码，原始的 Markdown 语法是缩进 4 个空格。不过，绝大多数 Markdown 编辑器/渲染器都支持连用三个反引号的扩展形式。为此，我们需要打开 <code>fencedCode</code> 参数。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;fencedCode = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">Python 中的 `print` 函数可用来将内容打印到标准输出。例如，下列 Python 代码将循环 10 次，打印「Hello world」至标准输出。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">for i in range(10):</span><br><span class="line">    print("hello world")</span><br><span class="line">```</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_fencedCode.jpg" alt></p><p>这样排版出来的效果不是很好，相当于使用了 LaTeX 的 <code>verbatim</code> 环境排版代码。不过，<code>markdown</code> 宏包贴心地与 <code>listings</code> 及 <code>minted</code> 宏包做了适配——只要使用了 <code>listings</code> 或者 <code>minted</code> 宏包，代码环境就会自动利用相应宏包的相应设置进行排版。在扩展用法一节当中，我们将会看到这一点。</p><h3 id="插入图表"><a href="#插入图表" class="headerlink" title="插入图表"></a>插入图表</h3><p>Markdown 中插图的语法是 <code>![imagelabel](uri)</code>，扩展的 Markdown 语法中则有表格的用法。前者在 <code>markdown</code> 宏包中直接支持，后者则需要打开 <code>pipeTables</code> 参数。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  pipeTables = true</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">![example-image](example-image.jpg "An example image")</span><br><span class="line"></span><br><span class="line">| 序号 | 姓名 |</span><br><span class="line">|-----|-----|</span><br><span class="line">| 1 | 张三 |</span><br><span class="line">| 2 | 李四 |</span><br><span class="line">| 3 | 王五 |</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_pipeTables.jpg" alt></p><p>注意到这里有两个问题：一是图片超宽，而在默认的 Markdown 语法中无法对图片宽度进行控制；二是三线表的线条粗细有问题。</p><p>后者可以通过引入 <code>booktabs</code> 宏包解决。<code>markdown</code> 宏包对此进行了适配，一旦检测到引入了 <code>booktabs</code> 宏包，三线表会自动选用 <code>booktabs</code> 宏包定义的表线来处理。前者则比较麻烦，将在「扩展用法」一节中介绍。</p><h2 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h2><h3 id="美化代码块"><a href="#美化代码块" class="headerlink" title="美化代码块"></a>美化代码块</h3><p>前面提到 <code>markdown</code> 对 <code>listings</code> 和 <code>minted</code> 宏包进行了适配，故而在引入相应宏包之后，可以更美观地排版代码块。这里举例说明。</p><p>首先是 <code>minted</code> 宏包。使用 <code>minted</code> 宏包时，需确保已安装好 Python 及 Pygments 库，并将相应的二进制文件所在的目录添加至系统环境变量 <code>PATH</code>。</p><figure class="highlight tex"><figcaption><span>markdown_minted.tex</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;minted&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setminted</span><span class="string">&#123;fontsize=\small, autogobble=true, breaklines&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;fencedCode = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">Python 中的 `print` 函数可用来将内容打印到标准输出。例如，下列 Python 代码将循环 10 次，打印「Hello world」至标准输出。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">for i in range(10):</span><br><span class="line">    print("hello world")</span><br><span class="line">```</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_minted.jpg" alt></p><p>然后是 <code>listings</code> 宏包。</p><figure class="highlight tex"><figcaption><span>markdown_listings.tex</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;xcolor&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;listings&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lstdefinestyle</span><span class="string">&#123;lfonts&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  basicstyle   = \scriptsize\ttfamily,</span></span></span><br><span class="line"><span class="tag"><span class="string">  stringstyle  = \color&#123;purple&#125;</span></span>,</span><br><span class="line">  keywordstyle = <span class="tag">\<span class="name">color</span><span class="string">&#123;blue!60!black&#125;</span></span><span class="tag">\<span class="name">bfseries</span></span>,</span><br><span class="line">  commentstyle = <span class="tag">\<span class="name">color</span><span class="string">&#123;olive&#125;</span></span><span class="tag">\<span class="name">scshape</span></span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">lstdefinestyle</span><span class="string">&#123;lnumbers&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  numbers     = left,</span></span></span><br><span class="line"><span class="tag"><span class="string">  numberstyle = \tiny,</span></span></span><br><span class="line"><span class="tag"><span class="string">  numbersep   = 1em,</span></span></span><br><span class="line"><span class="tag"><span class="string">  firstnumber = 1,</span></span></span><br><span class="line"><span class="tag"><span class="string">  stepnumber  = 1,</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lstdefinestyle</span><span class="string">&#123;llayout&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  breaklines       = true,</span></span></span><br><span class="line"><span class="tag"><span class="string">  tabsize          = 2,</span></span></span><br><span class="line"><span class="tag"><span class="string">  columns          = spacefixed,</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lstdefinestyle</span><span class="string">&#123;lgeometry&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  xleftmargin      = 20pt,</span></span></span><br><span class="line"><span class="tag"><span class="string">  xrightmargin     = 0pt,</span></span></span><br><span class="line"><span class="tag"><span class="string">  frame            = tb,</span></span></span><br><span class="line"><span class="tag"><span class="string">  framesep         = \fboxsep,</span></span></span><br><span class="line"><span class="tag"><span class="string">  framexleftmargin = 20pt,</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lstdefinestyle</span><span class="string">&#123;lgeneral&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  style = lfonts,</span></span></span><br><span class="line"><span class="tag"><span class="string">  style = lnumbers,</span></span></span><br><span class="line"><span class="tag"><span class="string">  style = llayout,</span></span></span><br><span class="line"><span class="tag"><span class="string">  style = lgeometry,</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lstset</span><span class="string">&#123;language = Python, style = lgeneral&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;fencedCode = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">Python 中的 `print` 函数可用来将内容打印到标准输出。例如，下列 Python 代码将循环 10 次，打印「Hello world」至标准输出。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">for i in range(10):</span><br><span class="line">    print("hello world")</span><br><span class="line">```</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_listings.jpg" alt></p><h3 id="混合-LaTeX-语法"><a href="#混合-LaTeX-语法" class="headerlink" title="混合 LaTeX 语法"></a>混合 LaTeX 语法</h3><p>虽然 Markdown 很方便，但终究不如 LaTeX 对格式的控制能力强。特别地，若是要在 Markdown 中插入数学公式，单纯的 Markdown 就无能为力了。<code>markdown</code> 宏包提供了 <code>hybrid</code> 参数，当它打开时，我们可以在 Markdown 中（几乎）如常地使用 LaTeX 宏和数学公式。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;hybrid = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\dif&#125;</span><span class="string">&#123;\mathop&#123;&#125;</span></span><span class="tag">\<span class="name">!</span></span><span class="tag">\<span class="name">mathrm</span><span class="string">&#123;d&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">行内数学公式： <span class="formula">$<span class="tag">\<span class="name">omega</span> = </span><span class="tag">\<span class="name">dif</span></span><span class="tag">\<span class="name">phi</span></span> / <span class="tag">\<span class="name">dif</span></span> t$</span>.</span><br><span class="line"></span><br><span class="line">行间数学公式：</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">I = <span class="tag">\<span class="name">int</span></span> <span class="tag">\<span class="name">rho</span></span> R^&#123;2&#125; <span class="tag">\<span class="name">dif</span></span> V</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"></span><br><span class="line">以及，利用反斜线输出各种标点符号：<span class="tag">\<span class="name">`</span></span>foo<span class="tag">\<span class="name">`</span></span>, <span class="tag">\<span class="name">*</span></span>bar<span class="tag">\<span class="name">*</span></span>。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_hybrid.jpg" alt></p><h3 id="更好地插入图片"><a href="#更好地插入图片" class="headerlink" title="更好地插入图片"></a>更好地插入图片</h3><p>为了解决插图宽度控制的问题，就要搞清楚 Markdown 插图标记经过 <code>markdown</code> 宏包翻译之后的宏，展开后会是怎样。答案在 <code>markdown.sty</code> 文件当中，对 <code>renderersPrototypes</code> 的定义有如下代码：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image = &#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;figure&#125;</span></span><span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;center&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">includegraphics</span><span class="string">&#123;#3&#125;</span></span><span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;center&#125;</span></span><span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">ifx</span></span><span class="tag">\<span class="name">empty</span></span>#4<span class="tag">\<span class="name">empty</span></span><span class="tag">\<span class="name">else</span></span></span><br><span class="line">      <span class="tag">\<span class="name">caption</span><span class="string">&#123;#4&#125;</span></span><span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">fi</span></span></span><br><span class="line">    <span class="tag">\<span class="name">label</span><span class="string">&#123;fig:#1&#125;</span></span><span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span>&#125;,</span><br></pre></td></tr></table></figure><p>可见 <code>\includegraphics{ #3 }</code> 并未对图片大小做任何限制。好在，我们既然已知是用 <code>\includegraphics</code> 插图，就可以通过 <code>graphicx</code> 宏包提供的接口来修改插图样式。<code>graphicx</code> 宏包使用 <code>Gin</code> 这个分组（可以理解为 C++ 当中的名字空间）对参数进行管理。为了控制插图宽度，可以这样做：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\setkeys&#123;Gin&#125;&#123;width = .8\linewidth&#125;</span><br><span class="line">![<span class="string">imagelabel</span>](<span class="link">imagepath "image caption"</span>)</span><br></pre></td></tr></table></figure><p>于是，对于插图之前的例子来说，可以这样做：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;hybrid = true&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setkeys</span><span class="string">&#123;Gin&#125;</span><span class="string">&#123;width = .8\linewidth&#125;</span></span></span><br><span class="line">![example-image](example-image.jpg "An example image")</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/markdown_width_image.jpg" alt></p><p>注意，这里因为要使用 LaTeX 宏，所以需要打开 <code>hybrid</code> 参数。如此，我们就（部分地）解决了图片宽度控制的问题。不过，这样也引出了新的两个问题：</p><ol><li>在 <code>figure</code> 环境当中套用 <code>center</code> 环境是不对的，这样会因 <code>center</code> 环境引入额外的垂直方向的空距。</li><li>在 Markdown 文稿中这样使用 LaTeX 宏——非是解决 Markdown 无法插入的内容，而是为了样式控制——有滥用的嫌疑。</li></ol><p>为解决问题 1)，我们需要修改 <code>images</code> 的渲染方式；在解决问题 1) 的过程中，可以顺带部分解决问题 2)。代码如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">markdownSetup</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  renderers = &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    image = &#123;\begin&#123;figure&#125;</span><span class="string">[htb]</span></span></span><br><span class="line">      <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">      <span class="tag">\<span class="name">includegraphics</span><span class="string">[width = .8\linewidth]</span><span class="string">&#123;#3&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">ifx</span></span><span class="tag">\<span class="name">empty</span></span>#4<span class="tag">\<span class="name">empty</span></span><span class="tag">\<span class="name">else</span></span></span><br><span class="line">        <span class="tag">\<span class="name">caption</span><span class="string">&#123;#4&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;fig:#1&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">fi</span></span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line">![example-image](example-image.jpg "An example image")</span><br><span class="line"></span><br><span class="line">![example-image](example-image-a.jpg "An example image")</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;markdown&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>这样一来，每次使用 Markdown 语法插入图片，其宽度都会是 <code>.8\linewidth</code>，并且解决了因误用 <code>center</code> 环境带来的额外的竖直方向空距。当然，也可以用更巧妙的办法，通过判断图片的实际宽度，决定是否需要限制宽度，不过，这超出了本文的讨论范围，按下不表。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p><code>markdown</code> 宏包是个很出彩的宏包，它还有很多功能，本文无法尽数。因此，欢迎各位读者继续阅读 <code>markdown</code> 宏包的文档，开发更多用法甚至是玩法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回顾我学习和使用 LaTeX 的经历，有几个时间节点让我感触颇深：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初次接触 LaTeX 时，感受到它对样式强大的控制能力和对数学公式的排版能力，心中对 Microsoft Word 颇有愤懑。&lt;/li&gt;
&lt;li&gt;熟练使用 LaTeX 后，困于 LaTeX 中过于强大的样式控制能力带来的复杂性与笔记等需要速记的场景之间难以调和的矛盾。&lt;/li&gt;
&lt;li&gt;初次接触 Markdown 时，感受到它在内容和样式之间取得了比较好的平衡。它的样式可以用 CSS 来控制。&lt;/li&gt;
&lt;li&gt;折腾 Sphinx、Pandoc 等工具尝试将 Markdown 文稿转换为 LaTeX 文稿时，对这些工具的转换效果和细节问题感到崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这之后很多年里，我一直期待能有一个工具，能够更好地平衡 Markdown 的便捷性和 LaTeX 对样式的控制能力和对数学公式的排版能力。前几天，我发现了 &lt;code&gt;markdown&lt;/code&gt; 宏包。我认为已找到了这样梦想中的工具。并且，我认为在熟练使用它之后，可以更好地实现 LaTeX 设计之初的愿望：&lt;a href=&quot;/2019/03/18/separation-of-content-and-presentation/&quot;&gt;内容与样式分离&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文又名：「你喜爱的 Markdown 写作，现更以 LaTeX 呈现」。&lt;br&gt;——来自 &lt;a href=&quot;https://harrychen.xyz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Harry Chen&lt;/a&gt; 的 Apple 风格标题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Package" scheme="https://liam.page/tags/Package/"/>
    
      <category term="Markdown" scheme="https://liam.page/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>英语听力之五步精听法</title>
    <link href="https://liam.page/2020/03/29/five-step-training-method-for-English-listening/"/>
    <id>https://liam.page/2020/03/29/five-step-training-method-for-English-listening/</id>
    <published>2020-03-29T13:06:10.000Z</published>
    <updated>2020-03-31T15:28:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>这里是凭回忆记录的赵东坡老师的「五步精听法」。这个方法是我很多年前在上 TOEFL iBT 培训时，从赵东坡老师处习得。</p><p>本文先讲怎么训练，然后解释为什么要这样训练。</p><a id="more"></a><h2 id="五步精听法"><a href="#五步精听法" class="headerlink" title="五步精听法"></a>五步精听法</h2><p>训练分为 5 步，需要的内容有两个：听力材料，听力材料对应的准确原文。</p><ol><li>播放一遍听力材料，不看原文，认真听；</li><li>打开听力原文，查找不认识的词和短语；</li><li>逐字句地翻译原文——必须成文，可以写在纸上或者打字放在电脑里，但不能口头翻译（「大概是这样就行了」是不行的）；</li><li>对照原文和译文，播放听力材料，落后听力原文三个单词做「影子跟读」，直到可以不看原文脱稿跟读；</li><li>在当天时间内（不一定要即时，但是要当天完成），认真听材料 20 遍，尝试根据听到的声音直接反应出对应的含义。</li></ol><h2 id="方法背后的原理"><a href="#方法背后的原理" class="headerlink" title="方法背后的原理"></a>方法背后的原理</h2><p>听力的最终目的是「听到声音就知道意思」。这就包括了两个步骤。首先是听到声音直到对方在说什么（英语，目标语言），这属于「听得清」的范畴；其次是知道对方说什么之后反应出对应的意思（中文，母语，思维语言）。</p><p>此外，因为听力是一个连续的过程，对这两个步骤还有「快」的要求。因为如果不够快，对方哗啦啦已经说到下一个话题了，可能我们还在反应上一个话题的内容。而「快」就要求对应于有一个比较大块的「意义反应单元」。什么意思呢？先以中文举例：当我们听到「我今天要去游泳」，我们理解的是整个句子，而不是逐词地理解「我、今天、要、去、游泳」。而放在英文中，非母语学生如果不经特别的训练，理解听力中说话人的语义往往是逐词进行的——就像后面那个例子一样。可以想见，这样去理解意思，是怎么都快不起来的。</p><p>可见，如果只是做听写练习，或者以美剧或者 VOA 之类的材料做泛听，是不够的。前者只解决了「辨音」的问题，而且效率低下；后者只是在不断地重复强化熟悉的句式和表达方式在脑海中的印象，不熟悉的内容还是不行。</p><p>这五步的精听练习中，第一步是模拟实际的环境（因为实际情况我们就只能听对方说一遍），第二步是辅助，第三步是建立英语到汉语的对应，第四步解决辨音的问题，第五步是在强化「声音 - 语义」的直接连接。这就是五步精听法背后的原理。</p><h2 id="推荐材料"><a href="#推荐材料" class="headerlink" title="推荐材料"></a>推荐材料</h2><ul><li>老托 93 篇听力练习</li><li>推荐的材料是科学美国人节目的「一分钟科学（Sixty Second Science）」</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是凭回忆记录的赵东坡老师的「五步精听法」。这个方法是我很多年前在上 TOEFL iBT 培训时，从赵东坡老师处习得。&lt;/p&gt;
&lt;p&gt;本文先讲怎么训练，然后解释为什么要这样训练。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="English" scheme="https://liam.page/tags/English/"/>
    
      <category term="Listening" scheme="https://liam.page/tags/Listening/"/>
    
  </entry>
  
  <entry>
    <title>使用 WITH ... AS ... 语句增强 SQL 查询的可读性</title>
    <link href="https://liam.page/2020/03/13/the-WITH-AS-clause-in-Hive-SQL/"/>
    <id>https://liam.page/2020/03/13/the-WITH-AS-clause-in-Hive-SQL/</id>
    <published>2020-03-13T10:36:46.000Z</published>
    <updated>2020-03-31T15:28:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读各种 Hive SQL，发现一个可读性问题，让我很无奈。这里记录一下，希望看到的读者能够写出可读性更好的代码。</p><p>因为业务比较复杂，所以大家经常会用到各种子查询（sub-query）。于是会写成类似这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  t1.foo,</span><br><span class="line">  t2.bar,</span><br><span class="line">  t3.baz</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      foo,</span><br><span class="line">      bar</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      tb1</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      &lt;conds&gt;</span><br><span class="line">  ) <span class="keyword">AS</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      baz</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      tb2</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      &lt;conds&gt;</span><br><span class="line">  ) <span class="keyword">AS</span> t2 <span class="keyword">ON</span> &lt;conds&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt;conds&gt;;</span><br></pre></td></tr></table></figure><p>这样写子查询会有两个问题。一是子查询的结果如果要在多个不同地方用到，那么就要复制粘贴多次，实际执行的时候也可能执行多次。二是当子查询或/和 JOIN 特别多的时候，整个查询就会变得无比复杂，可读性极差。为解决问题，可用视图（VIEW）解决，也可用 <code>WITH ... AS ...</code> 子句来解决。</p><a id="more"></a><p><code>WITH &lt;temprary_table_name&gt; AS (SELECT ... FROM &lt;table_name&gt; WHERE &lt;conds&gt;)</code>  和视图类似，可以创建一个临时表，供之后使用。按上述例子，改用 <code>WITH ... AS ...</code> 子句可以写成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> t1 <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    foo,</span><br><span class="line">    bar</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    tb1</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    &lt;conds&gt;</span><br><span class="line">),</span><br><span class="line">t2 <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    baz</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    tb2</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    &lt;conds&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  t1.foo,</span><br><span class="line">  t2.bar,</span><br><span class="line">  t3.baz</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> &lt;conds&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt;conds&gt;;</span><br></pre></td></tr></table></figure><p>很明显，这样写起来可读性会强很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读各种 Hive SQL，发现一个可读性问题，让我很无奈。这里记录一下，希望看到的读者能够写出可读性更好的代码。&lt;/p&gt;
&lt;p&gt;因为业务比较复杂，所以大家经常会用到各种子查询（sub-query）。于是会写成类似这样：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t1.foo,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t2.bar,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t3.baz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      foo,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      bar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      tb1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;conds&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ) &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; t1 &lt;span class=&quot;keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      baz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      tb2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;conds&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ) &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; t2 &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; &amp;lt;conds&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;conds&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样写子查询会有两个问题。一是子查询的结果如果要在多个不同地方用到，那么就要复制粘贴多次，实际执行的时候也可能执行多次。二是当子查询或/和 JOIN 特别多的时候，整个查询就会变得无比复杂，可读性极差。为解决问题，可用视图（VIEW）解决，也可用 &lt;code&gt;WITH ... AS ...&lt;/code&gt; 子句来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
      <category term="SQL" scheme="https://liam.page/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Hive SQL 中的 LATERAL VIEW</title>
    <link href="https://liam.page/2020/03/09/LATERAL-VIEW-in-Hive-SQL/"/>
    <id>https://liam.page/2020/03/09/LATERAL-VIEW-in-Hive-SQL/</id>
    <published>2020-03-09T03:04:13.000Z</published>
    <updated>2020-03-31T15:28:12.003Z</updated>
    
    <content type="html"><![CDATA[<p>这些天使用 Hive 的过程中遇到了新的知识点，于是将 <code>LATERAL VIEW</code> 的使用方法记录下来。</p><a id="more"></a><h2 id="UDTF"><a href="#UDTF" class="headerlink" title="UDTF"></a>UDTF</h2><p>UDTF 是 User-Defined Table-Generating Functions 的缩写，即用户定义的表生成函数。UDTF 用来解决从原始表中的一行生成多行数据的问题。典型的 UDTF 有 <code>EXPLODE</code> 函数，它能将 <code>array</code> 或者 <code>map</code> 展开。例如：</p><p>考虑以下名为 <code>pageAds</code> 的原始表，它有两列：<code>pageid</code>（网页名称）和 <code>adid_list</code>（网页上显示的广告数组）：</p><table><thead><tr><th>名称</th><th>类型</th></tr></thead><tbody><tr><td><code>pageid</code></td><td><code>STRING</code></td></tr><tr><td><code>adid_list</code></td><td><code>Array&lt;int&gt;</code></td></tr></tbody></table><p>假设其中有以下两行：</p><table><thead><tr><th><code>pageid</code></th><th><code>adid_list</code></th></tr></thead><tbody><tr><td><code>contact_page</code></td><td><code>[3, 4, 5]</code></td></tr><tr><td><code>front_page</code></td><td><code>[1, 2, 3]</code></td></tr></tbody></table><p>使用 <code>EXPLODE</code> 函数可以展开 <code>adid_list</code> 这一列，也就是说，SQL 语句的结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  EXPLODE(adid_list)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  pageAds;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- possible result:</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 4</span></span><br><span class="line"><span class="comment">-- 5</span></span><br></pre></td></tr></table></figure><p>不过，UDTF 有一个限制，它出现在 <code>SELECT</code> 子句中的时候，不能与其它列共同出现。也就是说下列 SQL 语句会报语法错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  pageid, EXPLODE(adid_list) <span class="keyword">AS</span> adid</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  pageAds;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们就需要引入 <code>LATERAL VIEW</code>。</p><h2 id="LATERAL-VIEW"><a href="#LATERAL-VIEW" class="headerlink" title="LATERAL VIEW"></a><code>LATERAL VIEW</code></h2><p><code>LATERAL VIEW</code> 的语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lateralView:</span></span><br><span class="line">LATERAL VIEW udtf(expression) tableAlias AS columnAlias (',' columnAlias)*</span><br><span class="line"><span class="comment">--fromClause:</span></span><br><span class="line">FROM baseTable (lateralView)*  -- 允许联用多个 LATERAL VIEW 子句</span><br></pre></td></tr></table></figure><p>这里，<code>udtf(expression)</code> 表示诸如 <code>EXPLODE</code> 之类的 UDTF 的表达式。<code>LATERAL VIEW</code> 对遇到的每一行，首先会按 UDTF 表达式进行处理，展开成若干行（可能是零行），然后将这些输出行与输入行 <code>INNER JOIN</code>。如果要保留输出为零的行，则需使用 <code>LATERAL VIEW OUTER</code> 执行 <code>OUTER JOIN</code>。</p><p>继续以上述名为 <code>pageAds</code> 的原始表为例，为了同时 <code>SELECT</code> 出 <code>pageid</code> 和 <code>adid</code>，我们需要使用 <code>LATERAL VIEW</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  pageid, adid</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  pageAds</span><br><span class="line">  LATERAL <span class="keyword">VIEW</span></span><br><span class="line">    EXPLODE(adid_list) tmp <span class="keyword">AS</span> adid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- possible result:</span></span><br><span class="line"><span class="comment">-- front_page1</span></span><br><span class="line"><span class="comment">-- front_page2</span></span><br><span class="line"><span class="comment">-- front_page3</span></span><br><span class="line"><span class="comment">-- contact_page3</span></span><br><span class="line"><span class="comment">-- contact_page4</span></span><br><span class="line"><span class="comment">-- contact_page5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天使用 Hive 的过程中遇到了新的知识点，于是将 &lt;code&gt;LATERAL VIEW&lt;/code&gt; 的使用方法记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
      <category term="SQL" scheme="https://liam.page/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之五：非谓语动词</title>
    <link href="https://liam.page/2020/02/27/nonfinite-verb/"/>
    <id>https://liam.page/2020/02/27/nonfinite-verb/</id>
    <published>2020-02-27T14:28:12.000Z</published>
    <updated>2020-03-02T14:20:07.828Z</updated>
    
    <content type="html"><![CDATA[<p>在很早的<a href="/2016/07/31/tense-selection/">上一篇</a>文章中，我们讲了英语当中的时态选择。时态选择涉及到的主要是谓语动词的形态变化。此篇继续讲动词，不过话题转向非谓语动词。</p><a id="more"></a><h2 id="独立子句与主谓结构"><a href="#独立子句与主谓结构" class="headerlink" title="独立子句与主谓结构"></a>独立子句与主谓结构</h2><p>任何一个独立子句（independent clause）都有且只有一套主谓结构。</p><p>什么叫独立子句呢？我们知道，英文当中的句子是有主句和（可选的若干个）从句之分。在不考虑并列的情况下，主句和（各个）从句就都分别是独立子句。如果存在并列，那么并列的若干分句又分别是独立子句。其中，既没有从句又没有并列的主句，称为简单句。在英语中，简单句有五种基本句型。这一点，我们在<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>中已经处理过了。</p><p>什么叫主谓结构呢？引用<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>中的表述如下：</p><blockquote><p>从意思上说，一个完整句子表达的无非是「一个人/一个东西怎么样了」。这里「一个人/一个东西」称为主语部分（subject），告诉人们「这个句子讨论的是『一个人或者一个东西』」；「怎么样了」称为谓语部分（predicate，也称「述语部分」），它可以是「做了什么事情」或者「具有某种特性」。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。<br>不过，不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。因此讨论基本句型就有必要讨论谓语动词。</p></blockquote><p>因此，独立子句都有且只有一套主谓结构这个命题可以理解成，在一个独立子句中，你可以说「一个人/一个东西怎么样了」，但不能说成「一个人/一个东西怎么样了怎么样了[怎么样了……]」。不然，句子就成病句了。</p><h2 id="谓语动词与非谓语动词"><a href="#谓语动词与非谓语动词" class="headerlink" title="谓语动词与非谓语动词"></a>谓语动词与非谓语动词</h2><p>由于谓语部分总是以动词起头，我们就把这个动词称之为谓语动词（predicate verb）。谓语动词又叫限定动词（finite verb）；这是因为：谓语动词会受到主语的人称、数量、时态和情态的限制。（这会引出主谓一致的话题，后表。）</p><blockquote><p>这里还有一点需要澄清的地方。<br>在中文教学中，常用「主谓宾」这样的表述来描述句子结构，似乎谓语和宾语是相互分开独立的部分。但实际上，宾语是谓语的一部分。「主谓宾」里的「谓」实际上指的是「谓语动词」的意思。这一点，在<a href="/2014/06/21/basic-sentence-and-the-complement/">基本句型</a>的讲解中也有体现：我们写 S(ubject) + V(erb) + O(bject) 而非是 S(ubject) + P(redicate) + O(bject)。</p></blockquote><p>一个独立子句都有且只有一套主谓结构的直接推论就是：一个独立子句都有且只有一个谓语动词或者并列的多个谓语动词。</p><blockquote><p>后者的例子比如：「I <strong>put</strong> the book on the desk and <strong>leave</strong> the room.」其中 put 和 leave 是并列的两个谓语动词，但整个句子只有一套主谓结构。不过，若写成「I <strong>put</strong> the book on the desk, and I <strong>leave</strong> the room.」就是两个并列子句了。这是因为，and 并列的是 I put 和 I leave 两套主谓结构。</p></blockquote><p>在这个规则限定之下，若是要在句子中独立于谓语动词之外表达动作的含义，就必须使用非谓语动词。由于它不受主语的限制，所以也称为非限定动词（nonfinite verb）。在英语中，非谓语动词主要有以下三类：不定式（infinitives），分词（participles，包括现在分词（present participles）和过去分词（past participles））和 动名词（gerunds）。后二者又统称为动状词（verbals）。</p><blockquote><p>除了这三种非谓语动词之外，在其他语言中还有动形词（gerundive，拉丁语）、动名词（supine，拉丁语，和 gerunds 的区别主要在「格」上）、动副词（converb，突厥语、蒙古语等）。</p></blockquote><h2 id="为什么需要非谓语动词"><a href="#为什么需要非谓语动词" class="headerlink" title="为什么需要非谓语动词"></a>为什么需要非谓语动词</h2><p>为什么需要非谓语动词，这一问题等价于，为什么人们会要在句子中独立于谓语动词之外表达动作的含义。</p><p>这个问题看起来有点傻，但我认为其实还是蛮重要的。因为这影响着我们能否用统一的方式来处理英语中的四种非谓语动词而不需要记忆额外的规则。对这个问题，我有以下朴素的思考：</p><ul><li>因为，每个动词作为谓语动词，都能「撑」起一个独立子句。</li><li>所以，非谓语动词及其宾语（表语）或其他附属结构摘出来能够和适当的主语组成一个独立子句，它通常可以作为原句的从句存在。</li><li>再然后，反过来，从句子简化的角度看待问题，如果将从句的关联词/引导词省略，再将可能重复的主语省略，再将可能存在的情态动词、助动词去掉或者变形，最后从句动词有实际意义不能直接省略，就只好变成非谓语动词了。</li></ul><p>在经过仔细观察之后，我发现从句子简化的角度，可以比较一贯地处理英语中的四种非谓语动词组成的短语；当然，对于动名词和分词单独使用分别充当名词和形容词的时候，直接将它们视作是对应词性的单词即可，不需要额外的处理。</p><h2 id="不定式（infinitives）"><a href="#不定式（infinitives）" class="headerlink" title="不定式（infinitives）"></a>不定式（infinitives）</h2><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p>英语当中的不定式（infinitives）的基本形式是 <em>to + V</em>，即以不变词（particle）<em>to</em> 引导的动词原形。举例来说，下列句子中，斜体标示的是不定式。</p><ul><li>I&#39;m glad <em>to know</em> you. | 很高兴认识你。</li><li>I want <em>to play</em> computer game. | 我想玩电脑游戏。</li><li>I asked Sophia <em>to help</em> me in English. | 我请 Sophia 帮我提升英语。</li></ul><p>不定式的不变词 <em>to</em> 在某些情况下可以省略，形成无修饰不定式（bald infinitives）；也就是说，光秃秃的动词原形，可能也是不定式。在使役动词和感官动词之后，往往不定式的不变词 <em>to</em> 需要省略。（原因后表）同样，下列句子中，斜体标示的是不定式。</p><ul><li>He made us <em>wash</em> his car. | 他令我们为他洗车。</li><li>I heard her <em>cry</em> out in pain. | 我听见她疼得大哭出声。</li></ul><p>在句子当中，视不同情况，不定式可以当做名词、形容词、副词的角色来使用。</p><h3 id="不定式的句子简化"><a href="#不定式的句子简化" class="headerlink" title="不定式的句子简化"></a>不定式的句子简化</h3><p>我们来看几个用到动词不定式的场景中，不定式都起到了什么成分的作用，以及它可以怎样的从句简化而来。在这部分，我们暂不处理无修饰不定式的情形。</p><p><strong>I&#39;m glad <em>to know</em> you.</strong></p><p>句子的主干是「I&#39;m glad.」，即「我很高兴」，「to know you」是高兴的原因状语，也就是不定式作为副词结构。因此原句如果以很重的翻译腔来翻译的话，应该是：「我很高兴因为我能认识你」。于是很容易得到它的原句：</p><blockquote><p>I&#39;m glad because I can know you.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语均为「I」，因此可以省略；原句变为：I&#39;m glad <del>because I</del> can know you.</li><li>主句谓语动词 <em>am</em> 和从句谓语动词 <em>can</em> 不能同时出现，且从句表意动词是 <em>know</em> 而非 <em>can</em>，因此<strong>将 <em>can</em> 改为 <em>to</em> 以保留「不确定的语气」</strong>；原句变为：I&#39;m glad <del>because I can</del> to know you.</li><li>简化完成。</li></ul><p><strong>I want <em>to play</em> computer game.</strong></p><p>句子的主干是「I want <em>sth.</em>」，即「我想要 sth」。显然，「to play computer game」是想要的动词宾语，也就是不定式作为名词结构。于是很容易得到它的原句：</p><blockquote><p>I want that I will play computer game.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语均为「I」，因此可以省略；原句变为：I want <del>that I</del> will play computer game.</li><li>主句谓语动词 <em>want</em> 和从句谓语动词 <em>will</em> 不能同时出现，且从句表意动词是 <em>play</em> 而非 <em>will</em>，因此<strong>将 <em>will</em> 改为 <em>to</em> 以保留「不确定的语气」</strong>；原句变为：I want <del>that I will ~</del> to play computer game.</li><li>简化完成。</li></ul><p><strong>I asked Sophia <em>to help</em> me in English.</strong></p><p>句子的主干是「I asked Sophia.」，即「我请求 Sophia」。「to help me in English」是 Sophia 的宾语补足语，也就是不定式做名词/形容词结构。于是很容易得到它的原句：</p><blockquote><p>I asked Sophia whether she will help me in English.</p></blockquote><p>简化流程：</p><ul><li>主句宾语和从句主语均为「Sophia」，因此可以省略；原句变为：I asked Sophia <del>whether she</del> will help me in English.</li><li>主句谓语动词 <em>asked</em> 和从句谓语动词 <em>will</em> 不能同时出现，且从句表意动词是 <em>help</em> 而非 <em>will</em>，因此<strong>将 <em>will</em> 改为 <em>to</em> 以保留「不确定的语气」</strong>；原句变为：I asked Sophia <del>whether she will</del> to help me in English.</li><li>简化完成。</li></ul><h3 id="不定式的特点"><a href="#不定式的特点" class="headerlink" title="不定式的特点"></a>不定式的特点</h3><p>从以上三例可以看到，不定式和助动词关系密切，从句子简化的角度来看，不定式可以视作是助动词的变形。在这个过程中，不定式的不变词 <em>to</em> 一方面承担了语法功能，一方面<strong>表达不确定的语气</strong>。下表更详细地描述了助动词和不定式（的不变词）之间的相似性。</p><table><thead><tr><th></th><th>助动词</th><th>不定式（的不变词）</th></tr></thead><tbody><tr><td>都要接动词原形</td><td>I will go.</td><td>I want to go.</td></tr><tr><td>都表达不确定语气</td><td>He is right. -&gt; He may be right.</td><td>He is right. -&gt; He seems to be right.</td></tr><tr><td>都需要借完成式表达过去时间</td><td>It might have rained last night.</td><td>It seems to have rained last night.</td></tr></tbody></table><blockquote><p>助动词缺少表达过去时间的能力。一般理解上，could 是 can 的过去式，而 might 是 may 的过去式。但实际上，它们在实际表意中，只能表示比 can/may 更弱的猜测力度，而不能表示对过去的猜测。比如「It may rain (in minutes).」和「It might rain (in minutes).」都表示「可能要下雨了」，都表示对现在/将来的猜测。若是要表达对过去的猜测，必须借助完成式，写成 It may/might have rain last night.</p></blockquote><p>此外，很容易发现常见助动词和不定式表达之间的对应关系。</p><table><thead><tr><th>助动词</th><th>不定式</th></tr></thead><tbody><tr><td>must</td><td>have to</td></tr><tr><td>shall/should</td><td>ought to / be responsible to</td></tr><tr><td>will/would</td><td>be going to</td></tr><tr><td>can/could</td><td>be able to</td></tr><tr><td>may/might</td><td>be likely to</td></tr></tbody></table><h3 id="无修饰不定式"><a href="#无修饰不定式" class="headerlink" title="无修饰不定式"></a>无修饰不定式</h3><p>在处理通常形式的不定式时，我们注意到不定式的不变词 <em>to</em> 可以视作是助动词的变化。在表意上，它表达了不确定性。据此，我们可分析看看何种情况下不定式应省略不变词，成为无修饰不定式。——当必须使用不定式，但又不能表达不确定性时，就应该省略不变词，变成无修饰不定式。</p><p>我们对比以下两例：</p><ul><li>He made us <em>wash</em> his car.</li><li>He asked us <em>to wash</em> his car.</li></ul><p>在这里，<em>made</em> 是使役动词而 <em>asked</em> 是普通动词。使役动词和普通动词的区别就在于，使役动词后的动作是具有强制性的，换言之也就是没有不确定性。这就是传统语法书里写的「使役动词后需要使用动词原形」的原因。</p><p>继续观察以下两例：</p><ul><li>I heard her <em>cry</em> out in pain.</li><li>I see the boy <em>play</em> on the playground.</li></ul><p>在这里，<em>heard</em> 和 <em>see</em> 都是感官动词。感官动词与普通动词的区别就在于，感官动词是「感受到的真相」。真相当然就没有不确定性，因此其后不能用 <em>to</em> 引导的不定式来表达不确定性。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>不定式的基本形态是 <em>to + V</em>；其中 <em>to</em> 是不变词，可视作助动词的变形，承担语法功能，同时表达「不确定性」。当不定式所处的上下文没有不确定性时，就要省略不变词，变成单纯的动词原形 <em>V</em>，此时称作无修饰不定式。</p><p>不定式在句子中可以承担名词、形容词、副词的功能。</p><h2 id="动名词（gerunds）"><a href="#动名词（gerunds）" class="headerlink" title="动名词（gerunds）"></a>动名词（gerunds）</h2><p>上一节介绍了不定式，不定式可以用来充作名词。这一节讲同样可以充作名词的动名词。</p><h3 id="基本形式-1"><a href="#基本形式-1" class="headerlink" title="基本形式"></a>基本形式</h3><p>在英语中，动名词的基本形式是 <em>V-ing</em>，即，在动词原形之后，加上 <code>ing</code> 作为后缀。举例来说，下列句子中，斜体标示的是动名词。</p><ul><li><em>Swiming</em> is my favorite sport. | 游泳是我最喜欢的运动。</li><li>I really enjoyed <em>playing</em> computer game with my brother that night. | 我着实享受那晚与哥哥一起玩电脑游戏。</li></ul><h3 id="动名词与名词——单独使用"><a href="#动名词与名词——单独使用" class="headerlink" title="动名词与名词——单独使用"></a>动名词与名词——单独使用</h3><p>在第一个例句中，<em>Swiming</em> 是<u>动名词单独使用</u>的例子。单独使用的动名词与普通名词没有太大的区别，都可以充当主语、动词宾语或者介词等需要名词填充的语法成分。</p><ul><li><em>Swiming</em> is my favorite sport. | 主语</li><li>My favorite sport is <em>swiming</em>. | 动词宾语做主语补语</li><li>I enjoy <em>swiming</em> daily. | 动词宾语做句子宾语</li><li>I&#39;m not afraid of death, but I&#39;m afraid of <em>dying</em>. | 介词宾语</li></ul><p>不过，动名词涉及到的动作通常带有<strong>延续性</strong>的意味。比如</p><ul><li><em>swiming</em> 总要多划几下才叫游泳，不然只能叫扑腾；</li><li><em>climbing</em> 总要持续地爬才叫攀登，不然只能叫小童学步；</li><li><em>dancing</em> 总要连续一串动作才叫跳舞，不然只能叫抽风；</li><li><em>drinking</em> 总要喝几口才能叫喝酒，不然只能叫酒精中毒。</li></ul><p>此外，因为动名词含有动作的意味，所以它通常是看不见摸不着的抽象名词。因此，动名词通常都是不可数名词。但也有少许例外，比如</p><ul><li>There will be two <em>weddings</em> at the auditorium tomorrow night.</li></ul><h3 id="名词从句简化——动名词短语"><a href="#名词从句简化——动名词短语" class="headerlink" title="名词从句简化——动名词短语"></a>名词从句简化——动名词短语</h3><p>处理完了动名词单独使用的情形，接下来处理所谓的<u>动名词短语</u>。</p><p><strong>I really enjoyed <em>playing</em> computer game with my brother that night.</strong></p><p>句子主干是「I enjoyed <code>object</code>」，即「我享受 <code>object</code>」。「playing computer game with my brother that night」是 enjoyed 的宾语。于是很容易得到它的原句：</p><blockquote><p>I really enjoyed that I played computer game with my brother that night.</p></blockquote><p>简化流程：</p><ul><li>主句宾语和从句主语均为「I」，因此可以省略；原句变为：I really enjoyed <del>that I</del> played computer game with my brother that night.</li><li>主句谓语动词 <em>enjoyed</em> 和从句谓语动词 <em>played</em> 不能同时出现，因此需将从句谓语动词修改为非谓语动词。由于充当名词成分，候选项有 <em>to play</em> 和 <em>playing</em>。考虑到此处无不确定语气，因此选择动名词；原句变为：I really enjoyed <del>that I played</del> playing computer game with my brother that night.</li><li>简化完成。</li></ul><p><strong><em>Killing</em> enemies on battlefield is glory of soldiers.</strong></p><p>句子主干是「<code>subject</code> is glory」，即「<code>subject</code> 是荣耀」。「Killing enemies on battlefield」是句子主语。于是很容易得到它的原句：</p><blockquote><p>That soldiers kill enemies on battlefield is glory of soldiers.</p></blockquote><p>简化流程：</p><ul><li>主句补语的所有格与从句主语都是「soldiers」，因此可以省略；原句变为：<del>That soldiers</del> kills enemies on battlefield is glory of soldiers.</li><li>主句谓语动词 <em>is</em> 和从句谓语动词 <em>kills</em> 不能同时出现，因此需将从句谓语动词修改为非谓语动词。由于充当名词成分，候选项有 <em>to kill</em> 和 <em>killing</em>。考虑到此处无不确定语气，因此选择动名词；原句变为：Killing enemies on battlefield is glory of soldiers.</li><li>简化完成。</li></ul><p><strong><em>Being</em> invited here is my honor.</strong></p><p>句子主干是「<code>subject</code> is honor.」，即「<code>subject</code> 是荣耀」。「Being invited here」是句子主语。于是很容易得到它的原句：</p><blockquote><p>That I was invited here is my honor.</p></blockquote><p>简化流程：</p><ul><li>主句补语所有格与从句主语都是「I」，因此可以省略；原句变为：<del>That I</del> was invited here is my honor.</li><li>主句谓语动词 <em>is</em> 和从句谓语动词 <em>was</em> 不能同时出现，因此需将从句谓语动词修改为非谓语动词。由于充当名词成分，候选项有 <em>to be</em> 和 <em>being</em>。考虑到此处无不确定语气，因此选择动名词；原句变为：Being invited here is my honor.</li><li>简化完成。</li></ul><p>注意，这里 <em>being invited</em> 是动名词的被动形式。其中 <em>being</em> 当中的 <em>be</em> 是不表意的，真正起到作用的是后缀 <em>-ing</em> 形成动名词。对于动名词的被动形式，和我们在<a href="/2015/05/03/tense-of-verb/">动词时态</a>中处理被动语态中一样，将 be-动词当成正常的动词，而后取其动名词形式。</p><p><strong>I don&#39;t like John&#39;s <em>calling</em> my girlfriend day after day.</strong></p><p>句子主干是「I don&#39;t like <code>object</code>」，即「我不喜欢 <code>object</code>」。「John&#39;s calling my girlfriend day after day」是句子宾语。注意到，动名词 <em>calling</em> 和普通名词一样，可以被所有格限定。而所有格的人称，即是动名词对应动作的逻辑主语。于是很容易得到它的原句：</p><blockquote><p>I don&#39;t like that John is calling my girlfriend day after day.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语不同，因此从句主语不能直接省略，而应当变为所有格；原句变为：I don&#39;t like <del>that John</del> John&#39;s is calling my girlfriend day after day.</li><li>主句谓语动词 <em>do</em> 和从句谓语动词 <em>is</em> 冲突，且从句谓语中实际承担表意的是 <em>calling</em>，因此可以直接删除从句谓语动词 <em>is</em>；原句变为：I don&#39;t like <del>that John</del> John&#39;s <del>is</del> calling my girlfriend day after day.</li><li>简化完成。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>动名词的基本形式是 <em>V-ing</em>。动名词可以单独使用，也可以组成动名词短语。不论是单独使用还是组成动名词短语，动名词都在句子当中充当名词成分。</p><p>单独使用的动名词和普通名词差异不大，但有以下一些特点：</p><ul><li>表达的动作带有延续性（后缀 <code>-ing</code> 的功能）；</li><li>通常是不可数名词。</li></ul><p>组成动名词短语时，动名词短语可看做是名词从句的简化。具体是何种名词性从句，取决于动名词短语在原句中的地位。在简化名词性从句时，若从句谓语动词不带有不确定性且主句不表达不确定性，则需使用动名词，组成动名词短语。在遇到从句主语与主句主语或所有格不重合时，在组成动名词短语时需将从句主语变成所有格。</p><p>在英语中，非谓语动词里的动名词和不定式都可以在句子当中充当名词成分。不同的是，<strong>不定式带有不确定性</strong>，而<strong>动名词带有延续性</strong>。</p><h2 id="分词（participles）"><a href="#分词（participles）" class="headerlink" title="分词（participles）"></a>分词（participles）</h2><h3 id="基本形式-2"><a href="#基本形式-2" class="headerlink" title="基本形式"></a>基本形式</h3><p>英语里的分词包括现在分词（present participles）和过去分词（past participles）。</p><ul><li>现在分词的基本形式是 <em>V-ing</em>，与动名词完全相同。</li><li>过去分词的基本形式是 <em>V-ed</em>。</li></ul><p>分词可以<strong>单独使用，类似形容词</strong>。举例来说，下列斜体标示的是现在分词：</p><ul><li>The <em>flying</em> bird is cute. | 那只正在飞的小鸟很可爱。（现在分词作形容词，修饰主语）</li><li>I love the <em>flying</em> bird. | 我喜欢那只正在飞的小鸟。（现在分词作形容词，修饰宾语）</li><li>The bird is <em>flying</em>. | 那只小鸟正在飞。（现在分词做形容词，作为主语补足语修饰主语）</li></ul><p>下列斜体标示的，则是过去分词：</p><ul><li>The <em>boiled</em> water is safe to drink. | 开水喝起来安全。（过去分词作形容词，修饰主语）</li><li>Please give me a bottle of <em>boiled</em> water. | 请给我来一杯开水。（过去分词做形容词，修饰宾语）</li><li>The water is <em>boiled</em>. | 水开了。（过去分词做形容词，作为主语补足语修饰主语）</li></ul><p>分词可以组成<strong>分词短语，充当形容词成分</strong>。举例来说，下列斜体标示的是现在分词短语和过去分词短语：</p><ul><li>Children <em>studying in school</em> make lots of friends. | 在学校读书的孩子们交了很多朋友。（现在分词短语做后置定语，修饰主语）</li><li>Soldiers <em>wounded in war</em> are sent home. | 在战场上受伤的士兵们被送回家了。（过去分词短语做后置定语，修饰主语）</li><li>Soldiers <em>being sent home</em> are wounded. | 正被送回家的士兵们受伤了。（现在分词短语，被动式，做后置定语，修饰主语）</li></ul><p>分词可以有特别的<strong>分词构句，充当副词成分</strong>。因为分词通常意义上被理解成形容词，不能充当副词成分。因此，对这种特别的语法现象，人们称之为分词构句。举例来说，下列斜体标示的是分词构句：</p><ul><li><em>Wounded in war</em>, the soldiers are sent home. | 因为在战场上受了伤，士兵们被送回了家。（过去分词构句，做原因状语）</li><li><em>Running for four hours</em>, John is exhausted. | 跑步 4 小时后，约翰筋疲力尽。（现在分词构句，做时间状语）</li><li><em>Having been treated unfairly</em>, Lisa quits her work. | 因为被不公平地对待，丽莎辞职了。（现在分词构句，完成式，做原因状语）</li></ul><p>下面分别就几种分词的使用方法讨论。</p><h3 id="分词与形容词——单独使用"><a href="#分词与形容词——单独使用" class="headerlink" title="分词与形容词——单独使用"></a>分词与形容词——单独使用</h3><p>在传统语法里，分词是形容词。分词可以做定语修饰主语或者宾语，也可以作为主语补足语（表语）修饰主语。在这个意义上，分词与形容词完全一样。</p><ul><li>The <em>black</em> dog is pitiful. | 黑狗很可怜。（形容词作定语修饰主语）</li><li>The <em>barking</em> dog is pitiful. | 汪汪叫的狗很可怜。（现在分词做定语修饰主语）</li><li>The <em>wounded</em> dog is pitiful. | 受伤的狗很可怜。（过去分词做定语修饰主语）</li><li>I see a <em>black</em> dog. | 我看见一只黑狗。（形容词做定语修饰宾语）</li><li>I see a <em>barking</em> dog. | 我看见一只汪汪叫的狗。（现在分词做定语修饰宾语）</li><li>I see a <em>wounded</em> dog. | 我看见一只受伤的狗。（过去分词做定语修饰宾语）</li><li>The dog is <em>black</em>. | 这狗是黑的。（形容词做主语补足语，修饰主语）</li><li>The dog is <em>barking</em>. | 这狗正在叫。（现在分词做主语补足语，修饰主语）</li><li>The dog is <em>wounded</em>. | 这狗受伤了。（过去分词做主语补足语，修饰主语）</li></ul><p>很显然，我们得到分词的第一个特点：<strong>现在分词和过去分词都能如普通形容词一样，用于定语和主语补足语</strong>。</p><p>此外，仿照之前处理不定式和分词的时候，我们可以将 <code>-ing</code> 和 <code>-ed</code> 视作是形容词后缀，和 <code>-ful</code>, <code>-able</code>, <code>-less</code> 之类的一样，表达一种特定的含义。<code>-ing</code> 暗示「持续」或者「正在发生」的含义；<code>-ed</code> 暗示「被动」或者「完成」的含义。</p><p>有了这一认识，<a href="/2015/05/03/tense-of-verb/">动词时态</a>及<a href="/2016/07/31/tense-selection/">时态选择</a>中处理进行式和被动语态的表述就很好理解了。而且，这一认识可能比 <code>be + V-ing</code> 表示进行以及 <code>be + V-ed</code> 表示被动的公式更好。比如说：</p><ul><li>「The dog is <em>barking</em>.」意思是「这狗正在叫」，看似是 <code>be + V-ing</code> 的功劳。但实际上「The barking dog」里没有 be-动词，也表示「正在汪汪叫的狗」。可见，表达「持续」或者「正在发生」的含义的是 <code>-ing</code> 后缀，而非 <code>be + V-ing</code> 这一结构。</li><li>被动语态也有类似处理，而且，<code>be + V-ed</code> 有时候也不表示被动。比如「The leaves are all fallen.」译作「叶子掉光了」。这里的翻译，取过去分词的「完成」意味，而不能套用 <code>be + V-ed</code> 表示被动语态。</li><li>又比如进行式和被动式的混合「The case is being investigated by police.」，如果以「背公式」的方法来学习，那就又要背下「Be + being + V-ed」表示进行式的被动语态。但如果按我们这里的认识就很简单了。<em>is</em> 无需翻译，<em>being</em> 中 <em>be</em> 无意义而 <code>-ing</code> 表示「正在」，<code>-ed</code> 表示被动翻译为被调查。于是译文就脱口而出：「案件正在被警察调查」。</li></ul><h3 id="形容词性从句简化——分词短语"><a href="#形容词性从句简化——分词短语" class="headerlink" title="形容词性从句简化——分词短语"></a>形容词性从句简化——分词短语</h3><p>处理完了分词单独使用的问题，接下来我们看看分词短语。形容词性从句简化后，往往留下分词短语。</p><p><strong>Children <em>studying in school</em> make lots of friends.</strong></p><p>句子的主干是「Children make lots of friends.」，即「孩子们交了很多朋友」。「studying in school」是修饰主语的定语。因此很容易得到原句：</p><blockquote><p>Children who are studing in school make lots of friends.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语（先行词 <em>who</em>）相同，因此可以省略；原句变为：Children <del>who</del> are studing in school make lots of friends.</li><li>主句谓语动词 <em>make</em> 与从句谓语动词 <em>are</em> 冲突，而从句谓语中实际承担表意的是 <em>studing</em>。因此，可以直接去掉从句谓语动词 <em>are</em>；原句变为：Children <del>who are</del> studing in school make lots of friends.</li><li>简化完成。</li></ul><p><strong>Soldiers <em>wounded in war</em> are sent home.</strong></p><p>句子的主干是「Soldiers are sent home.」，即「士兵们被送回了家」。「wounded in war」是修饰主语的定语。因此很容易得到原句：</p><blockquote><p>Soldiers who were wounded in war are sent home.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语（先行词 <em>who</em>）相同，因此可以省略；原句变为：Soldiers <del>who</del> were wounded in war are sent home.</li><li>主句谓语动词 <em>are</em> 与从句谓语动词 <em>were</em> 冲突，而从句谓语中实际承担表意的是 <em>wounded</em>。因此，可以直接去掉从句谓语动词 <em>were</em>；原句变为：Soldiers <del>who were</del> wounded in war are sent home.</li><li>简化完成。</li></ul><p><strong>Soldiers <em>being sent home</em> are wounded.</strong></p><p>句子的主干是「Soldiers are wounded.」，即「士兵们受伤了」。「being sent home」是修饰主语的定语。因此很容易得到原句：</p><blockquote><p>Soldiers who are being sent home are wounded.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语（先行词 <em>who</em>）相同，因此可以省略；原句变为：Soldiers <del>who</del> are being sent home are wounded.</li><li>主句谓语动词 <em>make</em> 与从句谓语动词 <em>are</em> 冲突，而从句谓语中实际承担表意的是 <em>sent</em>。因此，可以直接去掉从句谓语动词 <em>are</em>；原句变为：Soldiers <del>who are</del> being sent home are wounded.</li><li>简化完成。</li></ul><h3 id="副性从句简化——分词构句和独立主格"><a href="#副性从句简化——分词构句和独立主格" class="headerlink" title="副性从句简化——分词构句和独立主格"></a>副性从句简化——分词构句和独立主格</h3><p>接下来我们来处理分词构句和独立主格。</p><p><strong><em>Wounded in war</em>, the soldiers are sent home.</strong></p><p>句子的主干是「The soldiers are sent home.」，即「士兵们被送回了家」。「Wounded in war」是句子的原因状语。因此很容易得到原句：</p><blockquote><p>Because they were wounded in war, the soldiers are sent home.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语相同，因此可以省略；原句变为：<del>Because they</del> were wounded in war, the soldiers are sent home.</li><li>主句谓语动词 <em>are</em> 与从句谓语动词 <em>were</em> 冲突，而从句谓语中实际承担表意的是 <em>wounded</em>。因此，可以直接去掉从句谓语动词 <em>were</em>；原句变为：<del>Because they were</del> wounded in war, the soldiers are sent home.</li><li>简化完成。</li></ul><p><strong><em>Running for four hours</em>, John is exhausted.</strong></p><p>句子的主干是「John is exhausted.」，即「约翰筋疲力尽」。「Running for four hours」是句子的时间状语。因此很容易得到原句：</p><blockquote><p>After he was running for four hours, John is exhausted.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语相同，因此可以省略；原句变为：<del>After he</del> was running for four hours, John is exhausted.</li><li>主句谓语动词 <em>is</em> 与从句谓语动词 <em>was</em> 冲突，而从句谓语中实际承担表意的是 <em>running</em>。因此，可以直接去掉从句谓语动词 <em>was</em>；原句变为：<del>After he was</del> running for four hours, John is exhausted.</li><li>简化完成。</li></ul><p><strong><em>Having been treated unfairly</em>, Lisa quits her work.</strong></p><p>句子的主干是「Lisa quits her work.」，即「丽莎辞职了」。「Having been treated unfairly」是句子的原因状语。因此很容易得到原句：</p><blockquote><p>Because she has been treated unfairly, Lisa quits her work.</p></blockquote><p>简化流程：</p><ul><li>主句主语和从句主语相同，因此可以省略；原句变为：<del>Because she</del> has been treated unfairly, Lisa quits her work.</li><li>主句谓语动词 <em>quits</em> 与从句谓语动词 <em>has</em> 冲突，因此要将 <em>has</em> 转化为非谓语动词。利用分词构句，可选项有 <em>having</em> 及 <em>had*。考虑到此处没有被动的意味，而完成的意味已由完成式承担。因此，将 *has</em> 变为现在分词 <em>having</em>；原句变为：<del>Because she has</del> Having been treated unfairly, Lisa quits her work.</li><li>简化完成。</li></ul><p>观察不难得到分词构句的一般规律：</p><ul><li>现有两个句子，主语相同。</li><li>其中一个句子可以充当另一个句子的状语。这个状语可以是条件状语、原因状语、让步状语、时间状语等各种状语。</li><li>将充当状语的句子的主语去掉，将状语里的谓语动词变化：<ul><li>如果状语是一般式主动语态，则用现在分词构句。</li><li>如果状语是一般式被动语态，则用过去分词构句。</li><li>如果状语是完成式，则用现在分词构句。</li></ul></li></ul><p>特别地，如果两个句子的主语不同，则需要保留充当状语的句子中的主语。此时形成的结构叫独立主格结构。仅举一例：</p><ul><li>The condition is favorable. He might succeed. | 两个句子，主语不同。</li><li>前句可以充当后句的条件状语。</li><li>保留状语从句的主语，而后用现在分词构句，得到：The condition being favorable, he might succeed.</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>分词分为现在分词和过去分词，他们的基本形态是 <em>V-ing</em> 和 <em>V-ed</em>，</p><p>分词可以单独使用，与形容词相似，可以充当定语、补语。在分词单独使用时，可将 <code>-ing</code> 视作表达「正在」或「进行」的形容词后缀，可将 <code>-ed</code> 视作表达「被动」或「完成」的形容词后缀。</p><p>分词可组成分词短语，可视作是形容词性从句的简化。</p><p>分词相关短语也可以从副词从句简化而来。但由于分词是形容词性，所以专门起了名字叫做「分词构句」和「独立主格结构」。前者用于主从主语一致的情况，后者用于主从主语不一致的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很早的&lt;a href=&quot;/2016/07/31/tense-selection/&quot;&gt;上一篇&lt;/a&gt;文章中，我们讲了英语当中的时态选择。时态选择涉及到的主要是谓语动词的形态变化。此篇继续讲动词，不过话题转向非谓语动词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Verb" scheme="https://liam.page/tags/Verb/"/>
    
      <category term="Grammer" scheme="https://liam.page/tags/Grammer/"/>
    
      <category term="Nonfinte" scheme="https://liam.page/tags/Nonfinte/"/>
    
      <category term="Infinitives" scheme="https://liam.page/tags/Infinitives/"/>
    
      <category term="Gerunds" scheme="https://liam.page/tags/Gerunds/"/>
    
      <category term="Participles" scheme="https://liam.page/tags/Participles/"/>
    
  </entry>
  
  <entry>
    <title>SARS-CoV-2 莫自牢，千病万疫避白袍</title>
    <link href="https://liam.page/2020/02/12/pray-for-the-nation-against-COVID-19/"/>
    <id>https://liam.page/2020/02/12/pray-for-the-nation-against-COVID-19/</id>
    <published>2020-02-12T13:29:47.000Z</published>
    <updated>2020-03-02T14:20:07.827Z</updated>
    
    <content type="html"><![CDATA[<p>希望若干年后的史书，会这样记载 2020 年初的疫情。</p><a id="more"></a><blockquote><p>己亥末庚子初，荆楚大疫。又一旬，波及全国，染者以万计。一时间，举国闭户，风烟四起。<br>有国士者，南山也。衣白袍者，医护也。辛劳不辞，艰险不畏。又有商贾布衣无算，捐千金货，出万分力，立雷火于华胥。<br>月余，疫去而风烟定。时人记之，曰：SARS-CoV-2 莫自牢，千病万疫避白袍。</p><p>Liam Huang, 2020-02-12 于北京</p></blockquote><p>🙏</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望若干年后的史书，会这样记载 2020 年初的疫情。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="2019-nCoV" scheme="https://liam.page/tags/2019-nCoV/"/>
    
      <category term="SARS-CoV-2" scheme="https://liam.page/tags/SARS-CoV-2/"/>
    
      <category term="COVID-19" scheme="https://liam.page/tags/COVID-19/"/>
    
  </entry>
  
  <entry>
    <title>泥潭挣扎记：Linuxbrew 里的 Glibc</title>
    <link href="https://liam.page/2020/01/19/struggle-with-Glibc-and-Linuxbrew/"/>
    <id>https://liam.page/2020/01/19/struggle-with-Glibc-and-Linuxbrew/</id>
    <published>2020-01-19T10:10:52.000Z</published>
    <updated>2020-03-02T14:20:07.827Z</updated>
    
    <content type="html"><![CDATA[<p>本着 Homebrew 真香的原则，我尝试在 CentOS 上安装 Linuxbrew。至于不用 Yum 的原因，请看刚才提到的真香原则。</p><p>但随即，我就陷入到了 Glibc 的泥潭。这个泥潭是一个需要自举（bootstrap）的循环依赖；这个泥潭长这样：</p><ul><li>Linuxbrew 安装任何东西都依赖 <code>curl</code> 和 <code>git</code>，而且它不想用系统中自带的 <code>curl</code> 和 <code>git</code>。</li><li><code>curl</code> 和 <code>git</code> 都直接或间接依赖 Glibc。</li><li>Linuxbrew 里的 Glibc 版本比较高，目前是 2.23，因此依赖高版本的 GCC（<code>&gt;= 4.7</code>），以及因为 Linuxbrew 的缘故依赖 <code>curl</code> 和 <code>git</code>。</li><li>系统里的 GCC 版本较低，因此 Linuxbrew 安装 Glibc 失败；而通过 Linuxbrew 安装高版本的 GCC 又再次依赖 Glibc。</li></ul><p>泥潭里有两个循环依赖：</p><ul><li>Glibc 和 <code>curl</code> 及 <code>git</code> 等基础工具相互依赖；</li><li>Glibc 和 GCC 相互依赖。</li></ul><a id="more"></a><h2 id="寻找突破口，解决-Glibc-的存在性问题"><a href="#寻找突破口，解决-Glibc-的存在性问题" class="headerlink" title="寻找突破口，解决 Glibc 的存在性问题"></a>寻找突破口，解决 Glibc 的存在性问题</h2><p>两个循环都涉及到 Glibc，因此必须想办法从 Glibc 这里突破。考虑到 Glibc 基础库的地位，很多依赖它的模块，都是硬编码 Glibc 的位置。因此 Glibc 必须从源码编译安装，无法直接服用编译好的二进制文件。所以 Glibc 无论如何都得依赖 GCC。既然高版本的 Glibc 依赖高版本的 GCC，那么就只能想办法安装较低版本的 Glibc——首先解决有没有（Linuxbrew 中的）Glibc 的问题，再去解决 Glibc 版本的问题。</p><p>为了安装低版本的 Glibc，我们要用到 <code>brew</code> 直接从 <code>tap</code> 中安装的特性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAKEFLAGS=<span class="string">""</span> \</span><br><span class="line">HOMEBREW_MAKE_JOBS=<span class="string">"1"</span> \</span><br><span class="line">brew install --verbose --ignore-dependencies https://raw.githubusercontent.com/Linuxbrew/homebrew-core/6fb5dfd50895416bea3d00628b8d3b41fa1f4f32/Formula/glibc.rb  <span class="comment"># Glibc 2.20</span></span><br></pre></td></tr></table></figure><p>讲一下这里的黑魔法。</p><p><code>MAKEFLAGS</code> 和 <code>HOMEBREW_MAKE_JOBS</code> 的设定，都是为了让编译 Glibc 的过程中使用非并行编译。这是因为并行编译 Glibc 2.20 时，因为 Makefile 依赖没写好，会产生一些问题。</p><p><code>--verbose</code> 参数的意义是让 <code>brew</code> 打印尽可能多的调试信息。<code>--ignore-dependencies</code> 则是无奈之举，因为 Glibc 依赖的东西反过来又会依赖 Glibc，于是 Linuxbrew 会尝试去安装高版本 Glibc，这就毁了。</p><p>执行这条命令，Linuxbrew 首先还是会去尝试安装 <code>curl</code> 和 <code>git</code>。而它们又依赖 Glibc，所以又会尝试安装高版本的 Glibc，依然会失败。这没办法，由着他们失败去。等它们失败之后，就会尝试安装 Glibc 2.20。</p><h2 id="解决-GCC-的问题"><a href="#解决-GCC-的问题" class="headerlink" title="解决 GCC 的问题"></a>解决 GCC 的问题</h2><p>接下来要解决的是 GCC 的问题。因为但凡碰到要编译的，都离不开它。于是我们有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --verbose --ignore-dependencies xz gmp mpfr libmpc isl gcc</span><br></pre></td></tr></table></figure><p>这里安装 <code>xz</code>, <code>gmp</code>, <code>mpfr</code>, <code>libmpc</code>, <code>isl</code> 的原因是 GCC 自身就依赖他们——哪怕你不使用 Linuxbrew，手动编译 GCC 时，你也得安装它们。</p><h2 id="安装-curl-和-git"><a href="#安装-curl-和-git" class="headerlink" title="安装 curl 和 git"></a>安装 <code>curl</code> 和 <code>git</code></h2><p>有了 Glibc 和 GCC，安装 <code>curl</code> 和 <code>git</code> 就不成问题了。我们有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install --verbose curl git</span><br><span class="line">brew update  --verbose --force</span><br></pre></td></tr></table></figure><h2 id="升级-Glibc"><a href="#升级-Glibc" class="headerlink" title="升级 Glibc"></a>升级 Glibc</h2><p>之前我们安装的是 Glibc 2.20，现在我们来升级它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAKEFLAGS=<span class="string">""</span> \</span><br><span class="line">HOMEBREW_MAKE_JOBS=<span class="string">"1"</span> \</span><br><span class="line">brew upgrade glibc --verbose</span><br></pre></td></tr></table></figure><h2 id="重新安装-GCC"><a href="#重新安装-GCC" class="headerlink" title="重新安装 GCC"></a>重新安装 GCC</h2><p>因为 GCC 依赖的 Glibc 发生了变化，这导致 GCC 不可用。因此我们要做一些调整。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew postinstall gcc</span><br></pre></td></tr></table></figure><p>如此，万事 okay~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本着 Homebrew 真香的原则，我尝试在 CentOS 上安装 Linuxbrew。至于不用 Yum 的原因，请看刚才提到的真香原则。&lt;/p&gt;
&lt;p&gt;但随即，我就陷入到了 Glibc 的泥潭。这个泥潭是一个需要自举（bootstrap）的循环依赖；这个泥潭长这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linuxbrew 安装任何东西都依赖 &lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;，而且它不想用系统中自带的 &lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt; 都直接或间接依赖 Glibc。&lt;/li&gt;
&lt;li&gt;Linuxbrew 里的 Glibc 版本比较高，目前是 2.23，因此依赖高版本的 GCC（&lt;code&gt;&amp;gt;= 4.7&lt;/code&gt;），以及因为 Linuxbrew 的缘故依赖 &lt;code&gt;curl&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;系统里的 GCC 版本较低，因此 Linuxbrew 安装 Glibc 失败；而通过 Linuxbrew 安装高版本的 GCC 又再次依赖 Glibc。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;泥潭里有两个循环依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Glibc 和 &lt;code&gt;curl&lt;/code&gt; 及 &lt;code&gt;git&lt;/code&gt; 等基础工具相互依赖；&lt;/li&gt;
&lt;li&gt;Glibc 和 GCC 相互依赖。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Homebrew" scheme="https://liam.page/tags/Homebrew/"/>
    
      <category term="Linuxbrew" scheme="https://liam.page/tags/Linuxbrew/"/>
    
      <category term="brwe" scheme="https://liam.page/tags/brwe/"/>
    
      <category term="Glibc" scheme="https://liam.page/tags/Glibc/"/>
    
  </entry>
  
  <entry>
    <title>USB 3.0 射频噪声对 2.4GHz 无线设备的干扰</title>
    <link href="https://liam.page/2020/01/19/USB-3-0-Radio-Frequency-Interference-Impact-on-2-4-GHz-Wireless-Devices/"/>
    <id>https://liam.page/2020/01/19/USB-3-0-Radio-Frequency-Interference-Impact-on-2-4-GHz-Wireless-Devices/</id>
    <published>2020-01-19T02:34:48.000Z</published>
    <updated>2020-03-02T14:20:07.826Z</updated>
    
    <content type="html"><![CDATA[<p>早些年，第一次使用 USB 3.0 硬盘的时候，我就发现了它对 Wi-Fi 网络信号的影响。为了解决这个问题，当时投资几百块，换了 NetGear 的路由器，并启用其 5GHz 的 Wi-Fi 信号。最近，在结合 rMBP 使用无线鼠标时，我发现鼠标经常出现跳帧的现象。因为距离上一次踩坑的时间已经过去六七年的时间，一时完全没想到可能是 USB 3.0 带来的问题。在经历了一系列折腾之后，才突然想起这个坑。特此记录。</p><a id="more"></a><h2 id="向外辐射的电磁波"><a href="#向外辐射的电磁波" class="headerlink" title="向外辐射的电磁波"></a>向外辐射的电磁波</h2><p>有高中物理电磁知识的人都应该知道一个基本事实：任何未经完全屏蔽的非直流电流，都会向外辐射电磁波。在高中物理中，它的基本形式就是 <a href="https://zh.wikipedia.org/wiki/LC%E7%94%B5%E8%B7%AF" target="_blank" rel="noopener">LC 谐振电路</a>。但另一方面，向外辐射电磁波的另一个条件是电路开路。也就是说，在连续的电路中，一般来说很难产生足以干扰其他设备的射频信号。此外，线缆通常也会考虑屏蔽电磁辐射。因此，一般来说，产生电磁射频噪声的干扰源，通常是电路的连接点，例如接头、引脚处。</p><h2 id="USB-3-0-的射频噪声"><a href="#USB-3-0-的射频噪声" class="headerlink" title="USB 3.0 的射频噪声"></a>USB 3.0 的射频噪声</h2><p>根据 Intel 于 2012 年发布的<a href="https://usb.org/sites/default/files/327216.pdf" target="_blank" rel="noopener">白皮书</a>，从 USB 3.0 的 <a href="https://zh.wikipedia.org/wiki/Sinc%E5%87%BD%E6%95%B0" target="_blank" rel="noopener"><code>sinc</code> 函数</a>来看，USB 3.0 的频谱很宽，从直流一直到 5GHz 都有所涉及。</p><p><img data-src="/uploads/images/computer-skills/usb3-sinc.jpg" alt></p><p>直接在笔记本上测量 USB 3.0 线对（transmit-pair）上的频谱则有如下分布。</p><p><img data-src="/uploads/images/computer-skills/usb3-noise-power-over-frequence.jpg" alt></p><p>于是，不难想见，USB 3.0 的接头处，在非常广的频谱上，都会向外辐射无线电干扰。那么射频干扰主要集中在什么频段呢？Intel 以实验说话，发现射频干扰主要集中在 2.4GHz -- 2.5GHz 之间。</p><p><img data-src="/uploads/images/computer-skills/usb3-noise-HDD.jpg" alt></p><p>那么为什么射频干扰主要集中在 2.4GHz -- 2.5GHz 之间呢？USB 3.0 是以 NRZ-I 方式进行编码的。因此，在一个时钟周期里，随着电平的两次翻转，可以传递出 2bit 的信息。考虑到 USB 3.0 的比特率是 5Gbps，即，每秒传输 5Gb。因此，它的电平周期是 2.5GHz。这就是 USB 3.0 设备产生的射频干扰集中在 2.5GHz 附近的原因。</p><h2 id="信噪比与干扰"><a href="#信噪比与干扰" class="headerlink" title="信噪比与干扰"></a>信噪比与干扰</h2><p>无线信号接收器是否能够正确解析无线信号，不仅取决于无线信号的强度，还取决于接收器所处环境的无线噪声强度。并不是说无线信号强度大，就一定能正确解析无线信号。假设有一个 -20 dBm（分贝毫瓦，对数能量单位）的信号，已经算很强了；但若环境中有一个 -20dBm 的同频率干扰信号，则原信号依然是不可辨别的。</p><p>因此，人们定义了信噪比（Signal-to-Noise ratio）这个概念。信噪比的单位也是分贝（dB）。</p><p><code>$$\text{SNR} = 10 \log_{10}\Bigl(\frac{P_{\text{signal}}}{P_{\text{noise}}}\Bigr).$$</code></p><p>为了能够正确解调无线信号，无线信号接收器都会有一个最低限度的信噪比要求。当无线信号过于衰弱，或是无线噪声过于强大时，信噪比就可能低于无线信号接收器所需的最低信噪比。如此一来，无线信号接收器就无法正常工作了。</p><h2 id="2-4GHz"><a href="#2-4GHz" class="headerlink" title="2.4GHz"></a>2.4GHz</h2><p>无线电信号频段是有限的资源。在大多数主要国家，都有相应的法律法规，来约束和限制无线电信号频段的使用。2.4GHz 是国际通用的不受约束的频段（当然，这里的不受约束，指的是你可以使用，但功率不能太大）。因此，大多数无线设备，都在这一频段工作。常见的有 Wi-Fi、无线鼠标、无线键盘、蓝牙等外设。</p><p>不巧的是，USB 3.0 的射频干扰主要集中在 2.4GHz 和 2.5GHz 之间，正好与这一通用频段重合。于是，USB 3.0 设备干扰 Wi-Fi、无线鼠标等，也就不奇怪了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法很简单。</p><ol><li>屏蔽：使用金属箔纸，将 USB 3.0 的连接处和电缆包裹起来，起到无线屏蔽的作用。当然，这对动手能力要求很高。</li><li>远离：由于无线信号强度随着信号源的距离的增加而快速衰减（平方衰减），因此，使用 USB 2.0 延长线，将无线信号接收器（如果有）远离 USB 3.0 的设备和借口，即可避免这一问题。</li><li>换频：由于 USB 3.0 的射频干扰主要集中在 2.4GHz 至 2.5GHz 之间，那么换成不在 2.4GHz 频段工作的设备即可。例如，可以更换成 5(.8) GHz 的设备。</li><li>有线：开历史倒车，从无线设备切换回到有线设备，彻底绕开无线干扰这个问题。<code>XD</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早些年，第一次使用 USB 3.0 硬盘的时候，我就发现了它对 Wi-Fi 网络信号的影响。为了解决这个问题，当时投资几百块，换了 NetGear 的路由器，并启用其 5GHz 的 Wi-Fi 信号。最近，在结合 rMBP 使用无线鼠标时，我发现鼠标经常出现跳帧的现象。因为距离上一次踩坑的时间已经过去六七年的时间，一时完全没想到可能是 USB 3.0 带来的问题。在经历了一系列折腾之后，才突然想起这个坑。特此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="USB" scheme="https://liam.page/tags/USB/"/>
    
      <category term="USB3.0" scheme="https://liam.page/tags/USB3-0/"/>
    
      <category term="Wireless" scheme="https://liam.page/tags/Wireless/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑨）：Linux 系统里的进程状态</title>
    <link href="https://liam.page/2020/01/10/the-states-of-processes-on-Linux/"/>
    <id>https://liam.page/2020/01/10/the-states-of-processes-on-Linux/</id>
    <published>2020-01-10T07:22:34.000Z</published>
    <updated>2020-03-02T14:20:07.826Z</updated>
    
    <content type="html"><![CDATA[<p>今天有同事问到 <code>top</code> 命令里的 <code>running</code>, <code>sleep</code>, <code>stop</code>, <code>zombie</code> 等进程状态分别是什么意思。于是借这个机会写一下 Linux 系统里的进程状态。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>进程（Process）即当前正在运行的计算机程序之实例。每个进程都有一些属性变量，这些变量决定了进程所能使用的计算机资源。进程执行过程中，会处在不同状态；正如人会处在不同的人生状态一样。</p><p>和人一样，进程也是进程它妈生的。进程从其父进程当中 <em>fork</em> 出来。而后，程在执行（running）的过程中，会用到一些可用的资源；这一点，和人也是一样的。如果把精力当成是一种资源，那么人睡觉就是等待精力这一资源的过程；进程也是一样，当进程执行所需的资源暂时不可用时，进程就会进入睡眠（sleeping）状态。当然，和人一样，进程也会死。一个进程可能会正常结束，相当于人的寿终正寝；也可能被杀死（kill a process）。</p><h2 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h2><p>Linux 系统里有几种不同类型的进程：用户进程（User processes）、守护进程（Deamon processes）和内核进程（Kernel processes）。</p><h3 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h3><p>系统里大多数进程都是用户进程。用户进程由通常的用户账户启动，并在用户空间（user space）当中执行。在没有获得额外许可的情况下，通常用户进程无法对处理器进行特殊访问，或是访问启动进程的用户无权访问的文件。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程通常是后台程序，它们往往由一些持续运行的服务来管理。守护进程可以用来监听请求，而后访问某些服务。举例来说，<code>httpd</code> 这一守护进程监听访问网络页面的请求。守护进程也可以用来自行启动一些任务。例如，<code>crond</code> 这一守护进程会在预设的时间点启动计划任务。</p><p>尽管用于管理守护进程的服务通常是 <code>root</code> 用户启动的，但守护进程本身往往以非 <code>root</code> 用户启动。这种启动方式，符合「只赋予进程运行所必须的权限」之要求，因而能使系统免于一些攻击。举例来说，若是黑客骇入了 <code>httpd</code> 这一由 <code>Apache</code> 用户启动的守护进程，黑客仍然无法访问包括 <code>root</code> 用户在内的其他用户的文件，或是影响其他用户启动的守护进程。</p><p>守护进程通常由系统在启动时拉起，而后一直运行到系统关闭。当然，守护进程也可以按需启动和终止，以及让守护进程在特定的系统运行级别上执行，或是在运行过程中触发重新加载配置信息。</p><h3 id="内核进程"><a href="#内核进程" class="headerlink" title="内核进程"></a>内核进程</h3><p>内核进程仅在内核空间（kernel space）当中执行。内核进程与守护进程有些相似；它们之间主要的不同在于：内核进程对内核数据结构拥有完全的访问权限。此外，内核进程不如守护进程灵活：修改配置文件并触发重载即可修改守护进程的行为；但对于内核进程来说，修改行为则需要重新编译内核本身。</p><h2 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h2><p>系统在进程启动时会赋予其状态。进程的状态由该进程的状态描述符来描述。设置进程状态，通常对应了一个简单的赋值操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><p>这里，<code>p</code> 代表进程，<code>state</code> 是其状态标识，<code>TASK_RUNNING</code> 表示该进程正在运行或可以执行。</p><p>进程通常处于以下两种状态之一：</p><ul><li>在 CPU 上执行（此时，进程正在运行）</li><li>不在 CPU 上执行（此时，进程未在运行）</li></ul><p>同一时间同一 CPU 上只能运行一个进程，其他进程就只能等待，或处于其他状态。也就是说，未在运行的进程可能处于不同状态：</p><ul><li>可运行状态</li><li>可中断之睡眠状态</li><li>不可中断之睡眠状态</li><li>僵死状态</li></ul><p>接下来，详细说说不同状态。</p><h3 id="P-之初（人之初）"><a href="#P-之初（人之初）" class="headerlink" title="P 之初（人之初）"></a>P 之初（人之初）</h3><p>按 <code>fork(2)</code> 的手册页（执行 <code>man 2 fork</code> 可打开），<code>fork</code> 这一系统调用创建一个与调用 <code>fork</code> 的进程几乎完全相同的进程。这里，前者称为父进程，后者称为子进程。子进程与父进程几乎完全相同，但有以下一些差别：</p><ul><li>子进程拥有全局唯一的进程 ID（见 <code>setpgid(2)</code> 的手册页）</li><li>子进程的父进程 ID 是父进程的进程 ID</li><li>子进程不继承父进程的内存锁（见 <code>mlock(2)</code> 和 <code>mlockall(2)</code> 的手册页）</li><li>子进程的资源使用计数及 CPU 时间计数（见 <code>getrusage(2)</code> 和 <code>times(2)</code> 的手册页）重置为零</li><li>子进程未处理的信号队列重置为空（见 <code>sigpending(2)</code> 的手册页）</li><li>子进程不继承父进程的信号量修正（见 <code>semop(2)</code> 的手册页）</li><li>子进程不继承父进程的文件区域锁（record lock / file-region lock，见 <code>fcntl(2)</code> 的手册页）</li><li>子进程不继承父进程的计时器（见 <code>setitimer(2)</code>, <code>alarm(2)</code> 和 <code>timer_create(2)</code> 的手册页）</li><li>子进程不继承父进程未完成的异步输入输出操作（outstanding asynchronous I/O operations）（见 <code>aio_read(3)</code> 和 <code>aio_write(3)</code> 的手册页）</li><li>子进程不继承父进程的异步输入输出上下文（asynchronous I/O contexts）（见 <code>io_setup(2)</code> 的手册页）</li></ul><h3 id="正在运行状态"><a href="#正在运行状态" class="headerlink" title="正在运行状态"></a>正在运行状态</h3><p>系统中最珍贵的资源是 CPU。正使用 CPU 的进程处于「正在运行状态」。在 <code>ps</code> 或是 <code>top</code> 中，状态标识为 <code>R</code> 的进程，即处于正在运行状态。</p><p>接下来，我们看看进程是怎么进入「正在运行状态」的。比方说，你在 Shell（以 <code>bash</code> 为例）中执行 <code>ls</code> 命令时，Shell 会在环境变量 <code>PATH</code> 记录的搜索路径里寻找 <code>ls</code> 命令对应的可执行文件。找到后，Shell 使用 <code>fork</code> 克隆自身进程，而后在子进程中，使用 <code>ls</code> 的可执行文件替换虚存空间中 Shell 的内容。</p><p>此时，系统会设置子进程的运行状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><p>CPU 即可在内核模式运行，又可在用户模式运行。当用户初始化一个进程，进程在用户空间运行，对应 CPU 在用户模式运行。在用户空间运行的进程无权访问内核数据结构和算法。各型号的 CPU 都会提供一些特定的指令，以便在内核模式和用户模式之间切换。如果一个用户级的进程需要访问内核数据结构或算法，则它需要使用系统调用来与文件子系统或是进程控制子系统之间进行交互。部分系统调用罗列如下：</p><ul><li>文件子系统对应的系统调用：<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>chmod()</code> 以及 <code>chown()</code></li><li>进程控制子系统对应的系统调用：<code>fork()</code>, <code>exec()</code>, <code>exit()</code>, <code>wait()</code>, <code>brk()</code> 以及 <code>signal()</code></li></ul><p>当内核开始处理来自用户级进程的请求，相应进程就进入了内核空间，对应 CPU 就在内核模式运行。<code>/proc/&lt;pid&gt;/stat</code> 中的第 14 和 15 项，分别记录了进程在用户空间和内核空间执行的时间。摘录部分 <code>proc(5)</code> 的手册页内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">utime %lu</span><br><span class="line">  Amount of time that this process has been scheduled in user mode,</span><br><span class="line">  measured in clock ticks (divide by sysconf(_SC_CLK_TCK). This</span><br><span class="line">  includes guest time, guest_time (time spent running a virtual CPU, see</span><br><span class="line">  below), so that applications that are not aware of the guest time field do</span><br><span class="line">  not lose that time from their calculations.</span><br><span class="line"></span><br><span class="line">stime %lu</span><br><span class="line">  Amount of time that this process has been scheduled in kernel mode,</span><br><span class="line">  measured in clock ticks (divide by sysconf(_SC_CLK_TCK).</span><br></pre></td></tr></table></figure><p><code>top</code> 命令的 CPU 统计行，则展示了 CPU 位于用户模式和内核模式的时间占比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top - 12:27:25 up 2:51, 4 users, load average: 4.37, 3.64, 3.44</span><br><span class="line">Tasks: 194 total, 2 running, 192 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 57.0%us, 1.3%sy, 0.0%ni, 41.1%id, 0.0%wa, 0.4%hi, 0.1%si, 0.0%st</span><br></pre></td></tr></table></figure><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>进程获取了所有所需资源，正等待 CPU 时，就会进入可运行状态。处于可运行状态的进程在 <code>ps</code> 的输出中，也已 <code>R</code> 标识。</p><p>举例来说，一个正在 I/O 的进程并不立即需要 CPU。当进程完成 I/O 操作后，就会触发一个信号，通知 CPU 和调度器将该进程置于运行队列（由内核维护的可运行进程的列表）。当 CPU 可用时，该进程就会进入正在运行状态。</p><p>和正在运行状态一样，进程的状态被设置为 <code>TASK_RUNNING</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure><h3 id="睡眠状态"><a href="#睡眠状态" class="headerlink" title="睡眠状态"></a>睡眠状态</h3><p>当进程所需的资源暂不可用时，就会进入睡眠状态。此时，进程要么主动进入睡眠状态，要么被内核置于睡眠状态（不管你想不想睡，反正内核会让你睡；因此，后者又称为「进程被内核睡了」）。进入睡眠状态的进程，会立即交出 CPU 的使用权。</p><p>当进程所需的资源可用时，CPU 会收到一个信号。于是，当调度器下次调度该进程时，会将它置为正在运行或可以运行状态。</p><p>以 login shell 进程为例，它</p><ul><li>在你键入命令时进入睡眠状态，同时等待一个特定的事件（取决与你键入执行的命令）；</li><li>Shell 进程睡眠时，会进入一个特定的等待通道（<code>WCHAN</code>, wait channel，同样取决于你键入执行的命令）；</li><li>当 Shell 进程等待的事件发生时（例如，收到一个来自键盘的中断 <code>^C</code>），在该等待通道的所有进程都会苏醒。</li></ul><p>执行 <code>ps -l</code> 可看到与当前 shell 关联的进程，执行 <code>ps -el</code> 则可看到系统上所有进程。如果进程处于睡眠状态，<code>ps</code> 输出中的 <code>WCHAN</code> 字段会显示进程在等待什么系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -l | more</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R   867 12085 27779  0  80   0 - 27029 -      pts/480  00:00:00 ps</span><br><span class="line">0 S   867 12086 27779  0  80   0 - 25779 pipe_w pts/480  00:00:00 more</span><br><span class="line">0 S   867 27779 35146  0  80   0 - 27721 do_wai pts/480  00:00:01 bash</span><br></pre></td></tr></table></figure><p>例如，在这里，我们执行了 <code>ps -l | more</code> 这个命令。输出中，<code>more</code> 和 <code>bash</code> 都处于睡眠状态。前者是在等待管道输入，即 <code>pipe_wait</code>，因为 <code>ps</code> 输出时，<code>more</code> 还没有接到内容。后者是在 等待 <code>ps -l | more</code> 执行完毕，即等待 <code>do_wait</code> 系统调用。</p><p>除了等待资源之外，进程也可以主动进入睡眠状态并持续一段时间。例如，<code>sleep()</code> 函数接收一个时间长度（以秒为单位，比如 10 秒）的参数，然后调用该函数的进程就会进入睡眠状态，并持续 10 秒。当睡眠时间结束后，调度器再次调度到该进程时，会将其设置为可运行状态。之后，当 CPU 空闲时，进程会重新进入正在运行状态。</p><blockquote><p>由此可见，<code>sleep(10)</code> 并不能保证「恰好」睡眠 10 秒，它只保证睡眠时间不少于 10 秒。</p></blockquote><p>部分进程永远不会终止，而是不断地在睡眠、唤醒干活的状态中循环。每次循环开始时，进程进入睡眠状态，然后等待某个特定的事件。当事件发生时，进程被唤醒（进入正在运行或者可以运行状态），然后处理任务。</p><p>睡眠状态也分可中断之睡眠状态和不可中断之睡眠状态。</p><h4 id="可中断之睡眠状态"><a href="#可中断之睡眠状态" class="headerlink" title="可中断之睡眠状态"></a>可中断之睡眠状态</h4><p>可中断之睡眠状态表示进程在等待时间片段或者某个特定的事件。一旦事件发生，进程会从可中断之睡眠状态中退出。<code>ps</code> 命令的输出中，可中断之睡眠状态标识为 <code>S</code>。</p><p>系统会为可中断之睡眠状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_INTERRUPTABLE;</span><br></pre></td></tr></table></figure><h4 id="不可中断之睡眠状态"><a href="#不可中断之睡眠状态" class="headerlink" title="不可中断之睡眠状态"></a>不可中断之睡眠状态</h4><p>不可中断之睡眠状态的进程不会处理任何信号，而仅在其等待的资源可用或超时时退出（前提是设置了超时时间）。</p><p>不可中断之睡眠状态通常和设备驱动等待磁盘或网络 I/O 有关。在内核源码 <code>fs/proc/array.c</code> 中，其文字定义为 <code>&quot;D (disk sleep)&quot;, /* 2 */</code>。当进程进入不可中断之睡眠状态时，进程不会处理信号，而是将信号都积累起来，等进程唤醒之后再处理。在 Linux 中，<code>ps</code> 命令使用 <code>D</code> 来标识处于不可中断之睡眠状态的进程。</p><p>系统会为不可中断之睡眠状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_UNINTERRUPTABLE;</span><br></pre></td></tr></table></figure><p>由于处于不可中断之睡眠状态的进程不会处理任何信号，所以 <code>kill -9</code> 也杀不掉它。解决此类进程的办法只有两个:</p><ul><li>对于怨妇，你还能怎么办，只能满足它啊：搞定不可中断之睡眠状态进程所等待的资源，使资源可用。</li><li>如果满足不了它，那就只能 kill the world——重启系统。</li></ul><h3 id="进程的终止和僵尸状态"><a href="#进程的终止和僵尸状态" class="headerlink" title="进程的终止和僵尸状态"></a>进程的终止和僵尸状态</h3><p>进程可以主动调用 <code>exit</code> 系统调用来终止，或者接受信号来由信号处理函数来调用 <code>exit</code> 系统调用来终止。</p><p>当进程执行 <code>exit</code> 系统调用后，进程会释放相应的数据结构；此时，进程本身已经终止。不过，此时操作系统还没有释放进程表中该进程的槽位（可以形象地理解为，「父进程还没有替子进程收尸」）；为解决这个问题，终止前，进程会向父进程发送 <code>SIGCHLD</code> 信号，通知父进程来释放子进程在操作系统进程表中的槽位。这个设计是为了让父进程知道子进程退出时所处的状态。</p><p>子进程终止后到父进程释放进程表中子进程所占槽位的过程，子进程进入僵尸状态（zombie state）。如果在父进程因为各种原因，在释放子进程槽位之前就挂掉了，也就是，父进程来不及为子进程收尸。那么，子进程就会一直处于僵尸状态。而考虑到，处于僵尸状态的进程本身已经终止，无法再处理任何信号，所以它就只能是孤魂野鬼，飘在操作系统进程表里，直到系统重启。</p><p>在 <code>ps</code> 命令的输出中，僵尸状态的进程标识为 <code>Z</code>。系统会为僵尸状态的进程设置进程运行状态为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_ZOMBIE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有同事问到 &lt;code&gt;top&lt;/code&gt; 命令里的 &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;zombie&lt;/code&gt; 等进程状态分别是什么意思。于是借这个机会写一下 Linux 系统里的进程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Process" scheme="https://liam.page/tags/Process/"/>
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
  </entry>
  
</feed>
