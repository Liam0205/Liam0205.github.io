<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2020-10-27T13:50:35.260Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 C++ 中实现一个单例类模板</title>
    <link href="https://liam.page/2020/10/27/implement-a-singleton-class-template-in-cxx/"/>
    <id>https://liam.page/2020/10/27/implement-a-singleton-class-template-in-cxx/</id>
    <published>2020-10-27T13:14:18.000Z</published>
    <updated>2020-10-27T13:50:35.260Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是最简单的设计模式之一。在实际工程中，如果一个类的对象重复持有资源的成本很高，且对外接口是线程安全的，我们往往倾向于将其以单例模式管理。</p><p>此篇我们在 C++ 中实现正确的单例模式。</p><a id="more"></a><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>在 C++ 中，单例模式有两种方案可选。</p><ul><li>一是实现一个没有可用的公开构造函数的基类，并提供 <code>GetInstance</code> 之类的静态接口，以便访问子类唯一的对象。由于子类构造必须调用基类构造，但基类无公开构造函数可用，这使得子类对象无法由基类及基类的友元来构造，从而在机制上保证单例。</li><li>二是实现一个类模板，其模板参数是希望由单例管理的类的名字，并提供 <code>GetInstance</code> 之类的静态接口。这种做法的好处是希望被单例管理的类，可以自由编写，而无需继承基类；并且在需要的时候，可以随时脱去单例外衣。</li></ul><p>此篇选择实现一个单例类模板，其形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里重载成员访问运算符，是为了可以实现这样的简写 <code>Singleton&lt;T&gt;()-&gt;func()</code>。</p><p>显然，单例的实现核心在于静态成员函数 <code>T* get()</code>。</p><h2 id="一个典型的错误实现"><a href="#一个典型的错误实现" class="headerlink" title="一个典型的错误实现"></a>一个典型的错误实现</h2><p>一个典型的错误实现，是使用所谓的双重检查（double check）。</p><figure class="highlight cpp"><figcaption><span>错误的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;mtx&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> T;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton&lt;T&gt;::mtx;</span><br></pre></td></tr></table></figure><p>外层的检查，是为了避免锁住过大的区域，从而导致锁的竞争特别频繁；内层的检查，是为了确保只在别的线程没有提前抢占锁完成初始化工作而设计的。这种做法在 Java 下是正确的，但是在 C++ 下则没有保证。具体解析可以参看<a href="/2017/01/17/layers-and-operation-system/#CPU-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6">这篇旧文</a>。</p><p>另外，值得一提的是，这里 <code>p</code> 的初始化的线程安全性，是由 C++ 标准保证的。——在 C++11 之后，标准保证函数静态成员的初始化是线程安全的；对其读写则不保证线程安全。</p><h2 id="使用标准库提供的设施"><a href="#使用标准库提供的设施" class="headerlink" title="使用标准库提供的设施"></a>使用标准库提供的设施</h2><p>在单例的实现中，我们实际上是希望实现「执行且只执行一次」的语义。C++11 之后，标准库实际已经提供了这样的设施。其名为 <code>std::once_flag</code> 和 <code>std::call_once</code>。它们内部利用互斥量和条件变量组合，实现这样的语义。值得一提的是，如果执行过程中抛出异常，标准库的设施不认为这是一次「成功的执行」。于是其他线程可以继续抢占锁来执行函数。</p><p>我们利用标准库设施来实现这个类模板。</p><figure class="highlight cpp"><figcaption><span>利用标准库设施的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">      p = <span class="keyword">new</span> T;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::once_flag Singleton&lt;T&gt;::flag;</span><br></pre></td></tr></table></figure><p>于是你可以写出类似这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;mtx&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">this</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt;&gt; futs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    futs.emplace_back(<span class="built_in">std</span>::async(&amp;Foo::address, Singleton&lt;Foo&gt;::get()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; fut : futs) &#123;</span><br><span class="line">    fut.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的输出类似这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br></pre></td></tr></table></figure><blockquote><p>Bonus：需要注意的是，所有的 <code>std::once_flag</code> 内部共享了同一对互斥量和条件变量。因此当存在很多 <code>std::call_once</code> 的时候，性能会有所下降。这一点可能需要注意一下。不过，如果存在很多 <code>std::call_once</code>，大概也说明程序设计不合理吧……</p></blockquote><h2 id="如此如此，这般这般"><a href="#如此如此，这般这般" class="headerlink" title="如此如此，这般这般"></a>如此如此，这般这般</h2><p>如果你仔细读了这篇文章，你可能会忽然意识到刚才看到了这句话：「在 C++11 之后，标准保证函数静态成员的初始化是线程安全的；对其读写则不保证线程安全。」</p><p>既然如此，我们为啥还要费劲使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 呢？直接利用 <code>static</code> hack 出一个单例类模板不就好了吗？</p><figure class="highlight cpp"><figcaption><span>利用标准库设施的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T ins;</span><br><span class="line">    <span class="keyword">return</span> &amp;ins;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是最简单的设计模式之一。在实际工程中，如果一个类的对象重复持有资源的成本很高，且对外接口是线程安全的，我们往往倾向于将其以单例模式管理。&lt;/p&gt;
&lt;p&gt;此篇我们在 C++ 中实现正确的单例模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Mutex" scheme="https://liam.page/tags/Mutex/"/>
    
      <category term="Threading" scheme="https://liam.page/tags/Threading/"/>
    
      <category term="Singleton" scheme="https://liam.page/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中实现一个正确的时间循环器</title>
    <link href="https://liam.page/2020/10/14/implement-a-timed-looper-in-cxx/"/>
    <id>https://liam.page/2020/10/14/implement-a-timed-looper-in-cxx/</id>
    <published>2020-10-14T10:05:36.000Z</published>
    <updated>2020-10-27T13:14:49.582Z</updated>
    
    <content type="html"><![CDATA[<p>实际工程中可能会有这样一类普遍需求：在服务中，单独起一个线程，以一个固定的时间间隔，周期性地完成特定的任务。我们把这种问题抽象成一个时间循环器。</p><a id="more"></a><h2 id="Naive-Way"><a href="#Naive-Way" class="headerlink" title="Naive Way"></a>Naive Way</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerCircle</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> running_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="keyword">uint64_t</span>         sleep_&#123;<span class="number">0U</span>L&#125;;</span><br><span class="line">  <span class="built_in">std</span>::thread      thread_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit TimerCircle(uint64_t s) : sleep_&#123;s&#125; &#123;&#125;</span><br><span class="line">  ~TimerCircle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_.joinable()) &#123;</span><br><span class="line">      terminate();</span><br><span class="line">      thread_.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  TimerCircle(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_ = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(&amp;TimerCircle::loop, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    running_.store(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    running_.store(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">while</span> (running_.load()) &#123;</span><br><span class="line">      do_something();</span><br><span class="line">      <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(sleep_));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现简单平凡，一眼就能看出来没啥问题，于是也没啥好说的。</p><h2 id="细节里的魔鬼"><a href="#细节里的魔鬼" class="headerlink" title="细节里的魔鬼"></a>细节里的魔鬼</h2><p>唯一的魔鬼藏在细节里。如果 <code>TimerCircle</code> 类型的对象发生析构，那么析构该对象的线程最多会被阻塞 <code>sleep_</code> 秒。如果周期很长，比如长达 6 小时，那这显然是不可接受。</p><p>为此，我们需要借助标准库的<a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait_for" target="_blank" rel="noopener">条件变量 <code>std::condition_variable</code> 的 <code>wait_for</code> 函数</a>的帮助。首先看其函数签名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_for</span><span class="params">(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="function"><span class="params">              Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>函数接受三个参数。<code>lock</code> 是一个 <code>unique_lock</code>，它必须为调用 <code>wait_for</code> 的线程所锁住；<code>rel_time</code> 是一个时间段，表示超时时间；<code>pred</code> 是一个谓词，它要么返回 <code>true</code> 要么返回 <code>false</code>。</p><p>一旦调用，函数会阻塞当前线程，直到两种情况返回：</p><ul><li>超时；此时函数返回 <code>pred()</code>。</li><li>条件变量被通知，且谓词返回 <code>true</code>；此时函数返回 <code>true</code>。</li></ul><p>于是我们可以实现一个 <code>Countdown</code> 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> <span class="title">final</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">bool</span>    running_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex              mutex_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Countdown() = <span class="keyword">default</span>;</span><br><span class="line">  ~Countdown() = <span class="keyword">default</span>;</span><br><span class="line">  Countdown(<span class="keyword">const</span> Countdown&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Countdown&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Countdown&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Countdown(Countdown&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Countdown&amp; <span class="keyword">operator</span>=(Countdown&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex_);</span><br><span class="line">      running_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv_.notify_all();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Peroid&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">wait_for</span><span class="params">(<span class="built_in">std</span>::chrono::duration&lt;Rep, Peroid&gt;&amp;&amp; duration)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex_);</span><br><span class="line">    <span class="keyword">bool</span> terminated = cv_.wait_for(lock, duration, [&amp;]() &#123; <span class="keyword">return</span> !running_; &#125;);</span><br><span class="line">    <span class="keyword">return</span> !terminated;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>于是，<code>TimerCircle</code> 就变成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerCircle</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span>    sleep_&#123;<span class="number">0U</span>L&#125;;</span><br><span class="line">  Countdown   cv_;</span><br><span class="line">  <span class="built_in">std</span>::thread thread_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit TimerCircle(uint64_t s) : sleep_&#123;s&#125; &#123;&#125;</span><br><span class="line">  ~TimerCircle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_.joinable()) &#123;</span><br><span class="line">      terminate();</span><br><span class="line">      thread_.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  TimerCircle(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TimerCircle&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TimerCircle(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  TimerCircle&amp; <span class="keyword">operator</span>=(TimerCircle&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_ = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(&amp;TimerCircle::loop, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv_.terminate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cv_.wait_for(<span class="built_in">std</span>::chrono::seconds(sleep_))) &#123;</span><br><span class="line">      do_something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单，明了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际工程中可能会有这样一类普遍需求：在服务中，单独起一个线程，以一个固定的时间间隔，周期性地完成特定的任务。我们把这种问题抽象成一个时间循环器。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Mutex" scheme="https://liam.page/tags/Mutex/"/>
    
      <category term="Threading" scheme="https://liam.page/tags/Threading/"/>
    
      <category term="ConditionVariable" scheme="https://liam.page/tags/ConditionVariable/"/>
    
  </entry>
  
  <entry>
    <title>手动安装 XCode Command Line Tools</title>
    <link href="https://liam.page/2020/10/13/install-XCode-Command-Line-Tools-manually/"/>
    <id>https://liam.page/2020/10/13/install-XCode-Command-Line-Tools-manually/</id>
    <published>2020-10-13T09:00:43.000Z</published>
    <updated>2020-10-14T14:54:47.143Z</updated>
    
    <content type="html"><![CDATA[<p>使用 macOS 时，Apple 自家的 XCode Command Line Tools 基本上很难绕开。比如你想用 Homebrew 安装点什么东西，它都会依赖 XCode CLT。</p><p>比较不幸地是，如果你更新了 macOS，那你就得重新安装 XCode。如果你重新安装 XCode，那么匹配版本的 CLT 也得重新安装。更为不幸的是，最近使用 <code>xcode-select --install</code> 安装 CLT，经常失败。遂起了手动安装的念头。</p><p>摸索后步骤如下：</p><ul><li>Apple 家官网：<a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">https://developer.apple.com/download/more/</a></li><li>以 Apple ID 登录</li><li>在搜索框搜索 <code>Command Line Tools</code></li><li>打开你 macOS 上的 XCode，检查其版本号</li><li>下载对应版本的 <code>Command Line Tools</code> 镜像（<code>*.dmg</code>）</li><li>从镜像里手工安装</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 macOS 时，Apple 自家的 XCode Command Line Tools 基本上很难绕开。比如你想用 Homebrew 安装点什么东西，它都会依赖 XCode CLT。&lt;/p&gt;
&lt;p&gt;比较不幸地是，如果你更新了 macOS，那你就得重新安装 XCode。如
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="XCode" scheme="https://liam.page/tags/XCode/"/>
    
      <category term="CLT" scheme="https://liam.page/tags/CLT/"/>
    
  </entry>
  
  <entry>
    <title>快速生成 HTML 表格代码</title>
    <link href="https://liam.page/2020/07/29/tools-for-generating-HTML-table/"/>
    <id>https://liam.page/2020/07/29/tools-for-generating-HTML-table/</id>
    <published>2020-07-28T16:27:53.000Z</published>
    <updated>2020-07-28T16:30:07.864Z</updated>
    
    <content type="html"><![CDATA[<p>最近写博客的时候，需要用到表格。然后不可避免地再次发现 Markdown 孱弱的表格语法，于是又一次不能忍。</p><p>于是发现了这个<a href="https://www.tablesgenerator.com/html_tables" target="_blank" rel="noopener">神奇的网站</a>。它允许你从 Excel 当中贴入设计好的表格，然后自动生成相应的 HTML 表格代码（及所需的 CSS 样式表）。</p><p>简直是神器！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写博客的时候，需要用到表格。然后不可避免地再次发现 Markdown 孱弱的表格语法，于是又一次不能忍。&lt;/p&gt;
&lt;p&gt;于是发现了这个&lt;a href=&quot;https://www.tablesgenerator.com/html_tables&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Markdown" scheme="https://liam.page/tags/Markdown/"/>
    
      <category term="HTML" scheme="https://liam.page/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>修改休眠模式以节省 macOS 睡眠时的电池电量</title>
    <link href="https://liam.page/2020/07/26/change-hibernatemode-to-save-battery-on-macOS/"/>
    <id>https://liam.page/2020/07/26/change-hibernatemode-to-save-battery-on-macOS/</id>
    <published>2020-07-26T10:38:06.000Z</published>
    <updated>2020-09-30T09:37:11.644Z</updated>
    
    <content type="html"><![CDATA[<p>切换到 Mac 已经有六年了；一直以来，就发现 MacBook Pro 在扣上盖子睡眠时，会有明显的掉电现象。我觉着这么多年，我一直没去处理它，也是挺能忍的。</p><p>然而今天忍不了了哇。</p><a id="more"></a><h2 id="GUI-设置"><a href="#GUI-设置" class="headerlink" title="GUI 设置"></a>GUI 设置</h2><p>一般用户自然是会从 GUI 设置当中找寻相关线索。</p><p>于是我们打开「系统偏好设置」-「节能」-「电池」标签。</p><p><img data-src="/uploads/images/macOS/energy-saving.jpg" alt></p><p>可见，除了关闭显示器的时间，我的设置已经尽可能节能了；而我们讨论的是合盖睡眠的场景，所以关闭显示器的时间在这里不影响。</p><h2 id="macOS-睡眠机制"><a href="#macOS-睡眠机制" class="headerlink" title="macOS 睡眠机制"></a>macOS 睡眠机制</h2><p>既然 GUI 设置不解决问题，我们就要考虑深入了解 macOS 的睡眠机制了。</p><p>在 Google 上检索 <em>macOS hibernate</em>，比较可惜的是未能找到 Apple 官方的文档。不过，在 Stack Exchange 上我找到了<a href="https://apple.stackexchange.com/questions/51725/do-macbooks-have-a-true-hibernate-option" target="_blank" rel="noopener">这篇回答</a>。</p><p>按照这篇回答的说法，macOS 默认的睡眠，会关闭屏幕，但会维持用于内存（RAM）的供电。这样一来，一旦打开盖子，macOS 就能立即恢复。若是电池电量低于某个预设阈值，则会将内存中的数据转储到硬盘，而后彻底断电。</p><p>这样一来，macOS 睡眠时掉电就解释得通了。</p><p>原作者还提供了一个 <a href="http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/pmset.1.html" target="_blank" rel="noopener">Apple 官方的链接</a>，但无法打开。根据链接内容，看起来是 <code>pmset</code> 这个命令的 <code>man</code> 内容。于是在终端中执行 <code>man pmset</code> 查看相关信息。</p><p>经查，</p><ul><li>macOS 的睡眠有两种状态<ul><li>不断电，数据存储在内存中，可以快速恢复。我们称这种状态为睡眠（Sleep）</li><li>断电，数据存储在硬盘中，恢复得较慢。我们称这种状态为休眠（Hibernate/Stand-by）</li></ul></li><li>睡眠和休眠可以组合出三种模式，由 <code>hibernatemode</code> 控制<ul><li><code>hibernatemode = 0</code>，这是桌面设备的默认值。系统只睡眠，不休眠，不将数据存储在硬盘中。</li><li><code>hibernatemode = 3</code>，这是移动设备的默认值。系统默认睡眠，在一定时间后或电量低于阈值将数据存储在硬盘中，而后休眠。这是所谓的安全睡眠（Safe-Sleep）。</li><li><code>hibernatemode = 25</code>。只休眠，不睡眠。</li></ul></li><li>无论是安全睡眠模式还是休眠模式，从磁盘上恢复时，都会需要一定的时间（经测试，大约 3 秒钟）屏幕才会被点亮。</li></ul><p>对于 <code>hibernatemode = 3</code>，即安全睡眠模式，又有几个参数来控制细节。</p><ul><li>当剩余电量大于 <code>highstandbythreshold</code>（默认 50%）时，在 <code>standbydelayhigh</code> 秒（默认 86,400，即一整天）后进入休眠。</li><li>当剩余电量小于 <code>highstandbythreshold</code> 时，在 <code>standbydelaylow</code> 秒（默认 10,800，即三小时）后进入休眠。</li></ul><h2 id="实际操作看看"><a href="#实际操作看看" class="headerlink" title="实际操作看看"></a>实际操作看看</h2><p>搞清楚具体机制之后，我们就可以做更多细节设置了。</p><p>如果你不在乎每次开盖后需要等待 3 -- 5 秒屏幕才电量，那么你可以直接禁用安全睡眠模式，盒盖休眠。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pmset -b hibernatemode 25</span><br></pre></td></tr></table></figure><p>如果你仍然希望使用安全睡眠模式，但希望不要掉电得太厉害，则可以适当修改 <code>highstandbythreshold</code> 和 <code>standbydelayhigh</code>/<code>standbydelaylow</code> 的值。比如我是这样设置的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When Using Battery</span></span><br><span class="line">sudo pmset -b hibernatemode 3</span><br><span class="line">sudo pmset -b highstandbythreshold 95</span><br><span class="line">sudo pmset -b standbydelayhigh 3600  <span class="comment"># 1 hour</span></span><br><span class="line">sudo pmset -b standbydelaylow  1800  <span class="comment"># half an hour</span></span><br><span class="line"><span class="comment"># When Using AC Power</span></span><br><span class="line">sudo pmset -c hibernatemode 3</span><br><span class="line">sudo pmset -c highstandbythreshold 80</span><br><span class="line">sudo pmset -c standbydelayhigh 86400  <span class="comment"># 24 hours</span></span><br><span class="line">sudo pmset -c standbydelaylow  10800  <span class="comment"># 3 hours</span></span><br></pre></td></tr></table></figure><p>如此一来，我的节能设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ pmset -g custom</span><br><span class="line">Battery Power:</span><br><span class="line"> lidwake              1</span><br><span class="line"> standbydelayhigh     3600</span><br><span class="line"> standbydelaylow      1800</span><br><span class="line"> standby              1</span><br><span class="line"> proximitywake        0</span><br><span class="line"> ttyskeepawake        1</span><br><span class="line"> highstandbythreshold 95</span><br><span class="line"> powernap             0</span><br><span class="line"> gpuswitch            2</span><br><span class="line"> hibernatefile        /var/vm/sleepimage</span><br><span class="line"> hibernatemode        3</span><br><span class="line"> displaysleep         64</span><br><span class="line"> sleep                1</span><br><span class="line"> tcpkeepalive         1</span><br><span class="line"> halfdim              1</span><br><span class="line"> acwake               0</span><br><span class="line"> lessbright           1</span><br><span class="line"> disksleep            5</span><br><span class="line">AC Power:</span><br><span class="line"> lidwake              1</span><br><span class="line"> standbydelayhigh     86400</span><br><span class="line"> standbydelaylow      10800</span><br><span class="line"> standby              1</span><br><span class="line"> proximitywake        1</span><br><span class="line"> ttyskeepawake        1</span><br><span class="line"> hibernatemode        3</span><br><span class="line"> powernap             1</span><br><span class="line"> gpuswitch            2</span><br><span class="line"> hibernatefile        /var/vm/sleepimage</span><br><span class="line"> highstandbythreshold 80</span><br><span class="line"> womp                 1</span><br><span class="line"> displaysleep         180</span><br><span class="line"> networkoversleep     0</span><br><span class="line"> sleep                1</span><br><span class="line"> tcpkeepalive         1</span><br><span class="line"> halfdim              1</span><br><span class="line"> acwake               0</span><br><span class="line"> disksleep            10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切换到 Mac 已经有六年了；一直以来，就发现 MacBook Pro 在扣上盖子睡眠时，会有明显的掉电现象。我觉着这么多年，我一直没去处理它，也是挺能忍的。&lt;/p&gt;
&lt;p&gt;然而今天忍不了了哇。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Hibernate" scheme="https://liam.page/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>何谓「内卷化」</title>
    <link href="https://liam.page/2020/07/22/what-is-involution/"/>
    <id>https://liam.page/2020/07/22/what-is-involution/</id>
    <published>2020-07-22T03:30:02.000Z</published>
    <updated>2020-07-26T10:20:06.458Z</updated>
    
    <content type="html"><![CDATA[<p>最近互联网上经常说内卷。特别是识得的一些清华大学的小同学们经常在我耳边卷啊卷。作为一个跟不上时代的过气年轻人，我无法理解内卷是什么意思，于是有上网检索。</p><a id="more"></a><h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><p>内卷的英文是 involution。在医学上，它表示萎缩或者退化。在 AHD 当中，它的解释是：</p><ul><li>A decrease in size of an organ, as of the uterus following childbirth.（器官在大小上的萎缩，例如生育之后女性子宫的萎缩。）</li><li>A progressive decline or degeneration of normal physiological functioning occurring as a result of the aging process.（因年龄增长而出现的身体正常功能的持续衰退或退化。）</li></ul><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p><a href="https://baike.baidu.com/item/%E5%86%85%E5%8D%B7%E5%8C%96" target="_blank" rel="noopener">百度百科</a>对内卷化的描述中，有如下内容：</p><blockquote><p>内卷化一词源于美国人类学家吉尔茨（Clifford Geertz）《农业内卷化——印度尼西亚的生态变化过程》（Agricultural Involution: The Processes of Ecological Change in Indonesia）。根据吉尔茨的定义，「内卷化」是指一种社会或文化模式在某一发展阶段达到一种确定的形式后，便停滞不前或无法转化为另一种高级模式的现象。这一概念最早是用来研究爪哇的水稻农业。在殖民地时代和后殖民地时代的爪哇，农业生产长期以来原地不动，未曾发展，只是不断地重复简单再生产。不能提高单位人均产值。</p><p>黄宗智在《长江三角洲小农家庭与乡村发展》中，把内卷化这一概念用于中国经济发展与社会变迁的研究，他把通过在有限的土地上投入大量的劳动力来获得总产量增长的方式，即边际效益递减的方式，称为没有发展的增长即「内卷化」。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从词典和百度百科的描述来看，内卷用在社会现象上时，表达的大概有几层含义：</p><ul><li>在宏观上，发展停滞不前，甚至在规模上萎缩退化。</li><li>在微观上，努力的效用停滞不前，甚至在边际效用上萎缩退化。</li></ul><p>用数学的语言来表述，就是社会发展水平和经济规模，一阶导数和二阶导数均为负数。</p><h2 id="生活化的理解"><a href="#生活化的理解" class="headerlink" title="生活化的理解"></a>生活化的理解</h2><p>上面的解释，都是比较学术派的解释，普通老百姓是不会满意于这种解释的。</p><h3 id="思维实验的结论"><a href="#思维实验的结论" class="headerlink" title="思维实验的结论"></a>思维实验的结论</h3><blockquote><p>以下没有参考来源，纯粹是不可靠的思维实验得出的结论。请谨慎参考。</p></blockquote><p>就我的观察，我理解内卷化现象是一种恶性循环。在恶性循环当中，大多数人的边际效用极低（因而获利极少）而极少数人边际效用极高（因而获利极大）。造成这种现象的原因主要是恶性竞争。而这种恶性竞争的起因至少有二：资源压力、信息不对称。用一句话说，内卷化现象是<strong>资源压力下信息不对称导致的恶性竞争导致大多数人边际效用极低而极少数人赚取到大量利益并陷入恶性循环</strong>。</p><p>这里有几个关键点。</p><p>首先是资源压力。</p><p>这里说的资源，是广义的资源。可以是钢铁、石油之类的实体资源；也可以是医疗、教育之类的社会资源；也可以是其它利用信息不对称，构建的心理资源。在发展的早期，社会整体资源利用率相对较低，并且人口数量也较少，因而人们感受不到资源压力。但发展到一定水平之后，资源的瓶颈就出现了。此时，社会内部的竞争就存在从良性竞争转向恶性竞争的趋势。</p><p>而后是信息不对称导致的边际效用的歧化。</p><p>某种意义上，对信息的全面了解，是作出正确决定的基石。当社会存在明显的信息不对称时，可能出现歧化现象：信息优势者，轻易作出正确决定，从而极大地提升生产效率；信息劣势者，容易作出错误决定，从而投入大量资源在低效的生产方式上。当歧化现象趋于严重且长期持续时，信息劣势者之间发生恶性竞争的可能性就会放大，从而出现「劣币驱逐良币」的现象。</p><p>最后是恶性循环。</p><p>信息不对称可能因正反馈而出现马太效应，从而使群体陷入恶性循环。假设在群体中，初始情况下人们对信息的了解程度是随机的。那么，具有相对信息优势的人，就容易做出正确决定，从而极大地提升生产效率，赚取大量利益。而当利益成为资本沉淀，又会相对更容易地获取信息优势，从而形成正反馈。简单来说，就是在信息优劣上，强者恒强、强者更强。在人性恶的一面被放大的情况下（毕竟，「资本永不眠」），具有绝对信息优势者，可能主动引导甚至加剧信息劣势者之间的恶性竞争，从而稳固自身的信息优势。</p><p>在内卷化的进程中，最令人感觉不公的，大概就是随机的初始条件。——最早你可能只是因为运气好，然后不断放大自己的优势，以至于现在无法逾越的优势鸿沟。</p><h3 id="破局之法"><a href="#破局之法" class="headerlink" title="破局之法"></a>破局之法</h3><p>内卷的产生，有几个先决条件：</p><ul><li>资源压力；</li><li>信息不对称；</li><li>恶性竞争。</li></ul><p>这里，基于我们尚未实现「世界大同」，因而在感受到资源压力且存在信息不对称现象的社会中，某种意义上，恶性竞争是人性的必然结果。因此，避免或减轻内卷，就要从资源压力和信息不对称上下手。我们有如下一些解法：</p><ul><li>知识和技术升级。通过技术升级，提升资源利用率，从而使有限的资源提供更大的社会生产，进而降低整体资源压力。</li><li>信息公平化。通过强制手段，维护和加强信息公平，避免信息为资本所控制。</li></ul><p>这里，知识和技术的升级是手段，而信息公平化是基石。之所以这样说，是因为在资本的加持下，知识和技术的升级会更容易和快速，若无信息公平，则知识和技术的升级反而可能会加剧内卷。在这个意义上，当今世界两种制度及其背后的意识形态之优劣，就很明显了。只可惜，「自由化」的糖衣炮弹太厉害，很多人是看不清的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近互联网上经常说内卷。特别是识得的一些清华大学的小同学们经常在我耳边卷啊卷。作为一个跟不上时代的过气年轻人，我无法理解内卷是什么意思，于是有上网检索。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Involution" scheme="https://liam.page/tags/Involution/"/>
    
  </entry>
  
  <entry>
    <title>Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</title>
    <link href="https://liam.page/2020/07/17/memory-stat-in-TOP/"/>
    <id>https://liam.page/2020/07/17/memory-stat-in-TOP/</id>
    <published>2020-07-17T07:30:36.000Z</published>
    <updated>2020-07-19T12:02:45.685Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统中，著名的 <code>top</code> 命令可列出各个进程对系统资源的利用情况。其中有 <code>VIRT</code>, <code>RES</code>, <code>SHR</code>, <code>CODE</code>, <code>DATA</code> 等几个字段，用来描述进程对内存的使用情况。（后二者默认不展示，需要按下 F 键，将相关字段调出来）。</p><p>但它们究竟表示什么含义呢？</p><a id="more"></a><h2 id="top-命令的文档"><a href="#top-命令的文档" class="headerlink" title="top 命令的文档"></a><code>top</code> 命令的文档</h2><p>执行 <code>man top</code> 可查看 <code>top</code> 命令的手册。可见这些字段的含义：</p><ul><li><code>VIRT</code> Virtual Memory Size (KiB)：进程使用的所有虚拟内存；包括代码（code）、数据（data）、共享库（shared libraries），以及被换出（swap out）到交换区和映射了（map）但尚未使用（未载入实体内存）的部分。</li><li><code>RES</code> Resident Memory Size (KiB)：进程所占用的所有实体内存（physical memory），不包括被换出到交换区的部分。</li><li><code>SHR</code> Shared Memory Size (KiB)：进程可读的全部共享内存，并非所有部分都包含在 <code>RES</code> 中。它反映了可能被其他进程共享的内存部分。</li><li><code>CODE</code> Code Size (KiB)：进程所占用的实体内存中，可执行代码所占用的内存大小。此项亦称为驻存代码集合（Text Resident Set, TRS）。</li><li><code>DATA</code> Data + Stack Size (KiB)：进程所占用的实体内存中，除去可执行代码所占用部分之外的内存大小。此项亦称为驻存数据集合（Data Resident Set, DRS）。</li></ul><p>但是，真的这样吗？</p><p><img data-src="/uploads/images/captures/top.jpg" alt></p><p>按照 <code>top</code> 命令的手册，应有等式 <code>CODE + DATA = RES</code> 成立。但这里，进程号为 22 的进程，<code>CODE</code> 为 59,984KiB，<code>DATA</code> 为 42.076GiB，<code>RES</code> 为 5.348GiB。显然不满足上述等式。</p><h2 id="top-命令的数据源"><a href="#top-命令的数据源" class="headerlink" title="top 命令的数据源"></a><code>top</code> 命令的数据源</h2><p>经查，<code>top</code> 命令读取的是 <code>/proc/&lt;pid&gt;/statm</code> 当中的数据。</p><blockquote><p>你可以通过 <code>cat /proc/&lt;pid&gt;/statm</code> 来查看。它有 7 列，分别是以内存页计算的 <code>VIRT</code>, <code>RES</code>, <code>SHR</code>, <code>CODE</code>, LRS, <code>DATA</code>, DIRTY。其中 LRS 和 DIRTY 自 Linux 2.6 开始不再使用。内存页的大小是 4KiB，因此，将内存页的数量乘以 4，就是以 KiB 计算的内存占用大小。</p></blockquote><p>而 <code>/proc/&lt;pid&gt;/statm</code> 当中的数据，是经过内核函数 <code>task_statm</code> 读取而后由 <code>procfs</code> 写入的。</p><p>我们来看看<a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/fs/proc/task_mmu.c#L87-L98" target="_blank" rel="noopener">内核函数 <code>task_statm</code></a> 是怎样定义的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">task_statm</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">unsigned</span> <span class="keyword">long</span> *shared, <span class="keyword">unsigned</span> <span class="keyword">long</span> *text,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">unsigned</span> <span class="keyword">long</span> *data, <span class="keyword">unsigned</span> <span class="keyword">long</span> *resident)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *shared = get_mm_counter(mm, MM_FILEPAGES) +</span><br><span class="line">      get_mm_counter(mm, MM_SHMEMPAGES);</span><br><span class="line">  *text = (PAGE_ALIGN(mm-&gt;end_code) - (mm-&gt;start_code &amp; PAGE_MASK))</span><br><span class="line">                &gt;&gt; PAGE_SHIFT;</span><br><span class="line">  *data = mm-&gt;data_vm + mm-&gt;stack_vm;</span><br><span class="line">  *resident = *shared + get_mm_counter(mm, MM_ANONPAGES);</span><br><span class="line">  <span class="keyword">return</span> mm-&gt;total_vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>get_mm_counter</code> 实际啥也没干，就是保证读取计数器的原子性——这是因为读取的是实体内存占用情况。</p><p>由此可知，并不一定有等式 <code>CODE + DATA = RES</code> 成立，但一定成立等式 <code>ANON = RES - SHR</code>。这里 <code>ANON</code> 表示在堆上分配的内存。</p><blockquote><p><a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm.h#L1843-L1856" target="_blank" rel="noopener"><code>get_mm_counter</code> 在 <code>mm.h</code> 中定义</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_mm_counter</span><span class="params">(struct mm_struct *mm, <span class="keyword">int</span> member)</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="keyword">long</span> val = atomic_long_read(&amp;mm-&gt;rss_stat.count[member]);</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> SPLIT_RSS_COUNTING</span></span><br><span class="line">&gt;   <span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;    * counter is updated in asynchronous manner and may go to minus.</span></span><br><span class="line"><span class="comment">&gt;    * But it's never be expected number for users.</span></span><br><span class="line"><span class="comment">&gt;    */</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (val &lt; <span class="number">0</span>)</span><br><span class="line">&gt;     val = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;   <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)val;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可见 <code>get_mm_counter</code> 其实啥也没干，就是保证读取计数器的原子性。</p></blockquote><!--* <https://github.com/torvalds/linux/blob/cbafe18c71028d5e0ee1626b4776fea5d5824a78/include/linux/mm_types_task.h>* <https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm_types.h#L384-L548> --><p>从代码可见</p><ul><li><code>shared</code> 是共享文件和动态库占用实体内存页（memory page）之和；它对应 <code>SHR</code>。</li><li><code>text</code> 是代码段占用内存页；它对应 <code>CODE</code>。</li><li><code>data</code> 是 <code>VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK</code> 与 <code>VM_STACK</code> 占用内存页之和，也就是所有非栈内存中可写但非共享内存页与栈内存页之和；它对应 <code>DATA</code>。</li><li><code>resident</code> 是 <code>shared</code> 和实体匿名内存页（memory page）之和；它对应 <code>RES</code>。</li><li>return value 是整个虚拟内存的内存页；它对应 <code>VIRT</code>。</li></ul><p>从代码来看，<code>VIRT</code>, <code>SHR</code>, <code>CODE</code>, <code>RES</code> 与 <code>top</code> 命令的手册吻合，区别在于 <code>DATA</code> 这个字段——从我们观察到的现象，也确实在 <code>DATA</code> 上有明显的问题。</p><h2 id="DATA-之谜"><a href="#DATA-之谜" class="headerlink" title="DATA 之谜"></a><code>DATA</code> 之谜</h2><p>在<a href="/2016/05/01/Introduction-to-Memory-Addressing/#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">老文</a>中，我们谈到了虚拟内存和物理内存（实体内存）之间的差别与联系。在 Linux 中，进程能直接看到的，都是虚拟内存。</p><p>对于每一个虚拟内存页，根据其是否有对应的实体内存帧对应，有三种状态：</p><ol><li>该页没有实体内存帧与之对应；记为 vm_unmapped。</li><li>该页有实体内存帧与之对应，且未被换出到交换区；记为 vm_physic。</li><li>该页有实体内存帧与之对应，但已被换出到交换区；记为 vm_swap。</li></ol><p>在本文讨论的五个字段当中，按照是否有强调为 vm_physic，记录如下：</p><table><thead><tr><th></th><th><code>top</code> 手册</th><th>内核代码</th></tr></thead><tbody><tr><td><code>VIRT</code></td><td>x</td><td>x</td></tr><tr><td><code>RES</code></td><td>y</td><td>y</td></tr><tr><td><code>SHR</code></td><td>x</td><td>y</td></tr><tr><td><code>CODE</code></td><td>y</td><td>y</td></tr><tr><td><code>DATA</code></td><td>y</td><td>x</td></tr></tbody></table><p>可见，比较明确的是 <code>VIRT</code>, <code>RES</code> 和 <code>CODE</code>。<code>SHR</code> 的情况也比较好理解，内核代码可以明确是只包含实体内存部分，而 <code>top</code> 手册里则没有说明，因此我们也将其理解为只包含实体内存部分。</p><p>现在，需要确认的，就是 <code>DATA</code> 了。我们看一下 <code>DATA</code> 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*data = mm-&gt;data_vm + mm-&gt;stack_vm;</span><br></pre></td></tr></table></figure><p>其中 <code>mm</code> 是 Linux 的内存描述符，它定义在 <a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm_types.h#L384-L548" target="_blank" rel="noopener"><code>linux/mm_types.h</code></a> 当中，是一个相当大的结构体。其中 <code>data_vm</code> 和 <code>stack_vm</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data_vm;     <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;     <span class="comment">/* VM_STACK */</span></span><br></pre></td></tr></table></figure><p>这里，显然后缀 <code>vm</code> 表示虚拟内存（Virtual Memory），因此 <code>DATA</code> 表示的不只是实体内存占用，这一点是显然的了。接下来的问题是，这里的注释表示什么呢？<code>VM_WRITE</code> 等宏，定义在 <a href="https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm.h#L240-L391" target="_blank" rel="noopener"><code>linux/mm.h</code></a> 当中。这些宏表示虚拟内存区域（Virtual Memory Area, <code>vm_area</code>）的属性，由一些 one-hot 的整数来表示。于是，<code>VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK</code> 表示非栈且非共享的可写虚拟内存区域。因此 <code>DATA</code> 字段表达的是虚拟内存中，栈区域与非栈区域中非共享可写区域之和。</p><p>这也就能解释，为什么 <code>DATA</code> 看起来远远大于 <code>RES</code> 了。因为 <code>RES</code> 是实际占用的实体内存大小，而 <code>DATA</code> 计算的是数据部分占用虚拟内存的大小。后者可能包含了大量实际没有与实体内存帧映射的虚拟内存页，从而导致看起来虚高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>top</code> 的手册关于 <code>DATA</code> 的说明是错的，有 bug。更新如下：</p><ul><li><code>VIRT</code> Virtual Memory Size (KiB)：进程使用的所有<strong>虚拟内存</strong>；包括代码（code）、数据（data）、共享库（shared libraries），以及被换出（swap out）到交换区和映射了（map）但尚未使用（未载入实体内存）的部分。</li><li><code>RES</code> Resident Memory Size (KiB)：进程所占用的所有<strong>实体内存</strong>（physical memory），不包括被换出到交换区的部分。</li><li><code>SHR</code> Shared Memory Size (KiB)：进程可读的全部共享<strong>实体内存</strong>，并非所有部分都包含在 <code>RES</code> 中。它反映了可能被其他进程共享的内存部分。</li><li><code>CODE</code> Code Size (KiB)：进程所占用的<strong>实体内存</strong>中，可执行代码所占用的内存大小。此项亦称为驻存代码集合（Text Resident Set, TRS）。</li><li><code>DATA</code> Data + Stack Size (KiB)：进程所占用的<strong>虚拟内存</strong>中，栈区域与非栈区域中非共享可写区域之和。</li></ul><p>不一定有等式 <code>CODE + DATA = RES</code> 成立，但一定成立等式 <code>ANON = RES - SHR</code> 及不等式 <code>ANON &lt;= DATA (vm_physic) &lt;= DATA</code>。如果观察到程序稳定运行时 <code>RES - SHR</code> 不断增长，则可能预示着程序存在内存泄漏现象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 系统中，著名的 &lt;code&gt;top&lt;/code&gt; 命令可列出各个进程对系统资源的利用情况。其中有 &lt;code&gt;VIRT&lt;/code&gt;, &lt;code&gt;RES&lt;/code&gt;, &lt;code&gt;SHR&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;DATA&lt;/code&gt; 等几个字段，用来描述进程对内存的使用情况。（后二者默认不展示，需要按下 F 键，将相关字段调出来）。&lt;/p&gt;
&lt;p&gt;但它们究竟表示什么含义呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Linux" scheme="https://liam.page/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://liam.page/tags/Kernel/"/>
    
      <category term="VIRT" scheme="https://liam.page/tags/VIRT/"/>
    
      <category term="RES" scheme="https://liam.page/tags/RES/"/>
    
      <category term="SHR" scheme="https://liam.page/tags/SHR/"/>
    
      <category term="CODE" scheme="https://liam.page/tags/CODE/"/>
    
      <category term="DATA" scheme="https://liam.page/tags/DATA/"/>
    
  </entry>
  
  <entry>
    <title>PS 技巧：分频磨皮法</title>
    <link href="https://liam.page/2020/07/12/Fixing-Flaws-on-Face-by-Frequency-Seperation/"/>
    <id>https://liam.page/2020/07/12/Fixing-Flaws-on-Face-by-Frequency-Seperation/</id>
    <published>2020-07-12T09:36:25.000Z</published>
    <updated>2020-07-19T15:53:44.072Z</updated>
    
    <content type="html"><![CDATA[<p>对照片进行后期时，磨皮——修复面部细微瑕疵——是很常见的需求。最简单的磨皮方法，可能是利用涂抹工具、仿制图章工具、修补工具等在原图上直接进行处理。但这些方法都有一个不可避免的缺陷：无法保留诸如皮肤纹理、毛孔等细节。</p><p>本文介绍分频磨皮法的操作技巧及其背后的原理。</p><a id="more"></a><!-- https://youtu.be/bVI3pCdHPPE --><h2 id="素材图片"><a href="#素材图片" class="headerlink" title="素材图片"></a>素材图片</h2><p>我们以 <a href="https://pixabay.com/zh/users/Alexas_Fotos-686414/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3990680" target="_blank" rel="noopener">Alexas_Fotos</a> 在 <a href="https://pixabay.com/zh/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3990680" target="_blank" rel="noopener">Pixabay</a> 上发布的<a href="https://pixabay.com/zh/photos/woman-pretty-portrait-girl-young-3990680/" target="_blank" rel="noopener">图片</a>为例，作为素材进行演示。</p><p><img data-src="/uploads/images/photoshop/fenpinmopi_small.jpg" alt></p><p>可见，照片中的女性，其面部皮肤有不少暗淡瘢痕。消除她们，并保留照片中足够多的细节就是我们的目标。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="行前准备"><a href="#行前准备" class="headerlink" title="行前准备"></a>行前准备</h3><p>首先，我们在 Pixabay 上下载图片，而后用 Photoshop 打开。</p><p>而后，我们按 Command + J（Windows 是 Control + J，下同），将背景图层复制一次并命名为原片，以免误操作背景图层，而难以撤销。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_1.jpg" alt></p><h3 id="皮肤毛刺的处理"><a href="#皮肤毛刺的处理" class="headerlink" title="皮肤毛刺的处理"></a>皮肤毛刺的处理</h3><p>接下来，我们首先把明显的毛刺解决掉。</p><p>我们首先对原片图层做一个黑白蒙版，并降低红色通道的颜色。这样，面部皮肤上的毛刺就显得特别明显了。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_2.jpg" alt></p><p>接下来，新建一个空白图层，放在蒙版下方。然后按 J，调出污点修复画笔工具——当然，你也可以用其他你喜欢的修复工具来修复——在工具参数栏上勾选「对所有图层采样」。接下来即可对各个毛刺进行修复处理。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_3.jpg" alt></p><blockquote><p>这里我们以人物额头部分的毛刺作为演示。</p></blockquote><p>处理完成之后，删除蒙版，并将图层 1 与原片盖印在一起（Command + Alt + Shift + E），并产生新的图层，命名为「去除毛刺」。我们可以看看额头去除毛刺的效果。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_3.1.jpg" alt></p><h3 id="分频"><a href="#分频" class="headerlink" title="分频"></a>分频</h3><p>去除毛刺之后，我们选中「去除毛刺」图层，然后按 Command + J 两次。我们将复制出来的图层，上层命名为高频，下层命名为低频。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_4.jpg" alt></p><p>隐藏高频图层，对低频图层进行高斯模糊操作（滤镜 - 模糊 - 高斯模糊）。调整模糊半径，使得恰好看不出皮肤的纹理细节。如此，我们就得到了低频图层。可见色斑色块依然存在，但是皮肤纹理细节、汗毛就看不见了。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_5.png" alt></p><p>记下来我们获取高频图层——纹理细节。</p><p>显示高频图层并选择它，对高频图层进行「应用图像」操作（图像 - 应用图像）。</p><ul><li>在「源」当中，选择「低频」图层；</li><li>在「混合」当中，选择「减去」；</li><li>设定缩放值为 2；</li><li>设定补偿值为 128。</li></ul><p>如此，我们就得到了高频图层，也就是皮肤纹理、头发都等细节。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_6.jpg" alt></p><p>接下来，我们将高频图层的叠加模式，设置为「线性光」。此时可见「去除毛刺」图层的效果，与「高频」「低频」线性光叠加的效果完全一致。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_7.jpg" alt></p><h3 id="磨皮"><a href="#磨皮" class="headerlink" title="磨皮"></a>磨皮</h3><p>我们现在进入磨皮阶段。</p><p>首先，隐藏高频图层，显示低频图层。然后调出套索工具，选定人物面部高光的部分。调出高斯模糊进行磨皮。此次高斯模糊的模糊半径可根据需要自由调整。但要注意，过大的模糊半径，会破坏画面的光暗对比。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_8.jpg" alt></p><p>我们继续选定人物面部较暗的部分，同样进行高斯模糊磨皮。</p><p>完成磨皮后，使高频图层可见。此时我们能发现，人物面部皮肤瑕疵消失，但纹理、毛孔等细节却都保留了下来。</p><p><img data-src="/uploads/teaching/photoshop/fenpinmopi_9.jpg" alt></p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>至此，我们就可以将修图的结果保存下来了。以下是效果。</p><p><img data-src="/uploads/images/photoshop/fenpinmopi_after.jpg" alt></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>分频背后的数学原理其实很简单。之前我在讲<a href="/2017/07/27/convolutions-and-convolution-neural-network/#%E5%9B%BE%E5%83%8F%E7%9A%84%E6%BB%A4%E9%95%9C">卷积神经网络</a>的时候，提到了二维卷积应用在图像上的效果其实就是滤镜。</p><p>这里，低频图层的高斯模糊实际就是这里右上角的模糊化，而原片与模糊之后的结果做差，其实就起到这里右下角的边缘检测的效果。</p><p><img data-src="/uploads/images/MachineLearning/image_filter.png" alt></p><p>想明白这一点就不难理解我们在 Photoshop 当中做了什么事情了。<code>: )</code></p><hr><p><strong>更新 2020-07-14</strong></p><p>我将分频的步骤保存成了 Photoshop Action，其中高斯模糊的模糊半径设置为 6px。读者可根据自己需要适当调整。可在<a href="/uploads/teaching/photoshop/actions/Protrait%20Retouch.atn">这里</a>下载，其中的 <code>Frequency Seperation</code> 即是分频动作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对照片进行后期时，磨皮——修复面部细微瑕疵——是很常见的需求。最简单的磨皮方法，可能是利用涂抹工具、仿制图章工具、修补工具等在原图上直接进行处理。但这些方法都有一个不可避免的缺陷：无法保留诸如皮肤纹理、毛孔等细节。&lt;/p&gt;
&lt;p&gt;本文介绍分频磨皮法的操作技巧及其背后的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Photoshop" scheme="https://liam.page/categories/Photoshop/"/>
    
    
      <category term="Flaw" scheme="https://liam.page/tags/Flaw/"/>
    
      <category term="Retouch" scheme="https://liam.page/tags/Retouch/"/>
    
  </entry>
  
  <entry>
    <title>最佳搭档：利用 SSH 反向隧道和本地转发工具加速内网服务器的外网访问</title>
    <link href="https://liam.page/2020/07/10/Making-Network-Faster-by-SSH-Reverse-Tunel/"/>
    <id>https://liam.page/2020/07/10/Making-Network-Faster-by-SSH-Reverse-Tunel/</id>
    <published>2020-07-10T08:47:39.000Z</published>
    <updated>2020-07-12T09:35:28.793Z</updated>
    
    <content type="html"><![CDATA[<p>公司内网服务器（称作 <code>hostA</code>）访问外网速度特别慢，以至于使用 Linuxbrew 安装工具特别费事。经测试，下载同样的内容，处于办公网络的本机（称作 <code>hostB</code>）下载很快。遂起了代理加速的心思。</p><p>以下是解法。</p><a id="more"></a><h2 id="本机本地转发"><a href="#本机本地转发" class="headerlink" title="本机本地转发"></a>本机本地转发</h2><p>首先，我们需要在 <code>hostB</code> 上起一个进程，搭建一个本地的 socks5 代理。它将某个端口（记为 <code>portB</code>）收到的请求，全部转发到外网。</p><p>类似的工具有很多，这里不做展开。</p><h2 id="反向隧道"><a href="#反向隧道" class="headerlink" title="反向隧道"></a>反向隧道</h2><p><a href="/2018/04/11/break-firewall-by-the-use-of-SSH-tunnel/">前作</a>中，我们介绍了 SSH 隧道功能。此处，我们可以从 <code>hostB</code> 向 <code>hostA</code> 建立一个反向隧道，并在 <code>hostA</code> 上绑定端口 <code>portA</code>。于是，发往 <code>hostA:portA</code> 的请求，都会经由 SSH 反向隧道转发到 <code>hostB:portB</code>，再发到外网。我们需要在 <code>hostB</code> 上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fTCNR localhost:portA:localhost:portB hostA</span><br></pre></td></tr></table></figure><p>至此，大功告成~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司内网服务器（称作 &lt;code&gt;hostA&lt;/code&gt;）访问外网速度特别慢，以至于使用 Linuxbrew 安装工具特别费事。经测试，下载同样的内容，处于办公网络的本机（称作 &lt;code&gt;hostB&lt;/code&gt;）下载很快。遂起了代理加速的心思。&lt;/p&gt;
&lt;p&gt;以下是解法。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="SSH" scheme="https://liam.page/tags/SSH/"/>
    
      <category term="Socks5" scheme="https://liam.page/tags/Socks5/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中利用反射，动态获取 Protobuf 结构中的字段</title>
    <link href="https://liam.page/2020/06/29/Dynamic-Get-Fields-in-Protobuf-by-Their-Name-in-Cpp/"/>
    <id>https://liam.page/2020/06/29/Dynamic-Get-Fields-in-Protobuf-by-Their-Name-in-Cpp/</id>
    <published>2020-06-29T12:51:47.000Z</published>
    <updated>2020-07-09T16:07:23.992Z</updated>
    
    <content type="html"><![CDATA[<p>最近在实际业务中，我遇到了这样一类问题。</p><p>首先，我们定义了一个通用类，比如 <code>message Feature</code>。然后，在一个大的特征分组中，我们定义了若干个特征。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message FooGroup &#123;</span><br><span class="line">  Feature foo = 1;</span><br><span class="line">  Feature bar = 2;</span><br><span class="line">  Feature baz = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在实际使用中，我们需要根据配置文件，有筛选地选出其中的某几个来使用——比如选择使用 <code>foo</code> 和 <code>baz</code>。为此，我们会传递 <code>&quot;foo&quot;</code> 和 <code>&quot;baz&quot;</code> 给函数 <code>get_feature</code>，并期待它能返回 <code>const Feature&amp;</code>，分别装着 <code>foo</code> 和 <code>baz</code> 的常量引用。</p><p>查阅 Protobuf 的文档之后发现，使用描述器（Descriptor）、字段描述器（FieldDescriptor）和反射（Reflection）来实现该功能。</p><a id="more"></a><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>我们的 <code>get_feature</code> 函数的原型应该形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Feature&amp; <span class="title">get_features</span><span class="params">(<span class="keyword">const</span> FooGroup&amp; group, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><p>Protobuf 的描述器定义在头文件 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.descriptor" target="_blank" rel="noopener"><code>descriptor.h</code></a>。为了使用描述器，你需要引用相应的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>Protobuf 的描述器包含了通过 Protobuf 定义的消息类的相关信息。这实际上实现了所谓的「自省」（Introspection）。对于一个具体的消息类对象，可以使用 <code>GetDescriptor()</code> 接口来获取其描述器。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> google::protobuf::Descriptor* des = group.GetDescriptor();</span><br></pre></td></tr></table></figure><h2 id="字段描述器"><a href="#字段描述器" class="headerlink" title="字段描述器"></a>字段描述器</h2><p>Protobuf 的字段描述器也定义在头文件 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.descriptor" target="_blank" rel="noopener"><code>descriptor.h</code></a> 当中，它包含了对于消息类中某个字段的描述。在概念上，近似于 C++ 中类的成员指针。</p><p>由于消息类中某个字段的描述也属于消息类的描述的一部分，因此我们需要通过消息类的描述器来获取其中字段的描述器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> google::protobuf::Descriptor* des = group.GetDescriptor();</span><br><span class="line"><span class="keyword">const</span> google::protobuf::FieldDescriptor* fdes = des-&gt;FindFieldByName(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><p>这里，<code>FindFieldByName</code> 接口接受一个 <code>const std::string&amp;</code>，并查找描述器对应的消息类中，是否有相应名称的字段。如果存在，则返回相应的字段描述器。如果不存在，则返回 <code>nullptr</code>。注意，这里的 <code>FindFieldByName</code> 是大小写敏感的。</p><p>这样一来，我们就获取了 <code>FooGroup</code> 这个消息类当中字段 <code>foo</code> 的字段描述器（近似理解成 C++ 中的类成员指针）。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Protobuf 的反射定义在头文件 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message" target="_blank" rel="noopener"><code>message.h</code></a> 当中。为了使用它，你需要引用相应的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/message.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>Protobuf 的反射定义了一系列接口，用以在运行时动态地访问、修改消息类中的成员。对于一个具体的消息类对象，可以用 <code>GetReflection()</code> 接口来获取其反射。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> google::protobuf::Reflection* ref = group.GetReflection();</span><br></pre></td></tr></table></figure><p>然后，就可以通过反射提供的一系列接口来访问消息类中的字段了。由于我们需要获取 <code>const Feature&amp;</code>，所以我们需要用到 <code>const Message&amp; GetMessage(const Message &amp; message, const FieldDescriptor * field, MessageFactory * factory = nullptr) const</code> 这个接口。注意到，它返回的是 <code>const Messasge&amp;</code>。这里 <code>Message</code> 是所有 Protobuf 消息类的父类。于是，我们可以在获取到它之后，通过 <code>dynamic_cast&lt;const Feature&amp;&gt;</code> 将 <code>Message</code> 的常量引用动态转换成 <code>Feature</code> 的常量引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Feature&amp;&gt;(ref-&gt;GetMessage(group, fdes));</span><br></pre></td></tr></table></figure><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>如此，我们就能给出完整实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Feature&amp; <span class="title">get_feature</span><span class="params">(<span class="keyword">const</span> FooGroup&amp; group, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> google::protobuf::Descriptor* des = group.GetDescriptor();</span><br><span class="line">  <span class="keyword">const</span> google::protobuf::FieldDescriptor* fdes = des-&gt;FindFieldByName(name);</span><br><span class="line">  assert(fdes != <span class="literal">nullptr</span>);  <span class="comment">// in case of typo or something.</span></span><br><span class="line">  <span class="keyword">const</span> google::protobuf::Reflection* ref = group.GetReflection();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Feature&amp;&gt;(ref-&gt;GetMessage(group, fdes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在实际业务中，我遇到了这样一类问题。&lt;/p&gt;
&lt;p&gt;首先，我们定义了一个通用类，比如 &lt;code&gt;message Feature&lt;/code&gt;。然后，在一个大的特征分组中，我们定义了若干个特征。比如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;message FooGroup &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Feature foo = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Feature bar = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Feature baz = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但在实际使用中，我们需要根据配置文件，有筛选地选出其中的某几个来使用——比如选择使用 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt;。为此，我们会传递 &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;baz&amp;quot;&lt;/code&gt; 给函数 &lt;code&gt;get_feature&lt;/code&gt;，并期待它能返回 &lt;code&gt;const Feature&amp;amp;&lt;/code&gt;，分别装着 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 的常量引用。&lt;/p&gt;
&lt;p&gt;查阅 Protobuf 的文档之后发现，使用描述器（Descriptor）、字段描述器（FieldDescriptor）和反射（Reflection）来实现该功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Protobuf" scheme="https://liam.page/tags/Protobuf/"/>
    
      <category term="Reflection" scheme="https://liam.page/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>解决钉钉（DingTalk）在 macOS 上的权限问题</title>
    <link href="https://liam.page/2020/06/29/Issues-of-Dingtalk-on-macOS/"/>
    <id>https://liam.page/2020/06/29/Issues-of-Dingtalk-on-macOS/</id>
    <published>2020-06-29T10:19:55.000Z</published>
    <updated>2020-07-09T16:07:23.992Z</updated>
    
    <content type="html"><![CDATA[<p>最近，因为各种原因，我先后两次需要给<a href="https://anyi.im/" target="_blank" rel="noopener">悠悠</a>在 macOS 上安装钉钉。但是，两次安装钉钉，悠悠都反映通过钉钉和别人语音、视频会议的时候，别人看不见她、听不见她、无法共享屏幕等问题。</p><p>归根究底，这都是钉钉在 macOS 上权限控制的问题。</p><a id="more"></a><h2 id="权限管理在哪里"><a href="#权限管理在哪里" class="headerlink" title="权限管理在哪里"></a>权限管理在哪里</h2><p>GUI 下，macOS 的权限控制位于：<code>系统偏好设置</code> -&gt; <code>安全性与隐私</code> -&gt; <code>隐私</code>。</p><p><img data-src="/uploads/images/computer-skills/macOS-Privacy.jpg" alt></p><p>在隐私标签页中，我们可以看到有若干项涉及到隐私的权限控制。比如有</p><ul><li>定位服务</li><li>通讯录</li><li>日历</li><li>提醒事项</li><li>照片</li><li>摄像头</li><li>麦克风</li><li>辅助功能</li><li>磁盘完全访问权限</li><li>屏幕录制</li><li>……</li></ul><h2 id="钉钉都要什么权限"><a href="#钉钉都要什么权限" class="headerlink" title="钉钉都要什么权限"></a>钉钉都要什么权限</h2><p>钉钉在语音会议时，会申请麦克风权限；在视频会议时，还会额外申请摄像头权限；在共享屏幕时，还会额外申请屏幕录制权限。</p><p>理论上，只要在安全性与隐私里的隐私标签页的相应项目中，勾上钉钉，它就能够正常工作。但因为某些不明的原因（——我猜这个锅得由钉钉的开发与测试来背），你可能会遇到：</p><ul><li>勾上了，但仍然某项功能仍然无法正常工作；</li><li>没勾上，但是相应项目中也没有钉钉这个候选项，所以想勾也勾不上。</li></ul><h2 id="重置相应权限"><a href="#重置相应权限" class="headerlink" title="重置相应权限"></a>重置相应权限</h2><p>macOS 提供了 <code>ttcutil</code> 这个命令行程序来重置隐私设置。为此，你需要首先退出钉钉，并将其更新到官网的最新版本；而后打开终端（Terminal），然后键入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ttcutil reset Microphone</span><br><span class="line">sudo ttcutil reset Camera</span><br><span class="line">sudo ttcutil reset ScreenCapture</span><br></pre></td></tr></table></figure><p>这里，<code>sudo</code> 是为了获取系统最高权限——<code>root</code> 用户权限。这是因为，隐私设置的数据库，默认不允许普通用户访问。这里我们通过 <code>ttcutil reset</code> 依次重置了麦克风、摄像头、屏幕录制的隐私设置。</p><p>此时，再打开钉钉，发起视频会议，钉钉就会弹窗申请麦克风和摄像头的权限。你只需要在弹出的对话框中点击「好」，就能自动赋予钉钉相应权限。</p><p>共享桌面所需的屏幕录制权限则有些复杂。当你在视频会议状态，选择共享桌面时，钉钉确实会发起权限申请。但你不能直接点击「好」，而需要打开系统偏好设置，进入安全性与隐私的隐私标签页，找到屏幕录制，再给钉钉打上勾。但不幸的是，就算你这样操作，钉钉仍然没有该项权限。</p><p>实验后，我发现正确的做法：不是通过视频会议的共享桌面功能触发权限申请，而是通过另一个同样需要该项权限的功能——截图——来触发权限申请。你只需要找到任意联系人，进入对话状态后，点击小剪刀进行截图，然后再赋予权限，即可正常激活钉钉的屏幕录制权限。</p><p>做完这些之后，你只需要重启钉钉，就应该能正常使用语音、视频会议，并且能够正常地在会议中共享桌面了。</p><h2 id="万一操作失误了怎么办"><a href="#万一操作失误了怎么办" class="headerlink" title="万一操作失误了怎么办"></a>万一操作失误了怎么办</h2><p>请继续在终端当中执行下列命令，然后重新赋予权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ttcutil reset Microphone</span><br><span class="line">sudo ttcutil reset Camera</span><br><span class="line">sudo ttcutil reset ScreenCapture</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，因为各种原因，我先后两次需要给&lt;a href=&quot;https://anyi.im/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;悠悠&lt;/a&gt;在 macOS 上安装钉钉。但是，两次安装钉钉，悠悠都反映通过钉钉和别人语音、视频会议的时候，别人看不见她、听不见她、无法共享屏幕等问题。&lt;/p&gt;
&lt;p&gt;归根究底，这都是钉钉在 macOS 上权限控制的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="DingTalk" scheme="https://liam.page/tags/DingTalk/"/>
    
      <category term="tccutil" scheme="https://liam.page/tags/tccutil/"/>
    
      <category term="Privacy Control" scheme="https://liam.page/tags/Privacy-Control/"/>
    
  </entry>
  
  <entry>
    <title>gperftools 中 CPU Profiler 不工作问题的解法</title>
    <link href="https://liam.page/2020/06/22/CPU-Profiler-in-gperftools-not-working/"/>
    <id>https://liam.page/2020/06/22/CPU-Profiler-in-gperftools-not-working/</id>
    <published>2020-06-22T13:01:30.000Z</published>
    <updated>2020-07-09T16:07:23.992Z</updated>
    
    <content type="html"><![CDATA[<p>为了分析服务性能瓶颈，今次我们计划用 gperftools 当中的 CPU Profiler 来打印服务当中的性能热点。按<a href="https://gperftools.github.io/gperftools/cpuprofile.html" target="_blank" rel="noopener">官网介绍</a>，以下三种方式之一，可开启 CPU Profiler。</p><ol><li>运行时，用 <code>LD_PRELOAD</code> 环境变量加载 CPU Profiler 的共享对象（动态库）。例如 <code>env LD_PRELOAD=&quot;/usr/lib/libprofiler.so&quot; /path/to/elf_bin</code>。</li><li>链接时，加上 <code>-lprofiler</code>（或者 <code>-ltcmalloc_and_profiler</code>，如果还需要 TCMalloc 的话），而后在运行时通过 <code>env CPUPROFILE=foo.prof /path/to/elf_bin</code> 将性能分析文件写入 <code>foo.prof</code>。</li><li>在加上链接参数 <code>-lprofiler</code> 的基础上，在代码内引入头文件 <code>#include &lt;gperftools/profiler.h&gt;</code>，而后在需要分析性能的代码块前后加上 <code>ProfilerStart(&quot;/path/to/foo.prof&quot;)</code> 及 <code>ProfilerStop()</code>。</li></ol><p>这里 (1) 不需要重新编译，但是一看就很山寨；(3) 在分析特定代码片块的性能时很有效，但在意图分析整个程序的性能时就很鸡肋。目光集中在 (2) 上面。</p><p>尝试 (2) 时，遇到一个问题。不管如何设置 <code>CPUPROFILE</code>，程序都不会将性能分析文件转储出来。</p><a id="more"></a><p>经过分析，原因水落石出。链接器在链接 <code>libprofiler</code> 时，会根据程序中的符号引用情况，将未被引用的符号都删掉。由于我们的代码里，没有引用任何 CPU Profiler 的函数，相当于整个 <code>libprofiler</code> 其实没有被链入程序当中。</p><p>为解决这个问题，最标准的解法，是在 <code>-lprofiler</code> 前后加上链接器参数，抑制这种行为：<code>--no-as-needed</code> 和 <code>--as-needed</code>。</p><p>如果因为种种原因，无法给链接器传参，则可考虑在 <code>main</code> 函数返回之前，加入这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> tmp = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp) ProfilerStop();</span><br></pre></td></tr></table></figure><p>这里，布尔变量 <code>tmp</code> 被 <code>volatile</code> 修饰，因而编译器不会将其优化掉。而因为我们没有机会改变 <code>tmp</code> 的值，所以 <code>ProfilerStop()</code> 没有机会被执行。但是，虽然我们知道这一点，但编译器并不知道。因此，在得到的目标文件之中，会有针对 <code>ProfilerStop</code> 及相关符号的引用。这样，哪怕不加 <code>--no-as-needed</code> 和 <code>--as-needed</code> 参数，链接器也会将需要的符号链入程序当中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了分析服务性能瓶颈，今次我们计划用 gperftools 当中的 CPU Profiler 来打印服务当中的性能热点。按&lt;a href=&quot;https://gperftools.github.io/gperftools/cpuprofile.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网介绍&lt;/a&gt;，以下三种方式之一，可开启 CPU Profiler。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行时，用 &lt;code&gt;LD_PRELOAD&lt;/code&gt; 环境变量加载 CPU Profiler 的共享对象（动态库）。例如 &lt;code&gt;env LD_PRELOAD=&amp;quot;/usr/lib/libprofiler.so&amp;quot; /path/to/elf_bin&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;链接时，加上 &lt;code&gt;-lprofiler&lt;/code&gt;（或者 &lt;code&gt;-ltcmalloc_and_profiler&lt;/code&gt;，如果还需要 TCMalloc 的话），而后在运行时通过 &lt;code&gt;env CPUPROFILE=foo.prof /path/to/elf_bin&lt;/code&gt; 将性能分析文件写入 &lt;code&gt;foo.prof&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在加上链接参数 &lt;code&gt;-lprofiler&lt;/code&gt; 的基础上，在代码内引入头文件 &lt;code&gt;#include &amp;lt;gperftools/profiler.h&amp;gt;&lt;/code&gt;，而后在需要分析性能的代码块前后加上 &lt;code&gt;ProfilerStart(&amp;quot;/path/to/foo.prof&amp;quot;)&lt;/code&gt; 及 &lt;code&gt;ProfilerStop()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里 (1) 不需要重新编译，但是一看就很山寨；(3) 在分析特定代码片块的性能时很有效，但在意图分析整个程序的性能时就很鸡肋。目光集中在 (2) 上面。&lt;/p&gt;
&lt;p&gt;尝试 (2) 时，遇到一个问题。不管如何设置 &lt;code&gt;CPUPROFILE&lt;/code&gt;，程序都不会将性能分析文件转储出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="gperftools" scheme="https://liam.page/tags/gperftools/"/>
    
      <category term="CPU Profiler" scheme="https://liam.page/tags/CPU-Profiler/"/>
    
  </entry>
  
  <entry>
    <title>得年、享年、享寿</title>
    <link href="https://liam.page/2020/05/30/denian-xiangnian-and-xiangshou/"/>
    <id>https://liam.page/2020/05/30/denian-xiangnian-and-xiangshou/</id>
    <published>2020-05-30T08:45:50.000Z</published>
    <updated>2020-05-30T13:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>描述去世之人去世时的阳寿有「得年」、「享年」、「享寿」三种相对文雅的说法。其中</p><ul><li>得年用于过世之时较年轻之人；</li><li>享年用于过世之时年龄适中之人；</li><li>享寿用于过世之时年岁极长之人。</li></ul><p>台湾所谓「教育部」之字典的「享寿」词条里提到用法：「習慣上稱卒年六十以上者為『享壽』，不滿六十者稱『享年』，三十以下者稱『得年』。」可为参考。</p><p>不过，随着现代人均寿命增加，私以为：卒年四十五以下称得年都不会突兀；卒年七十五以上恐怕称享寿才较为妥帖；若是卒年过百，恐怕得尊称一声「享高寿」了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;描述去世之人去世时的阳寿有「得年」、「享年」、「享寿」三种相对文雅的说法。其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;得年用于过世之时较年轻之人；&lt;/li&gt;
&lt;li&gt;享年用于过世之时年龄适中之人；&lt;/li&gt;
&lt;li&gt;享寿用于过世之时年岁极长之人。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;台湾所谓「
      
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Death" scheme="https://liam.page/tags/Death/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中实现一个线程安全的频率限制器</title>
    <link href="https://liam.page/2020/05/17/Implementing-a-Thread-safe-Rate-Limiter-in-C/"/>
    <id>https://liam.page/2020/05/17/Implementing-a-Thread-safe-Rate-Limiter-in-C/</id>
    <published>2020-05-17T08:41:10.000Z</published>
    <updated>2020-05-18T05:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前，在学习使用 Python 的 <code>deque</code> 容器时，我<a href="/2016/09/23/using-deque-to-implement-marquee-and-rate-limiter/">实现了一个玩具版的频率限制器</a>。最近需要压测线上服务的性能，又不愿意总是在 QA 那边排队，于是需要自己写一个压测用的客户端。其中一个核心需求就是要实现 QPS 限制。</p><p>于是，终究逃不开要在 C++ 中实现一个线程安全的频率限制器。</p><a id="more"></a><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>所谓频率限制，就是要在一个时间段（inteval）中，限制操作的次数（limit）。这又可以引出两种强弱不同的表述：</p><ul><li>强表述：在任意一个长度等于设定的时间段（interval）的滑动窗口中，频率限制器放行的操作次数（count）都不高于限制次数（limit）。</li><li>弱表述：在一组长度等于设定的时间段（interval）且紧密相连的固定窗口中，每一个窗口里频率限制器放行的操作次数（count）都不高于限制次数（limit）。</li></ul><p>不难发现，强表述通过「滑动窗口」的方式，不仅限制了频率，还要求了操作在时间上的均匀性。前作的频率限制器，实际上对应了这里的强表述。但实际工程中，我们通常只需要实现弱表述的频率限制器就足够使用了。</p><p>对于弱表述，实现起来主要思路如下：</p><ul><li>当操作计数（count）小于限制（limit）时直接放行；</li><li>当操作计数（count）不小于限制（limit）时，继续判断当前时间与上一次记录时间戳（timestamp）的差值。<ul><li>若差值不小于设定的时间段（interval），则更新记录时间戳、将计数重置为 <code>1</code> 并放行；</li><li>否则拒绝操作。</li></ul></li></ul><h2 id="单线程实现"><a href="#单线程实现" class="headerlink" title="单线程实现"></a>单线程实现</h2><p>在不考虑线程安全时，不难给出这样的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ms_clock</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> rep        = <span class="built_in">std</span>::chrono::milliseconds::rep;</span><br><span class="line">  <span class="keyword">using</span> period     = <span class="built_in">std</span>::chrono::milliseconds::period;</span><br><span class="line">  <span class="keyword">using</span> duration   = <span class="built_in">std</span>::chrono::duration&lt;rep, period&gt;;</span><br><span class="line">  <span class="keyword">using</span> time_point = <span class="built_in">std</span>::chrono::time_point&lt;ms_clock, duration&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  <span class="function">time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> time_point(<span class="built_in">std</span>::chrono::duration_cast&lt;duration&gt;(</span><br><span class="line">                  <span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace __details</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> clock    = __details::ms_clock;  <span class="comment">// 1.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span>        limit_;</span><br><span class="line">  <span class="keyword">const</span> clock::duration interval_;</span><br><span class="line">  <span class="keyword">const</span> clock::rep      interval_count_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">uint64_t</span>   count_&#123;<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">uint64_t</span>&gt;::max()&#125;;  <span class="comment">// 2.a.</span></span><br><span class="line">  <span class="keyword">mutable</span> clock::rep timestamp_&#123;<span class="number">0</span>&#125;;                                 <span class="comment">// 2.b.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  constexpr RateLimiter(uint64_t limit, clock::duration interval) :</span><br><span class="line">    limit_(limit), interval_(interval), interval_count_(interval_.count()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  RateLimiter(<span class="keyword">const</span> RateLimiter&amp;) = <span class="keyword">delete</span>;             <span class="comment">// 3.a.</span></span><br><span class="line">  RateLimiter&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RateLimiter&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.b.</span></span><br><span class="line">  RateLimiter(RateLimiter&amp;&amp;) = <span class="keyword">delete</span>;                  <span class="comment">// 3.c.</span></span><br><span class="line">  RateLimiter&amp; <span class="keyword">operator</span>=(RateLimiter&amp;&amp;) = <span class="keyword">delete</span>;       <span class="comment">// 3.d.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">qps</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000.0</span> * <span class="keyword">this</span>-&gt;limit_ / <span class="keyword">this</span>-&gt;interval_count_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> RateLimiter::<span class="keyword">operator</span>()() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count_++;</span><br><span class="line">  <span class="keyword">if</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ts  = <span class="keyword">this</span>-&gt;timestamp_;</span><br><span class="line">    <span class="keyword">auto</span> now = clock::now().time_since_epoch().count();</span><br><span class="line">    <span class="keyword">if</span> (now - ts &lt; <span class="keyword">this</span>-&gt;interval_count_) &#123;  <span class="comment">// 5.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;timestamp_ = now;</span><br><span class="line">    <span class="keyword">this</span>-&gt;count_     = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，</p><ul><li>(1) 表明频率限制器使用单位为毫秒的时钟。在实际使用时，也可以按需改成微妙甚至纳秒。</li><li>(2) 使用 <code>mutable</code> 修饰内部状态 <code>count_</code> 和 <code>timestamp_</code>。这是因为两个 <code>limit_</code> 和 <code>interval_</code> 相同的频率限制器，在逻辑上是等价的，但他们的内部状态却不一定相同。因此，为了让 <code>const</code> 成员函数能够修改内部状态（而不改变逻辑等价），我们要给内部状态数据成员加上 <code>mutable</code> 修饰。<ul><li>(2.a) 处将 <code>count_</code> 设置为类型可表示的最大值是为了让 (4) 的判断失败，而对 <code>timestamp_</code> 进行初始化。</li><li>(2.b) 处将 <code>timestamp_</code> 设置为 <code>0</code> 则是基于同样的原因，让 (5) 的判断失败。</li><li>(2.a) 和 (2.b) 处通过巧妙的初值设计，将初始化状态与后续正常工作状态的逻辑统一了起来，而无须丑陋的判断。</li></ul></li><li>(3) 禁止了对象的拷贝和移动。这是因为一个频率限制器应绑定一组操作，而不应由两组或更多组操作共享（对于拷贝的情形），或是中途失效（对于移动的情形）。</li></ul><p>如此一来，函数调用运算符就忠实地实现了前述逻辑。</p><h2 id="多线程改造"><a href="#多线程改造" class="headerlink" title="多线程改造"></a>多线程改造</h2><h3 id="第一步改造"><a href="#第一步改造" class="headerlink" title="第一步改造"></a>第一步改造</h3><p>当有多线程同时调用 <code>RateLimiter::operator()</code> 时，显而易见，在 <code>count_</code> 和 <code>timestamp_</code> 上会产生竞争。我们有两种办法解决这个问题：要不然加锁，要不然把 <code>count_</code> 和 <code>timestamp_</code> 设为原子变量然后用原子操作解决问题。于是，对函数调用运算符，我们有如下第一步的改造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> &#123;</span></span><br><span class="line">  <span class="comment">// 其余保持不变</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt;   count_&#123;<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">uint64_t</span>&gt;::max()&#125;;  <span class="comment">// 1.a.</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;clock::rep&gt; timestamp_&#123;<span class="number">0</span>&#125;;                                 <span class="comment">// 1.b.</span></span><br><span class="line">  <span class="comment">// 其余保持不变</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> RateLimiter::<span class="keyword">operator</span>()() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count_.fetch_add(<span class="number">1U</span>L);  <span class="comment">// 2.</span></span><br><span class="line">  <span class="keyword">if</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ts  = <span class="keyword">this</span>-&gt;timestamp_.load();  <span class="comment">// 3.</span></span><br><span class="line">    <span class="keyword">auto</span> now = clock::now().time_since_epoch().count();</span><br><span class="line">    <span class="keyword">if</span> (now - ts &lt; <span class="keyword">this</span>-&gt;interval_count_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;timestamp_.store(now);  <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;count_.store(<span class="number">1U</span>L);  <span class="comment">// 5.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，</p><ul><li>(1) 将 <code>count_</code> 和 <code>timestamp_</code> 声明为原子的，从而方便后续进行原子操作。</li><li>(2) -- (5) 则将原有操作分别改为对应的原子操作。</li></ul><p>这样看起来很完美，但其实是有 bug 的。我们重点关注 (4) 这里。(4) 的本意是更新 <code>timestamp_</code>，以备下一次 <code>orig_count &gt;= this-&gt;limit_</code> 时进行判断。准确设置这一 <code>timestamp</code> 是频率限制器正确工作的基石。但是，<strong>如果有两个（或更多）线程，同时走到了 (4)</strong> 会发生什么？</p><ul><li>因为原子操作的存在，两个线程会先后执行 (4)。于是 <code>timestamp_</code> 的值究竟是什么，我们完全不可预期。</li><li>此外，两个线程会先后执行 (5)，即原子地将 <code>count_</code> 置为 <code>1</code>。但是你想，频率限制器先后放行了两次操作，但为什么 <code>count_</code> 是 <code>1</code> 呢？这是不是就「偷跑」了一次操作？</li></ul><p>为此，我们要保证只有一个线程会真正设置 <code>timestamp_</code>，而拒绝其他同样走到 (4) 位置的线程的操作，以避免其重复设置 <code>timestamp_</code> 以及错误地将 <code>count_</code> 再次置为 <code>1</code>。</p><h3 id="第二步改进"><a href="#第二步改进" class="headerlink" title="第二步改进"></a>第二步改进</h3><p>于是有以下改进。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RateLimiter::<span class="keyword">operator</span>()() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count_.fetch_add(<span class="number">1U</span>L);  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ts  = <span class="keyword">this</span>-&gt;timestamp_.load();</span><br><span class="line">    <span class="keyword">auto</span> now = clock::now().time_since_epoch().count();</span><br><span class="line">    <span class="keyword">if</span> (now - ts &lt; <span class="keyword">this</span>-&gt;interval_count_) &#123;  <span class="comment">// 5.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="keyword">this</span>-&gt;timestamp_.compare_and_exchange_strong(ts, now)) &#123;  <span class="comment">// 1.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;count_.store(<span class="number">1U</span>L);  <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，(1) 是一个 CAS 原子操作。它会原子地比较 <code>timestamp_</code> 和 <code>ts</code> 的值（Compare）：若他们相等，则将 <code>now</code> 的值写入 <code>timestamp_</code>（Swap），并返回 <code>true</code>；若他们不相等，则将 <code>timestamp_</code> 的值写入 <code>ts</code>，并返回 <code>false</code>。如果没有其他线程抢先修改 <code>timestamp_</code> 的值，那么 CAS 操作应该成功并返回 <code>true</code>，继续执行后面的代码；否则，说明其他线程已经抢先修改了 <code>timestamp_</code>，当前线程的操作被记入上一个周期而被频率限制器拒绝。</p><p>现在要考虑 (2)。如果执行完 (1) 之后立即立刻马上没有任何延迟地执行 (2)，那么当然一切大吉。但如果这时候当前线程被切出去，会发生什么？我们要分情况讨论。</p><ul><li><p>如果 <code>ts == 0</code>，也就是「当前线程」是频率限制器第一次修改 <code>timestamp_</code>。于是，当前线程可能会在 (3) 处将 <code>count_</code> （溢出地）自增为 <code>0</code>，从而可能有其他线程通过 (4)。此时，当前线程在当前分片有可能应当被拒绝操作。为此，我们需要在 (1) 和 (2) 之间做额外的判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ts == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count.fetch_add(<span class="number">1U</span>L);</span><br><span class="line">  <span class="keyword">return</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>ts != 0</code>，也就是「当前线程」并非频率限制器第一次修改 <code>timestamp_</code>。那么其他线程在 (4) 处必然判断失败，但在 (5) 处的判断可能成功，从而可能继续成功执行 (1)，从而接连两次执行 (2)。但这不影响正确性。因为通过 (5) 表明相对当前线程填入的 <code>timestamp_</code>，已经由过了一个时间段（interval），而在这个时间段里，只有当前线程的一次操作会被接受。</p></li></ul><h3 id="第三次改进"><a href="#第三次改进" class="headerlink" title="第三次改进"></a>第三次改进</h3><p>由此，我们得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RateLimiter::<span class="keyword">operator</span>()() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count_.fetch_add(<span class="number">1U</span>L);</span><br><span class="line">  <span class="keyword">if</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ts  = <span class="keyword">this</span>-&gt;timestamp_.load();</span><br><span class="line">    <span class="keyword">auto</span> now = clock::now().time_since_epoch().count();</span><br><span class="line">    <span class="keyword">if</span> (now - ts &lt; <span class="keyword">this</span>-&gt;interval_count_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="keyword">this</span>-&gt;timestamp_.compare_and_exchange_strong(ts, now)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ts == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count.fetch_add(<span class="number">1U</span>L);</span><br><span class="line">      <span class="keyword">return</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;count_.store(<span class="number">1U</span>L);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的代码在逻辑上已经成立了，接下来要做一些性能方面的优化。</p><p>原子操作默认采用 <code>std::memory_order_seq_cst</code> 的内存模型。这是 C++ 中最严格的内存模型，它有两个保证：</p><ul><li>程序指令和源码顺序一致；</li><li>所有线程的所有操作都有一致的顺序。</li></ul><p>为了实现顺序一致性（sequential consistency），编译器会使用很多对抗编译器优化和 CPU 乱序执行（Out-of-Order Execution）的手段，因而性能较差。对于此处的 <code>count_</code>，我们无需顺序一致性模型，只需要获取释放模型（Aquire-Release）模型就足够了。</p><h3 id="第四次改进"><a href="#第四次改进" class="headerlink" title="第四次改进"></a>第四次改进</h3><p>于是有第四次改进：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RateLimiter::<span class="keyword">operator</span>()() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count_.fetch_add(<span class="number">1U</span>L, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">  <span class="keyword">if</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ts  = <span class="keyword">this</span>-&gt;timestamp_.load();</span><br><span class="line">    <span class="keyword">auto</span> now = clock::now().time_since_epoch().count();</span><br><span class="line">    <span class="keyword">if</span> (now - ts &lt; <span class="keyword">this</span>-&gt;interval_count_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="keyword">this</span>-&gt;timestamp_.compare_and_exchange_strong(ts, now)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ts == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> orig_count = <span class="keyword">this</span>-&gt;count.fetch_add(<span class="number">1U</span>L, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">      <span class="keyword">return</span> (orig_count &lt; <span class="keyword">this</span>-&gt;limit_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;count_.store(<span class="number">1U</span>L, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就完整实现了一个频率限制器，可以愉快地开始拉 QPS 压测了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早以前，在学习使用 Python 的 &lt;code&gt;deque&lt;/code&gt; 容器时，我&lt;a href=&quot;/2016/09/23/using-deque-to-implement-marquee-and-rate-limiter/&quot;&gt;实现了一个玩具版的频率限制器&lt;/a&gt;。最近需要压测线上服务的性能，又不愿意总是在 QA 那边排队，于是需要自己写一个压测用的客户端。其中一个核心需求就是要实现 QPS 限制。&lt;/p&gt;
&lt;p&gt;于是，终究逃不开要在 C++ 中实现一个线程安全的频率限制器。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="QPS" scheme="https://liam.page/tags/QPS/"/>
    
      <category term="Rate Limiter" scheme="https://liam.page/tags/Rate-Limiter/"/>
    
      <category term="Thread-safe" scheme="https://liam.page/tags/Thread-safe/"/>
    
  </entry>
  
  <entry>
    <title>删除 Hive SQL 查询结果中的重复内容</title>
    <link href="https://liam.page/2020/05/14/remove-duplicate-entries-in-Hive-SQL/"/>
    <id>https://liam.page/2020/05/14/remove-duplicate-entries-in-Hive-SQL/</id>
    <published>2020-05-14T02:17:16.000Z</published>
    <updated>2020-05-16T14:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用 Hive 实在太频繁了，此篇继续讲 Hive。</p><p>此篇遇到的问题是要以某几列为 key，对 Hive SQL <code>SELECT</code> 出来的数据进行去重。以下逐步讨论。</p><a id="more"></a><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a><code>DISTINCT</code></h2><p>说到要去重，自然会想到 <code>DISTINCT</code>。但是在 Hive SQL 里，它有两个问题。</p><ul><li><code>DISTINCT</code> 会以 <code>SELECT</code> 出的全部列作为 key 进行去重。也就是说，只要有一列的数据不同，<code>DISTINCT</code> 就认为是不同数据而保留。</li><li><code>DISTINCT</code> 会将全部数据打到一个 reducer 上执行，造成严重的数据倾斜，耗时巨大。</li></ul><h2 id="ROW-NUMBER-OVER"><a href="#ROW-NUMBER-OVER" class="headerlink" title="ROW_NUMBER() OVER"></a><code>ROW_NUMBER() OVER</code></h2><p><code>DISTINCT</code> 的两个问题，用 <code>ROW_NUMBER() OVER</code> 可解。比如，如果我们要按 <code>key1</code> 和 <code>key2</code> 两列为 key 去重，就会写出这样的代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> temp_table <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    key1,</span><br><span class="line">    key2,</span><br><span class="line">    [<span class="keyword">columns</span>]...,</span><br><span class="line">    ROW_NUMBER() <span class="keyword">OVER</span> (</span><br><span class="line">      <span class="keyword">PARTITION</span> <span class="keyword">BY</span> key1, key2</span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span></span><br><span class="line">    ) <span class="keyword">AS</span> rn</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">table</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  key1,</span><br><span class="line">  key2,</span><br><span class="line">  [<span class="keyword">columns</span>]...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  temp_table</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  rn = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样，Hive 会按 <code>key1</code> 和 <code>key2</code> 为 key，将数据打到不同的 mapper 上，然后对 <code>key1</code> 和 <code>key2</code> 都相同的一组数据，按 <code>column</code> 升序排列，并最终在每组中保留排列后的第一条数据。借此就完成了按 <code>key1</code> 和 <code>key2</code> 两列为 key 的去重任务。</p><p>注意 <code>PARTITION BY</code> 在此起到的作用：一是按 <code>key1</code> 和 <code>key2</code> 打散数据，解决上述问题 (2)；二是与 <code>ORDER BY</code> 和 <code>rn = 1</code> 的条件结合，按 <code>key1</code> 和 <code>key2</code> 对数据进行分组去重，解决上述问题 (1)。</p><p>但显然，这样做十分不优雅（not-elegant），并且不难想见其效率比较低。</p><h2 id="GROUP-BY-和-COLLECT-SET-COLLECT-LIST"><a href="#GROUP-BY-和-COLLECT-SET-COLLECT-LIST" class="headerlink" title="GROUP BY 和 COLLECT_SET/COLLECT_LIST"></a><code>GROUP BY</code> 和 <code>COLLECT_SET</code>/<code>COLLECT_LIST</code></h2><p><code>ROW_NUMBER() OVER</code> 的解法的一个核心是利用 <code>PARTITION BY</code> 对数据按 key 分组，同样的功能用 <code>GROUP BY</code> 也可以实现。但是，<code>GROUP BY</code> 需要与聚合函数搭配使用。<code>ORDER BY</code> 和 <code>rn = 1</code> 的条件结合起来实现了「保留第一条」的功能。我们需要考虑，什么样的聚合函数能实现或者间接实现这样的功能呢？不难想到有 <code>COLLECT_SET</code> 和 <code>COLLECT_LIST</code>。</p><p>于是有这样的代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  key1,</span><br><span class="line">  key2,</span><br><span class="line">  [COLLECT_LIST(<span class="keyword">column</span>)[<span class="number">1</span>] <span class="keyword">AS</span> <span class="keyword">column</span>]...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  temp_table</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  key1, key2</span><br></pre></td></tr></table></figure><p>对于 <code>key1</code> 和 <code>key2</code> 以外的列，我们用 <code>COLLECT_LIST</code> 将他们收集起来，然后输出第一个收集进来的结果。这里使用 <code>COLLECT_LIST</code> 而非 <code>COLLECT_SET</code> 的原因在于 SET 内是无序的，因此你无法保证输出的 columns 都来自同一条数据。若对于此没有要求或限制，则可以使用 <code>COLLECT_SET</code>，它会更节省资源。</p><p>相比前一种办法，由于省略了排序和（可能的）落盘动作，所以效率会高不少。但是因为（可能）不落盘，所以 <code>COLLECT_LIST</code> 中的数据都会缓存在内存当中。如果重复数量特别大，这种方法可能会触发 OOM。此时应考虑将数据进一步打散，然后再合并；或者干脆换用前一种办法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用 Hive 实在太频繁了，此篇继续讲 Hive。&lt;/p&gt;
&lt;p&gt;此篇遇到的问题是要以某几列为 key，对 Hive SQL &lt;code&gt;SELECT&lt;/code&gt; 出来的数据进行去重。以下逐步讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
      <category term="SQL" scheme="https://liam.page/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>使用 TRANSFORM 在 Hive 中调用用户自定义的脚本</title>
    <link href="https://liam.page/2020/05/11/TRANSFORM-in-Hive/"/>
    <id>https://liam.page/2020/05/11/TRANSFORM-in-Hive/</id>
    <published>2020-05-11T14:57:50.000Z</published>
    <updated>2020-05-11T15:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在实际工作一个典型的机器学习任务中，我们在线上和线下都要对特征数据进行处理。线上处理的目的是为了推理预测，线下处理的目的则是为了准备训练数据。显然，因为处理区分线上线下，数据一致性就会成为非常关键的问题。</p><p>然而，数据一致性是挺烫手的山芋。因为，如果尝试在线上线下先后两次实现同样的功能，不论如何小心，都有出错的可能。更不用说，如果使用不同语言，那对于数据处理上的些微不同最终都可能破坏数据一致性。</p><p>因此，保证数据一致性最好的办法就是用一份代码在两个地方干同样的事情。我们线上服务是用 C++ 编写的，因此我们可以将特征 ETL 抽象成单独的模块，分别链接到线上服务以及离线特征处理程序中。这样，二者对于特征的 ETL 的行为就完全一致了。</p><p>剩下的问题就是：离线数据通过 Kafka 落在 Hive 表当中，我们需要在 Hive 处理数据的过程中，嵌入我们自己编写的特征处理程序。</p><a id="more"></a><p>经过简单的检索，我发现 Hive SQL 的 <code>TRANSFORM</code> 语法可以很方便地完成这一工作。</p><p>首先，我们需要使用 <code>ADD FILE</code> 将可执行程序以及可能的其他资源文件加入 Hive 豪华套餐。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD FILE hdfs://path/to/feature_etl;</span><br><span class="line">ADD FILE hdfs://path/to/feature_etl.cfg;</span><br></pre></td></tr></table></figure><p>而后，我们就可以将 <code>TRANSFORM</code> 语句嵌入在 <code>SELECT</code> 子句当中了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  TRANSFORM (column1, column2)</span><br><span class="line">    <span class="keyword">USING</span> <span class="string">'./feature_etl --config_file=./feature_etl.cfg'</span></span><br><span class="line">    <span class="keyword">AS</span> (out_column1 <span class="keyword">STRING</span>, out_column2 <span class="built_in">BIGINT</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  db_name.tb_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  conds;</span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><code>column1</code> 和 <code>column2</code> 是原始表 <code>db_name.tb_name</code> 中的列名字。</li><li><code>TRANSFORM</code> 子句表示 Hive 会将 <code>column1</code> 和 <code>column2</code> 以制表符 <code>\t</code> 分割拼成一个字符串传给用户指定的程序。<ul><li>注意，如果 <code>column1</code> 或者 <code>column2</code> 当中包含制表符，则用户需要自行处理，Hive 对此不负责。</li></ul></li><li><code>USING</code> 子句指示使用什么命令来处理输入。这里我们用 <code>./feature_etl --config_file=./feature_etl.cfg</code>。<ul><li>注意，使用 <code>ADD FILE</code> 导入的文件就在「当前目录」中。</li><li>另外，Hive 会像 Hadoop Streaming 任务那样，将数据通过标准输入传给用户指定的程序，并从标准输出读取输出。</li></ul></li><li><code>AS</code> 子句指示用户程序的输出都有哪些列。<ul><li>注意，用户程序的输出也应当是以制表符 <code>\t</code> 分割拼成的字符串；如果输出字符串中包含换行符，则会被 Hive 视作是输出了多条数据（一行变多行）。</li><li>另外，<code>AS</code> 子句当中可以指定列数据的类型，若不指定则默认都是字符串。Hive 会和往常一样去解析数据类型。</li></ul></li></ul><p>另外，Hive 也提供了 <code>MAP</code> 和 <code>REDUCE</code> 子句，同样可以使用用户自定程序处理数据。但是 <code>MAP</code> 和 <code>REDUCE</code> 其实只是 <code>TRANSFORM</code> 的别称，使用 <code>MAP</code> 并不一定会在 MapReduce 的 Map 阶段进行处理，使用 <code>REDUCE</code> 也是一样。因此，使用这两个子句难免有误导之嫌，不如不用，统一转向 <code>TRANSFORM</code>。</p><p><code>TRANSFORM</code> 子句还有其他一些细节，可参考 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Transform" target="_blank" rel="noopener">Apache 的 wiki 页</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际工作一个典型的机器学习任务中，我们在线上和线下都要对特征数据进行处理。线上处理的目的是为了推理预测，线下处理的目的则是为了准备训练数据。显然，因为处理区分线上线下，数据一致性就会成为非常关键的问题。&lt;/p&gt;
&lt;p&gt;然而，数据一致性是挺烫手的山芋。因为，如果尝试在线上线下先后两次实现同样的功能，不论如何小心，都有出错的可能。更不用说，如果使用不同语言，那对于数据处理上的些微不同最终都可能破坏数据一致性。&lt;/p&gt;
&lt;p&gt;因此，保证数据一致性最好的办法就是用一份代码在两个地方干同样的事情。我们线上服务是用 C++ 编写的，因此我们可以将特征 ETL 抽象成单独的模块，分别链接到线上服务以及离线特征处理程序中。这样，二者对于特征的 ETL 的行为就完全一致了。&lt;/p&gt;
&lt;p&gt;剩下的问题就是：离线数据通过 Kafka 落在 Hive 表当中，我们需要在 Hive 处理数据的过程中，嵌入我们自己编写的特征处理程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data and Machine Learning" scheme="https://liam.page/categories/Big-Data-and-Machine-Learning/"/>
    
    
      <category term="Hive" scheme="https://liam.page/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>利用 Protobuf 中 oneof 的特性生成 has_xxx 接口</title>
    <link href="https://liam.page/2020/05/05/using-oneof-to-generate-has-xxx-in-pb3/"/>
    <id>https://liam.page/2020/05/05/using-oneof-to-generate-has-xxx-in-pb3/</id>
    <published>2020-05-05T11:38:42.000Z</published>
    <updated>2020-05-16T14:25:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Protobuf（全称 Protocal Buffer，简称 pb）是 Google 开源的序列化/反序列化工具，在工业界相当流行。pb3 相比 pb2 的一个显著变化，就是在 pb3 当中不再区分 <code>required</code> 和 <code>optional</code> 字段。与此同时，在 pb2 中针对 <code>optional</code> 基本类型字段设计的 <code>[default = foobar]</code> 的默认值功能和 <code>has_xxx()</code> 的接口也随之消失。这样引出来一个问题，即：</p><ul><li>在多数场景下，「未设置」和「取值为 <code>0</code>/<code>0.0</code>/<code>&quot;&quot;</code>/<code>false</code>」等价；但是</li><li>在某些场景下，「未设置」和上述取值不等价。</li></ul><p>特别地，在序列化 - 反序列化之后，如果拿到一个零值，你无法得知这个值是确实为零值，还是说因为没有显示设置而得到的零值。本文在 C++ 场景下来解决这个问题。</p><a id="more"></a><h2 id="oneof"><a href="#oneof" class="headerlink" title="oneof"></a><code>oneof</code></h2><p>Protobuf 提供了 <code>oneof</code> 功能（见<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#oneof" target="_blank" rel="noopener">文档</a>）。其本意是想实现 C/C++ 当中 <code>union</code> 的功能，即多个不同类型共享存储空间，但同一时间只有一个类型有实际值。但在实现的过程中，Protobuf 做了一些妥协。例如，对于下面这样定义的 <code>message</code> 来说，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message FooMessage &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  oneof oneof_name &#123;</span><br><span class="line">    int32 bar = 2;</span><br><span class="line">    int64 baz = 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成的类当中，会有一个名为 <code>OneofNameCase</code> 的枚举类型来标记 <code>oneof_name</code> 字段的设置状态——你可以用 <code>oneof_name_case()</code> 接口来获取该状态。若状态取 <code>ONEOF_NAME_NOT_SET</code> 说明 <code>oneof_name</code> 未设置，若状态取 <code>kBar</code>/<code>kBaz</code> 其意义不言自明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> OneofNameCase &#123;</span><br><span class="line">  kBar = <span class="number">2</span>,</span><br><span class="line">  kBaz = <span class="number">3</span>,</span><br><span class="line">  ONEOF_NAME_NOT_SET = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文档未注明的特性"><a href="#文档未注明的特性" class="headerlink" title="文档未注明的特性"></a>文档未注明的特性</h2><p>对比开发文档和 pb3 的源码，我们发现 pb3 会为 <code>oneof</code> 字段生成一个 <code>has_xxx()</code> 的接口，其实现正是内联了 <code>return xxx_case() != XXX_NOT_SET;</code>。</p><p>注意到其命名策略，我们只需定义一个<strong>只含有一个字段的同名 <code>oneof</code></strong>就能方便地判断了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message FooMessage &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  oneof bar &#123;</span><br><span class="line">    int32 bar = 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Protobuf 会生成 <code>has_bar()</code> 这个接口。于是，利用这一特性，我们就可以在反序列化之后来判断字段是否有设置过了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Protobuf（全称 Protocal Buffer，简称 pb）是 Google 开源的序列化/反序列化工具，在工业界相当流行。pb3 相比 pb2 的一个显著变化，就是在 pb3 当中不再区分 &lt;code&gt;required&lt;/code&gt; 和 &lt;code&gt;optional&lt;/code&gt; 字段。与此同时，在 pb2 中针对 &lt;code&gt;optional&lt;/code&gt; 基本类型字段设计的 &lt;code&gt;[default = foobar]&lt;/code&gt; 的默认值功能和 &lt;code&gt;has_xxx()&lt;/code&gt; 的接口也随之消失。这样引出来一个问题，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多数场景下，「未设置」和「取值为 &lt;code&gt;0&lt;/code&gt;/&lt;code&gt;0.0&lt;/code&gt;/&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;」等价；但是&lt;/li&gt;
&lt;li&gt;在某些场景下，「未设置」和上述取值不等价。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别地，在序列化 - 反序列化之后，如果拿到一个零值，你无法得知这个值是确实为零值，还是说因为没有显示设置而得到的零值。本文在 C++ 场景下来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Protobuf" scheme="https://liam.page/tags/Protobuf/"/>
    
      <category term="Protobuf 3" scheme="https://liam.page/tags/Protobuf-3/"/>
    
  </entry>
  
  <entry>
    <title>在 CTeX 套装附带的 WinEdt 中自由切换发行版</title>
    <link href="https://liam.page/2020/04/30/switch-between-CTeX-and-TeX-Live-in-WinEdt/"/>
    <id>https://liam.page/2020/04/30/switch-between-CTeX-and-TeX-Live-in-WinEdt/</id>
    <published>2020-04-30T07:11:49.000Z</published>
    <updated>2020-05-06T16:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然站在如今（2020-04-30），CTeX 套装已经应该被扫进历史的垃圾桶。但是，CTeX 套装曾经的贡献不应该被一并扫进垃圾桶。</p><p>CTeX 套装是很多人用的第一个 TeX 发行版。其中的 WinEdt 编辑器，也是非常优秀的 TeX 编辑器，很多人更是用顺手了不乐意换。于是，如何方便地切换到 TeX Live 2020，并允许用户在需要的时候切回 CTeX 套装就是个问题了。</p><p>本文来解决它。</p><a id="more"></a><h2 id="问题拆分"><a href="#问题拆分" class="headerlink" title="问题拆分"></a>问题拆分</h2><p>问题需要拆分成两个部分。</p><ol><li>如何在 CTeX 套装和 TeX Live 当中自由切换；</li><li>如何让 WinEdt 的编码在 GBK（CTeX 套装的默认设定）和 UTF-8（使用现代 TeX 时推荐的编码）之间切换。</li></ol><h2 id="发行版的切换"><a href="#发行版的切换" class="headerlink" title="发行版的切换"></a>发行版的切换</h2><p>我们假定用户首先安装了 CTeX，此时想要用 TeX Live，但又有保留 CTeX 套装的需求。此时，用户无需卸载 CTeX 套装，可以直接<a href="/texlive/">安装 TeX Live</a>。</p><p>安装好 TeX Live 之后，当需要使用 TeX Live 时，用户可以打开 WinEdt，遵循如下操作路径：</p><ul><li>菜单栏 Options</li><li>菜单 Configurations</li><li>二级菜单 TeX Live</li></ul><p>如此就完成了，可谓是超简单。若要切换回 CTeX 套装，则只需按照相同的操作步骤，选择 MiKTeX 即可。</p><p><img data-src="/uploads/images/LaTeX/WinEdt-switch.png" alt></p><p>若要确定当前使用哪一个发行版，只需抬头看看 WinEdt 标题栏上的提示即可。</p><p><img data-src="/uploads/images/LaTeX/WinEdt-status-bar.png" alt></p><h2 id="切换编码"><a href="#切换编码" class="headerlink" title="切换编码"></a>切换编码</h2><p>切换编码稍显复杂，但也不困难。具体设置在以下位置：</p><ul><li>菜单栏 Options</li><li>菜单 Preferences</li><li>标签 Unicode</li><li>区域 Unicode Preferences</li></ul><p>我们将「Enable UTF-8 Format for Modes:」下面的输入框的内容修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TeX;UTF-8|ACP;EDT;INI</span><br></pre></td></tr></table></figure><p>而后，</p><ul><li>当你需要使用 UTF-8 编码时，勾选「Enable UTF-8 Format for Modes:」前的复选框，而不勾选本页其他三个复选框。（如图）<br>  <img data-src="/uploads/images/LaTeX/WinEdt-encoding.png" alt></li><li>当你需要使用 GBK 编码时，取消勾选「Enable UTF-8 Format for Modes:」前的复选框，而勾选本页其他三个复选框。</li></ul><p>至此，老树焕新春，CTeX 套装可以愉快地和最新的 TeX Live 共存了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然站在如今（2020-04-30），CTeX 套装已经应该被扫进历史的垃圾桶。但是，CTeX 套装曾经的贡献不应该被一并扫进垃圾桶。&lt;/p&gt;
&lt;p&gt;CTeX 套装是很多人用的第一个 TeX 发行版。其中的 WinEdt 编辑器，也是非常优秀的 TeX 编辑器，很多人更是用顺手了不乐意换。于是，如何方便地切换到 TeX Live 2020，并允许用户在需要的时候切回 CTeX 套装就是个问题了。&lt;/p&gt;
&lt;p&gt;本文来解决它。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="CTeX" scheme="https://liam.page/tags/CTeX/"/>
    
      <category term="TeX Live" scheme="https://liam.page/tags/TeX-Live/"/>
    
      <category term="MiKTeX" scheme="https://liam.page/tags/MiKTeX/"/>
    
      <category term="WinEdt" scheme="https://liam.page/tags/WinEdt/"/>
    
  </entry>
  
  <entry>
    <title>用 minted 构建 example 环境</title>
    <link href="https://liam.page/2020/04/29/combine-minted-and-its-layout-as-example/"/>
    <id>https://liam.page/2020/04/29/combine-minted-and-its-layout-as-example/</id>
    <published>2020-04-29T03:41:32.000Z</published>
    <updated>2020-04-29T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 LaTeX 中排版代码的环境有很多，在普通用户里最出名的当属 listings 和 minted。前者在纯粹的 LaTeX 环境中就能使用，后者则需要开启 <code>--shell-escape</code> 标记调用外部 Pygmentize 来美化代码。对于 listings 来说，配置一个美观的输出还是比较麻烦的，于是越来越多的人开始使用 minted。</p><p>此次要解决的问题，是构造一个 <code>example</code> 环境。其中包含 LaTeX 代码，然后输出分两部分。左侧是代码本身，用 minted 排版输出；右侧是代码的输出效果。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为我们要「一码两用」，所以就必然牵扯到将代码暂存，然后由两部分输出代码分别调用的问题。在 TeX 里暂存代码，要不然暂存到一个文件当中，要不然暂存到一个宏当中。考虑到我们之后要使用 minted 将代码原样输出，若是将代码暂存到一个宏当中，之后的展开控制会变得非常复杂。所以方案基本就确定了：我们要将代码暂存到外部文件当中。</p><p>代码既存，我们接下来就要考虑输出。对于 minted 来说，它有 <code>\inputminted</code> 可读入外部文件进行排版。对于输出代码效果来说，因为暂存的代码本就是 LaTeX 的代码，所以只需 <code>\input</code> 进来即可。我们需要做的工作，就只有将两部分输出安排的明明白白。</p><h2 id="暂存代码"><a href="#暂存代码" class="headerlink" title="暂存代码"></a>暂存代码</h2><p>minted 宏包会将需要排版的代码内容交给 Pygmentize 来美化，而 Pygmentize 美化的输入当然也是文件。所以，这样推论下去，minted 宏包必然会将需要排版的代码内容临时输出到文件。因此，我们要将代码暂存到外部文件，就可以借助 minted 宏包已经实现的内部宏来实现。我们现在需要找到这段代码，然后做可能必要的修改。</p><p>首先打开 <code>minted.sty</code>，找到定义 <code>minted</code> 环境的地方。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">ifthenelse</span><span class="string">&#123;\boolean&#123;minted@draft&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;minted&#125;</span><span class="string">[2]</span><span class="string">[]</span></span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@configlang&#123;#2&#125;<span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">setkeys</span><span class="string">&#123;minted@opt@cmd&#125;</span><span class="string">&#123;#1&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@fvset</span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@langlinenoson</span><br><span class="line">      <span class="tag">\<span class="name">begin</span><span class="string">&#123;Verbatim&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">end</span><span class="string">&#123;Verbatim&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@langlinenosoff&#125;&#125;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;minted&#125;</span><span class="string">[2]</span><span class="string">[]</span></span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVB</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut</span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVE</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@configlang&#123;#2&#125;<span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">setkeys</span><span class="string">&#123;minted@opt@cmd&#125;</span><span class="string">&#123;#1&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">minted</span></span>@fvset</span><br><span class="line">      <span class="tag">\<span class="name">begin</span><span class="string">&#123;VerbatimOut&#125;</span><span class="string">[codes=&#123;\catcode`\^^I=12&#125;,firstline,lastline]</span><span class="string">&#123;\minted@jobname.pyg&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    &#123;<span class="tag">\<span class="name">end</span><span class="string">&#123;VerbatimOut&#125;</span></span><span class="comment">%</span></span><br><span class="line">        <span class="tag">\<span class="name">minted</span></span>@langlinenoson</span><br><span class="line">        <span class="tag">\<span class="name">minted</span></span>@pygmentize&#123;<span class="tag">\<span class="name">minted</span></span>@lang&#125;<span class="comment">%</span></span><br><span class="line">        <span class="tag">\<span class="name">minted</span></span>@langlinenosoff&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们显然应该看非 draft 的版本。注意到环境定义前半截的最后有：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;VerbatimOut&#125;</span><span class="string">[codes=&#123;\catcode`\^^I=12&#125;,firstline,lastline]</span><span class="string">&#123;\minted@jobname.pyg&#125;</span></span>&#125;</span><br></pre></td></tr></table></figure><p><code>\minted@jobname.pyg</code> 这显然是一个外部文件，而且，看文件扩展名这应该是一个已经经由 Pygmentize 美化好的结果了。因此，将代码暂存外部的实现一定在这之前。从命名来看，下列两行代码就变得非常可疑：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVB</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut</span><br><span class="line"><span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FVE</span></span>@VerbatimOut<span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br></pre></td></tr></table></figure><p>我们来看看这两个命令是怎么定义的。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\minted@FVB@VerbatimOut&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \setcounter&#123;minted@FancyVerbLineTemp&#125;</span><span class="string">&#123;\value&#123;FancyVerbLine&#125;</span></span>&#125;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">@</span></span>bsphack</span><br><span class="line">  <span class="tag">\<span class="name">begingroup</span></span></span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@UseKeyValues</span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@DefineWhiteSpace</span><br><span class="line">    <span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@Space&#123;<span class="tag">\<span class="name">space</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@DefineTabOut</span><br><span class="line">    <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@ProcessLine<span class="tag">\<span class="name">minted</span></span>@write@detok</span><br><span class="line">    <span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile #1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">    <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@FontScanPrep<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">    <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">@</span></span>noligs<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">    <span class="tag">\<span class="name">FV</span></span>@Scan&#125;</span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\minted@FVE@VerbatimOut&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \immediate\closeout\FV@OutFile\endgroup\@esphack</span></span></span><br><span class="line"><span class="tag"><span class="string">  \setcounter&#123;FancyVerbLine&#125;</span><span class="string">&#123;\value&#123;minted@FancyVerbLineTemp&#125;</span></span>&#125;&#125;<span class="comment">%</span></span><br></pre></td></tr></table></figure><p>我们先不出去处理那一堆 <code>\FV@</code> 开头的宏，把目光集中在以下几行：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile #1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line"><span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">closeout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile</span><br></pre></td></tr></table></figure><p>这是 TeX 中与文件交互的经典命令。其中</p><ul><li><code>\immediate</code> 表示立即执行。这是因为大多数 TeX 和文件相关的命令都会延后执行，等到命令所在位置被真正排版完成后再执行。</li><li><code>\openout</code> 和 <code>\closeout</code> 相当于 C 语言当中的 <code>fopen</code> 和 <code>fclose</code>。</li><li><code>\FV@OutFile</code> 则相当于 C 语言当中的 <code>FILE</code> 指针，对应一个实际的外部文件。</li><li>这里的 <code>#1</code> 就是外部文件的文件名，它是 <code>\minted@FVB@VerbatimOut</code> 的参数。</li></ul><p>由此可见，我们确实已经找到了 minted 宏包暂存代码的位置。接下来，我们逐行来看这两个宏都干了啥。</p><ul><li><p><code>\setcounter{minted@FancyVerbLineTemp}{\value{FancyVerbLine}}</code>/<code>\setcounter{FancyVerbLine}{\value{minted@FancyVerbLineTemp}}</code> 这是在设置行号相关的计数器。我们用不着。</p></li><li><p><code>\@bsphack</code>/<code>\@esphack</code> 这是 LaTeX 定义的内部宏，作用是使他们界定的范围内的代码，当被用在一串文字中间时，不出现额外的空格。这个我们照旧保留。</p></li><li><p><code>\FV@DefineWhiteSpace</code> 定义在 fancyvrb 宏包（为 minted 宏包所调用）内的宏，它将空格和制表符定义为活动字符，并将他们分别定义为 <code>\FV@Space</code> 和 <code>\FV@Tab</code>。其定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begingroup</span></span></span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span>`<span class="tag">\<span class="name"> </span>=</span><span class="tag">\<span class="name">active</span></span></span><br><span class="line"><span class="tag">\<span class="name">catcode</span></span>`<span class="tag">\<span class="name">^</span></span>^I=<span class="tag">\<span class="name">active</span></span></span><br><span class="line"><span class="tag">\<span class="name">gdef</span></span><span class="tag">\<span class="name">FV</span></span>@DefineWhiteSpace&#123;<span class="tag">\<span class="name">def</span></span> &#123;<span class="tag">\<span class="name">FV</span></span>@Space&#125;<span class="tag">\<span class="name">def</span></span>^^I&#123;<span class="tag">\<span class="name">FV</span></span>@Tab&#125;&#125;<span class="comment">%</span></span><br><span class="line"><span class="tag">\<span class="name">endgroup</span></span></span><br></pre></td></tr></table></figure><p>我们照旧保留。</p></li><li><p><code>\def\FV@Space{\space}</code> 和上面的 <code>\FV@DefineWhiteSpace</code> 的定义相对应可知其意。我们照旧保留。</p></li><li><p><code>\FV@DefineTabOut</code> 也是定义在 fancyvrb 宏包内的宏，它将制表符定义为连续多个空格。其定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@DefineTabOut&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@Tab&#123;&#125;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">@</span></span>tempcnta=<span class="tag">\<span class="name">FancyVerbTabSize</span></span><span class="tag">\<span class="name">relax</span></span></span><br><span class="line">  <span class="tag">\<span class="name">loop</span></span><span class="tag">\<span class="name">ifnum</span></span><span class="tag">\<span class="name">@</span></span>tempcnta&gt;<span class="tag">\<span class="name">z</span></span>@</span><br><span class="line">    <span class="tag">\<span class="name">edef</span></span><span class="tag">\<span class="name">FV</span></span>@Tab&#123;<span class="tag">\<span class="name">FV</span></span>@Tab<span class="tag">\<span class="name">space</span></span>&#125;<span class="comment">%</span></span><br><span class="line">    <span class="tag">\<span class="name">advance</span></span><span class="tag">\<span class="name">@</span></span>tempcnta<span class="tag">\<span class="name">m</span></span>@ne</span><br><span class="line">  <span class="tag">\<span class="name">repeat</span></span>&#125;</span><br></pre></td></tr></table></figure><p>我们照旧保留。</p></li><li><p><code>\let\FV@ProcessLine\minted@write@detok</code> 看名字是用来处理一行代码的宏，后者的定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\minted@write@detok&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \immediate\write\FV@OutFile&#123;\detokenize&#123;#1&#125;</span></span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>显然，它就是将一行内容去记号化之后写入文件。这正是我们要的东西，照旧保留。</p></li><li><p><code>\FV@Scan</code> 也是定义在 fancyvrb 宏包内的宏，其定义是：</p>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">FV</span></span>@Scan&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">FV</span></span>@CatCodes</span><br><span class="line">  <span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line">  <span class="tag">\<span class="name">FV</span></span>@DefineCheckEnd</span><br><span class="line">  <span class="tag">\<span class="name">FV</span></span>@BeginScanning&#125;</span><br></pre></td></tr></table></figure><p>可知其意是开始逐行扫描内容。照旧保留。</p></li></ul><p>既然已知 <code>\minted@FVB@VerbatimOut</code> 和 <code>\minted@FVE@VerbatimOut</code> 都做了什么，自然就知道应如何重定义他们了。我们有：</p><figure class="highlight tex"><figcaption><span>foo.tex</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;minted&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">makeatletter</span></span></span><br><span class="line"><span class="tag">\<span class="name">edef</span></span><span class="tag">\<span class="name">example</span></span>@name&#123;<span class="tag">\<span class="name">jobname</span></span>-example.aux&#125;</span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;example&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \renewcommand&#123;\minted@FVB@VerbatimOut&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \@bsphack</span></span></span><br><span class="line"><span class="tag"><span class="string">    \begingroup</span></span></span><br><span class="line"><span class="tag"><span class="string">      \FV@DefineWhiteSpace</span></span></span><br><span class="line"><span class="tag"><span class="string">      \def\FV@Space&#123;\space&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@DefineTabOut</span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@ProcessLine<span class="tag">\<span class="name">minted</span></span>@write@detok</span><br><span class="line">      <span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile ##1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@FontScanPrep<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">@</span></span>noligs<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@Scan&#125;</span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut&#123;<span class="tag">\<span class="name">example</span></span>@name&#125;<span class="comment">%</span></span><br><span class="line">&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\minted@FVE@VerbatimOut&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \immediate\closeout\FV@OutFile\endgroup\@esphack&#125;</span></span><span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">makeatother</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">Hello <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>.</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">[</span></span> E = mc^2. <span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>至此，我们的 <code>example</code> 环境会将环境内容原样输出到 <code>\jobname-example.aux</code> 这个文件里面了。若文件保存为 <code>foo.tex</code>，则我们在 <code>foo-example.aux</code> 当中能看到质能方程的内容。</p><figure class="highlight tex"><figcaption><span>foo-example.aux</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">[</span></span> E = mc^2. <span class="tag">\<span class="name">]</span></span></span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>解决了代码暂存的问题，接下来就是排版了。这里我们实现一个最简单的排版效果：左代码，右效果，上下加两条横线以示区分。读者有兴趣可以扩充其效果。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;minted&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">makeatletter</span></span></span><br><span class="line"><span class="tag">\<span class="name">edef</span></span><span class="tag">\<span class="name">example</span></span>@name&#123;<span class="tag">\<span class="name">jobname</span></span>-example.aux&#125;</span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;example&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">  \renewcommand&#123;\minted@FVB@VerbatimOut&#125;</span><span class="string">[1]</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \@bsphack</span></span></span><br><span class="line"><span class="tag"><span class="string">    \begingroup</span></span></span><br><span class="line"><span class="tag"><span class="string">      \FV@DefineWhiteSpace</span></span></span><br><span class="line"><span class="tag"><span class="string">      \def\FV@Space&#123;\space&#125;</span></span><span class="comment">%</span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@DefineTabOut</span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@ProcessLine<span class="tag">\<span class="name">minted</span></span>@write@detok</span><br><span class="line">      <span class="tag">\<span class="name">immediate</span></span><span class="tag">\<span class="name">openout</span></span><span class="tag">\<span class="name">FV</span></span>@OutFile ##1<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">FV</span></span>@FontScanPrep<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">let</span></span><span class="tag">\<span class="name">@</span></span>noligs<span class="tag">\<span class="name">relax</span></span></span><br><span class="line">      <span class="tag">\<span class="name">FV</span></span>@Scan&#125;</span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVB@VerbatimOut&#123;<span class="tag">\<span class="name">example</span></span>@name&#125;<span class="comment">%</span></span><br><span class="line">&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\minted@FVE@VerbatimOut&#125;</span><span class="string">&#123;%</span></span></span><br><span class="line"><span class="tag"><span class="string">    \immediate\closeout\FV@OutFile\endgroup\@esphack&#125;</span></span><span class="comment">%</span></span><br><span class="line">  <span class="tag">\<span class="name">minted</span></span>@FVE@VerbatimOut</span><br><span class="line">  <span class="tag">\<span class="name">setlength</span><span class="string">&#123;\parindent&#125;</span><span class="string">&#123;0pt&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">hrulefill</span></span><span class="tag">\<span class="name">par</span></span><span class="tag">\<span class="name">vspace</span><span class="string">&#123;1em&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[c]</span><span class="string">&#123;0.45\linewidth&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">inputminted</span><span class="string">&#123;latex&#125;</span><span class="string">&#123;\example@name&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span><span class="tag">\<span class="name">hfill</span></span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[c]</span><span class="string">&#123;0.45\linewidth&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">input</span><span class="string">&#123;\example@name&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span><span class="tag">\<span class="name">par</span></span><span class="tag">\<span class="name">vspace</span><span class="string">&#123;1em&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">hrulefill</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">makeatother</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">Hello <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>.</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">[</span></span> E = mc^2. <span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;example&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/example-demo.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 LaTeX 中排版代码的环境有很多，在普通用户里最出名的当属 listings 和 minted。前者在纯粹的 LaTeX 环境中就能使用，后者则需要开启 &lt;code&gt;--shell-escape&lt;/code&gt; 标记调用外部 Pygmentize 来美化代码。对于 listings 来说，配置一个美观的输出还是比较麻烦的，于是越来越多的人开始使用 minted。&lt;/p&gt;
&lt;p&gt;此次要解决的问题，是构造一个 &lt;code&gt;example&lt;/code&gt; 环境。其中包含 LaTeX 代码，然后输出分两部分。左侧是代码本身，用 minted 排版输出；右侧是代码的输出效果。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="minted" scheme="https://liam.page/tags/minted/"/>
    
      <category term="example" scheme="https://liam.page/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>嘿嘿嘿使 TeX 爆炸</title>
    <link href="https://liam.page/2020/04/28/hhh-explodes-TeX/"/>
    <id>https://liam.page/2020/04/28/hhh-explodes-TeX/</id>
    <published>2020-04-28T11:48:31.000Z</published>
    <updated>2020-04-29T04:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>TeX 里有 <code>\leavevmode</code> 用来从竖直模式中切出去，那么有没有 <code>\leavehmode</code> 呢？一定会有好奇宝宝好奇这个奇怪的问题的。</p><p>答案是：<del>嘿嘿嘿使 TeX 爆炸</del>不存在。</p><a id="more"></a><p>TeX 总是从竖直模式开始，然后一旦遇到水平命令时，就会离开竖直模式，然后开始构建段落。除非结束这个段落，TeX 是不会离开水平模式的。</p><p>怎么结束这个段落？当然是你熟知的 <code>\par</code> 命令。实际上，任何会导致 TeX 离开水平模式的命令，都会调用 <code>\par</code> 这个命令——这里的 <code>\par</code> 是最原始到那个 <code>\par</code> 原语。如果你把 <code>\par</code> 定义成了一个不包含原语版的 <code>\par</code> 的时候，所有导致 TeX 离开水平模式的命令都会导致死循环。比如下面代码：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">par</span><span class="string">&#123;&#125;</span></span></span><br><span class="line">x<span class="tag">\<span class="name">vskip</span></span> 1pt</span><br></pre></td></tr></table></figure><p>（你看，让 TeX 死循环就这么简单）</p><p>所以，不存在 <code>\leavehmode</code> 这种东西。能让 TeX 离开水平模式的只有 <code>\par</code>。</p><p>不过，存在一种情况下，TeX 可以部分地离开模式——<code>\vadjust</code> 命令。在水平模式中遇到 <code>\vadjust</code> 时，TeX 会把它的参数中的所有竖直元素打包在一起暂存，然后等到断行成段之后，TeX 再把 <code>\vadjust</code> 里的内容插入到 <code>\vadjust</code> 存在的那一行之后。比如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;zhlipsum&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">嘿嘿嘿<span class="tag">\<span class="name">vadjust</span><span class="string">&#123;\vskip 3ex&#125;</span></span><span class="tag">\<span class="name">zhlipsum</span><span class="string">[3]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/images/LaTeX/vadjust.jpg" alt></p><hr><p>那么为什么「嘿嘿嘿使 TeX 爆炸」呢？因为当你把 <code>\par</code> 定义成「嘿嘿嘿」的时候，TeX 就会因为陷入死循环而不断地把「嘿嘿嘿」塞入内存，然后就炸掉了。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">par</span><span class="string">&#123;嘿嘿嘿&#125;</span></span></span><br><span class="line">x<span class="tag">\<span class="name">vskip</span></span> 1pt</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(./ltxtest.aux) ABD: EverySelectfont initializing macros</span><br><span class="line">! TeX capacity exceeded, sorry [main memory size=5000000].</span><br><span class="line">&lt;to be read again&gt;</span><br><span class="line">                   \vskip</span><br><span class="line">l.4 x\vskip</span><br><span class="line">            1pt</span><br><span class="line">No pages of output.</span><br><span class="line">Transcript written on ltxtest.log.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TeX 里有 &lt;code&gt;\leavevmode&lt;/code&gt; 用来从竖直模式中切出去，那么有没有 &lt;code&gt;\leavehmode&lt;/code&gt; 呢？一定会有好奇宝宝好奇这个奇怪的问题的。&lt;/p&gt;
&lt;p&gt;答案是：&lt;del&gt;嘿嘿嘿使 TeX 爆炸&lt;/del&gt;不存在。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Mode" scheme="https://liam.page/tags/Mode/"/>
    
  </entry>
  
</feed>
