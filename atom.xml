<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2021-12-12T05:28:59.495Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的自我修养（⑫）：C++ 的内存顺序·中</title>
    <link href="https://liam.page/2021/12/11/memory-order-cpp-02/"/>
    <id>https://liam.page/2021/12/11/memory-order-cpp-02/</id>
    <published>2021-12-11T00:27:42.000Z</published>
    <updated>2021-12-12T05:28:59.495Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇（<a href="/2021/06/05/memory-model-cpp/">内存模型</a>与<a href="/2021/06/06/memory-order-cpp-01/">内存顺序·上</a>）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">对应页面</a>的翻译，但会展开做一些讨论。</p><a id="more"></a><h2 id="六种内存顺序标签"><a href="#六种内存顺序标签" class="headerlink" title="六种内存顺序标签"></a>六种内存顺序标签</h2><p>C++ 标准库定义了六中内存顺序标签（memory order tag）。他们被定义为一个枚举类型。在 C++11 之后、C++20 之前，定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> memory_order &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p>在 C++20 中，则使用新的 <code>enum class</code> 重新定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">memory_order</span> :</span> <span class="comment">/*unspecified*/</span> &#123;</span><br><span class="line">    relaxed, consume, acquire, release, acq_rel, seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_relaxed = memory_order::relaxed;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_consume = memory_order::consume;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acquire = memory_order::acquire;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_release = memory_order::release;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acq_rel = memory_order::acq_rel;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_seq_cst = memory_order::seq_cst;</span><br></pre></td></tr></table></figure><p>我们知道，原子变量上没有数据竞争，从而提供了良定义的多线程并发读写能力。因此，原子变量有可能实际上建立了线程间的同步关系，于是建立了某种<ins>先于（happens-before）</ins>关系。</p><p>在原子操作上添加六种内存顺序标签（中的一部分），会<strong>影响（但不一定改变；视 CPU 架构）原子操作附近的内存访问顺序（包括其他原子操作，亦包含对非原子变量的读写操作）</strong>。注意，内存顺序（通过六种标签）讨论的实际上是线程内原子操作附近非原子操作访问内存的顺序，而非是多线程之间的执行顺序。只不过，因为原子变量自身可能建立了线程间的同步关系，所以<strong>两个线程内各自的内存顺序会经由原子变量的同步建立间接的顺序关系</strong>。亦即，<strong>内存顺序本质上是在讨论单线程内指令执行顺序对多线程影响</strong>的问题。显然，通过添加内存顺序标签，编译器优化和 CPU 指令多发射（multiple issue）、CPU 乱序执行（out-of-order execution）都可能受到一定影响。</p><p>所有原子操作默认的内存顺序标签是 <code>std::memory_order_seq_cst</code>，亦即，提供顺序一致性的顺序保证（后续讨论）。目前而言，在绝大多数 CPU 架构上，顺序一致性模型都需要或多或少地在原子操作前后加上内存屏障（memory fence）。因而，顺序一致性虽好，但会损失部分性能。使用其它内存顺序标签则或多或少降低顺序一致性的保证。</p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>memory_order_relaxed</code></td><td>宽松操作：仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。</td></tr><tr><td><code>memory_order_consume</code></td><td>打上此标签的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E6%B6%88%E8%B4%B9%E6%93%8D%E4%BD%9C%EF%BC%88consume-operation%EF%BC%89">消费操作（consume operation）</a></ins>：当前线程中，所有依赖当前 load 操作读取的值的读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>依赖的变量的写入，对当前线程是可见的。多数平台上，该标签仅影响编译器优化。</td></tr><tr><td><code>memory_order_acquire</code></td><td>打上此标签的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E5%8D%A0%E6%9C%89%E6%93%8D%E4%BD%9C%EF%BC%88aquire-operation%EF%BC%89">占有操作（aquire operation）</a></ins>：当前线程中，所有读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前线程是可见的。</td></tr><tr><td><code>memory_order_release</code></td><td>打上此标签的 store 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%EF%BC%88release-operation%EF%BC%89">释放操作（release operation）</a></ins>：当前线程中，所有读写操作不得重排至当前操作之后。因此，当前操作所在线程之前的写入操作，在其他线程中，对该原子变量施加<ins>占有操作（aquire operation）</ins>之后是可见的。也因此，当前操作所在线程中，当前操作所依赖的写入操作，在其他线程中，对该原子变量施加<ins>消费操作（consume operation）</ins>之后是可见的。</td></tr><tr><td><code>memory_order_acq_rel</code></td><td>打上此标签的 read-modify-write 操作既是<ins>占有操作（aquire operation）</ins>又是<ins>释放操作（release operation）</ins>：当前线程中的读写操作不能重排至当前操作之后（如果原本在之前），亦不能重排至当前操作之前（如果原本在之后）。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前 modification 是可见的；该 modification 对其他线程中相同原子变量<ins>占有操作（aquire operation）</ins>之后亦是可见的。</td></tr><tr><td><code>memory_order_seq_cst</code></td><td>打上此标签的 load 操作对相关内存位置施加<ins>占有操作（aquire operation）</ins>；打上此标签的 store 操作对相关内存位置施加<ins>释放操作（release operation）</ins>；打上此标签的 read-modify-write 对相关内存位置施加<ins>占有操作（aquire operation）</ins>和<ins>释放操作（release operation）</ins>。此外，对所有线程来说，所有打上该标签的写操作，存在一个全局修改顺序（尽管具体顺序在执行时才确定）。也就是说，对于所有线程来说，看见的这些写操作的顺序是一致的。</td></tr></tbody></table><h2 id="宽松顺序（Relaxed-ordering）"><a href="#宽松顺序（Relaxed-ordering）" class="headerlink" title="宽松顺序（Relaxed ordering）"></a>宽松顺序（Relaxed ordering）</h2><p>宽松顺序仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。因此，它们不是同步操作，仅保证原子变量上读写操作的原子性，以及各个原子变量自身修改顺序的一致性（对于同一个变量的两次修改，虽然顺序不一定，但是所有其他线程观察到的修改顺序都是相同的）。</p><p>假定 <code>x</code> 和 <code>y</code> 是两个全局变量，均被初始化为零，则下列代码执行完毕之后，存在 <code>r1 == r2 == 42</code> 的可能性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.load(<span class="built_in">std</span>::memory_order_relaxed);  <span class="comment">// A</span></span><br><span class="line">x.store(r1, <span class="built_in">std</span>::memory_order_relaxed);  <span class="comment">// B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.load(<span class="built_in">std</span>::memory_order_relaxed);  <span class="comment">// C</span></span><br><span class="line">y.store(<span class="number">42</span>, <span class="built_in">std</span>::memory_order_relaxed);  <span class="comment">// D</span></span><br></pre></td></tr></table></figure><p>这是因为，虽然在线程 1 和线程 2 中分别有 A <ins>先序于（sequenced-before）</ins> B 和 C <ins>先序于（sequenced-before）</ins> D；但是，对于原子变量 <code>y</code> 的<ins>修改顺序（Modification Order）</ins>来说，D 可能先于 A 发生；同样，对于原子变量 <code>x</code> 的<ins>修改顺序（Modification Order）</ins>来说，B 可能先于 C 发生。</p><p>这种现象，（以线程 2 为例），可能是编译器优化时的乱序导致的，也可能是 CPU 执行时的乱序导致的。</p><p>宽松顺序的典型场景是不断增加的计数器。计数器的增加只需有原子性的保证，而对同步或是内存顺序没有要去。例如，<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener"><code>std::shared_ptr</code></a> 当中的引用计数的增加。实例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        cnt.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        v.emplace_back(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : v) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value is "</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final counter value is 10000</span><br></pre></td></tr></table></figure><p>不过，对于 <code>std::shard_ptr</code> 当中的引用计数来说，其减少需要与析构函数当中的 load 操作有 acquire-release 的同步。</p><h2 id="释放-获取顺序（Release-Acquire-ordering）"><a href="#释放-获取顺序（Release-Acquire-ordering）" class="headerlink" title="释放-获取顺序（Release-Acquire ordering）"></a>释放-获取顺序（Release-Acquire ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_acquire</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行释放操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在部分强顺序的 CPU 架构中（例如 <code>x86</code>, SPARC TSO, IBM mainframe 等），释放-获取顺序对大多数操作来说都是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将非原子的 load 操作挪到原子 load-acquire 操作之前）。</p><p>在弱顺序的 CPU 架构中（例如 ARM,Itanium, PowerPC），则需加入额外的 CPU 指令或是内存屏障。</p><p>互斥锁（例如 <a href="https://en.cppreference.com/w/cpp/thread/mutex" target="_blank" rel="noopener"><code>std::mutex</code></a>/<a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag" target="_blank" rel="noopener">atomic spinlock</a>）亦属于释放-获取同步：当锁被线程 A 释放而后被线程 B 获取，则在锁被释放之前临界区中所有对共享变量的写入操作在线程 B 获取锁之后均可见。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的获取-释放同步，因此两个 <code>assert</code> 永远不会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> data&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.load(<span class="built_in">std</span>::memory_order_acquire)));</span><br><span class="line">    assert(*p2 == <span class="string">"Hello"</span>); <span class="comment">// never fires</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例则展示了在三个线程之中，获取-释放顺序的传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.push_back(<span class="number">42</span>);</span><br><span class="line">    flag.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="number">2</span>, <span class="built_in">std</span>::memory_order_acq_rel)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.load(<span class="built_in">std</span>::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">    assert(data.at(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.join(); b.join(); c.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放-消费顺序（Release-Consume-ordering）"><a href="#释放-消费顺序（Release-Consume-ordering）" class="headerlink" title="释放-消费顺序（Release-Consume ordering）"></a>释放-消费顺序（Release-Consume ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_consume</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中依赖该原子变量的表达式和函数看来都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 中依赖该原子变量的表达式和函数可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行消费操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在除 DEC Alpha 之外的主流 CPU 上，释放-消费顺序（亦称：依赖顺序）是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将涉及到依赖链的非原子的 load 操作挪到原子 load-consume 操作之前）。</p><p>该顺序的使用，往往见于对并发共享数据结构有频繁读取而极少写入的场景（例如路由表、安全策略、防火墙规则等）。</p><p>注意，截至 2015 年 2 月，尚未有编译器追踪了依赖链条，因此，消费操作被提升为获取操作。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的释放-消费同步，因此第一个 <code>assert</code> 永远不会失败，但第二个 <code>assert</code> 可能失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.load(<span class="built_in">std</span>::memory_order_consume)));</span><br><span class="line">    assert(*p2 == <span class="string">"Hello"</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序一致顺序（Sequentially-consistent-ordering）"><a href="#顺序一致顺序（Sequentially-consistent-ordering）" class="headerlink" title="顺序一致顺序（Sequentially-consistent ordering）"></a>顺序一致顺序（Sequentially-consistent ordering）</h2><p>标记上 <code>std::memory_order_seq_cst</code> 的原子操作不仅满足释放-获取顺序的要求（一个线程中 store-release 之前的写入操作在另一个 load-acquire 之后都可见），而且为所有如此标记的原子操作建立了<strong>唯一的全局统一修改顺序（single total modification order）</strong>。</p><p>正式地说，在不考虑 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence" target="_blank" rel="noopener"><code>std::atomic_thread_fence</code></a> 的情况下，对于每个 load 原子变量 M 的操作 B（标记为 <code>std::memory_order_seq_cst</code>），它读取到的值来自以下三种可能：</p><ul><li>在上述<strong>唯一的全局统一修改顺序</strong>中的上一个修改了 M 的操作 A 的结果；</li><li>若存在这样的 A，B 还可能读到另一个修改了 M 的操作 C，它没有标记为 <code>std::memory_order_seq_cst</code>，并且不<ins>先于（happens-before）</ins> A；</li><li>若不存在这样的 A，B 读取的结果来自另一个修改了 M 的没有标记为 <code>std::memory_order_seq_cst</code>的操作 D。</li></ul><!-- Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order. --><p>顺序一致对于多生产者多消费者的情形是必要的。这是因为，所有消费者必须能够以相同的顺序观察到所有生产者的行为。</p><!-- Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core. --><p>在所有多核系统中（注：逻辑核），完全的顺序一致都会插入大量内存屏障指令。这使得相应的内存访问需要对所有核心进行广播，因而可能成为性能瓶颈。</p><!-- This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads c and d to observe changes to the atomics x and y in opposite order. --><p>下例中，顺序一致即是必要的。其他更弱的顺序模型可能导致线程 C 和线程 D 观察到原子变量 <code>x</code> 和 <code>y</code> 以不同的顺序修改，从而导致 <code>assert</code> 失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.join(); b.join(); c.join(); d.join();</span><br><span class="line">    assert(z.load() != <span class="number">0</span>);  <span class="comment">// will never happen</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与-volatile-的关系"><a href="#与-volatile-的关系" class="headerlink" title="与 volatile 的关系"></a>与 <code>volatile</code> 的关系</h2><!-- Within a thread of execution, accesses (reads and writes) through volatile glvalues cannot be reordered past observable side-effects (including other volatile accesses) that are sequenced-before or sequenced-after within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. --><p>在<strong>同一线程</strong>中，对 <code>volatile</code> 修饰的<a href="https://en.cppreference.com/w/cpp/language/value_category#glvalue" target="_blank" rel="noopener">泛左值</a>（包括左值和将亡值）的访问（包括读写）不允许被重排序至<ins>先序于（sequenced-before）</ins>该操作的可观测的副作用（包括其他 <code>volatile</code> 访问）之前，亦不允许被重排序至<ins>后序于（sequenced-after）</ins>该操作的可观测的副作用（同上）之后。然而，<code>volatile</code> 访问并未建立线程之间的同步，故而在其他线程中，上述顺序无法得到保证。</p><!-- In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access). --><p>此外，对 <code>volatile</code> 修饰的泛左值的访问不是原子的（这意味着读写同一内存位置上的 <code>volatile</code> 变量属于<a href="https://en.cppreference.com/w/cpp/language/memory_model" target="_blank" rel="noopener">数据竞争</a>），同时也不影响内存顺序（非 <code>volatile</code>-访问可以在 <code>volatile</code>-访问附近自由重排序）。</p><!-- One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (Microsoft Docs), and thus volatiles may be used for inter-thread synchronization. Standard volatile semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a std::signal handler that runs in the same thread when applied to sig_atomic_t variables. --><p>一个例外是 Visual Studio。根据<a href="https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp" target="_blank" rel="noopener">微软提供的文档</a>，在默认设置下，<code>volatile</code>-读自带 acquire 语义而 <code>volatile</code>-写自带 release 语义。因此，这些 <code>volatile</code>-访问可被用来建立线程间的同步。但要注意，标准的 <code>volatile</code> 语义不应被用于多线程编程。（这一点在<a href="/2018/01/18/volatile-in-C-and-Cpp/">前作</a>中也有讨论）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇（&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;与&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;内存顺序·上&lt;/a&gt;）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应页面&lt;/a&gt;的翻译，但会展开做一些讨论。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>论善良</title>
    <link href="https://liam.page/2021/06/17/discussion-on-kind/"/>
    <id>https://liam.page/2021/06/17/discussion-on-kind/</id>
    <published>2021-06-17T13:07:31.000Z</published>
    <updated>2021-06-17T15:52:46.963Z</updated>
    
    <content type="html"><![CDATA[<p>博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。</p><a id="more"></a><h2 id="善良是什么？"><a href="#善良是什么？" class="headerlink" title="善良是什么？"></a>善良是什么？</h2><p>善良一词，与我所见最早者，当出自《礼记·学记》。曰：「发虑宪，求善良，足以謏闻，不足以动众。」</p><p>按文言一贯作风，善良虽在现代汉语中成词已久，但在文言中大概是分别表意的。在文言文词典中，<a href="https://wyw.hwxnet.com/view/hwxE5hwx96hwx84.html" target="_blank" rel="noopener">善</a>作名词表示「好的行为」，作形容词表示「赞许的」或是「熟悉」。显然，此处应取「值得赞许的」的含义。<a href="https://wyw.hwxnet.com/view/hwxE8hwx89hwxAF.html" target="_blank" rel="noopener">良</a>作形容词表示「好」。因此，讲白了，文言中的「善良」大约就是人类品德中所有好的品德的集合体。</p><p>在现代汉语中，善良的表意某种意义上被圈定在「和善」、「心地好」这样的意思上了。</p><h2 id="人善被人欺？"><a href="#人善被人欺？" class="headerlink" title="人善被人欺？"></a>人善被人欺？</h2><p>大多数生长于传统中国家庭的孩子，大都从小被教育「要善良」。与之相应，孩子被要求「爱分享」、「乐于助人」等。</p><p>然而，步入社会之后，或多或少地，这些从小被教育要善良的孩子，都因「善良」吃过亏。其中不乏「屡教不改」抑或是「执迷不悔」的人，当然也有些人从此「黑化」或是抑郁。</p><p>这些时候，「孩子们」大约会想起父母的另一句话「害人之心不可有，防人之心不可无」。可是，爸爸妈妈，你们从来没教过我们要如何才能「防人」呀……</p><p>所以，到底要怎么办？</p><h2 id="善心？善举？"><a href="#善心？善举？" class="headerlink" title="善心？善举？"></a>善心？善举？</h2><p>面对这个问题，我们不能逃避。因为你能逃一次，但将来不断发生的事情，会不断质疑你的内心。最终逃无可逃，必须直面。</p><p>为了解决这个问题，我们将善良分为两个部分，或者说两个层次：善心和善举。善心是无条件的，行善举是有条件的。若是行善举会危害到自己的核心利益，那便要慎重。世人多被要求善良，却不分善举和善心。无差别的善举最终往往害人害己。</p><p>对于以善良为代表的一切「美好的德行」，都有<strong>论心不论迹</strong>。也就是说，我们要将善心和善举区分开来；而后，常怀善心，擅行善举。</p><h2 id="何时行善举？"><a href="#何时行善举？" class="headerlink" title="何时行善举？"></a>何时行善举？</h2><p>是否要行善举，这其实是一个选择题。</p><p>在我看来，这一选择题理当无有特殊性。也就是说，人生中其他类似的选择题如何做，这一道选择题就如何做。亦即，人自身的一切行为，都要有统一的标准去考量。不能因为善举于道德地位更高，就降低评判标准，而后决定施行，而不顾其可能带来的负面影响。</p><p>操作层面上，当意图行善时，脑回路里加一个步骤：这事儿做了之后最坏的结果自己能不能接受。如果不能接受的话，哪怕是善举，也慎重一些。</p><h2 id="不为善其与为恶异乎？"><a href="#不为善其与为恶异乎？" class="headerlink" title="不为善其与为恶异乎？"></a>不为善其与为恶异乎？</h2><p>或曰：「不为善者与为恶者，无异也」。曰：「道德绑架者也。」</p><p>有人认为，善而不为，其与恶无异。此类谬误有二。一者，忽略世界的多样性，将善恶二元对立，认为非善即恶。他们认为，不做善事就是恶；不作恶事就是善。二者，将善良至于绝对片面的语境之下，忽略实际情况，忽略自身自我，将善良狭隘化为一个放之四海而皆准的道德标尺。殊不知，因为行善举，而将自己置于无法承受的危险之下，实际上是忽略了自我。「我」都没有了，还谈什么善良呢？这不是善良，而是伪善。</p><p>这些人可能也会拿汉昭烈帝的「勿以善小而不为」来做例证。然而，刘备遗诏中的意思，是强调善举大小、影响范围，却没有教刘禅不分青红皂白应当一律行善。</p><p>因此，认为不行善举即是作恶的人，其实就是道德绑架罢了。</p><h2 id="真正的英雄主义"><a href="#真正的英雄主义" class="headerlink" title="真正的英雄主义"></a>真正的英雄主义</h2><p>罗曼·罗兰说：「世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它」。</p><p>如何能做到这一点？</p><p>自己的善举可能为自己带来危害，这也是生活的真相之一。被伤害过后，你还愿意保持善良吗？被伤害过后，你能控制自己不去伤害别人吗？换言之，被伤害过后，你还热爱这个世界吗？</p><p>广义地看待善良，将善心和善举分开，常怀善心、擅行善举，则哪怕不能成为真的英雄，也常在成为英雄的路上了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Kind" scheme="https://liam.page/tags/Kind/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑪）：C++ 的内存顺序·上</title>
    <link href="https://liam.page/2021/06/06/memory-order-cpp-01/"/>
    <id>https://liam.page/2021/06/06/memory-order-cpp-01/</id>
    <published>2021-06-06T04:16:06.000Z</published>
    <updated>2021-06-06T12:55:12.344Z</updated>
    
    <content type="html"><![CDATA[<p>此篇继<a href="/2021/06/05/memory-model-cpp/">前文</a>讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">对应页面</a>术语部分的翻译，有删减和补充。</p><a id="more"></a><p>线程间同步及内存顺序决定表达式的<ins>求值（evaluations）</ins>及其<ins>副作用（side effects）</ins>在不同线程中的顺序。首先有相关术语的定义。</p><h2 id="消费操作（consume-operation）"><a href="#消费操作（consume-operation）" class="headerlink" title="消费操作（consume operation）"></a>消费操作（consume operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>std::memory_order_consume</code></a> 或更强的内存顺序的原子读操作是消费操作（consume operation）。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比消费操作更强。</p><h2 id="占有操作（aquire-operation）"><a href="#占有操作（aquire-operation）" class="headerlink" title="占有操作（aquire operation）"></a>占有操作（aquire operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>std::memory_order_acquire</code></a> 或更强的内存顺序的原子读操作是占有操作（aquire operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex" target="_blank" rel="noopener">互斥量（mutex）</a>上执行 <code>lock()</code> 操作亦属于占有操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比占有操作更强。</p><h2 id="释放操作（release-operation）"><a href="#释放操作（release-operation）" class="headerlink" title="释放操作（release operation）"></a>释放操作（release operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>std::memory_order_release</code></a> 或更强的内存顺序的原子读操作是释放操作（release operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex" target="_blank" rel="noopener">互斥量（mutex）</a>上执行 <code>unlock()</code> 操作亦属于释放操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比释放操作更强。</p><h2 id="表达式求值（evaluations-of-expressions）"><a href="#表达式求值（evaluations-of-expressions）" class="headerlink" title="表达式求值（evaluations of expressions）"></a>表达式求值（evaluations of expressions）</h2><p>对一个表达式<ins>求值（evaluation）</ins>包含以下两个部分：</p><ul><li><ins>值计算（value computations）</ins>：计算表达式的返回值。其中可能涉及到对象的识别（identity of the object；左值求值）或是读取对象中保存的值（右值求值）。前者例如返回某个对象的引用，后者例如返回一个数值。</li><li><ins>副作用（side effect）</ins>：通过一个易变左值访问（读/写）对象；修改对象；调用函数库中的 I/O 函数；或调用包含上述操作的其他函数。</li></ul><h2 id="先序（sequenced-before）关系"><a href="#先序（sequenced-before）关系" class="headerlink" title="先序（sequenced-before）关系"></a>先序（sequenced-before）关系</h2><p>先序关系描述同一个线程中两次求值之间的偏序关系。</p><ul><li>若 A <ins>先序于（sequenced-before）</ins> B，则 A 将在 B 开始执行之前完成。</li><li>若 A 不先序于 B，而 B 先序于 A，则 B 将在 A 开始执行之前完成。</li><li>若 A 不先序于 B 而 B 亦不先序于 A，则有两种可能性<ul><li>A 和 B 的求值不存在序列关系：二者可能以任意顺序求值，并且它们的求值动作在时间上可能重叠（在同一线程中，编译器可能打乱组成 A 和 B 的指令的顺序，使他们相互穿插）。</li><li>A 和 B 的求值序列关系不确定：二者可能以任意顺序求值，但它们的求值动作在时间上不可能重叠。此外，程序再次执行时，二者的执行顺序可能和上一次不同。</li></ul></li></ul><h2 id="带去依赖（Carries-dependency）"><a href="#带去依赖（Carries-dependency）" class="headerlink" title="带去依赖（Carries dependency）"></a>带去依赖（Carries dependency）</h2><p>在同一线程中，若 A <ins>先序于</ins> B，则在下列情况下，A 为 B 带去依赖（即，B 依赖于 A）：</p><ul><li>A 的返回值是 B 的操作数，但下列情形除外：<ul><li>B 是对 <a href="https://en.cppreference.com/w/cpp/atomic/kill_dependency" target="_blank" rel="noopener"><code>std::kill_dependency</code></a> 的调用；</li><li>A 的返回值是内建 <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code> 或是 <code>,</code> 运算符的左操作数。</li></ul></li><li>执行 A 的过程中写入标量 M，而执行 B 的过程读取标量 M。</li><li>A 为 X 带去依赖，而 X 为 B 带去依赖。（即依赖关系具有传递性）</li></ul><h2 id="修改顺序（Modification-Order）"><a href="#修改顺序（Modification-Order）" class="headerlink" title="修改顺序（Modification Order）"></a>修改顺序（Modification Order）</h2><p>对于某个原子变量来说，其全部写入操作组成一个全局修改顺序。</p><p>所有原子操作都保证符合以下四个要求：</p><ol><li>写写一致性：若对原子变量 M 的写入操作 A <ins>先于（happens-before）</ins>对同一原子变量的写入操作 B。则在 M 的<ins>修改顺序（modification order）</ins>中，A 在 B 之前。</li><li>读读一致性：若 A 和 B 的值计算均读取原子变量 M，且 A <ins>先于</ins> B；又假定 A 读到的原子变量 M 的值来自某个对 M 有写操作的表达式 X；则 B 读到的值，要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li><li>读写一致性：若 A 的值计算读取原子变量 M 而 B 写入 M，且 A <ins>先于</ins> B；则 A 读到的值来自在 M 的<ins>修改顺序（modification order）</ins>中早于 B 的某个写入 X。</li><li>写读一致性：若 X 对原子变量 M 有写入，而 B 的值计算读取原子变量 M；又假定 X <ins>先于</ins> B；则 B 读到的值要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li></ol><h2 id="释放序列（Release-sequence）"><a href="#释放序列（Release-sequence）" class="headerlink" title="释放序列（Release sequence）"></a>释放序列（Release sequence）</h2><p>假定 A 是原子变量 M 上的一个<ins>释放操作（release operation）</ins>。则在 M 的修改顺序中，<strong>位于 A 之后</strong>的由下列操作组成的最长连续子序列被称为以 A 为首的<ins>释放序列（release sequence）</ins>：</p><ol><li>执行 A 的线程中，对 M 的写入操作（until C++20）；</li><li>任意线程对 M 的读-改-写操作（CAS 成功时的操作）。</li></ol><h2 id="依赖顺序上先于（Dependency-ordered-before）"><a href="#依赖顺序上先于（Dependency-ordered-before）" class="headerlink" title="依赖顺序上先于（Dependency-ordered before）"></a>依赖顺序上先于（Dependency-ordered before）</h2><p>满足下列某个情况时，我们称表达式 A 在<ins>依赖顺序上先于（dependency-ordered before）</ins>表达式 B——其中 A 和 B 处于不同线程。</p><ol><li>A 对原子变量 M 执行<ins>释放操作（release operation）</ins>，在另一线程中 B 对同一原子变量 M 执行<ins>消费操作（consume operation）</ins>，且 B 读取的值来自 A（以 A 为首的<ins>释放序列（release sequence）</ins>中的任意部分（until C++20））的写入。</li><li>A 在依赖顺序上先于 X，而 X 为 B 带去依赖。</li></ol><h2 id="线程间先于（Inter-thread-happens-before）"><a href="#线程间先于（Inter-thread-happens-before）" class="headerlink" title="线程间先于（Inter-thread happens-before）"></a>线程间先于（Inter-thread happens-before）</h2><p>若满足下列条件之一，则称对表达式 A 的求值<ins>线程间先于（inter-thread happens-before）</ins>对表达式 B 的求值：</p><ol><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>依赖顺序上先于</ins> B；</li><li>A 与某个表达式 X <ins>同步</ins>，而 X <ins>先序于</ins> B；</li><li>A <ins>先序于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B；</li><li>A <ins>线程间先于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B。</li></ol><h2 id="先于（happens-before）"><a href="#先于（happens-before）" class="headerlink" title="先于（happens-before）"></a>先于（happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>线程间先于（inter-thread happens-before）</ins> B。</li></ol><p>编译器实现应当引入必要的同步措施，以保证表达式求值之间的先于关系链不成环。（仅当引入消费操作（consume operation）时有此必要；参见 <a href="http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf" target="_blank" rel="noopener">Betty 等的论文</a>）</p><p>若某个求值操作修改了一个内存位置（见<a href="/2021/06/05/memory-model-cpp/">前文</a>），另一个求值操作读写同一内存位置，且至少其一不是原子操作，除非二者之间存在<ins>先于</ins>关系，程序行为未定义（程序有数据竞争）。</p><h2 id="简单先于（Simply-happens-before；since-C-20）"><a href="#简单先于（Simply-happens-before；since-C-20）" class="headerlink" title="简单先于（Simply happens-before；since C++20）"></a>简单先于（Simply happens-before；since C++20）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>简单先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>简单先于</ins> 某个表达式 X 的求值，而 X <ins>简单先于</ins> B。</li></ol><p>注：没有消费操作（consume operation）时，简单先于等价于先于。</p><h2 id="强先于（Strongly-happens-before）"><a href="#强先于（Strongly-happens-before）" class="headerlink" title="强先于（Strongly happens-before）"></a>强先于（Strongly happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>强先于（strongly happens-before）</ins>对表达式 B 的求值：</p><h3 id="until-C-20"><a href="#until-C-20" class="headerlink" title="until C++20"></a>until C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：C++20 之前的强先于，即是 C++20 及之后的简单先于。</p><h3 id="since-C-20"><a href="#since-C-20" class="headerlink" title="since C++20"></a>since C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>，且 A/B 均为顺序一致（sequentially consistent）的原子操作；</li><li>A <ins>先序于（sequenced-before）</ins> X，X <ins>简单先于</ins> Y，Y <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：不正式地讲，若 A <ins>强先于（strongly happens-before）</ins> B，则在任何上下文中，A 都先于 B 求值。</p><p>注：强先于关系排除了消费操作（consume operation）。</p><h2 id="可见副作用（Visible-side-effects）"><a href="#可见副作用（Visible-side-effects）" class="headerlink" title="可见副作用（Visible side-effects）"></a>可见副作用（Visible side-effects）</h2><p>若下列条件均成立，则 A 对于标量 M 的副作用（写操作）于在标量 M 上的求值 B（读操作）可见：</p><ol><li>A <ins>先于</ins> B；</li><li>任意满足 A <ins>先于</ins> X 且 X <ins>先于</ins> B 的表达式 X 对标量 M 没有副作用。</li></ol><p>若 A 的副作用对 B 可见，则在 M 的修改顺序当中 B 之前的最长连续副作用子集称之为 B 可见的副作用序列。（B 见到的 M 的值是上述副作用其中之一写入的）</p><p>注：线程间同步本质是要通过建立<ins>先于（happens-before）</ins>关系来避免数据竞争以及定义在哪些条件下哪些副作用可见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇继&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;前文&lt;/a&gt;讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应页面&lt;/a&gt;术语部分的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（十）：C++ 的内存模型</title>
    <link href="https://liam.page/2021/06/05/memory-model-cpp/"/>
    <id>https://liam.page/2021/06/05/memory-model-cpp/</id>
    <published>2021-06-05T02:36:41.000Z</published>
    <updated>2021-12-11T14:18:33.647Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/language/memory_model" target="_blank" rel="noopener">对应页面</a>的翻译，有删减和补充。</p><a id="more"></a><p>内存模型为 C++ 抽象机器定义了计算机内存存储语义。</p><p>C++ 程序可用的内存是一个或多个连续的字节序列。每个字节有自己独有的内存地址。</p><h2 id="字节（Byte）"><a href="#字节（Byte）" class="headerlink" title="字节（Byte）"></a>字节（Byte）</h2><p>字节是内存中的最小可寻址单元，由连续的多个比特组成。C++ 中，<code>char</code>/<code>unsigned char</code>/<code>signed char</code> 的对象存储和<a href="https://en.cppreference.com/w/cpp/language/object" target="_blank" rel="noopener">值表示</a>均使用恰好 1 字节。于是，字节中有多少比特，可以通过 <a href="http://en.cppreference.com/w/cpp/types/numeric_limits" target="_blank" rel="noopener"><code>std::numeric_limits&lt;unsigned char&gt;::digits</code></a>取得。</p><h2 id="内存位置（Memory-Location）"><a href="#内存位置（Memory-Location）" class="headerlink" title="内存位置（Memory Location）"></a>内存位置（Memory Location）</h2><p>内存位置是</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/type" target="_blank" rel="noopener">标量类型</a>（算数类型、指针类型、枚举类型或是 <code>std::nullptr_t</code>）的对象；</li><li>或是，长度不为零的<a href="https://en.cppreference.com/w/cpp/language/bit_field" target="_blank" rel="noopener">位域</a>组成的最长连续序列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;     <span class="comment">// memory location #1</span></span><br><span class="line">    <span class="keyword">int</span> b : <span class="number">5</span>;  <span class="comment">// memory location #2</span></span><br><span class="line">    <span class="keyword">int</span> c : <span class="number">11</span>, <span class="comment">// memory location #2 (continued)</span></span><br><span class="line">          : <span class="number">0</span>,  <span class="comment">// zero-length, as a delimiter of continued sequence of bit-fields</span></span><br><span class="line">        d : <span class="number">8</span>;  <span class="comment">// memory location #3</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ee : <span class="number">8</span>; <span class="comment">// memory location #4</span></span><br><span class="line">    &#125; e;</span><br><span class="line">&#125; obj; <span class="comment">// The object 'obj' consists of 4 separate memory locations</span></span><br></pre></td></tr></table></figure><p>注意：语言中的许多特性会引入额外的内存位置。这些内存位置程序无法访问，而是为编译器实现自行管理。这些特性例如：<a href="https://en.cppreference.com/w/cpp/language/reference" target="_blank" rel="noopener">引用</a>和<a href="https://en.cppreference.com/w/cpp/language/virtual" target="_blank" rel="noopener">虚函数</a>。</p><h2 id="线程与数据竞争（Thread-and-data-races）"><a href="#线程与数据竞争（Thread-and-data-races）" class="headerlink" title="线程与数据竞争（Thread and data races）"></a>线程与数据竞争（Thread and data races）</h2><p>程序中的线程是自 <a href="https://en.cppreference.com/w/cpp/thread/thread/thread" target="_blank" rel="noopener"><code>std::thread::thread</code></a>, <a href="https://en.cppreference.com/w/cpp/thread/async" target="_blank" rel="noopener"><code>std::async</code></a> 或者其他方式调用顶层函数开始的控制流。</p><p>任一线程都可能访问程序中的任意对象。其中，原子及<a href="https://en.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener">线程内部存储</a>亦可能为其它线程通过指针或引用来访问。</p><p>在没有同步或阻塞的情况下，不同线程可并发访问（读/写）不同内存位置。</p><p>若一个表达式求值对某一内存位置进行写操作，而另一求值过程对同一内存位置进行读或写操作，则两个求值过程存在冲突。除非满足下列条件，程序中冲突的求值操作将引发数据竞争：</p><ul><li>存在冲突的求值操作在同一线程中执行，或在同一<a href="https://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler" target="_blank" rel="noopener">信号处理函数</a>中执行；或者</li><li>存在冲突的求值操作均是原子操作（参见 <a href="https://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="noopener"><code>std::atomic</code></a>）；或者</li><li>存在冲突的求值操作，其一<ins>先于（happens-before）</ins>另一发生（参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>std::memory_order</code></a>）。</li></ul><p>数据竞争将导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line"><span class="built_in">std</span>::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line"><span class="built_in">std</span>::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using atomic variable</span></span><br></pre></td></tr></table></figure><p>特别地，对于同一个 <a href="https://en.cppreference.com/w/cpp/thread/mutex" target="_blank" rel="noopener"><code>std::mutex</code></a>，在一个线程中释放它与在另一线程中获取它是<ins>同步的（synchronized-with）</ins>，故而释放动作<ins>先于（happens-before）</ins>获取动作。因此，可用 <code>std::mutex</code> 来避免数据竞争。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mtx); cnt++; &#125;;</span><br><span class="line"><span class="built_in">std</span>::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using mutex to ensure happens-before semantic</span></span><br></pre></td></tr></table></figure><h2 id="内存顺序（Memory-Order）"><a href="#内存顺序（Memory-Order）" class="headerlink" title="内存顺序（Memory Order）"></a>内存顺序（Memory Order）</h2><p>线程自某个内存位置取值时，读到的可能是它的初始值，也可能是当前线程写入的值，亦可能是其他线程写入的值。有关内存顺序的细节可参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>std::memory_order</code></a>；其中讨论了线程的写入操作在其他线程可见性的问题。</p><h2 id="前向执行（Forward-Progress）"><a href="#前向执行（Forward-Progress）" class="headerlink" title="前向执行（Forward Progress）"></a>前向执行（Forward Progress）</h2><h3 id="无阻塞（Obstruction-freedom）"><a href="#无阻塞（Obstruction-freedom）" class="headerlink" title="无阻塞（Obstruction freedom）"></a>无阻塞（Obstruction freedom）</h3><p>仅有一个未被标准库函数阻塞的线程在执行无锁<a href="https://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">原子函数（atomic function）</a>时，该原子函数必能执行完毕（标准库内所有无锁操作均<a href="obstruction-free">无阻塞</a>）。</p><h3 id="无锁（Lock-freedom）"><a href="#无锁（Lock-freedom）" class="headerlink" title="无锁（Lock freedom）"></a>无锁（Lock freedom）</h3><p>一个或更多无锁原子函数并发执行时，至少其中之一必能执行完毕（标准库内所有无所操作均<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom" target="_blank" rel="noopener">无锁</a>——编译器实现会保证它们不会被一直锁住，例如持续地被窃走缓存行（cache-line stealing；一种因为执行其他线程的 CPU 核心对内存数据做预取而导致当前 CPU 核心缓存行变脏的现象））。</p><blockquote><p>关于 cache-line stealing，参见：<a href="https://www.researchgate.net/publication/221497089_Tackling_Cache-Line_Stealing_Effects_Using_Run-Time_Adaptation" target="_blank" rel="noopener">这篇论文</a>。</p></blockquote><h3 id="执行之担保（Progress-guarantee）"><a href="#执行之担保（Progress-guarantee）" class="headerlink" title="执行之担保（Progress guarantee）"></a>执行之担保（Progress guarantee）</h3><p>在正确的 C++ 程序当中，所有线程终将执行到下列情形之一：</p><ul><li>终止；</li><li>调用 I/O 库的函数；</li><li>经由<a href="https://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener">易变（volatile）</a>的左值（lvalue）或者将亡值（xvalue）——拥有内存地址的长寿对象——访问外部设备；</li><li>执行原子操作或是同步操作。</li></ul><p>若一个线程执行上述任一操作（I/O, volatile, 原子操作或是同步操作），或是阻塞在标准库函数当中，亦或是因其他为阻塞线程正在并发执行导致调用一个无锁原子操作却尚未完成，则称该线程<ins>有进展（make progress）</ins>。</p><h3 id="并发前向执行（Concurrent-forward-progress-since-C-17）"><a href="#并发前向执行（Concurrent-forward-progress-since-C-17）" class="headerlink" title="并发前向执行（Concurrent forward progress; since C++17）"></a>并发前向执行（Concurrent forward progress; since C++17）</h3><p>若某线程有<ins>并发前向执行之担保（concurrent forward progress guarantee）</ins>，则在它终止之前，无论其他线程（若有）是否有进展，它都将于有限时间内取得如上定义之<ins>进展（make progress）</ins>。</p><p>C++ 标准鼓励（但并不强求）主线程和其他由 <code>std::thread</code> 启动的线程提供<ins>并发前向执行之担保</ins>。</p><h3 id="并行前向执行（Parallel-forward-progress-since-C-17）"><a href="#并行前向执行（Parallel-forward-progress-since-C-17）" class="headerlink" title="并行前向执行（Parallel forward progress; since C++17）"></a>并行前向执行（Parallel forward progress; since C++17）</h3><p>若某线程有<ins>并行前向执行之担保（parallel forward progress guarantee）</ins>，则</p><ul><li>在它尚未执行任何步骤（I/O, volatile, 原子操作或是同步操作）时，编译器实现不保证它在有限时间内有<ins>进展</ins>；</li><li>而一旦它执行了某一步骤，它提供<ins>并发前向执行之担保</ins>。</li></ul><p>此规则表明，线程池中的线程可以按照任意顺序执行任务。</p><h3 id="弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）"><a href="#弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）" class="headerlink" title="弱并行前向执行（Weakly parallel forward progress; since C++17）"></a>弱并行前向执行（Weakly parallel forward progress; since C++17）</h3><p>若某线程有<ins>弱并行前向执行之担保（weakly parallel forward progress guarantee）</ins>，则无论其他线程是否有<ins>进展</ins>，它都不保证它在有限时间内有<ins>进展</ins>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/memory_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应页面&lt;/a&gt;的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>xTR 预估任务中的特征工程</title>
    <link href="https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/"/>
    <id>https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/</id>
    <published>2021-05-23T13:59:12.000Z</published>
    <updated>2021-07-31T07:45:45.071Z</updated>
    
    <content type="html"><![CDATA[<p>xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&gt; W&amp;D 系列 -&gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。</p><p>此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。</p><a id="more"></a><h2 id="时间类特征"><a href="#时间类特征" class="headerlink" title="时间类特征"></a>时间类特征</h2><blockquote><p>作者：大博<br>链接：<a href="https://www.zhihu.com/question/350863682/answer/860524396" target="_blank" rel="noopener">https://www.zhihu.com/question/350863682/answer/860524396</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>考虑问题中的「时间」。从三个角度：用户的时间，商品的时间，用户与商品间的时间。每个角度可以包括的时间类型：时间绝对值，时间间隔值。每个时间类型可以有不同的计算方法：统计型，独立型。（备注：一下就计算来的值算独立型，通过一堆独立值统计来的，用「平均/最大」等描述的特征算统计型。）</p><ul><li>用户的时间：(刻画用户本身的习惯)<ul><li>时间绝对值<ul><li>统计型：一个月内最高频的浏览时间</li><li>独立型：用户当前浏览时间/用户上一次浏览时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户曾经两次浏览的时间间隔的「平均」</li><li>独立型：用户本次浏览与上次浏览的时间间隔</li></ul></li></ul></li><li>商品的时间：(刻画商品本身的属性)<ul><li>时间绝对值<ul><li>统计型：商品最常被购买的时间</li><li>独立型：商品上架时间/预计下架时间（上下架指一个动作）</li></ul></li><li>时间间隔值<ul><li>统计型：三天除以三天内商品被购买次数</li><li>独立型：商品的在线时间/当前时间与商品常被购买时间的间隔</li></ul></li></ul></li><li>用户与商品间的时间：(刻画该用户到该商品的匹配程度)<ul><li>时间绝对值<ul><li>统计型：用户历史购买该商品的平均时间分布</li><li>独立型：用户上次购买该商品的时间/用户上次购买该商品所属品类的时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户历史购买该品类商品的平均时间间隔</li><li>独立型：用户上次购买该商品到当前时间的时间间隔</li></ul></li></ul></li></ul><p>最后总结下思路：</p><ol><li>一般强特征都是用户到商品的交叉特征，「商品」要从商品id扩展到「品类」/「商户」/「标签」等等能交叉的角度。</li><li>时间间隔一般是强特。</li><li>历史统计型特征可以用条件概率去理解，虽不是强特，但多了是有用的。</li><li>哪怕是从「时间」考虑特征，特征所反应的含义应该是：这个人平时愿不愿意买东西，这件商品平时的受众是怎样的，这个人对这个商品的敏感程度是怎样的。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&amp;gt; W&amp;amp;D 系列 -&amp;gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。&lt;/p&gt;
&lt;p&gt;此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="xTR" scheme="https://liam.page/tags/xTR/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之十：名词性从句</title>
    <link href="https://liam.page/2021/05/09/noun-subordinate-clauses/"/>
    <id>https://liam.page/2021/05/09/noun-subordinate-clauses/</id>
    <published>2021-05-09T09:28:51.000Z</published>
    <updated>2021-05-09T14:59:56.649Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第十篇。<a href="/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/">前作</a>介绍了复合句的概念，并介绍了分析和练习复合句的方法。</p><p>考虑到合句本身简单，所以在本系列中略去不讲，将来另开一系列讨论。本系列从此篇开始，介绍各种类型的复句。此篇介绍名词性从句。</p><a id="more"></a><h2 id="复句的种类"><a href="#复句的种类" class="headerlink" title="复句的种类"></a>复句的种类</h2><p>在英文当中，除动词外，几种主要词类在剧中充当成分时，都能为相应的从句代替，从而与主句一起组成复句。由此，我们可知英文当中有以下复句类型：</p><ul><li>名词性从句<ul><li>主语从句</li><li>宾语从句</li><li>补语从句（表语从句）</li><li>同位语从句</li></ul></li><li>形容词性从句<ul><li>各类状语从句</li></ul></li><li>副词性从句<ul><li>各类关系从句</li></ul></li></ul><p>此篇我们介绍名词性从句。</p><h2 id="名词性从句的主要特点"><a href="#名词性从句的主要特点" class="headerlink" title="名词性从句的主要特点"></a>名词性从句的主要特点</h2><p>名词性从句有以下一些特点：</p><ol><li>在句中充当名词的角色。这也是名词性从句的由来。</li><li>本身是一个完整的独立子句。也就是说，名词性从句自身可归于五种基本句型里去，并且有相应的组成成分。</li><li>名词性从句通常以一个有时可以省略的 <code>that</code> 开头；它不表意，只有语法功能，表示引导了一个名词性从句。当名词性从句的引导词需要参与表意时，往往需要相应的 <code>wh-</code> 疑问词或是 <code>whether</code>/<code>if</code> 来引导。</li></ol><h2 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h2><p>当名词性从句出现在主语位置时，它就是主语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong><em>That he finished writing the composition in such a short time</em> surprised us all.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>he finished writing the composition in such a short time. | 他于短时间内写完作文。</li><li>something surprised us all. | 某事震惊了我们所有人。</li></ol><p>以 <code>that</code> 加在第一个独立子句之前，形成主语从句，替代第二个独立子句的 <code>something</code> 即得到原句。原句翻译为：他于短时间内写完作文震惊了我们所有人。</p><p>此句重点在于表达「我们所有人都惊了」，至于为何事震惊实际处于次要地位。因此，于修辞计，考虑到从句很长，我们倾向于让主句的内容先出来。为此，我们用附加虚词 <code>it</code> 来代替主语从句的内容，作为「形式主语」。原句变为：「It surprised us all <em>that he finished writing the composition in such a short time</em>.」</p><p><strong><em>Who you are</em> doesn&#39;t matter at all.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>who you are. | 你是谁？</li><li>the question doesn&#39;t matter at all. | 这问题根本不重要。</li></ol><p><code>wh-</code> 疑问词 <code>who</code> 一方面具有表意功能，另一方面可以直接引导句子。因而，第一个独立子句可以直接替换主句中的 <code>the question</code>，充作主语从句而得到原句。原句的翻译为：你是谁（这个问题）根本不重要。</p><p>当名词性从句替换的名词是一个问题（the question/a question）时，我们往往需要 <code>wh-</code> 疑问词参与表意。</p><p><strong><em>Whether he is telling the truth or not</em> is anyone&#39;s guess.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>which he is telling either the truth or not. | 他在讲真话还是假话？</li><li>the question is anyone&#39;s guess. | 这问题谁也不知道答案。</li></ol><p><code>wh-</code> 疑问词 <code>which</code> 一方面具有表意功能，另一方面可以直接引导句子。再注意到，<code>whether</code> 实际是 <code>which</code> 和 <code>either</code> 的合成。因而，第一个独立子句可以直接替换主句中的 <code>the question</code>，充作主语从句而得到原句。原句的翻译为：他在讲真话还是假话（这个问题）谁也不知道答案。</p><p>既知 <code>whether</code> 是 <code>which</code> 和 <code>either</code> 的合成，那么，在表达「是否」的含义并引导名词性从句时我们就可以用它了。在成词日久之后，由于 <code>if</code> 也能表示「是否」的含义，所以在一些情况下以 <code>whether</code> 引导名词性从句时也可以由 <code>if</code> 来引导。但并非所有情形都适合做这样的替换。以下距离不能替换的场景：</p><ul><li><code>whether</code> 引导名词性从句位于句首时。此时 <code>if</code> 容易被误认为是在引导一个条件状语从句，产生歧义，故不可。</li><li><code>whether</code> 引导名词性从句位于介词之后，充当介词宾语时（此时必然是宾语从句）。此时，介词与 <code>which</code> 组成固定短语，不适合替换成 <code>if</code>，而只能由合成词 <code>whether</code> 来担此任务。</li></ul><h2 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h2><p>当名词性从句出现在宾语位置时，它就是宾语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong>Liam swears <em>that he will love Sophia forever.</em></strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>Liam swears something. | Liam 发誓说了什么。</li><li>he will love Sophia forever. | 他会永远爱 Sophia。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成宾语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「Liam 发誓说他会永远爱 Sophia」。</p><p>这里，因为 <code>swears</code> 是一个及宾动词。陈述句中，位于及宾动词之后的，肯定是宾语。所以，此处即使去掉 <code>that</code>，读者也能看出这是一个宾语从句，不至于引起歧义：「Liam swears <em>he will love Sophia forever.</em>」于是，在及宾动词之后，于修辞计，引导宾语从句的 <code>that</code> 可以省略。</p><p>举一个反例，若我们在 <code>swears</code> 之后加上方式状语 <code>on the Bible</code>，变成：「Liam swears on the Bible <em>that he will love Sophia forever.</em>」，引导词 <code>that</code> 就不适合省略了。若不然，句子变成「Liam swears on the Bible <em>he will love Sophia forever.</em>」很容易让人困惑。</p><p><strong>We all found <em>that he finished writing the composition in such a short time</em> surprising.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>We all found something surprising. | 我们都发现了某事令人惊奇。</li><li>he finished writing the composition in such a short time. | 他于短时间内写完作文。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成宾语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「我们都发现他于短时间内写完作文这件事令人惊奇」。</p><p>和主语从句的情形类似。此句重点在于表达「我们所有人都惊了」，至于为何事震惊实际处于次要地位。因此，于修辞计，考虑到从句很长，我们倾向于让主句的主要成分之一的补语（surprising）先出来。为此，我们用附加虚词 <code>it</code> 来代替宾语从句的内容，作为「形式宾语」。原句变为：「We all found it surprising <em>that he finished writing the composition in such a short time</em>.」</p><p>与主语从句的情况类似，宾语从句也可以由 <code>wh-</code> 疑问词引导。读者可自己试着造句，此处不做展开。</p><p>在某些情况下，宾语从句的内容比主句本身要重要。这时候，宾语从句会被提前。（山东人民应该会感到舒服，笑~）我们来看一个例子。</p><p><strong>This is what you&#39;ve done, I suppose.</strong></p><p>这里，正常语序实际应该是：I suppose that this is what you&#39;ve done. 不过，因为宾语从句的内容比「我猜」更重要，所以它被提到前面，同时去掉引导词 <code>that</code> 并和主句之间用逗号分隔开。</p><h2 id="补语从句"><a href="#补语从句" class="headerlink" title="补语从句"></a>补语从句</h2><p>当名词性从句出现在补语位置时，它就是补语从句。充作主语的补语时，传统语法也称之为表语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong>The point is <em>that nobody died in the accident</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The point is something. | 要点在于某事。</li><li>nobody died in the accident. | 事故中无人死亡。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成补语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「要点在于事故中无人死亡」。</p><p>与宾语从句的情况类似，位于联系动词之后的，肯定是补语。所以，此处即使去掉 <code>that</code>，读者也能看出这是一个补语从句，不至于引起歧义：「The point is <em>nobody died in the accident</em>.」因此，充作主语补语的补语从句，其引导词 <code>that</code> 在非正式场合下也可以省略。</p><p><strong>My education and my experience made me <em>that/who I am today</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>My education and my experience made me something. | 我所接受的教育和过去的经历塑造我成为某事。</li><li>I am today. | 我如今的样子。</li></ol><p>以 <code>that</code>/<code>who</code> 加在第二个独立子句之前，形成（宾语）补语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「我所接受的教育和过去的经历塑造我成为我如今的样子」。注意这里的 <code>am</code> 单独出现，表示「存在」。「我如今的存在」即是「我如今的样子」。</p><p>继续 <code>that</code> 省略的讨论。此处，由于补语从句充作宾语的补语，故而前面没有明确的联系动词作为提示。故而，此处不宜将引导词 <code>that</code> 省略。</p><p>此处还要额外注意一点。实际上，充当补语的既可以是名词也可以是形容词。因此，简单地说补语从句是一种名词性从句，其实并不能另所有人信服。基于同样的原因，将它归类为形容词性从句，也会有同样的问题。若是把补语从句同时归纳于名词性从句和形容词性从句里面，又生造了一个特例，无甚必要。处理这一问题，我们还是要从表意的角度出发，不要过度纠结，以简御繁为上。</p><h2 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h2><p>名词性从句当中，比较容易产生误会的就是同位语从句了。为此，我们先来确定一下什么是同位语。所谓同位语，就是用不同的方式，把一个概念再说一遍，并且用逗号隔开。它通常是对抽象概念的解释说明——毕竟，确切的概念也就不必反复说明了嘛。</p><p>举几个🌰：</p><ul><li>My wife, <em>Sophia</em>, is compatible with me very well. | 我爱人，Sophia，与我很合得来。</li><li>The fact, <em>rabbit eats carrot</em>, is not suprising. | 兔子爱吃胡萝卜这一事实不会令人意外。</li></ul><p>两个例子中，<em>Sophia</em> 和 <em>rabbit eats carrot</em> 都是各自主语的同位语，他们和各自的主语是同一个概念。对于同位语，我们往往可以用联系动词将同位语和它解释的对象连起来。比如：</p><ul><li>My wife is Sophia.</li><li>The fact is that rabbit eats carrot.</li></ul><p>同位语可以解释主语，也可以解释宾语。比如：</p><ul><li>I love my wife, <em>Sophia</em>. | 我爱我的妻子 Sophia。</li></ul><p>同样，宾语 my wife 及其同位语，也可以用联系动词连起来。比如：</p><ul><li>My wife is Sophia.</li></ul><p>以上例子应该足够讲清楚同位语是什么。同时我们也不难发现，<strong>同位语和补语之间有不少相似之处</strong>。在后续的文章里，我们会再次看到这一点。</p><hr><p>现在我们来看同位语从句。同样地，此处举几个例子，并随附说明一些注意要点。</p><p><strong>The fact <em>that rabbit eats carrot</em> is not suprising.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The fact is not suprising. | 这一事实不会令人意外。</li><li>rabbit eats carrot. | 兔子吃胡萝卜。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中的主语 <em>the fact</em> 本身。于是我们在第二个独立子句之前加上引导词  <code>that</code> ，形成同位语从句，作为第一个独立子句的 the fact 的同位语即得到原句。原句翻译为：「兔子爱吃胡萝卜这一事实不会令人意外」。</p><p>类似地，我们可以改造出一个对宾语做同位语从句的例子。</p><p><strong>One will not be suprised by the fact <em>that rabbit eats carrot</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>One will not be suprised by the fact. | 人们不会对这一事实感到惊讶。</li><li>rabbit eats carrot. | 兔子吃胡萝卜。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中的宾语 <em>the fact</em> 本身。于是我们在第二个独立子句之前加上引导词  <code>that</code> ，形成同位语从句，作为第一个独立子句的 the fact 的同位语即得到原句。原句翻译为：「人们不会对兔子吃胡萝卜这一事实感到惊讶」。</p><p>和其他名词从句类似，当被同位语解释的对象是一个问题时，<code>wh-</code> 疑问词就会登场。</p><p><strong>The question <em>who the killer is</em> is on the police officer&#39;s mind.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The question is on the police officer&#39;s mind. | 这个问题萦绕在警官心头。</li><li>who the killer is. | 杀手是谁。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中主语 <em>the question</em> 本身。考虑到第二个子句是个问句，已经有 <code>wh-</code> 疑问词 <em>who</em>，此处无需 <code>that</code> 做引导即可作为同位语从句。原句翻译为：「杀手是谁这一问题萦绕在警官心头」。</p><blockquote><p> 有这三个例子打底，我们来分析一下同位语从句和定语从句的区别。在这里，同位语从句和限定修饰先行名词的定语从句十分相似。他们同样放在名词后面，同样可以由 <code>that</code> 或者 <code>wh-</code> 疑问词引导。从形式上来看，他们很相似。同位语从句和限定修饰先行名词的定语从句之间的区别，主要体现在两个方面：</p><ul><li><p>从表意上说：</p><ul><li>同位语从句的内容，就是被其解释的抽象名词本身。因此，被解释的名词和同位语从句之间，可以用联系动词连起来，形成 SVC 的结构。这也体现了同位语和补语之间紧密的联系——实际上在某些语法体系里面，甚至没有同位语的概念，而是将之作为补语的一种来处理。</li><li>限定修饰先行名词的定语从句的内容，对先行名词起到限定修饰的作用。先行名词和定语从句之间，无法用联系动词直接连接在一起。</li></ul></li><li><p>从形式上说：</p><ul><li>同位语的 <code>that</code> 只有语法功能，没有表意能力；从句去掉 <code>that</code> 是一个完整句子。</li><li>定语从句的 <code>that</code> 不仅有语法功能，还在从句中充当先行词本身；从句去掉 <code>that</code> 变得不完整。</li></ul><p>借助上述三个例子，我们择其一来观察同位语从句和定语从句之间的区别。</p></li><li><p>The fact <em>that rabbit eats carrot</em> is not suprising. | 兔子爱吃胡萝卜这一事实不会令人意外。</p></li><li><p>The fact <em>that is figured out by Liam</em> is not suprising. | 为 Liam 所指出的事实不会令人意外。</p><p>第二个例子当中 <code>that</code> 引导的是定语从句，限定修饰先行词 the fact。显然，我们没法讲：「The fact is that is figured out by Liam」。一是因为表意上不通；二是因为 <code>that</code> 后的句子看起来是个补语从句，但是缺少主语。</p><p>如此，读者应该能比较明确地分辨同位语从句和定语从句。</p></li></ul></blockquote><p>上述三个例子都是比较典型的同位语从句。下面举三个不那么典型的同位语从句。</p><ul><li>I&#39;m afraid <em>that I cannot help you</em>. | 我恐怕没法帮你。</li><li>You should take care <em>that the baby is sleeping well</em>. | 你应当小心让宝贝睡好。</li><li>I&#39;m not sure <em>whether the police officer will find the killer or not</em>. | 我不确定警官是否能找出杀手。</li></ul><p>在这三个例子当中，去掉斜体标识的同位语从句，在主句中我们找不到可供同位语从句解释说明的名词。实际上，这类 case 的主句有被简化。如果把主句改成下面这样，就不难理解了：</p><ul><li>I&#39;m afraid <strong>of the thing</strong>.</li><li>You should take care <strong>of the thing</strong>.</li><li>I&#39;m not sure <strong>about the thing</strong>.</li></ul><p>原来，同位语从句是在解释说明被省略掉的 the thing。只不过，在长期的语言实践当中，由于 the thing 本身太虚，没有含义，处于修辞的考虑，就被省略掉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第十篇。&lt;a href=&quot;/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/&quot;&gt;前作&lt;/a&gt;介绍了复合句的概念，并介绍了分析和练习复合句的方法。&lt;/p&gt;
&lt;p&gt;考虑到合句本身简单，所以在本系列中略去不讲，将来另开一系列讨论。本系列从此篇开始，介绍各种类型的复句。此篇介绍名词性从句。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
      <category term="Subordinate Clause" scheme="https://liam.page/tags/Subordinate-Clause/"/>
    
      <category term="Subjective Clause" scheme="https://liam.page/tags/Subjective-Clause/"/>
    
      <category term="Predicative Clause" scheme="https://liam.page/tags/Predicative-Clause/"/>
    
      <category term="Objective Clause" scheme="https://liam.page/tags/Objective-Clause/"/>
    
      <category term="Appositive Clause" scheme="https://liam.page/tags/Appositive-Clause/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之⑨：忘记长难句，欢迎来到复合句的世界</title>
    <link href="https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/"/>
    <id>https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/</id>
    <published>2021-05-07T14:46:19.000Z</published>
    <updated>2021-05-09T09:34:40.274Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第⑨篇。<a href="/2021/05/06/model-verbs-and-moods-in-English/">前作</a>处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。</p><p>从此篇开始，我们要进入复合句的世界。</p><a id="more"></a><h2 id="忘记长难句"><a href="#忘记长难句" class="headerlink" title="忘记长难句"></a>忘记长难句</h2><p>前北京新东方 GMAT 名师杨鹏著有《GRE&amp;GMAT 阅读难句教程》一书。因书中对 GRE 和 GMAT 考试阅读题中常常出现的长句难句做了一些解读，故而被坊间惯称为「杨鹏长难句」。然而，以数学系学生的视角，我对这本书是不甚满意的。这种不满在于它没有很好地解决一个基本问题：到底多长算长句，又到底多难算难句？对于难句，是你觉得难算难，还是我觉得难算难？因为缺少一个客观稳定的标准，在我的视角，它很难提出一个完备的方案去处理所有的情况。</p><p>因此，虽然《长难句》一书仍可一看，但忘记「长难句」这一概念却是必要的。</p><h2 id="破而立……什么？"><a href="#破而立……什么？" class="headerlink" title="破而立……什么？"></a>破而立……什么？</h2><p>或曰：「你不能光顾着破坏，还要负责建设」。</p><p>忘记长难句，我们要以怎样的视角去切入英文中那些看起来很长又很难的句子呢？答案是，以简单句和复合句的视角。</p><p>我们在系列第一篇介绍了五种基本句型，在系列第五篇（非谓语动词篇）里又提到了独立子句（independent clause）的概念。据此，我们可以给出一个明确的结论：有且只有一套主谓结构的句子，是独立子句。独立子句必属于五种基本句型之一。独立子句单独成句时，就是简单句。</p><p>在简单句的定义基础上，我们又能「非此即彼」地定义出复合句：不是简单句的句子，就是复合句。复合句由若干个独立子句组合而成。独立子句组成复合句又有两种方式。一是由 and/or/but 等连接词连接的两个并列子句组成的合句（compound sentence）；二是由各种从句与主句连接而成的复句（complex sentence）。</p><p>你看，按照这样的定义，绝不会有一个句子被遗漏。于是我们有信心能处理所有的情况。</p><h2 id="怎样分析和练习复合句？"><a href="#怎样分析和练习复合句？" class="headerlink" title="怎样分析和练习复合句？"></a>怎样分析和练习复合句？</h2><p>系列的后续文章，会处理各种类型的复合句。这里提前讲一讲，在理解各种类型复合句的基础上，如何分析和练习。在这里，分析是为了解决阅读方面的问题，让你在阅读遇到复合句时不至于抓瞎；练习是为了解决写作方面的问题，让你在写作时能自如地应用复合句。</p><p>这里总结整理了一个四步分析法：</p><ol><li>标记出复合句当中的各个独立子句。</li><li>对于每个独立子句，识别其应用的基本句型，而后标出其中的主要成分。</li><li>对于每个独立子句，翻译之。</li><li>将独立子句的翻译组合起来，得到整个复合句的翻译。——注意，一定要写下来翻译成通顺的人话（可以打字）。</li></ol><p>反复应用这一分析法，按我这等笨人的经验，每天坚持分析五个句子并坚持一个月能在阅读 GRE/GMAT/LSAT 级别的文章上有一个质的飞跃。（当然 GRE 级别的文章不只是复合句一个问题需要解决就是了。）相信读者老爷们这么聪明，应当相比当年的我，能更快获得提升。</p><p>分析完成之后，就要练习。练习的方法也很简单：模仿造句——牙牙学语嘛！对每个你初时感到困难的复合句进行三到五次模仿造句——模仿它的句子结构，也模仿子句之间的逻辑关系。</p><p>按照这样分析和练习的方法，每天花费大概半个小时的时间，你将能一劳永逸地征服英语复合句。它不香吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第⑨篇。&lt;a href=&quot;/2021/05/06/model-verbs-and-moods-in-English/&quot;&gt;前作&lt;/a&gt;处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们要进入复合句的世界。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
      <category term="Single Sentence" scheme="https://liam.page/tags/Single-Sentence/"/>
    
      <category term="Compound Sentence" scheme="https://liam.page/tags/Compound-Sentence/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之八：情态动词与虚拟语气</title>
    <link href="https://liam.page/2021/05/06/model-verbs-and-moods-in-English/"/>
    <id>https://liam.page/2021/05/06/model-verbs-and-moods-in-English/</id>
    <published>2021-05-06T13:36:57.000Z</published>
    <updated>2021-06-05T02:16:29.759Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第八篇。<a href="/2021/04/29/adverbs/">前作</a>处理了副词，此篇我们引出语气的问题，然后处理情态动词。</p><a id="more"></a><h2 id="语气是什么"><a href="#语气是什么" class="headerlink" title="语气是什么"></a>语气是什么</h2><p>我们从<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>开始（在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇中又一次强调），就从表意的角度解读：一个完整句子表达的无非是「一个人/一个东西怎么样（了）」。但这其实是一个「善意的谎言」；若说它不是谎言，也至少是不完整的。它欠缺的部分，就是「语气」。</p><p>语气的英文是 mood。在 AHD 中可见它有几层与文法中的语气相关意思：</p><ul><li>心情、情绪：A state of mind or emotion.</li><li>印象、感受：A pervading impression of an observer.</li><li>倾向、意愿：Inclination; disposition.</li></ul><p>无论何种解释，mood 都是「唯心」的，天然带有一层模糊的、不确定的感觉；这与「一个人/一个东西怎么样（了）」这种确定性的表述有明显差别。于是我们有：</p><ul><li><strong>语气其实就是句子表意过程中的不确定性</strong>；</li><li>确定的表意总是相似的；</li><li>不确定的表意则各有各的不确定（在不确定的程度和不确定的方式上）。</li></ul><p>在英文中，普通动词本身只能表达确定性的语义。例如：I like math. 若是要表达不确定性的语义，则必须有其他动词的帮助才行。帮助其他动词进行表意的动词，通称「助动词」。表达各种类别和各种程度的不确定性的助动词，是情态动词（modal verbs）。</p><blockquote><p>情态动词这个翻译，我认为不好。但因已成惯例，所以不去改它。更好的翻译应该是「语气动词」。modal 这个词，在 AHD 当中关于文法的解释只有一条「Of, relating to, or expressing the mood of a verb.」，即：语气的：属于，有关或表达一个动词的语气的。可见「语气动词」翻译之贴切。</p></blockquote><p>接下来的问题是，英文当中都有哪些语气呢？这是个令人头秃的问题，因为不同的语法专家对此的认知并不相同。有人认为英文当中语气分三种：陈述语气、祈使语气、虚拟语气。有人认为英文当中语气分四类，在上述三类基础上增加「疑问语气」。有人认为应当分五类，在上述四类基础上增加「感叹语气」。</p><p>于我看来，不论如何分类，祈使语气、疑问语气和感叹语气是不会有太多争议的。表达这三种语气时，在句法上会有很规律的变化，以至于有「祈使句」、「疑问句」和「感叹句」之说。因而人们想要弄混它们都不太容易。我们的宗旨是从表意和修辞出发。既然它们不容易弄混，我们就干脆地将他们放下，不尊「务虚论理者多，经世致用者少」那等做派。这样一来，剩下的问题就在陈述语气和虚拟语气当中了。</p><h2 id="以简御繁：关于不确定性的讨论"><a href="#以简御繁：关于不确定性的讨论" class="headerlink" title="以简御繁：关于不确定性的讨论"></a>以简御繁：关于不确定性的讨论</h2><p>以简御繁的手段是去摸索句子表意当中的不确定性。</p><h3 id="陈述语气（indicative）"><a href="#陈述语气（indicative）" class="headerlink" title="陈述语气（indicative）"></a>陈述语气（indicative）</h3><p>如果一个句子的表意十分确定，那显然就是陈述语气了。例如有：</p><ul><li>It rains. | 天在下雨。</li><li>You are right. | 你是对的。</li><li>I like mathematics. | 我喜欢数学。</li><li>Sophia gives me her pencil. | Sophia 将她的铅笔给我。</li><li>Liam finds the house big. | Liam 发现房子很大。</li></ul><h3 id="条件语气（conditional）"><a href="#条件语气（conditional）" class="headerlink" title="条件语气（conditional）"></a>条件语气（conditional）</h3><p>若在陈述语气的基础上，加上心情、情绪（例如 must）或是印象、感受（例如 can/could, may/might）亦或是倾向、意愿（例如 will/would, shall/should；注意此处并不表示将来时态，而是表示倾向意愿），句子中就有了不确定性了。在上述例子的基础上，我们处理一下：</p><ul><li>It <em>may/might</em> rain. | 天可能在下雨。</li><li>You <em>must</em> be right. | 你一定是对的。</li><li>I <em>shall</em> like mathematics. | 我应当喜欢数学。</li><li>Sophia <em>can/could</em> give me her pencil. | Sophia 可以将她的铅笔给我。</li><li>Liam <em>shall/should</em> have found the house big. | Liam 应当已经发现房子很大了。</li></ul><p>此处有两点需要注意。一是我们在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇里讲过的，情态动词后面，实际上是无修饰的不定式，因而要用动词原型。二是尽管部分情态动词有其过去式的形态，但对「不确定性」表达过去本身无意义，因此需要借用完成式来表达对过去的猜测（或曰，表达过去时态下的不确定性）。</p><p>在陈述语气的句子上，直接加上情态动词（可能还需要对动词做一些变形）可以表达不同类型和程度的不确定性。但这些不确定性，都没有否定陈述句意本身，只是在语气上的弱化。为便于归纳，我们把这类语法现象称之为条件语气。</p><h3 id="虚拟语气（subjunctive）"><a href="#虚拟语气（subjunctive）" class="headerlink" title="虚拟语气（subjunctive）"></a>虚拟语气（subjunctive）</h3><p>还有一种情况，我们的表意需要否定陈述句意本身。这种表意发生在假定一个不存在的事实的基础上，作出的推定。这里有四点需要注意的地方：</p><ul><li>因为假定非事实，所以称为虚拟语气；</li><li>因为假定非事实，所以从句中假定本身需要比正常时态退一格（现在 -&gt; 过去；过去 -&gt; 过去完成；将来 -&gt; 过去将来）；</li><li>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式表达强烈的不确定性；</li><li>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式。</li></ul><p>对虚拟语气，举几个例子。</p><p><strong>If I <em>were</em> you, I <em>would</em> fend off that shot. | 要我是你的话，我会把那一球扑出去。</strong></p><p>表达「我是你」，应该用 I am you 才对。但我不是你，这非是事实，所以要退一格，用过去式来表意。那么为什么是 <code>were</code> 而非是 <code>was</code> 呢？因为 <code>be</code> 这个动词是这样的：</p><ul><li>原型：be</li><li>第一人称单数现在陈述语气：am</li><li>第三人称单数现在陈述语气：is</li><li>其余人称和单复数的现在陈述语气：are</li><li>现在分词：being</li><li>过去分词：been</li><li>第一和第三人称单数过去陈述语气：was</li><li>第二人称单数和复数，第一人称复数，第三人称复数，过去陈述语气：were</li><li>过去虚拟语气：were</li></ul><p>亦即，在虚拟语气中，be-动词的过去式就是 were，不区分单复数，也不区分人称。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>would</code> 表达强烈的不确定性。</p><p><strong>If I <em>had known</em> that earlier, I <em>might have revised</em> for the examination harder. | 要早知道的话，我会为考试更努力复习。</strong></p><p>表达「我知道」，应该用 I knew that earlier 才对。但实际我并不知道，这非是事实，所以要退一格，用过去完成式来表意，变成 <code>had known</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>might</code> 表达强烈的不确定性。</p><p>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式，有 <code>might have revised</code>。</p><p><strong>If I <em>should take</em> the bribe, <em>could</em> you <em>keep</em> the secret for me? | 要我收下了那笔贿赂，你能替我保守秘密吗？</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>should take</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><p><strong>If I <em>were to take</em> the bribe, my fingers <em>could be</em> illicit from then on. | 要我收下了那笔贿赂，我的手就再也不干净了。</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>were to take</code>。这和上例的 <code>should take</code> 又有所不同。虽然都非是事实，用 should take 表示还有一些 take 的可能性，而用 were to take 则十分决绝，毫无可能。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>借助「不确定性」的表意，我们轻而易举地处理了虚拟语气，可见其以简御繁的为例。</p><p>虚拟语气中还有一个倒装的问题，属修辞范畴。我们在后续的文章中再来讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第八篇。&lt;a href=&quot;/2021/04/29/adverbs/&quot;&gt;前作&lt;/a&gt;处理了副词，此篇我们引出语气的问题，然后处理情态动词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Model Verbs" scheme="https://liam.page/tags/Model-Verbs/"/>
    
      <category term="Moods" scheme="https://liam.page/tags/Moods/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之七：副词</title>
    <link href="https://liam.page/2021/04/29/adverbs/"/>
    <id>https://liam.page/2021/04/29/adverbs/</id>
    <published>2021-04-29T13:47:12.000Z</published>
    <updated>2021-04-30T14:47:48.651Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第七篇。<a href="/2021/04/21/adjectives/">前作</a>处理了形容词，此篇我们处理同为修饰词类的副词。</p><p>从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。</p><p>除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。</p><p>除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 <code>-ly</code>。因此，在双音节的副词变为比较级和最高级时，若是以 <code>-ly</code> 结尾，则应保持不变，通过联合 <code>more</code> 及 <code>most</code> 来实现。</p><a id="more"></a><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><p>如何以简御繁？这是很重要的问题。</p><p>从系列第一篇读至此的朋友，若是细心就会发现我们至今为止以简御繁的两大法宝：</p><ul><li>从表意上考量——我们相信文法是为表意服务的；</li><li>从修辞上考量——我们相信文法形成过程中，人们有趋同的修辞偏好。</li></ul><p>这两大法宝将在整个系列贯穿始终、提纲挈领。我们从表意上，把副词分为以下几大类，分别处理：</p><ul><li>表达方式方法的副词；</li><li>表达强调的副词；</li><li>修饰句子的副词。</li></ul><h2 id="表达方式方法的副词"><a href="#表达方式方法的副词" class="headerlink" title="表达方式方法的副词"></a>表达方式方法的副词</h2><p>表达方式方法的副词，在传统语法当中被称为「方式状语」。方式状语直接修饰动词，表达动作发出的方式方法。</p><p>至于副词的位置——因为方式状语直接修饰动词，所以理想状态，它应该距离动词较近；若不然，人们很难领会到二者之间修饰 - 被修饰的关系。又考虑到动词本身肯定比修饰语要重要一些，所以作为修饰语的副词，一般性应该要放在动词后面。这是表达方式方法的副词的典型位置。</p><p>接下来，我们按<a href="/2014/06/21/basic-sentence-and-the-complement/">五种基本句型</a>各举一例，说明表达方式方法的副词在句子中位置应当如何处理。</p><ul><li>The girl cries <em>sadly</em> after being betrayed by her ex-boyfriend. | 被前男友背叛后，女孩哭得很伤心。</li></ul><p>句子中，我们把表达方式方法的副词放在动词 cries 后面。可选的位置还有两个。一是放在 cries 之前。这样做是可以的，但是 cries 后面没有句子主干成分了（宾语、补语之类）；所以还是放在 cries 后面，凸显动词更佳。另一是放在整个 after 短语之后。但这样距离 cries 太远，反而距离另一个动词 betrayed 更近，造成句意不明。</p><ul><li>The girl swings her bat <em>vigorously</em>. | 女孩用力挥动她的棒球棒。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是和上例一样，放在动词 swing 后面。但这样就把句子的主干成分 her bat（句子中做宾语）挤到后面去了，不利于表意。另一是放在 swing 之前。这也属于可以考虑的方案，但此处宾语并不冗长，放在宾语之后距离被修饰的动词 swing 也不算太远，所以显得有些鸡肋。但如果换成下面的句子，副词就最好放在动词 swing 之前了——若不然，就距离动词太遥远了。</p><blockquote><p>The girl <em>vigorously</em> swings her brand new Italian aluminum alloy bat. | 女孩用力挥动她那崭新的意大利产铝合金棒球棒。</p></blockquote><ul><li>The girl becomes mature <em>gradually</em>. | 女孩逐渐变得成熟。</li></ul><p>句子中，我们表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一个是放在动词 becomes 之前，这没问题。另一是放在动词 becomes 之后，变成「The girl becomes <em>gradually</em> mature.」。这样一来，因为副词既可以修饰动词，又可以修饰形容词，放在这里的 gradually 很容易让人困惑它到底是修饰 becomes 的还是修饰 mature 的。</p><ul><li>The girl gave him a jar of honey <em>readily</em>. | 女孩爽快地给了他一罐蜂蜜。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是放在动词 gave 之前，这没问题。另一是放在动词 gave 之后，变成「The girl gave <em>readily</em> him a jar of honey.」。这样做，表意上倒是不至于有歧义，但副词 readily 把句子的主干成分（直接宾语 + 间接宾语）挤到后面去了，所以在修辞上不好。</p><ul><li>The priest <em>happily</em> announced the boy and the girl man and wife. | 神父高兴地宣布男孩和女孩结为夫妻。</li></ul><p>句子中，我们把表达方式方法的副词放在了动词 announced 之前。可选的位置还有两个。一是放在动词 announced 之后，但这会让句子的主干成分（宾语 + 宾语补语）后移，在修辞上不佳。二是放在句子最后。但这个句子重点是要强调二者结为夫妻，若是将 happily 放在句子最后，一则显得我们在强调神父是高兴的，二则让副词和被修饰的动词距离过远。</p><h2 id="表达强调的副词"><a href="#表达强调的副词" class="headerlink" title="表达强调的副词"></a>表达强调的副词</h2><p>副词当中，还有一大类是表达强调的副词（Intensifier）。这些副词的修饰对象广泛，可以修饰几乎全部词类，特别是可以修饰几种主要词类：名词、动词、形容词、副词。因之，这些副词必须和被修饰的对象紧密相连（而且通常都是放在被修饰对象的前面）。若不然，可能会被误以为是修饰其他句子成分，表意出现漂移。</p><p>表达强调意味的副词，大致有三类。以下分别处理。</p><h3 id="强调范围的副词"><a href="#强调范围的副词" class="headerlink" title="强调范围的副词"></a>强调范围的副词</h3><p>表达强调的副词中，有一部分是用来强调所谈事物的范围的，将所谈事物的范围限定在一个小的范围内。这类副词加与不加、加在何处，对句子的表意影响很大。这类副词中，一个典型是「只有」。举例如下。</p><p>原句：Liam studied mathematics when he was young. | Liam 年轻时学习数学。</p><p>添加「只有」：</p><ul><li><em>Only</em> Liam studied mathematics when he was young. | 只有 Liam 年轻时学习数学。——别人年轻时不学。</li><li>Liam <em>only</em> studied mathematics when he was young. | Liam 年轻时只学习数学。——但没对数学做别的事情；比如对数学并不热爱。</li><li>Liam studied <em>only</em> mathematics when he was young. | Liam 年轻时只学习数学。——但没学别的学科。</li><li>Liam studied mathematics <em>only</em> when he was young. | Liam 只在年轻时学习数学。——长大之后不学了。</li></ul><p>不难发现，添加「只有」之后的四个变种，其表意各不相同，亦与原句表意不同。由此可见「这类副词加与不加、加在何处，对句子的表意影响很大」之说。此又印证「这些副词必须和被修饰的对象紧密相连」之言。</p><p>常见的用于强调表意范围的副词还有：</p><ul><li>only / just / merely | 只有</li><li>also | 也</li><li>especially / particularly | 尤其、特别地</li><li>even | 更加、甚至、居然、恰如</li><li>exactly / precisely | 恰恰</li><li>……</li></ul><h3 id="强调程度的副词"><a href="#强调程度的副词" class="headerlink" title="强调程度的副词"></a>强调程度的副词</h3><p>表达强调的副词中的第二类是强调程度的副词。这些副词也是句子表意中很重要的一部分；同样地，这类副词加与不加对句意影响很大。举一例：</p><ul><li>原句：Liam knows Wenyue well. | Liam 了解 Wenyue。</li><li>改程度：Liam knows Wenyue <em>rather</em> well. | Liam 还算了解 Wenyue。</li></ul><p>再举一例：</p><ul><li>原句：The task is done. | 任务已完成。</li><li>改程度：The task is <em>almost</em> done. | 任务已近完成。</li></ul><p>不难发现，这些表达程度的副词也是句子表意的重要组成部分。若是去掉它们，句子表意会发生巨大变化。常见的用于强调程度的副词不少，就不举例了。</p><h3 id="强调语气的副词"><a href="#强调语气的副词" class="headerlink" title="强调语气的副词"></a>强调语气的副词</h3><p>强调语气的副词看起来和强调程度的副词很像。但是，去掉句子当中强调语气的副词只是影响语气，不影响句子表意。举几例：</p><ul><li>Fat XXX looks <em>very much</em> a ball. | 胖子 XXX 看着就是个球。</li><li>XXX is <em>absolutely</em> insane. | XXX 绝对是疯了。</li><li>XXX <em>urgently</em> need being hospitalized. | XXX急需入院治疗。</li></ul><h2 id="修饰句子的副词"><a href="#修饰句子的副词" class="headerlink" title="修饰句子的副词"></a>修饰句子的副词</h2><p>这是一类特殊的副词。和一般（狭隘的）认知不同，有些副词可以用来修饰整个句子。举例来说：</p><ul><li><em>Therefore</em>, Wenyue is less than too fat. | 因此，Wenyue 还称不上太胖。</li><li><em>Frankly</em>, Wenyue is very much a gentleman. | 坦率地说，Wenyue 是个绅♂士。</li></ul><p>例中，无论是 <em>therefore</em> 还是 <em>frankly</em>，在句中都找不到被它们直接修饰的句子成分。这是因为它们都是修饰整个句子的副词。此二例中，看着相似，但实际仍有区别。第二例中的 <em>frankly</em>，实际是一条件状语从句的缩写：</p><blockquote><p>If we are specking frankly, Wenyue is very much a gentleman.</p></blockquote><p>对于这类从副词从句缩写而来的副词，我们称之为分离副词。此外，不难发现，分离副词前后的逗号，原就是两个句子之间的逗号。这种简化，最早应是出于修辞的考虑；简化之后保留逗号，则是出自表意的考虑。</p><p>第一例中的 <em>therefore</em> 本身能表达逻辑关系。因之，此类副词被称为连接副词。这些副词还有</p><ul><li>表达逻辑等号的：therefore, besides, futhermore, ...</li><li>表达逻辑不等号的：however, nonetheless, ...</li></ul><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>此篇，我们通过「两大法宝」，串起了几大类副词，同时辨析了各类副词在句中的用法。所谓渔重于🐟，读者在了解各类副词用法的同时，更重要地是善用两大法宝，复习过去学过的文法和学习新的文法知识。</p><p>下一篇我们处理情态动词和虚拟语气。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第七篇。&lt;a href=&quot;/2021/04/21/adjectives/&quot;&gt;前作&lt;/a&gt;处理了形容词，此篇我们处理同为修饰词类的副词。&lt;/p&gt;
&lt;p&gt;从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。&lt;/p&gt;
&lt;p&gt;除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。&lt;/p&gt;
&lt;p&gt;除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 &lt;code&gt;-ly&lt;/code&gt;。因此，在双音节的副词变为比较级和最高级时，若是以 &lt;code&gt;-ly&lt;/code&gt; 结尾，则应保持不变，通过联合 &lt;code&gt;more&lt;/code&gt; 及 &lt;code&gt;most&lt;/code&gt; 来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adverbs" scheme="https://liam.page/tags/Adverbs/"/>
    
  </entry>
  
  <entry>
    <title>喉咙和声带的结构</title>
    <link href="https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/"/>
    <id>https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/</id>
    <published>2021-04-26T16:28:03.000Z</published>
    <updated>2021-04-26T16:34:00.953Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！</p><a id="more"></a><p>声带是两片相对的膜状韧带，有长度宽度和厚度。</p><p>声带附近有四块软骨：甲状软骨、勺状软骨（两块）和环状软骨。</p><p>连接软骨有肌肉：甲杓（读音：彪）肌（连接甲状软骨和勺状软骨；TA 肌）、杓间肌（连接两块勺状软骨，横向一条，斜向两条；IA 肌）、环杓侧肌（在侧面连接环状软骨和勺状软骨；LCA 肌）、环杓后肌（在后面连接勺状软骨和环状软骨；PCA 肌）、环甲肌（在前面连接环状软骨和甲状软骨；CT 肌）。</p><p>肌肉通过拉扯软骨，来改变连接着软骨的声带的形状。相对来说，有四种：</p><ul><li>变短变厚：甲杓肌收缩，发出响亮的中低音，传说中的「真声」。</li><li>变长变薄：环甲肌收缩，引起整个环状软骨绕环甲连接处转动，从而带动勺状软骨后移，拉动声带变长变薄。</li><li>闭合：杓间肌和环杓侧肌收缩，拉近两块勺状软骨之间的距离。</li><li>张开：环杓后肌收缩，拉开两块勺状软骨之间的距离，声带分开。</li></ul><p>当声带闭合，又有气流从下而上推出，两片声带在气流的冲击和伯努利效应（边界层表面效应）的作用下会不断相互拍击，发出声音。</p><p>接下来的问题就是，要想唱好歌，本质上就是要在各种情况下，相应的肌肉都有足够的力量，去使声带作出相应的动作。所以，练歌，本质上和去健身房撸铁没啥区别——都是要锻炼肌肉。下回如果有人跟你说要去撸铁，不一定是去健身房，也可能是去练歌房。</p><p>唔哈哈哈，是不是很有趣~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Vocal" scheme="https://liam.page/tags/Vocal/"/>
    
      <category term="Autopsy" scheme="https://liam.page/tags/Autopsy/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之六：形容词</title>
    <link href="https://liam.page/2021/04/21/adjectives/"/>
    <id>https://liam.page/2021/04/21/adjectives/</id>
    <published>2021-04-21T13:49:22.000Z</published>
    <updated>2021-04-22T14:24:34.516Z</updated>
    
    <content type="html"><![CDATA[<p>这个<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>最近<a href="https://github.com/Liam0205/liam0205.github.io/issues/333#issuecomment-808816973" target="_blank" rel="noopener">又被吐槽了</a>。<a href="https://github.com/PolyMark" target="_blank" rel="noopener">PolyMark</a> 讲我更新的太慢。遭不住催更的我，于是就又开始更新了。</p><p>英文当中，用来修饰其他词的词类有两种：形容词和副词。</p><p>大体上，形容词是修饰名词的词，副词则用来修饰名词以外的词类。不过也有少许例外。一方面，少数副词也可以修饰名词；另一方面，用来修饰名词的，不仅仅是狭义上的形容词。比方说，形容词性从句及其简化版本、介词短语、复合词等，在一些场合下，都能充当形容词，承担相应的表意功能。</p><p>此篇先介绍最简单的部分——单词形状的形容词。</p><a id="more"></a><p>单词形状的形容词是英文文法当中比较简单的部分，就只有三大主题：</p><ul><li>补语位置（包括主语补语和宾语补语）的形容词；</li><li>名词短语当中的形容词；</li><li>形容词的比较级。</li></ul><p>我们分别来处理。</p><h2 id="补语位置的形容词——从几个例子开始"><a href="#补语位置的形容词——从几个例子开始" class="headerlink" title="补语位置的形容词——从几个例子开始"></a>补语位置的形容词——从几个例子开始</h2><p>名词短语当中的形容词，在我们处理名词短语时已经见过。它出现在限定词和名词之间，是「属性形容词」（attribute adjectives），描述名词的一种属性。我们举几个例子复习一下。（下划线部分是限定词，加粗部分是形容词）：</p><ul><li><u>a</u> <strong>new</strong> book | 一本新书</li><li><u>many</u> <strong>good</strong> students | 许多好学生</li><li><u>his</u> <strong>beautiful</strong> wife | 他美丽的妻子</li><li><u>the</u> <strong>best</strong> answer | （那个）最佳答案</li><li><u>those</u> <strong>sweet</strong> roses | 那些芳香的玫瑰</li><li><strong>dirty</strong> water | 脏水</li><li><strong>Fat</strong> Wenyue doesn&#39;t like taking exercises. | 胖 Wenyue 不喜欢运动</li></ul><p>出现在补语位置的形容词则是「叙述形容词」（predicate adjectives），它通常是对名词做临时性、暂时性的叙述。同样举几个例子。</p><ul><li>Wenyue is <strong>fat</strong>. | Wenyue 很胖。</li><li>Eating too many junk foods and lack of working-out make Wenyue <strong>fat</strong>. | 吃过多垃圾食品又缺少锻炼导致 Wenyue 很胖。</li></ul><p>比较关于 Wenyue 的几个例子，我们不难发现：<strong>出现在名词短语当中的形容词，暗含一种固有、长期的感觉</strong>。「Fat Wenyue」的表述告诉大家，Wenyue 他就是个胖子，不管他说什么做什么，都很难瘦下来。反过来，<strong>出现在补语位置的形容词，则缺乏固有、长期的意味</strong>。不管是充作主语的补语还是充作宾语的补语，你都能感觉 Wenyue 只是暂时有点胖，过段时间还是有可能瘦下去的，还是有救的，不能放弃治疗。</p><blockquote><p>P.S. 此文的打赏请备注，我需要给模特儿 Wenyue 分润一些。哈哈~！</p></blockquote><p>我们知道，来自古英语中，有一些以「a-」开头的形容词，往往都表示短暂的状态。这类形容词就喜欢出现在补语位置——尽管他们也可以出现在名词短语中，但会有一些小的变化，而且显得多少有些奇怪。</p><ul><li>The sick man is still <strong>alive</strong>. | 那个久病之人仍旧活着。</li><li>The balloon stays <strong>afloat</strong>. | 气球保持漂浮。</li><li>Coffee keeps modern people <strong>awake</strong>. | 咖啡让现代人保持清醒。</li></ul><p>补语是对名词的一种补述，单靠一个单词显然是难以完成各种各样的表意的。因此，补语位置的形容词形式比较自由。除了单词形式的形容词之外，还可以是各种短语。举几个例子：</p><ul><li>She always wants to make everyone <strong>happy</strong>.</li><li>I heard her <strong>playing the violin</strong> yesterday.</li><li>The lake is <strong>large</strong>.</li></ul><h2 id="名词短语当中的形容词"><a href="#名词短语当中的形容词" class="headerlink" title="名词短语当中的形容词"></a>名词短语当中的形容词</h2><p>属性形容词这个主题下，我们已有名词短语当中的讨论打底，因此只需要处理几个问题就好。</p><ul><li>后置的形容词；</li><li>名词形容词化；</li><li>复合词做形容词；</li><li>属性形容词的相对顺序。</li></ul><h3 id="后置的形容词"><a href="#后置的形容词" class="headerlink" title="后置的形容词"></a>后置的形容词</h3><p>在处理名词短语时，我们讲修饰词要放在限定词（如果有）和名词（如果有）之间。也就是说，相对名词，修饰名词的形容词要前置。但是，有两种情形，形容词需要后置。</p><h4 id="复合名词与-else-联用"><a href="#复合名词与-else-联用" class="headerlink" title="复合名词与 else 联用"></a>复合名词与 else 联用</h4><p>首先还是看一个例子。</p><ul><li>Someone <strong>else</strong> will handle it well.</li></ul><p>在这个例子当中，形容词 else 放在名词 someone 的后面。这几乎已经是「习以为常」的用法了，在传统语法当中可能会被解释成「约定俗成」。但是我们就偏偏要掰扯掰扯到底是怎样「俗成」的。</p><p>其实这里，someone 是所谓「复合名词」。这类复合名词把名词短语当中的限定词和名词粘连到一起了，于是修饰词失去了位置，就只好往后放了。就这么简单。</p><blockquote><p>类似的复合名词还有（不完整举例）：someone, everyone, anyone, somebody, everybody, anybody...</p></blockquote><h4 id="古英语当中的-a-形容词"><a href="#古英语当中的-a-形容词" class="headerlink" title="古英语当中的 a- 形容词"></a>古英语当中的 <code>a-</code> 形容词</h4><p>之前我们已经讲到，古英语当中的 <code>a-</code> 形容词往往都表示短暂的状态，因此不适合放在名词之前作为属性，而只能后置。举一个例子看看：</p><ul><li>Money <strong>alone</strong> cannot solve every problem, meanwhile, without money solves no problem. | 钱不是万能的，没钱是万万不能的。</li></ul><p>显然，alone 不可能是 money 的一种属性。在句子当中，money alone 表示「只有钱」这一种特殊而暂时的状态。</p><h3 id="名词形容词化"><a href="#名词形容词化" class="headerlink" title="名词形容词化"></a>名词形容词化</h3><p>初看起来，可能会觉得名词形容词化是个很吓人的事情。但其实它真的很常见。比如，中文当中「校门」这个词，实际上「校」就是名词充作了形容词。所以名词形容词化不是什么值得大惊小怪的事情。我们看几个例子。</p><ul><li>a <strong>government</strong> shop | 一家公营商店</li><li><strong>movie</strong> theaters | 电影院（其实就是 cinema <code>: )</code>）</li></ul><p>值得一讲的是，名词既已形容词化，那就要遵循形容词的一些「规矩」。比如电影院，实际上不可能只放映一部电影。但由于形容词不存在复数的概念，所以我们不能写作 movies theaters。</p><h3 id="复合词做形容词"><a href="#复合词做形容词" class="headerlink" title="复合词做形容词"></a>复合词做形容词</h3><p>名词短语中的修饰词位置只能放单词形状的词。因此，如果有一个短语形状的形容词想要放进名词短语当中，就需要用连字符（hyphen）将短语连起来变成一个词；同时，为了遵循形容词的规矩，短语中如果有复数名词应该变成单数形式。举几个例子完事儿~</p><ul><li>an <strong>eye-opening</strong> show | 一场令人大开眼界的表演</li><li>a <strong>five-year-old</strong> girl | 一个五岁的小女孩儿</li></ul><h3 id="属性形容词的相对顺序"><a href="#属性形容词的相对顺序" class="headerlink" title="属性形容词的相对顺序"></a>属性形容词的相对顺序</h3><p>这又是国内英语考试喜欢考察的考点之一。传统语法书惯常让人背诵一个特定的顺序。然而，学生每次都会发现，考卷上的题目会涉及到一个之前没背过的东西，然后就抓耳挠腮。</p><p>实际上，稍作思考就能想清楚了。属性形容词表达的是名词的属性。那么，越接近名词本质的，就要越靠近名词；反过来，越是容易变化或是主观感受的，就要相对远离名词。</p><p>举个两栗子。</p><ul><li>A <strong>poisoned small green</strong> almost kills the White Snow. | 一个有毒的小小绿色苹果差点毒死了白雪公主。</li><li>The murderer left behind a <strong>bloody old black US leather</strong> glove. | 凶手在现场遗留了一个带血的老旧黑色美国皮手套。</li></ul><p>稍微体会一下就容易感受出来了，不是吗？</p><h2 id="形容词的比较级"><a href="#形容词的比较级" class="headerlink" title="形容词的比较级"></a>形容词的比较级</h2><p>形容词和副词都有比较级和最高级。二者有一个共同的问题需要处理：<strong>拼法</strong>。除此之外，最高级比较简单，只有一个定冠词的问题需要处理。比较级则复杂一些。因为比较就一定会导致句子当中出现重复的成分，于是就会有省略和倒装的语法现象。</p><p>我们先来看看比较级和最高级的几个基本例子，然后分别来看这几个问题。</p><h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><p>比较级就是为了解决表意中「大于」、「小于」、「等于」、「不等于」而出现的。前两者的基本形态是「A is <em>adj.-er</em> than B.」；后两者是同级比较，基本形态是「A is <em>(not) as adj. as</em> B」。</p><ul><li>Liam is <em>taller</em> than Sophia. | Liam 比 Sophia 高。</li><li>Liam is <em>as old as</em> Sophia. | Liam 和 Sophia 年岁一般大。</li></ul><p>最高级是为了解决表意中「最」的概念而出现的。举例：</p><ul><li>The Hua Mountain is the <em>most precipitous</em> mountain in China. | 华山是中国最险峻的山。</li><li>The Hua Mountain is <em>most crowded</em> in public holidays. | 华山在公共假期时最拥挤。</li></ul><h3 id="拼法"><a href="#拼法" class="headerlink" title="拼法"></a>拼法</h3><p>对于单音节形容词来说，比较级和最高级的拼法很简单——加 <code>-er</code> 或者 <code>-est</code> 即可。额外多一句就是，以 <code>y</code> 结尾的词，为发音规则计，需要改 <code>y</code> 为 <code>i</code> 再加 <code>-er</code> 或者 <code>-est</code>。对于三音节或更多音节的长词来说，比较级和最高级的拼法也很简单——联用用 <code>more adj.</code>/<code>most adj.</code> 来解决。</p><p>麻烦事儿出现在双音节上。它不长不短，到底是联用 <code>more</code> 好呢？还是加 <code>-er</code> 小尾巴好呢？传统语法书，又要让你背诵了。仔细观察，其实这事儿也很简单。一句话版本：如果形容词有典型的形容词后缀，那就和 <code>more</code> 联用；不然，两者皆可。</p><p>举几个典型形容词后缀的例子。</p><ul><li>act<em>ive</em> -&gt; more act<em>ive</em> -&gt; most act<em>ive</em></li><li>fam<em>ous</em> -&gt; more fam<em>ous</em> -&gt; most fam<em>ous</em></li><li>use<em>ful</em> -&gt; more use<em>ful</em> -&gt; most use<em>ful</em></li><li>lov<em>ing</em> -&gt; more lov<em>ing</em> -&gt; most lov<em>ing</em></li></ul><h3 id="定冠词与最高级"><a href="#定冠词与最高级" class="headerlink" title="定冠词与最高级"></a>定冠词与最高级</h3><p>「最高级前面要加定冠词」可能对于中国学生来说是深入人心的。但看看刚才华山的两个例子，立马就「打脸」了。</p><p>其实，回顾我们在名词短语篇中的讨论就知道，定冠词是限定词的一种，是名词短语的一部分。如果需要表达 that 语义的时候，就要用 the。但是，在有关华山的第二个例子当中，最高级 <em>most crowded</em> 根本就不是名词短语的一部分，当然就谈不上用定冠词了。</p><blockquote><p>我们继续走在秒杀英文文法要点的道路上……嘻嘻……</p></blockquote><h3 id="重复——省略和倒装"><a href="#重复——省略和倒装" class="headerlink" title="重复——省略和倒装"></a>重复——省略和倒装</h3><p>我们先来看两个例子。</p><ul><li>Children grown up in cities are likely to be somewhat more self-confident than children grown up in countryside. | 某种意义上，城里长大的小孩相比农村长大的小孩相较而言更显自信。</li><li>Golden retriever dog has as much I.Q. as a child of five or six has I.Q. | 金毛狗拥有和五六岁小孩一般多的智商。</li></ul><p>啥感觉？读起来累不累？是不是感觉累赘？那就对了！若非是简单的二者直接比较，而是比较具有不同属性的相同物体，物体本身就必然重复。若非是简单地二者直接比较，而是比较不同的二者做的同样的事，做的事情就必然重复。</p><p>那么，问题来了。有重复咋办呢？对于重复的物体，我们可以用代词来指代。对于重复的动作，我们可以用助动词来代替，在加入倒装以便让助动词和它代替的动作在句子里距离更近。我们来分析这两个例子。</p><p>在第一个例子中，重复的物体是 children。我们用 those 来代替它，句子变成：Children grown up in cities are likely to be somewhat more self-confident than <em>those</em> grown up in countryside.</p><p>在第二个例子中，重复的动作是 has I.Q.。我们用 does 来代替它，句子变成：Golden retriever dog has as much I.Q. as a child of five or six <em>does</em>. 此时我们发现助动词 does 距离它实际表意的 has I.Q. 特别远，于是我们来倒装，将助动词 <em>does</em> 提前：Golden retriever dog has as much I.Q. as <em>does</em> a child of five or six.</p><p>关于形容词的事情，就这样齐活儿啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;最近&lt;a href=&quot;https://github.com/Liam0205/liam0205.github.io/issues/333#issuecomment-808816973&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;又被吐槽了&lt;/a&gt;。&lt;a href=&quot;https://github.com/PolyMark&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PolyMark&lt;/a&gt; 讲我更新的太慢。遭不住催更的我，于是就又开始更新了。&lt;/p&gt;
&lt;p&gt;英文当中，用来修饰其他词的词类有两种：形容词和副词。&lt;/p&gt;
&lt;p&gt;大体上，形容词是修饰名词的词，副词则用来修饰名词以外的词类。不过也有少许例外。一方面，少数副词也可以修饰名词；另一方面，用来修饰名词的，不仅仅是狭义上的形容词。比方说，形容词性从句及其简化版本、介词短语、复合词等，在一些场合下，都能充当形容词，承担相应的表意功能。&lt;/p&gt;
&lt;p&gt;此篇先介绍最简单的部分——单词形状的形容词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adjectives" scheme="https://liam.page/tags/Adjectives/"/>
    
  </entry>
  
  <entry>
    <title>Again：不要重新造轮子</title>
    <link href="https://liam.page/2021/03/17/do-not-reinventing-the-wheel-again/"/>
    <id>https://liam.page/2021/03/17/do-not-reinventing-the-wheel-again/</id>
    <published>2021-03-17T03:56:10.000Z</published>
    <updated>2021-04-21T13:48:50.293Z</updated>
    
    <content type="html"><![CDATA[<p>最近，宝玉在群里抛了一个 case，大意是说，因为 <code>npm</code> 更新了上游一个包，导致他们的服务性能下降明显。排查之后发现，上游把一个处理字符串的函数（用于将 <code>&amp;&lt;&gt;&quot;</code> 替换为相应的 HTML 转义）从类似 <code>str.replace(/&quot;/g, &#39;&amp;quot;&#39;)</code> 的写法，改成了循环遍历 <code>str</code>，然后逐个字符检查，再用 <code>+=</code> 拼接到新的输出字符串上。</p><p>显然，这又是一个重新造的轮子不圆引发的问题。</p><a id="more"></a><p>为啥这么说呢？我不了解 JavaScript，但对 Python 有所了解。我找了一下 Python 对字符串 replace 的实现，一下就看明白了差距。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://svn.python.org/projects/python/trunk/Objects/stringobject.c</span></span><br><span class="line">Py_LOCAL(PyStringObject *)</span><br><span class="line">replace(PyStringObject *self,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *from_s, Py_ssize_t from_len,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *to_s, Py_ssize_t to_len,</span><br><span class="line">    Py_ssize_t maxcount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxcount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxcount = PY_SSIZE_T_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxcount == <span class="number">0</span> || PyString_GET_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* nothing to do; return the original string */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxcount == <span class="number">0</span> ||</span><br><span class="line">        (from_len == <span class="number">0</span> &amp;&amp; to_len == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/* nothing to do; return the original string */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle zero-length special cases */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from_len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* insert the 'to' string everywhere.   */</span></span><br><span class="line">        <span class="comment">/*    &gt;&gt;&gt; "Python".replace("", ".")     */</span></span><br><span class="line">        <span class="comment">/*    '.P.y.t.h.o.n.'                   */</span></span><br><span class="line">        <span class="keyword">return</span> replace_interleave(self, to_s, to_len, maxcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Except for "".replace("", "A") == "A" there is no way beyond this */</span></span><br><span class="line">    <span class="comment">/* point for an empty self string to generate a non-empty string */</span></span><br><span class="line">    <span class="comment">/* Special case so the remaining code always gets a non-empty string */</span></span><br><span class="line">    <span class="keyword">if</span> (PyString_GET_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* delete all occurances of 'from' string */</span></span><br><span class="line">        <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_delete_single_character(</span><br><span class="line">                self, from_s[<span class="number">0</span>], maxcount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_delete_substring(self, from_s, from_len, maxcount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special case where both strings have the same length */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from_len == to_len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_single_character_in_place(</span><br><span class="line">                self,</span><br><span class="line">                from_s[<span class="number">0</span>],</span><br><span class="line">                to_s[<span class="number">0</span>],</span><br><span class="line">                maxcount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> replace_substring_in_place(</span><br><span class="line">                self, from_s, from_len, to_s, to_len, maxcount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise use the more generic algorithms */</span></span><br><span class="line">    <span class="keyword">if</span> (from_len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> replace_single_character(self, from_s[<span class="number">0</span>],</span><br><span class="line">                                        to_s, to_len, maxcount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* len('from')&gt;=2, len('to')&gt;=1 */</span></span><br><span class="line">        <span class="keyword">return</span> replace_substring(self, from_s, from_len, to_s, to_len, maxcount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过边界检查，Python 的 C 实现当中，对 <code>from_s</code> 和 <code>to_s</code> 不同长度的情况作了不同的处理。当二者长度相同的时候，由于无需额外分配内存，可以使用 in-place 的方式解决问题。当二者长度不同时，若 <code>from_s</code> 的长度为 1，走特定优化的版本；否则，走最通用的版本。</p><p>对应到宝玉遇到的问题，显然落到了 <code>from_s</code> 长度为 1 的情形。我们继续再深入看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* len(self)&gt;=1, len(from)==1, len(to)&gt;=2, maxcount&gt;=1 */</span></span><br><span class="line">Py_LOCAL(PyStringObject *)</span><br><span class="line">replace_single_character(PyStringObject *self,</span><br><span class="line">                         <span class="keyword">char</span> from_c,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span> *to_s, Py_ssize_t to_len,</span><br><span class="line">                         Py_ssize_t maxcount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *self_s, *result_s;</span><br><span class="line">    <span class="keyword">char</span> *start, *next, *end;</span><br><span class="line">    Py_ssize_t self_len, result_len;</span><br><span class="line">    Py_ssize_t count, product;</span><br><span class="line">    PyStringObject *result;</span><br><span class="line"></span><br><span class="line">    self_s = PyString_AS_STRING(self);</span><br><span class="line">    self_len = PyString_GET_SIZE(self);</span><br><span class="line"></span><br><span class="line">    count = countchar(self_s, self_len, from_c, maxcount);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* no matches, return unchanged */</span></span><br><span class="line">        <span class="keyword">return</span> return_self(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use the difference between current and new, hence the "-1" */</span></span><br><span class="line">    <span class="comment">/*   result_len = self_len + count * (to_len-1)  */</span></span><br><span class="line">    product = count * (to_len<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (product / (to_len<span class="number">-1</span>) != count) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">"replace string is too long"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result_len = self_len + product;</span><br><span class="line">    <span class="keyword">if</span> (result_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError, <span class="string">"replace string is too long"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (result = (PyStringObject *)</span><br><span class="line">          PyString_FromStringAndSize(<span class="literal">NULL</span>, result_len)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    result_s = PyString_AS_STRING(result);</span><br><span class="line"></span><br><span class="line">    start = self_s;</span><br><span class="line">    end = self_s + self_len;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        next = findchar(start, end-start, from_c);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == start) &#123;</span><br><span class="line">            <span class="comment">/* replace with the 'to' */</span></span><br><span class="line">            Py_MEMCPY(result_s, to_s, to_len);</span><br><span class="line">            result_s += to_len;</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* copy the unchanged old then the 'to' */</span></span><br><span class="line">            Py_MEMCPY(result_s, start, next-start);</span><br><span class="line">            result_s += (next-start);</span><br><span class="line">            Py_MEMCPY(result_s, to_s, to_len);</span><br><span class="line">            result_s += to_len;</span><br><span class="line">            start = next+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Copy the remainder of the remaining string */</span></span><br><span class="line">    Py_MEMCPY(result_s, start, end-start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，这是一个对特定情况的专门优化。</p><ol><li>遍历原字符串，计数 <code>from_c</code> 出现的次数；</li><li>计算目标字符串的长度 <code>len(str) + count * (len(to_str) - 1)</code>，提前分配内存；</li><li>循环地找 from_str 下一次出现的位置，然后 memcpy 原始字符串 + memcpy to_str。</li></ol><p>这种操作，肯定会比不断用 <code>+=</code> 追加单个字符要快得多。因此有标题：Again, 不要重复造轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，宝玉在群里抛了一个 case，大意是说，因为 &lt;code&gt;npm&lt;/code&gt; 更新了上游一个包，导致他们的服务性能下降明显。排查之后发现，上游把一个处理字符串的函数（用于将 &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; 替换为相应的 HTML 转义）从类似 &lt;code&gt;str.replace(/&amp;quot;/g, &amp;#39;&amp;amp;quot;&amp;#39;)&lt;/code&gt; 的写法，改成了循环遍历 &lt;code&gt;str&lt;/code&gt;，然后逐个字符检查，再用 &lt;code&gt;+=&lt;/code&gt; 拼接到新的输出字符串上。&lt;/p&gt;
&lt;p&gt;显然，这又是一个重新造的轮子不圆引发的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="JavaScript" scheme="https://liam.page/tags/JavaScript/"/>
    
      <category term="Software Engineering" scheme="https://liam.page/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中类的构造函数中使用 this 指针</title>
    <link href="https://liam.page/2021/03/17/using-this-pointer-in-ctor/"/>
    <id>https://liam.page/2021/03/17/using-this-pointer-in-ctor/</id>
    <published>2021-03-17T03:44:57.000Z</published>
    <updated>2021-04-21T13:48:50.293Z</updated>
    
    <content type="html"><![CDATA[<p>遇见一个有趣的问题。</p><p>C++ 里面，在类的 constructor 当中使用 this 指针访问成员，是否是安全的？在哪些情况下安全？在哪些情况下不安全？</p><a id="more"></a><p>Ao Shen 给了一个<a href="https://isocpp.org/wiki/faq/ctors#using-this-in-ctors" target="_blank" rel="noopener">标准答案</a>，跟我之前的认知一致：只要对类内成员初始化顺序，以及对基类子类初始化顺序熟悉，就很容易理解了。</p><p>因为类内成员初始化顺序和类内成员声明顺序一致，基类总是在子类之前初始化。所以</p><ul><li>在父类初始化列表当中，使用 <code>this</code> 引用更早声明的变量初始化是安全的。</li><li>在父类构造函数体当中，使用 <code>this</code> 指针引用类内成员是安全的（不包括子类成员）。</li><li>在父类构造函数体当中，down-cast <code>this</code> 指针为子类指针，这一行为本身是安全的；但是使用 down-casted 指针访问子类成员是不安全的。</li><li>在子类初始化列表当中，使用 <code>this</code> 指针引用父类成员总是安全的。</li><li>访问函数的情况，则看对应的函数访问的类内成员是否已经初始化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇见一个有趣的问题。&lt;/p&gt;
&lt;p&gt;C++ 里面，在类的 constructor 当中使用 this 指针访问成员，是否是安全的？在哪些情况下安全？在哪些情况下不安全？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="this" scheme="https://liam.page/tags/this/"/>
    
      <category term="Constructor" scheme="https://liam.page/tags/Constructor/"/>
    
  </entry>
  
  <entry>
    <title>扩展版领口策略</title>
    <link href="https://liam.page/2021/03/16/the-extended-callar-strategy/"/>
    <id>https://liam.page/2021/03/16/the-extended-callar-strategy/</id>
    <published>2021-03-16T06:43:46.000Z</published>
    <updated>2021-04-21T13:48:50.292Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2021/03/15/price-of-option-and-the-collar-strategy/">前文</a>讨论了期权价格的决定因素并简单介绍了领口策略。</p><p>领口策略通过买入虚值看跌期权（后简称买入 PUT otm）并卖出虚值看涨期权（后简称卖出 CALL otm），在 CALL 有效期内放弃超额收益，在 PUT 有效期内控制风险。此篇我们在基础版领口策略的基础上进行一些扩展，以便能够让领口策略长期滚动起来，并持续获得收益/降低持仓成本。</p><blockquote><p>此篇文章介绍的策略，是我从 Ming Ma 先达处学到，而后加工整理的。感谢 Ming Ma 的无私分享和细心解读。</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基础版的领口策略的 PUT 和 CALL 的过期时间相同，这有一点不好。因为从本性来说，我们对下跌的担忧是长久的，对上涨的期待也是长久的。因此，对于固定行权价的保护性 PUT 来说，我们期待它的过期时间长；对于固定行权价的对冲性 CALL 来说，我们期待它过期时间短，以便能够及时根据市场行情作出调整。这促使我们在构建领口策略的时候，买入远期的 PUT，卖出相对短期的 CALL。</p><p>领口策略的本意，是利用卖出 CALL otm 的收入，抵消/降低买入 PUT otm 的成本。现在，我们打算买入远期 PUT otm。那么，它的价格就很难为短期 CALL otm 所抵消。在这种情况下，我们有两种选择。一是继续卖出更多的 CALL otm，二是选择也卖出一些 PUT otm。</p><p>若是继续卖出更多的 CALL otm，那么多出来的这部分 CALL，就会成为没有对应正股保护的敞口风险。构造领口策略是为了降低风险，因此，显然我们不会选择这种平白增加风险的行为。那么选择就很明朗了——卖出部分短期 PUT otm。</p><p>现在，我们的策略由以下部分组成：</p><ul><li>一份正股；</li><li>一份远期，紧跟正股成本价的 PUT otm；</li><li>卖出一份近期，价格稍高的 CALL otm；</li><li>卖出一份近期，价格稍低的 PUT otm。</li></ul><p>最理想的情况，是在卖出的两份近期 option 到期之前，正股价格波动没有击穿 CALL/PUT 的行权价格。在这种情况下，两份期权都不会被对家行权，我们白赚权利金。</p><p>但若</p><ul><li>在近期 CALL 到期之前，上涨击穿 CALL 的行权价，则我们持有的一份正股，会被 CALL 走；此时正股被迫平仓，远期 PUT 的保护就失去了意义。这种情况应当补仓。</li><li>或者，在近期 PUT 到期之前，下跌击穿 PUT 的行权价，则对家会 PUT 一份正股给我们；此时正股仓位高于远期 PUT 的保护，形成敞口风险。这种情况应当减仓。</li></ul><h2 id="补仓的策略"><a href="#补仓的策略" class="headerlink" title="补仓的策略"></a>补仓的策略</h2><p>无论是 CALL 还是 PUT 被击穿，恢复策略都涉及两个方面。一是正股，而是围绕正股当前价格的近期 PUT/CALL。我们先来讨论 CALL 被击穿时候，补仓的策略。</p><p>对于近期 PUT/CALL 来说。</p><p>考虑 PUT。如果 CALL 被提前行权（在到期日之前被行权，仅适用于美式期权），则 PUT 依然在履约期内。此时，由于 1) CALL 被击穿，正股价格相对卖出 PUT otm 时要高，以及 2) 时间的推移，此前我们卖出的 PUT 合约，价格会下跌，低于卖出时的价格。于是我们可以将它买回来。对于 PUT 来说，我们的权利金不会损失。</p><p>考虑 CALL。由于 CALL 被行权，合约结束，权利金完全落入我们的口袋。此时我们的权利金也不会损失。</p><p>因此，我们的结论是，我们应当：</p><ul><li>购回之前卖出的 PUT otm；</li><li>围绕正股当前价格，重新卖出近期的 PUT otm 和 CALL otm。</li></ul><p>对于正股来说，由于卖出的 CALL 被对家行权，我们此时手上没有正股。为了补仓，我们有两种选择。</p><ul><li>一是直接在高于刚刚被击穿的 CALL 行权价，直接购回一份正股。这种情况下，只要购回正股的价格与被击穿的行权价，价格差不超过两份权利金的收入，我们就没有吃亏。</li><li>二是，卖出一份行权价与被击穿的 CALL 的行权价相同的 PUT，并期待正股价格在履约期内跌破行权价，对家行权将正股 PUT 给你。这样操作的好处是，又可以赚一份权利金；但风险在于，如果股价一路上涨，则对家不会行权，我们手头没有正股，从而失去后续正股价格上涨的收益。</li></ul><p>考虑到我们购买远期 PUT 时，是为了在控制风险的情况下长期持有正股。<strong>在基本判断不发生变化的情况下</strong>，更好的选择应该是选择第一种方案：直接购入一份正股。</p><h2 id="减仓的策略"><a href="#减仓的策略" class="headerlink" title="减仓的策略"></a>减仓的策略</h2><p>接下来我们讨论减仓的策略。</p><p>同样地，对于近期 PUT/CALL 来说。</p><p>考虑 CALL。如果 PUT 被提前行权（在到期日之前被行权，仅适用于美式期权），则 CALL 依然在履约期内。此时，由于 1) PUT 被击穿，正股价格相对卖出 CALL otm 时要低，以及 2) 时间的推移，此前我们卖出的 CALL 合约，价格会下跌，低于卖出时的价格。于是我们可以将它买回来。对于 CALL 来说，我们的权利金不会损失。</p><p>考虑 PUT。由于 PUT 被行权，合约结束，权利金完全落入我们的口袋。此时我们的权利金也不会损失。</p><p>因此，我们的结论是，我们应当：</p><ul><li>购回之前卖出的 CALL otm；</li><li>围绕正股当前价格，重新卖出近期的 PUT otm 和 CALL otm。</li></ul><p>类似地，对于正股来说，由于卖出的 PUT 被对家行权，我们此时手上有两份正股。为了减仓，我们有两种选择。</p><ul><li>一是直接在低于刚刚被击穿的 PUT 行权价，直接卖出一份正股。（注意，此时手上还卖出了一份 CALL，所以只能卖出一份正股，不能两份全部卖出。）这种情况下，只要卖出正股的价格与被击穿的行权价，价格差不超过两份权利金的收入，我们就没有吃亏。</li><li>二是，卖出一份行权价与被击穿的 PUT 的行权价相同的 CALL，并期待正股价格在履约期内涨过行权价，对家行权将正股 CALL 走。这样操作的好处是，又可以赚一份权利金；但风险在于，如果股价一路下跌，则对家不会行权，我们手头有两份正股，从而需要承担额外的一份正股下跌带来的损失。</li></ul><p>考虑到我们购买远期 PUT 时，是为了在控制风险的情况下长期持有正股。<strong>在基本判断不发生变化的情况下</strong>，更好的选择应该是选择第二种方案：通过卖出 CALL，让对家主动行权，CALL 走我们手头额外的正股。</p><h2 id="风险的分析"><a href="#风险的分析" class="headerlink" title="风险的分析"></a>风险的分析</h2><p>在这个交易体系当中，存在的风险可以罗列如下。</p><ol><li>正股：下跌风险为远期 PUT 保护，在做好远期 PUT 过期的心理建设的情况下，相当于无风险。</li><li>远期 PUT：正股股价长期下跌，被迫行权远期 PUT，承担 otm 部分以及未被近期 option 权利金抵消的风险。</li><li>近期 CALL：正股股价暴涨，导致没有在击穿短期 CALL 后及时补仓，导致没有享受后续正股价格上涨的收益。</li><li>近期 PUT：正股股价暴跌，导致没有在击穿短期 PUT 后及时减仓，导致无远期 PUT 保护的敞口风险。</li></ol><p>可见，为避免这些风险，应用这一交易体系应当满足以下条件：</p><ol><li>正股股价长期看涨——公司基本面良好、正股股价处在低估区间；</li><li>正股股价波动幅度较小——公司体量相对较大。</li></ol><p>在满足这些条件的基础上，应用这一体系，可以在相当低的风险的情况下，获得可观的长期收益。并且，在这个过程中，操作者无需投入大量精力盯盘，只需在关键时间节点做少量操作即可。运作得好，可以以相当低的成本（甚至零成本）持有正股，从此享受股价上涨、分红带来的收益。</p><p>相对应地，这一系统，也不适和追求短期超额收益的投资风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2021/03/15/price-of-option-and-the-collar-strategy/&quot;&gt;前文&lt;/a&gt;讨论了期权价格的决定因素并简单介绍了领口策略。&lt;/p&gt;
&lt;p&gt;领口策略通过买入虚值看跌期权（后简称买入 PUT otm）并卖出虚值看涨期权（后简称卖出 CALL otm），在 CALL 有效期内放弃超额收益，在 PUT 有效期内控制风险。此篇我们在基础版领口策略的基础上进行一些扩展，以便能够让领口策略长期滚动起来，并持续获得收益/降低持仓成本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此篇文章介绍的策略，是我从 Ming Ma 先达处学到，而后加工整理的。感谢 Ming Ma 的无私分享和细心解读。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Collar Strategy" scheme="https://liam.page/tags/Collar-Strategy/"/>
    
  </entry>
  
  <entry>
    <title>期权价格与领口策略</title>
    <link href="https://liam.page/2021/03/15/price-of-option-and-the-collar-strategy/"/>
    <id>https://liam.page/2021/03/15/price-of-option-and-the-collar-strategy/</id>
    <published>2021-03-15T12:00:35.000Z</published>
    <updated>2021-04-21T13:48:50.292Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://liam.page/2019/11/24/option-and-hedge/">前作</a>简单讨论了期权，也提及了卖权价格变化的影响因素。不过，对于这些影响因素背后的原理并未深究。</p><p>此外，我们已经知道，合理利用期权可以对冲股票价格下跌的风险。但简单地买入卖权（long put options），也会对应增加持仓成本。</p><p>针对这两个话题，此篇做进一步讨论。</p><a id="more"></a><h2 id="期权的价格"><a href="#期权的价格" class="headerlink" title="期权的价格"></a>期权的价格</h2><p>要讨论期权的价格，就要搞清楚期权的本质究竟是什么。</p><p>可能你已经买过期权，或者打算买期权。那么，既然又买，就一定有卖。你有没有考虑过，究竟是谁在卖给你呢？以及，卖给你期权的人，究竟和你做了怎样一笔交易？</p><p>我们拿买权来说。假定你以 5 元的价格，购买了一份 3 个月后行权的看涨期权。期权的行权价是 100 元。显然，你之所以买这一期权，是有一定把握认为对应标的物的价格，在 3 个月后（内）会上涨超过 105 元（break-even price）。因为如此，你买入的看涨期权才会为你带来收益。相对应的，卖给你期权的那个人（虽然你不知道是谁），肯定认为 3 个月后（内），标的物的价格不会超过 100 元。因为这样一来，它就能稳赚这 5 元的期权权利金。</p><p>从这里出发，不难看出：期权的买卖双方，实际是在通过自己的认知，对标的物未来的价格进行判断，而后以期权合约做做媒介进行赌博。也就是说，期权实际是一种对赌。</p><p>既然是对赌，就涉及到概率（赌徒获胜的概率）和赔率（赌徒获胜的收益）。显然，赌徒获胜的概率越高，庄家设定的赔率就会越低。若不然，庄家肯定亏死了。在期权的语境里，期权的买方是赌徒，卖方是庄家。因此，对于买方来说，越容易赚钱的期权，其价格就越高。</p><p>因此，其他条件不变的情况下，不难有分析：</p><p>对于买权（call option）</p><ul><li>行权价格越高，正股价格上涨超过行权价的可能性越小，因此买权价格越低；——买权的内涵价值随行权价上升而减小</li><li>截止日期越近，正股价格上涨超过某个行权价需要的日均涨幅越大，因而可能性越小，因此买权价格越低；——期权的时间价值随到期日临近而衰减</li><li>标的物（预期）波动越大，正股价格上涨超过某个行权价格（哪怕只是一瞬间）的可能性越大，因而买权价格越高。</li></ul><p>对于卖权（put option）</p><ul><li>行权价格越高，正股价格下跌低于行权价的可能性越大，因此买权价格越高；——卖权的内涵价值随行权价上升而上升</li><li>截止日期越近，正股价格下跌低于某个行权价需要的日均跌幅越大，因而可能性越小，因此买权价格越低；——期权的时间价值随到期日临近而衰减</li><li>标的物（预期）波动越大，正股价格下跌低于某个行权价格（哪怕只是一瞬间）的可能性越大，因而买权价格越高。</li></ul><h2 id="领口策略（the-Collar-Strategy）"><a href="#领口策略（the-Collar-Strategy）" class="headerlink" title="领口策略（the Collar Strategy）"></a>领口策略（the Collar Strategy）</h2><p>市场行情不确定性高时，买股票是会有很大风险的。合理地利用期权，可以有效地对冲风险。当然，对冲风险的同时，不可避免地会让收益也有所缩减。这是因为，购买看跌期权以锁定亏损上限是有成本的。将标的物（比如正股）和期权看做一个整体时，计算收益时，应当把购买看跌期权的成本计算在内。比如你以 100 元的价格购入 1 股正股，然后以 2 元的价格购入行权价为 95 元的看跌期权。此时，你锁定了亏损上限，但同时拉高了持仓成本。此时你的持仓成本是买入股价与期权价格之和，即 102 元。</p><p>为了抵消因购入看跌期权带来的成本上升，很自然地，我们会想：要不我们卖点期权出去？显然，如果同样是卖出看跌期权是没意义的，所以，我们考虑卖出看涨期权。亦即，我们在买入正股的同时，买入一份虚值看跌期权（行权价比现价低的看跌期权），卖出一份虚值看涨期权（行权价比现价高的看涨期权）。其中看跌期权用来保护股价下跌，看涨期权则用来低消对冲成本。这种运用期权的策略，就是领口策略。</p><p>领口策略如何运用呢？我们来看一个例子：</p><blockquote><p>假定现在 01/01 正股价格是 100 元。此时，买入正股 1 股；卖出行权价 105 的 call（04/01），收入 20 元；买入行权价 95 的 put（04/01），成本 17.5 元。这样一来，实际成本 97.5 元（100 - 20 + 17.5）。</p><p>04/01，期权到期。</p><ul><li>若正股价格大于 105，卖出的 call 被行权，收入 105 元。净赚 7.5 元。</li><li>若正股价格小于 95，对买入的 put 行权，收入 95 元。净亏 2.5 元。</li><li>若正股价格位于 95 和 105 之间，期权失效，但持仓成本被策略从 100 拉低到 97.5 元，纸面收益（paper profit）是当前股价与 97.5 元之间的差值。</li></ul></blockquote><p>在这样的场景当中，如果正股价格疯涨，那么由于卖出的看涨期权被对家行权，相当于放弃了正股价格在 105 元之上的收益；如果正股价格暴跌，你可以选择行权买入的看跌期权，锁住最大亏损。因此，领口策略最适用的场景是：</p><ul><li>操作人<strong>不追求暴涨带来的超额收益</strong>（因为超额收益被 call option 截去）；</li><li>操作人<strong>长期看好标的价格上涨</strong>（因为如果标的物价格持续下跌，持续触发 put option，终将产生可观亏损）。</li></ul><p>因此，在上例中，若你是操作人，且依然长期看好标的物，那么你应该：</p><ul><li>如果期权被行权，你的正股被卖出，你应该重新建仓并建立领口策略；</li><li>如果期权没有被行权，你应该围绕最新的价格，继续建立领口策略。</li></ul><p>这样往复操作下去，如果通过合理的操作，最终将综合成本降低到看跌期权的行权价之下；那么，实际上在期权到期之前，策略就是稳赚不赔的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://liam.page/2019/11/24/option-and-hedge/&quot;&gt;前作&lt;/a&gt;简单讨论了期权，也提及了卖权价格变化的影响因素。不过，对于这些影响因素背后的原理并未深究。&lt;/p&gt;
&lt;p&gt;此外，我们已经知道，合理利用期权可以对冲股票价格下跌的风险。但简单地买入卖权（long put options），也会对应增加持仓成本。&lt;/p&gt;
&lt;p&gt;针对这两个话题，此篇做进一步讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Option" scheme="https://liam.page/tags/Option/"/>
    
      <category term="Collar Strategy" scheme="https://liam.page/tags/Collar-Strategy/"/>
    
  </entry>
  
  <entry>
    <title>Dalio 经济学 ②：中央银行与货币政策</title>
    <link href="https://liam.page/2021/02/24/central-bank-and-monetary-policy/"/>
    <id>https://liam.page/2021/02/24/central-bank-and-monetary-policy/</id>
    <published>2021-02-24T15:18:10.000Z</published>
    <updated>2021-02-24T15:20:57.030Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Dalio 经济学的第二篇，我们来谈一谈中央银行和货币政策。</p><a id="more"></a><h2 id="中央银行"><a href="#中央银行" class="headerlink" title="中央银行"></a>中央银行</h2><p>在介绍中央银行之前，我们可以先复习一下各个主要经济体的中央银行。</p><ul><li>中国：中国人民银行<ul><li>香港：香港金融管理局</li><li>澳门：澳门金融管理局</li><li>台湾：中华民国中央银行</li></ul></li><li>美国：美国联邦储备系统（美联储）</li><li>欧元区：欧洲中央银行<ul><li>德国：德意志联邦银行</li><li>法国：法兰西银行</li></ul></li><li>英国：英格兰银行</li></ul><p>如果对这些主要经济体的中央银行至少有些熟悉，那么便不难了解中央银行的主要职责，即制定和执行货币政策：</p><ul><li>（直接或间接）负责发行经济体中流通的法定货币；</li><li>（直接或间接）调节经济体中的利率；</li><li>（直接或间接）控制汇率。</li></ul><p>那么央行是怎样做到这些的呢？这就涉及到央行的资产负债表。</p><h2 id="央行的资产与负债"><a href="#央行的资产与负债" class="headerlink" title="央行的资产与负债"></a>央行的资产与负债</h2><h3 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h3><p>央行的资产大约有以下种类：</p><ul><li>货币储备<ul><li>黄金</li><li>外汇</li></ul></li><li>对商业银行的债权（应收款项）</li><li>对公共财政的债权（购买国债、地方债）</li><li>其他资产（如有价证券）</li></ul><p>央行的负债大约有以下种类：</p><ul><li>流通中的现金</li><li>外国机构存款</li><li>商业银行转账账户存款（包含，比如说，最低准备金）</li><li>国家存款</li><li>其他负债</li></ul><p>这里有一个很有意思的点，即流通中的货币现金是发行该种货币的央行的负债。这是因为，货币实际上是发行者给出的一种承诺：你可以持有货币，到我这里兑换点什么东西出去（通常是货币储备之类的其他等价物，例如黄金）。于是，在这个意义上，持有货币的人，就是对应央行的债权人。</p><h3 id="超发货币"><a href="#超发货币" class="headerlink" title="超发货币"></a>超发货币</h3><p>货币是央行发行的，并且央行「承诺」货币可以兑换某些东西。于是就引出一个相当自然的问题：但如果央行超发货币（发行货币的量，超过实际可以兑换东西的量），会发生什么呢？</p><p>这里首先就要注意，并非所有货币，都是对应央行的负债。只有流通的那部分，才是央行的负债。如果央行印了很多钞票，但是没有投入市场。那么就没人能用这部分货币到央行处兑换些什么。于是这些未流通的货币，显然不是央行的负债。</p><p>那么，央行发行的货币，要怎样投入市场呢？答案是信贷。注意此时的央行和<a href="/2021/02/20/expenditure-receipt-credit/">前作</a>当中提到的那些「有很多自己暂时用不到的钱的贷款人」没什么两样。于是，央行可以贷款给中央政府或者商业银行，或者说央行可以购买中央政府的债务（即国债）或者商业银行的债务（或者有价证券），将货币经由财政或是商业银行经过进一步的投资或是信贷，投入流通市场。在这个过程中，央行的资产负债表的两端，分别增加了资产（某种债务/有价证券）和负债（流通中的现金）。显然，央行的资产负债表变得更长了。因此，我们将这个过程称为<strong>扩表</strong>或者是<strong>债务货币化</strong>。</p><p>至此，央行超发的货币就进入了流通市场。这是<strong>突然发生</strong>的，相对而言，市场能提供的的商品、服务、金融资产的数量，并没有变多。因此，一定有什么东西会涨价。具体而言，超发的货币流向哪里，哪里就会涨价。比如，流向房地产市场（通过给房企、购房者贷款），那么房地产市场就会火爆；流向证券市场（通过融资，比如说），股市就会大涨；流向实体经济，假定实体经济并没有相应增长的情况下，商品和服务的价格就会上升，也就是形成通货膨胀。</p><h3 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h3><p>由于央行可以购买商业银行的债券（以贷款给商业银行），所以央行可能成为信贷链条的最终购买者。于是，央行贷款给商业银行的利率（即贴现率），会成为制约下游所有信贷利率的下限利率。——如果低于这个下限利率，债权人就要亏钱（这还没有考虑通胀）。有鉴于此，央行能够轻易地控制某些短期利率，从而影响股市、债券市场、房地产和其他利率。</p><h3 id="汇率"><a href="#汇率" class="headerlink" title="汇率"></a>汇率</h3><p>当央行大量印钞而后扩表时，大量相应货币被投入市场，于是商品、服务、金融资产的价格被推高。站在货币以及以该种货币计价的债券的持有者看来，货币的购买力降低，可能贬值。货币的持有者关心的是货币购买力在将来的变化。通货膨胀以及汇率下跌会导致货币购买力下降。反过来，以该种货币计价的债务利率的上升，则会提升货币购买力。为了保值（保护购买力），人们会倾向于将货币（称为本币）兑换成没有超发的外币。当这种倾向形成规模，</p><ul><li>在外汇市场上出现大量卖出本币的现象，于是本币容易出现贬值；</li><li>央行为了保卫汇率，可能消耗外汇储备（央行自身的资产）购入本币（央行自身的负债），导致外汇储备下降。</li></ul><p>这二者反过来，又会加剧人们兑换外币的倾向。于是形成不断自我加强的循环，导致本币贬值。因此我们说，<strong>在其它条件不变的情况下，央行大量印钞将拉低汇率</strong>。</p><h2 id="货币政策"><a href="#货币政策" class="headerlink" title="货币政策"></a>货币政策</h2><p>央行宽松的货币政策（扩表、降息）会直接导致两方面：</p><ul><li>有些人（贷款人）手里闲钱变多；</li><li>有些人（借款人）负债成本下降。</li></ul><p>于是，市场中倾向于产生更多的信贷。这些信贷会推升金融资产的价格，从而使借款人的信用资质看上去变得更好，从而更容易获得贷款。于是形成不断自我加强的循环，使得信贷变得越来越多。</p><p>央行不希望这种现象发生。因为没有生产力提升做背书时，金融资产价格的不断攀升是不可持续的，泡沫终将破裂。未免与此，在到了一定程度时，央行会缩紧自身货币政策。</p><p>央行紧缩的货币政策（加息），将降低新的信贷的产生，因为资产价格下降而借款人信誉变差，并且负债成本上升。于是形成不断自我加强的循环，使得信贷变得越来越少。</p><p>因为信贷自身的周期性，央行必须周期性地调整货币政策，控制社会上的信贷总量。于此，我们又见到了<strong>周期</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 Dalio 经济学的第二篇，我们来谈一谈中央银行和货币政策。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Dalio" scheme="https://liam.page/tags/Dalio/"/>
    
      <category term="Cycle" scheme="https://liam.page/tags/Cycle/"/>
    
      <category term="Central Bank" scheme="https://liam.page/tags/Central-Bank/"/>
    
      <category term="Monetary Policy" scheme="https://liam.page/tags/Monetary-Policy/"/>
    
      <category term="Interest Rate" scheme="https://liam.page/tags/Interest-Rate/"/>
    
      <category term="Exchange Rate" scheme="https://liam.page/tags/Exchange-Rate/"/>
    
  </entry>
  
  <entry>
    <title>Dalio 经济学 ①：支出、收入和信贷</title>
    <link href="https://liam.page/2021/02/20/expenditure-receipt-credit/"/>
    <id>https://liam.page/2021/02/20/expenditure-receipt-credit/</id>
    <published>2021-02-20T15:22:25.000Z</published>
    <updated>2021-02-21T09:05:00.063Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新的系列，讨论桥水基金创始人 Ray Dalio 的经济学理论。这些内容是我在读 Dalio 的书《A Template for Understanding BIG DEBT CRISES》之后，结合书中内容和自我思考总结出来的内容。</p><a id="more"></a><h2 id="支出和收入"><a href="#支出和收入" class="headerlink" title="支出和收入"></a>支出和收入</h2><p>整个经济是由无数的交易组成的。</p><p>交易涉及到的双方，一方支出购买力，收获标的物；另一方付出标的物，收获另一方支出的购买力。因此我们可以得到几个简单的结论：</p><ul><li>一个人的支出是另一个人的收入。</li><li>如果经济体中，大多数人减少支出，那么整体的收入就会减少，从而<ul><li>降低大家的生产积极性，导致通缩预期。</li></ul></li><li>如果经济体中，大多数人增加支出，那么整体的收入就会增加。</li></ul><p>交易涉及到的标的物分成三类：1. 商品，2. 服务，3. 金融资产。考虑到持有金融资产的人，是在将来能够变现，化为购买力；因此，金融资产的本质是将来的购买力。</p><p>在交易中，标的物的另一面，是起到交易媒介作用的货币或者信贷。货币很好理解，于是重点在信贷。</p><h2 id="信贷"><a href="#信贷" class="headerlink" title="信贷"></a>信贷</h2><p>信贷的双方，贷款人评估借款人的信用，使用自己暂时用不到的钱，购买债务资产，以期将来能获得利息收入；借款人凭借自己的信用，以将来提供利息汇报的代价，「购买」贷款人现金当下的使用权。</p><p>从贷款人的角度，他将自己暂时不用的钱借出，得到了将来的回报。如果相应货币发生通胀，那么将来的回报在购买力上会贬值，贷款人就会承受损失。不过，利息收入能对这种损失进行对冲。只要利息收入足够大，因通胀带来的损失就能被弥补。</p><p>从借款人的角度，他用未来的收入「购买」现金当下的使用权。这种行为看似是向他人借钱，实际是对自己的未来有良好预期，向未来的自己借钱。</p><p>如果借款人将通过信贷得来的现金用于扩大再生产，提高自己的生产效率，那么借款人将来能获得更多的收入。另一方面，贷款人也能确信在将来能够收回贷款。这种情况下，本不会流通的钱（贷款人暂时不用的钱）进入市场流通，并扩大了经济体总的生产力。于是，这是一件好事——贷款人、借款人、经济体加在一起赢了三次。</p><p>如果借款人将通过信贷得来的先进用于购买商品或服务；由于一个人的支出是另一个人的收入，提供商品或服务的人得到更多的收入，可用于扩大再生产，提高经济体总的生产力。只要借款人将来能够偿还债务，那么，这也是一件好事。从经济利益的角度来说，贷款人、经济体加在一起赢了两次；借款人获得商品或服务，也有所收获。</p><p>糟糕的情况在于，如果借款人没有将借贷得到的现金直接或间接地投入扩大再生产，且最终无力偿还债务，那就成了「全输」的局面。当这种问题大量发生，就会形成债务危机。</p><h2 id="信贷天然产生周期"><a href="#信贷天然产生周期" class="headerlink" title="信贷天然产生周期"></a>信贷天然产生周期</h2><p>从借款人的角度来说，在信贷凭空产生的那一瞬间，借款人获得了在当前时间超出自身收入水平的消费能力。但也意味着，在未来的一段时间，借款人必须控制自己的消费水平低于收入水平，以便偿还债务。因为借贷，借款人的消费能力的起伏，自然就构成了一个周期。</p><p>将经济体中所有的借款人当做一个整体，那么，在周期的早些阶段，大家的购买力都很强，于是：</p><ul><li>一个人的支出是另一个人的收入，商品的生产者和服务的提供者的收入增加，倾向于扩大再生产；</li><li>相对有限的金融资产涌入相对更多的资金（其实很大程度是信贷），金融资产价格被推高；</li><li>上述过程让借款人的「信用水平」提升，于是能借到更多的资金，也倾向于接入更多的资金，形成自我增强的正循环。</li></ul><p>但若没有生产力水平的提升，这种正循环是不可持续的。随着债务陆续到期、偿债负担日益增加，整个经济体必然进入周期的后半阶段。在周期的后半阶段，大家的购买力都减弱，于是：</p><ul><li>一个人的支出是另一个人的收入，商品的生产者和服务的提供者的收入减少，倾向于减少生产；</li><li>人们倾向于卖出金融资产，获得现金以偿债，这使得金融资产价格被拉低；</li><li>上述过程让借款人的「信用水平」降低，于是愈发难以接到足够资金，购买力水平进一步下降，形成自我增强的负循环。</li></ul><p>周期的前半部分和后半部分，都会形成自我加强的循环。若不加以控制，最终必然导致债务危机。央行和中央政府的责任之一，就是要运用自身的货币政策和财政政策，使得经济体总体的债务水平增长的幅度，不会显著偏离整体生产力水平的提升幅度。</p><p>这就引出了央行和中央政府的调控政策相关问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个新的系列，讨论桥水基金创始人 Ray Dalio 的经济学理论。这些内容是我在读 Dalio 的书《A Template for Understanding BIG DEBT CRISES》之后，结合书中内容和自我思考总结出来的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Economics and Investment" scheme="https://liam.page/categories/Economics-and-Investment/"/>
    
    
      <category term="Dalio" scheme="https://liam.page/tags/Dalio/"/>
    
      <category term="Expenditure" scheme="https://liam.page/tags/Expenditure/"/>
    
      <category term="Receipt" scheme="https://liam.page/tags/Receipt/"/>
    
      <category term="Credit" scheme="https://liam.page/tags/Credit/"/>
    
      <category term="Cycle" scheme="https://liam.page/tags/Cycle/"/>
    
  </entry>
  
  <entry>
    <title>设计一个线程安全的数据重载器</title>
    <link href="https://liam.page/2021/01/03/design-a-thread-safe-data-reloader-in-cxx/"/>
    <id>https://liam.page/2021/01/03/design-a-thread-safe-data-reloader-in-cxx/</id>
    <published>2021-01-03T01:35:49.000Z</published>
    <updated>2021-04-22T14:22:45.562Z</updated>
    
    <content type="html"><![CDATA[<p>实际工程中，可能会遇见这样的场景：</p><p>一个词典，在 C++ 里实现为一个 <code>class</code>。它的生命周期从进程启动开始到进程杀死结束。这个词典很大，所以在多线程工作的时候，希望在全局共享一份。</p><p>现在的问题是，进程可能持续跑很长时间，比如跑几个月。在进程执行过程中，这个词典可能会更新。于是我需要重新载入词典。要求线程安全并且高效地做这个重新载入的工作。</p><p>今天我们来设计一下，要怎样实现它。</p><a id="more"></a><h2 id="初步讨论"><a href="#初步讨论" class="headerlink" title="初步讨论"></a>初步讨论</h2><p>比较显然的是，这一功能将代码分成了相对独立的两个部分：词典和重载器。词典负责数据的管理，并提供数据查询的功能。重载器负责按照一定规则，触发重载动作，以及负责提供安全的词典访问机制。</p><p>为通用计，我们希望重载器能够管理多种不同的词典。这些词典可能管理不同的数据类型、格式，也可能提供不同的访问接口。就后者而言，这意味着不同词典类可能提供了不同的查询函数签名。</p><p>为解决这个问题，考虑到重载器只需负责触发重载动作，而不需关心查询接口，在 C++ 里大体有两种比较成熟的思路：</p><ul><li>实现一个基类，其名为 <code>Reloadable</code>，并定义一个名为 <code>load</code> 的纯虚函数作为接口。所有词典继承 <code>Reloadable</code>，并实现该接口，而后作为模板类 <code>Reloader</code> 的模板参数，传递给重载器，重载器调用 <code>load</code> 接口。</li><li>无需基类，将词典类多种多样的读取接口，封装成各自的可调用对象（利用 <code>std::bind</code> 之类的工具），而后作为回调函数传递给 <code>Reloader</code>。</li></ul><p>前一种方式是面向对象和模板思路，后一种方式是函数式的思路。两种方式的共同特点，是都可以在少量修改的情况下，应用于已有的词典类。相较而言，后一种方式完全不用修改已有的词典类本身，提供了更大的自由度。</p><p>但在工程中，这种自由度累积起来，往往会泛滥成灾。因此我个人更倾向于使用第一个方案。</p><p>至此，我们需要设计一个 <code>Reloadable</code> 和一个 <code>Reloader</code> 类，来实现这个需求。</p><h2 id="Reloadable"><a href="#Reloadable" class="headerlink" title="Reloadable"></a><code>Reloadable</code></h2><p>按讨论，<code>Reloadable</code> 应该是一个虚基类，其有一个名为 <code>load</code> 的纯虚函数作为接口，负责读入数据。我们将其定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reloadable</span> &#123;</span></span><br><span class="line">  Reloadable() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~Reloadable() = <span class="keyword">default</span>;  <span class="comment">// 1.</span></span><br><span class="line"></span><br><span class="line">  Reloadable(<span class="keyword">const</span> Reloadable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.a.</span></span><br><span class="line">  Reloadable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Reloadable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.b.</span></span><br><span class="line"></span><br><span class="line">  Reloadable(Reloadable&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 3.a.</span></span><br><span class="line">  Reloadable&amp; <span class="keyword">operator</span>=(Reloadable&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 3.b.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>= <span class="number">0</span>;  <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li>我们将析构函数声明为 <code>virtual</code>，是因为显然 <code>Reloadable</code> 会是一个基类。为避免子类析构不完全造成内存泄露，我们都需要将基类的析构函数声明为虚函数。</li><li>由于词典数据往往很大，而又在多线程中共享。那么显然对数据的拷贝是不必要的。于是我们将拷贝构造和拷贝赋值都声明为 <code>delete</code>。</li><li>与 (2) 对应，移动操作是允许的。</li><li>我们将 <code>load</code> 接口声明为纯虚的，它留待子类实现。入参 <code>path</code> 是一个字符串，它通常会是一个路径，指向数据本身，或是词典的配置文件。</li></ol><h2 id="Reloader"><a href="#Reloader" class="headerlink" title="Reloader"></a><code>Reloader</code></h2><p>按讨论，<code>Reloader</code> 应该是一个虚基类模板。它有一个模板参数 <code>Payload</code>，是 <code>Reloadable</code> 的子类。而后提供几个关键接口：</p><ul><li><code>init</code>：负责初始化重载器。由于重载器会在多线程共享，所以初始化应该只执行一次。</li><li><code>inited</code>：负责观察重载器是否已初始化成功。</li><li><code>get</code>：负责返回 <code>Payload</code>，供外部使用。</li><li><code>terminate</code>：负责终止重载器，通常在进程终止时调用它。</li></ul><p>于是我们可以设计 <code>Reloader</code> 的大体框架。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload,</span><br><span class="line">          <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_base_of&lt;Reloadable, Payload&gt;::value, <span class="keyword">bool</span>&gt; = <span class="literal">true</span>&gt;  <span class="comment">// 4.</span></span><br><span class="line">class Reloader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">payload_t</span> = Payload;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">ptr_t</span> = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">payload_t</span>&gt;;  <span class="comment">// 1.a.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Reloader() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~Reloader() = <span class="keyword">default</span>;  <span class="comment">// 2.a.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Reloader(<span class="keyword">const</span> Reloader&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.b.</span></span><br><span class="line">  Reloader&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Reloader&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 2.c.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 3.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// observers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ptr_t</span> get() <span class="keyword">const</span>;  <span class="comment">// 1.b.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li><code>get</code> 接口的返回类型是 <code>Payload</code> 的智能指针。此处用智能指针，有两个考虑。一是避免值语义，使用引用语义。这样避免了数据的拷贝（实际上 <code>Payload</code> 已经禁止了拷贝，想用值语义必然报错）。二是管理 <code>Payload</code> 的生命周期，避免使用裸指针时，外部通过 <code>get</code> 拿到数据，却为 <code>reload</code> 析构，造成野指针。</li><li>基于类似的理由，我们将 <code>Reloader</code> 的析构函数声明为 <code>virtual</code>，将拷贝动作声明为 <code>delete</code>。</li><li>和 <code>init</code> 不同，<code>terminate</code> 接口被声明为纯虚。这是因为，适应不同的重载方式，其 <code>init</code> 都承担了相同的指责：第一次载入数据；而 <code>terminate</code> 则依据重载方式会有不同的写法。</li><li>这里 <code>std::enable_if_t</code>，强制保证了模板参数 <code>Payload</code> 是 <code>Reloadable</code>。这保证了 <code>Payload</code> 一定有符合规范的 <code>load</code> 接口。</li></ol><h3 id="inited"><a href="#inited" class="headerlink" title="inited"></a><code>inited</code></h3><p>我们首先考虑观察器 <code>inited</code>。重载器是否初始化，这个状态对于外部，有三种：</p><ul><li>未初始化</li><li>初始化中</li><li>已初始化</li></ul><p>当然，可能还有第四种：初始化失败。我们可将其归结于「未初始化」当中。</p><p>虽有三种状态，但对于外部来说，有意义的只有「是/否」。于是，我们可用一原子变量，来维护初始化状态。于是我们有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reloader</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> inited_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// observers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inited_.load();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><p>显然，<code>Reloader</code> 应该有一个成员，保存着由其管理的数据的智能指针。当外部调用 <code>get</code> 接口时，我们根据初始化状态，来判断如何返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reloader</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mtx_;  <span class="comment">// 1.a.</span></span><br><span class="line">  <span class="keyword">ptr_t</span> payload_;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// observers</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">ptr_t</span> get() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inited()) &#123;  <span class="comment">// 2.</span></span><br><span class="line">      <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lk(mtx_);  <span class="comment">// 1.b.</span></span><br><span class="line">      <span class="keyword">return</span> payload_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li>我们用一个读写锁（共享互斥量）来保护智能指针 <code>payload_</code>。这是因为，虽然 <code>std::shared_ptr</code> 当中的引用计数是原子的，但是 <code>std::shared_ptr</code> 本身并无线程安全保证。考虑到我们可能在多线程中同时读写 <code>payload_</code>，因此必须要加锁。此处细节，可参考<a href="https://blog.csdn.net/Solstice/article/details/8547547" target="_blank" rel="noopener">陈硕的雄文</a>。</li><li>这里是对 <code>Reloader</code> 状态的判断。若未初始化，则返回空指针。</li></ol><h3 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h3><p>有了这些铺垫，我们可以来实现修改器 <code>init</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Payload&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reloader</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::once_flag init_flag_;  <span class="comment">// 1.a.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> path_;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(init_flag_, [&amp;]() -&gt; <span class="keyword">void</span> &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;path(path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (reload()) &#123;  <span class="comment">// 2.a.</span></span><br><span class="line">        launch();  <span class="comment">// 3.a.</span></span><br><span class="line">        inited_.store(<span class="literal">true</span>);  <span class="comment">//4.a.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> inited();  <span class="comment">// 4.b.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:  <span class="comment">// modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;  <span class="comment">// 2.b.</span></span><br><span class="line">    <span class="keyword">ptr_t</span> tmp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">payload_t</span>&gt;();  <span class="comment">// 5.a.</span></span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;load(path_)) &#123;  <span class="comment">// 5.b.</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;shared_mutex&gt; lk(mtx_);  <span class="comment">// 6.</span></span><br><span class="line">        payload_.swap(tmp);  <span class="comment">// 7.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    path_ = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 3.b.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，</p><ol><li>为保证 <code>init</code> 只执行一次，我们使用 C++ 标准中提供的 <code>std::once_flag</code> 和 <code>std::call_once</code>。</li><li><code>reload</code> 接口如其名，每次重载器触发重载动作时，都应调用它。<code>init</code> 实际是第一次重载，当然也会调用它。</li><li><code>launch</code> 是一个纯虚函数，它由子类模板实现。<code>launch</code> 负责初始化重载器的一些细节工作，以便在进程声明周期中循环/监视文件变动，触发重载。</li><li>维护 <code>inited_</code> 原子变量，与 <code>inited</code> 接口遥相呼应。</li><li>重载时，为避免影响正在对外提供服务的 <code>payload_</code> 指针，我们通过临时指针来载入数据。</li><li>若临时指针载入数据成功，我们在读写锁（共享互斥量）的「写入状态」的保护下，更新 <code>payload_</code> 的值。</li><li>这里使用 <code>payload_.swap(tmp)</code> 而非 <code>payload_ = std::move(tmp)</code> 的原因在于，后者会导致立即析构 <code>payload_</code> 先前指向的对象。考虑到此时尚在写入锁保护下，而析构词典对象可能非常耗时，这种做法是不明智的。使用 <code>swap</code> 延迟析构旧对象（在 <code>return</code> 处，析构 <code>tmp</code> 时），是更好的选择。</li></ol><p>至此，<code>Reloader</code> 的主要接口，我们就已实现完备。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在现有的 <code>Reloadable</code> 和 <code>Reloader</code> 的基础上，我们可借助<a href="/2020/10/14/implement-a-timed-looper-in-cxx/">前文提到的时间循环器</a>来实现一个基于倒计时轮询的重载器；又可借助<a href="/2020/10/27/implement-a-singleton-class-template-in-cxx/">前文提到的单例模式</a>，让重载器于多线程共享。另附一个<a href="https://github.com/Liam0205/data-reloader" target="_blank" rel="noopener">仓库</a>，供来者学习参考。</p><h2 id="对不同意见的回复"><a href="#对不同意见的回复" class="headerlink" title="对不同意见的回复"></a>对不同意见的回复</h2><p>文章出来已经收到了一些反对意见。此处做一些回复。</p><h3 id="Reloadable-不是必须的，只需实现相同的接口即可。"><a href="#Reloadable-不是必须的，只需实现相同的接口即可。" class="headerlink" title="Reloadable 不是必须的，只需实现相同的接口即可。"></a><code>Reloadable</code> 不是必须的，只需实现相同的接口即可。</h3><p>诚然，若能保证所有用到 <code>Reloader</code> 的类，都实现了相同的接口，那么 <code>Reloadable</code> 及对应的 <code>std::enable_if_t</code> 可以去掉。但在实际工程中，这是一个相当高的要求，通常很难达到。这是因为，很可能在实现 <code>Reloader</code> 类模板时，代码库当中已有不少词典、模型类。这些 legacy codes 可能并不遵循现下定义的标准接口。若要使它们为 <code>Reloader</code> 所管理，则需要细致地修改，而后祈祷编译不出错。而若是使它们继承 <code>Reloadable</code>，则编译器会告诉你哪些词典/模型类还未正确修改。——编译器要么提示你，尚有纯虚函数未实现而无法实例化；要么提醒你 <code>Reloader</code> 的 <code>Payload</code> 类并非由 <code>Reloadable</code> 派生而得。</p><p>退一步说，即使能够通过口头/文档约束，达到接口统一的要求；那么，既然你已经在代码上约束大家实现 <code>load</code> 接口了，那么交给编译器去用 <code>std::enable_if_t</code> 做一次校验岂非更好？</p><p>因此，我们倾向于保留 <code>Reloadable</code> 及相应的 <code>std::enable_if_t</code> 之设计。</p><h3 id="在-Reloader-类当中，实现一个-lookup-接口，避免通过-get-接口返回词典类，是否更好？"><a href="#在-Reloader-类当中，实现一个-lookup-接口，避免通过-get-接口返回词典类，是否更好？" class="headerlink" title="在 Reloader 类当中，实现一个 lookup 接口，避免通过 get 接口返回词典类，是否更好？"></a>在 <code>Reloader</code> 类当中，实现一个 <code>lookup</code> 接口，避免通过 <code>get</code> 接口返回词典类，是否更好？</h3><p>若能约束所有词典类，都有一个统一的 <code>lookup</code> 接口，那这样做自然可以。但 <code>Reloader</code> 并非单纯针对词典类设计，例如带有 <code>predict</code> 接口的模型类，也能为 <code>Reloader</code> 所管理。讲到底，<code>Reloader</code> 只是为管理进程运行时可能需要重载的资源而设计的，对于资源是什么，<code>Reloader</code> 本身并不关心。</p><p>即便 <code>Reloader</code> 仅仅只为词典设计，这样封装接口也有至少三个劣势。</p><ul><li>基于与前一问题类似的理由，对于 legacy codes 的修改，会比较麻烦。</li><li>过早地约束了词典可用的接口，而忽略了词典的多样性。于是在将来的使用中，新的词典（比如涉及到二段查询的词典）可能无法轻易套用 <code>Reloader</code>。</li><li>在单次请求中，我们希望对词典的多次查询的结果稳定。但在 <code>Reloader&lt;Payload&gt;::lookup()</code> 当中，我们无法保证这一点。因为在单次请求过程中，可能触发了 <code>reload</code> 动作，于是相邻两次查询时，词典内容可能已经发生变化，造成对业务不可知的影响。</li></ul><p>反过来讲，通过对内部智能指针加锁，返回只能指针的拷贝，则基本避免了这种影响。</p><ul><li>legacy codes 只需 <code>sed</code> 替换即可。</li><li>不约束词典可用接口。</li><li>通过拷贝传递出去的智能指针，hook 住词典内容；即便在使用过程中触发 <code>reload</code> 动作，词典内容也不会提前析构，保证结果统一性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际工程中，可能会遇见这样的场景：&lt;/p&gt;
&lt;p&gt;一个词典，在 C++ 里实现为一个 &lt;code&gt;class&lt;/code&gt;。它的生命周期从进程启动开始到进程杀死结束。这个词典很大，所以在多线程工作的时候，希望在全局共享一份。&lt;/p&gt;
&lt;p&gt;现在的问题是，进程可能持续跑很长时间，比如跑几个月。在进程执行过程中，这个词典可能会更新。于是我需要重新载入词典。要求线程安全并且高效地做这个重新载入的工作。&lt;/p&gt;
&lt;p&gt;今天我们来设计一下，要怎样实现它。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Thread" scheme="https://liam.page/tags/Thread/"/>
    
      <category term="Thread-safe" scheme="https://liam.page/tags/Thread-safe/"/>
    
      <category term="Data" scheme="https://liam.page/tags/Data/"/>
    
      <category term="Dict" scheme="https://liam.page/tags/Dict/"/>
    
      <category term="Reloader" scheme="https://liam.page/tags/Reloader/"/>
    
  </entry>
  
  <entry>
    <title>让 Vim 在保存文件时自动格式化代码</title>
    <link href="https://liam.page/2020/11/04/Vim-auto-format-codes-on-save/"/>
    <id>https://liam.page/2020/11/04/Vim-auto-format-codes-on-save/</id>
    <published>2020-11-04T02:45:15.000Z</published>
    <updated>2021-01-02T07:32:18.202Z</updated>
    
    <content type="html"><![CDATA[<p>写代码时，遵循一定的代码风格是很有必要的。对于这种机械性的工作，我们的主张是要寻找自动化的解决方案。</p><p>对于 Vim 和 C++ 的组合，这里推荐以下搭配，并辅以适当配置：</p><ul><li><code>clang-format</code></li><li><a href="https://github.com/Chiel92/vim-autoformat" target="_blank" rel="noopener"><code>vim-autoformat</code> 插件</a></li></ul><a id="more"></a><p>配置分为两部分。一是实现在保存文件时自动格式化代码；二是实现在 visual 模式下格式化部分代码。</p><figure class="highlight vim"><figcaption><span>在保存文件时自动格式化代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">c</span>,cpp <span class="keyword">autocmd</span> BufWritePre * :Autoformat</span><br></pre></td></tr></table></figure><p>这里对 C 和 C++ 代码，在保存文件之前，自动执行 <code>:Autoformat</code>，以便使用 <code>vim-autoformat</code> 插件调用 <code>clang-format</code> 格式化代码。</p><figure class="highlight vim"><figcaption><span>在 visual 模式下格式化部分代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" autoformat</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>ff :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"file"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>ff :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"file"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>gf :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"Google"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>gf :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"Google"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cf</span> :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"Chromium"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">cf</span> :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"Chromium"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">lf</span> :<span class="keyword">call</span> FormatCode(<span class="string">""</span>, <span class="string">"LLVM"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">lf</span> :<span class="keyword">call</span> FormatCode(<span class="built_in">visualmode</span>(), <span class="string">"LLVM"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line">func! FormatCode(exe_mode, style) <span class="built_in">range</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">a:exe_mode</span> == <span class="string">""</span></span><br><span class="line">    <span class="keyword">let</span> firstline_no = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> lastline_no = <span class="built_in">line</span>(<span class="string">"$"</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> firstline_no = <span class="variable">a:firstline</span></span><br><span class="line">    <span class="keyword">let</span> lastline_no = <span class="variable">a:lastline</span></span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">l:save_formatdef</span> = <span class="variable">g:formatdef_clangformat</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">l:tmpa</span> = <span class="keyword">join</span>([<span class="string">"clang-format --lines="</span>, firstline_no, <span class="string">":"</span>, lastline_no], <span class="string">""</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">g:formatdef_clangformat</span> = <span class="string">"'"</span> . <span class="variable">l:tmpa</span> . <span class="string">" --assume-filename=' . bufname('%') . ' -style="</span> . <span class="variable">a:style</span> . <span class="string">"'"</span></span><br><span class="line">  <span class="keyword">let</span> formatcommand = <span class="string">":Autoformat"</span></span><br><span class="line">  exec formatcommand</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">g:formatdef_clangformat</span> = <span class="variable">l:save_formatdef</span></span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure><p>这里利用 range 函数，根据调用时的所在的模式的不同，格式化整个文件，或者是在 Visual 模式下格式化选中的行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码时，遵循一定的代码风格是很有必要的。对于这种机械性的工作，我们的主张是要寻找自动化的解决方案。&lt;/p&gt;
&lt;p&gt;对于 Vim 和 C++ 的组合，这里推荐以下搭配，并辅以适当配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clang-format&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Chiel92/vim-autoformat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;vim-autoformat&lt;/code&gt; 插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Format" scheme="https://liam.page/tags/Format/"/>
    
      <category term="Vim" scheme="https://liam.page/tags/Vim/"/>
    
      <category term="Clang-format" scheme="https://liam.page/tags/Clang-format/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中实现一个单例类模板</title>
    <link href="https://liam.page/2020/10/27/implement-a-singleton-class-template-in-cxx/"/>
    <id>https://liam.page/2020/10/27/implement-a-singleton-class-template-in-cxx/</id>
    <published>2020-10-27T13:14:18.000Z</published>
    <updated>2021-05-23T13:58:27.086Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是最简单的设计模式之一。在实际工程中，如果一个类的对象重复持有资源的成本很高，且对外接口是线程安全的，我们往往倾向于将其以单例模式管理。</p><p>此篇我们在 C++ 中实现正确的单例模式。</p><a id="more"></a><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>在 C++ 中，单例模式有两种方案可选。</p><ul><li>一是实现一个没有可用的公开构造函数的基类，并提供 <code>GetInstance</code> 之类的静态接口，以便访问子类唯一的对象。由于子类构造必须调用基类构造，但基类无公开构造函数可用，这使得子类对象只能由基类及基类的友元来构造，从而在机制上保证单例。</li><li>二是实现一个类模板，其模板参数是希望由单例管理的类的名字，并提供 <code>GetInstance</code> 之类的静态接口。这种做法的好处是希望被单例管理的类，可以自由编写，而无需继承基类；并且在需要的时候，可以随时脱去单例外衣。</li></ul><p>此篇选择实现一个单例类模板，其形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里重载成员访问运算符，是为了可以实现这样的简写 <code>Singleton&lt;T&gt;()-&gt;func()</code>。</p><p>显然，单例的实现核心在于静态成员函数 <code>T* get()</code>。</p><h2 id="一个典型的错误实现"><a href="#一个典型的错误实现" class="headerlink" title="一个典型的错误实现"></a>一个典型的错误实现</h2><p>一个典型的错误实现，是使用所谓的双重检查（double check）。</p><figure class="highlight cpp"><figcaption><span>错误的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;mtx&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nullptr</span> == p) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> T;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton&lt;T&gt;::mtx;</span><br></pre></td></tr></table></figure><p>外层的检查，是为了避免锁住过大的区域，从而导致锁的竞争特别频繁；内层的检查，是为了确保只在别的线程没有提前抢占锁完成初始化工作而设计的。这种做法在 Java 下是正确的，但是在 C++ 下则没有保证。具体解析可以参看<a href="/2017/01/17/layers-and-operation-system/#CPU-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6">这篇旧文</a>。</p><p>另外，值得一提的是，这里 <code>p</code> 的初始化的线程安全性，是由 C++ 标准保证的。——在 C++11 之后，标准保证函数静态成员的初始化是线程安全的；对其读写则不保证线程安全。</p><h2 id="使用标准库提供的设施"><a href="#使用标准库提供的设施" class="headerlink" title="使用标准库提供的设施"></a>使用标准库提供的设施</h2><p>在单例的实现中，我们实际上是希望实现「执行且只执行一次」的语义。C++11 之后，标准库实际已经提供了这样的设施。其名为 <code>std::once_flag</code> 和 <code>std::call_once</code>。它们内部利用互斥量和条件变量组合，实现这样的语义。值得一提的是，如果执行过程中抛出异常，标准库的设施不认为这是一次「成功的执行」。于是其他线程可以继续抢占锁来执行函数。</p><p>我们利用标准库设施来实现这个类模板。</p><figure class="highlight cpp"><figcaption><span>利用标准库设施的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">      p = <span class="keyword">new</span> T;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::once_flag Singleton&lt;T&gt;::flag;</span><br></pre></td></tr></table></figure><p>于是你可以写出类似这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;mtx&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">const_cast</span>&lt;Foo*&gt;(<span class="keyword">this</span>)) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Singleton&lt;Foo&gt;()-&gt;address();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt;&gt; futs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    futs.emplace_back(<span class="built_in">std</span>::async(&amp;Foo::address, Singleton&lt;Foo&gt;::get()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; fut : futs) &#123;</span><br><span class="line">    fut.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的输出类似这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br><span class="line">0x7fbc6f405a10</span><br></pre></td></tr></table></figure><blockquote><p>Bonus：需要注意的是，所有的 <code>std::once_flag</code> 内部共享了同一对互斥量和条件变量。因此当存在很多 <code>std::call_once</code> 的时候，性能会有所下降。这一点可能需要注意一下。不过，如果存在很多 <code>std::call_once</code>，大概也说明程序设计不合理吧……</p></blockquote><blockquote><p>Bonus：注意我们这里没有释放 <code>p</code> 指向的对象。这是因为 C++ 程序对静态变量的析构顺序是不确定的。如果静态变量之间有相互依赖，析构被依赖的对象可能会导致段错误。因此干脆就不释放了，这是所谓的 <code>LeakySingleton</code>。当然，如果你的工程当中有实现一个通用的 <code>ExitManager</code>，是有可能正确析构的。但考虑到还可能大量使用第三方库，而第三方库不可能使用你实现的 <code>ExitManager</code>，于是管理所有静态变量的析构又变得不可能，于是干脆就不管它了。</p></blockquote><h2 id="如此如此，这般这般"><a href="#如此如此，这般这般" class="headerlink" title="如此如此，这般这般"></a>如此如此，这般这般</h2><p>如果你仔细读了这篇文章，你可能会忽然意识到刚才看到了这句话：「在 C++11 之后，标准保证函数静态成员的初始化是线程安全的；对其读写则不保证线程安全。」</p><p>既然如此，我们为啥还要费劲使用 <code>std::once_flag</code> 和 <code>std::call_once</code> 呢？直接利用 <code>static</code> hack 出一个单例类模板不就好了吗？</p><figure class="highlight cpp"><figcaption><span>利用 C++11 标准新规的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T ins;</span><br><span class="line">    <span class="keyword">return</span> &amp;ins;</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是最简单的设计模式之一。在实际工程中，如果一个类的对象重复持有资源的成本很高，且对外接口是线程安全的，我们往往倾向于将其以单例模式管理。&lt;/p&gt;
&lt;p&gt;此篇我们在 C++ 中实现正确的单例模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Mutex" scheme="https://liam.page/tags/Mutex/"/>
    
      <category term="Threading" scheme="https://liam.page/tags/Threading/"/>
    
      <category term="Singleton" scheme="https://liam.page/tags/Singleton/"/>
    
  </entry>
  
</feed>
