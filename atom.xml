<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2019-01-13T11:38:39.416Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 中虚函数的声明与定义</title>
    <link href="https://liam.page/2019/01/13/virtual-member-function-declaration-and-definition-in-Cxx/"/>
    <id>https://liam.page/2019/01/13/virtual-member-function-declaration-and-definition-in-Cxx/</id>
    <published>2019-01-13T10:01:18.000Z</published>
    <updated>2019-01-13T11:38:39.416Z</updated>
    
    <content type="html"><![CDATA[<p>多态（Polymorphism）是面向对象程序设计最重要的特性之一。C++ 通过结合虚函数和指针（引用）来实现多态。作为 C++ 用户，你当然知道如何将虚函数和指针（引用）结合起来以实现多态。但在这些概念之间，可能还存在些许模糊地带。例如说，你有思考过下面这个问题吗？</p><blockquote><p>纯虚函数能有实现吗？</p></blockquote><p>此篇讨论 C++ 中虚函数的声明与定义。</p><a id="more"></a><h2 id="直接回答问题"><a href="#直接回答问题" class="headerlink" title="直接回答问题"></a>直接回答问题</h2><p>能！纯虚函数可以有定义，并且有时我们必须给出纯虚函数的定义。不过有一点需要注意：和其它成员函数不同，纯虚函数的定义必须实现在类定义之外。（见下例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Abstract</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual</span></span><br><span class="line">    ~Abstract() &#123;</span><br><span class="line">        <span class="comment">// f(); // undefined behavior</span></span><br><span class="line">        Abstract::f(); <span class="comment">// OK: non-virtual call</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition of the pure virtual function</span></span><br><span class="line"><span class="keyword">void</span> Abstract::f() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Concrete</span> :</span> Abstract &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        Abstract::f(); <span class="comment">// OK: calls pure virtual function</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Concrete() &#123;</span><br><span class="line">        f(); <span class="comment">// OK: calls Concrete::f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h2><p>我们首先来看看关于虚成员函数生命和定义的一些规则。根据 C++ 标准，虚成员函数应在类定义中生命，且必须有定义（实现）。注意，在类定义外实现虚成员函数时，不能再加 <code>virtual</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// declare and define at the same time, inside the class definition.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bar::bar() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bar::bar()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，C++ 标准没有要求必须在编译期对这条规则进行诊断。也就是说，如果没有给出虚成员函数的实现，编译器可能不会报错。不过，链接器可能会提示引用了未定义的符号这样的错误。</p><h2 id="纯虚成员函数"><a href="#纯虚成员函数" class="headerlink" title="纯虚成员函数"></a>纯虚成员函数</h2><p>纯虚函数使类成为「抽象类」。具体来说，我们不能创建抽象类类型的对象，也不能将其作为函数的参数类型、返回类型，也不能作为显式类型转换的目标类型。</p><p>因此，我们永远不会有机会调用抽象类中的徐成员函数。另一方面，纯虚函数必然会在派生类中被复写。因此，在大多数情况下，纯虚函数的实现是没什么用处的。也因此，我们可以将一个成员函数声明为纯虚的，但是不给它的定义。</p><p>也就是说，对于纯虚函数，我们可以：</p><ul><li>在类定义中声明纯虚函数，并且不给实现；</li><li>在类定义中声明纯虚函数，并且在类定义之外给出实现。</li></ul><p>不过，这里有两处例外：</p><ol><li>对于纯虚析构函数，必须提供实现。</li><li>派生类中的成员函数可以调用抽象类中的纯虚函数，但必须加上抽象类的限定符（<code>Base::some_pure_virtual_function()</code>）。</li></ol><p>在这两种情况下，提供纯虚函数的定义是有意义的——也必须提供。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态（Polymorphism）是面向对象程序设计最重要的特性之一。C++ 通过结合虚函数和指针（引用）来实现多态。作为 C++ 用户，你当然知道如何将虚函数和指针（引用）结合起来以实现多态。但在这些概念之间，可能还存在些许模糊地带。例如说，你有思考过下面这个问题吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;纯虚函数能有实现吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此篇讨论 C++ 中虚函数的声明与定义。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="Virtual Member Function" scheme="https://liam.page/tags/Virtual-Member-Function/"/>
    
  </entry>
  
  <entry>
    <title>2018 个税新法计征算法及 Excel 个税计算器</title>
    <link href="https://liam.page/2019/01/04/Excel-Personal-Income-Tax-Calculator/"/>
    <id>https://liam.page/2019/01/04/Excel-Personal-Income-Tax-Calculator/</id>
    <published>2019-01-04T01:43:06.000Z</published>
    <updated>2019-01-13T10:52:46.159Z</updated>
    
    <content type="html"><![CDATA[<p>2018 年颁布的个税新法于 2019 年 1 月 1 日起施行。个税新法的个税计征办法，相较个税旧法的改变主要有以下几个：</p><ul><li>计征周期发生变化：旧法按月计征工资和薪金的个税；新法按年计征工资和薪金的个税，按月预缴。</li><li>起征点发生变化：旧法按月计征个税的起征点是 ¥3,500.00；新法按月预缴个税的起征点是 ¥5,000.00。</li><li>计算应纳税所得额时，增加专项附加扣除：新法在子女教育、继续教育、大病医疗、（首套）住房贷款利息、住房租金、赡养老人等六个方面新增了专项附加扣除。</li></ul><p>此外，按个税新法，个税旧法中全年一次性奖金收入（年终奖即属此类）的优惠将被取消，全年一次性奖金收入也将纳入全年累计收入进行个税计征。不过，按财政部税务总局发布的<a href="http://www.chinatax.gov.cn/n810341/n810755/c3978994/content.html" target="_blank" rel="noopener">通知（关于个人所得税法修改后有关优惠政策衔接问题的通知，财税（2018）164 号）</a>，个税旧法中的优惠政策将在一定程度上延续至 2022 年 1 月 1 日。</p><p>对于我等升斗小民，赚点钱真的不容易。个税改革的细节又很多，想想就脑壳疼。为此，我将个税新法的计征办法归纳总结了一下，形成此文。此外，我制作了一个 Excel 表格（后附），大家可据此自行计算。若有不正确的地方，欢迎指正。</p><a id="more"></a><h2 id="月收入"><a href="#月收入" class="headerlink" title="月收入"></a>月收入</h2><h3 id="应纳税所得额"><a href="#应纳税所得额" class="headerlink" title="应纳税所得额"></a>应纳税所得额</h3><p>计征个税的第一步，是计算当月应纳税所得额。它的公式如下：</p><p><code>$$\text{月应纳税所得额} = \text{当月税前收入} - \text{起征点} - \text{三险一金（五险一金个人缴存部分）减除} - \text{专项附加扣除}.$$</code></p><p>举例来说，某人某月的税前收入是 ¥30,000.00，三险一金减除额是 ¥4,500.00，个税新法下专项附加扣除总额是 ¥2,000.00，则其该月应纳税所得额是</p><p><code>$$\begin{aligned}\text{月应纳税所得额} &amp;{}= \text{当月税前收入} - \text{起征点} - \text{三险一金（五险一金个人缴存部分）减除} - \text{专项附加扣除}\\&amp;{} = ¥30,000.00 - ¥5,000.00 - ¥4,500.00 - ¥2,000.00 \\&amp;{} = ¥18,500.00\end{aligned}$$</code></p><h3 id="当年累计应纳税所得额"><a href="#当年累计应纳税所得额" class="headerlink" title="当年累计应纳税所得额"></a>当年累计应纳税所得额</h3><p>计征个税的第二步，是计算当年累计应纳税所得额。它的公式如下：</p><p><code>$$ \text{当年累计应纳税所得额}_k = \sum_{i = 1}^{k} \text{月应纳税所得额}_i. $$</code></p><p>续上例。当年一月、二月，该人税前月收入是 ¥30,000.00，三月起，他的税前月收入增长到 ¥35,000.00。则其一月、二月的月应纳税所得额是 ¥18,500.00，三月起的月应纳税所得额是 ¥23,500.00。于是，截至四月，他当年的累计应纳税所得额是</p><p><code>$$\begin{aligned}\text{当年累计应纳税所得额}_4 &amp;{}= \sum_{i = 1}^{4} \text{月应纳税所得额}_i \\&amp;{}= ¥18,500.00 + ¥18,500.00 + ¥23,500.00 +　¥23,500.00 \\&amp;{}= ¥84,000.00\end{aligned}$$</code></p><h3 id="当年累计应预缴税额"><a href="#当年累计应预缴税额" class="headerlink" title="当年累计应预缴税额"></a>当年累计应预缴税额</h3><p>计征个税的第三步，是计算当年累计应预缴税额。它的公式如下：</p><p><code>$$ \text{当年累计应预缴税额}_k = \text{当年累计应纳税所得额}_k * \text{适用税率} - \text{适用速算扣除数}. $$</code></p><p>其中，适用税率和适用速算扣除数取决于当年累计应纳税所得额。对应关系如下表。</p><table><thead><tr><th>级数</th><th>累计预扣预缴应纳税所得额</th><th>预扣率（%）</th><th>速算扣除数</th></tr></thead><tbody><tr><td>1</td><td>不超过 36000 元的部分</td><td>3</td><td>0</td></tr><tr><td>2</td><td>超过 36000 元至 144000 元的部分</td><td>10</td><td>2520</td></tr><tr><td>3</td><td>超过 144000 元至 300000 元的部分</td><td>20</td><td>16920</td></tr><tr><td>4</td><td>超过 300000 元至 420000 元的部分</td><td>25</td><td>31920</td></tr><tr><td>5</td><td>超过 420000 元至 660000 元的部分</td><td>30</td><td>52920</td></tr><tr><td>6</td><td>超过 660000 元至 960000 元的部分</td><td>35</td><td>85920</td></tr><tr><td>7</td><td>超过 960000 元的部分</td><td>45</td><td>181920</td></tr></tbody></table><p>续上例。截至四月，他当年的累计应预缴税额是：</p><p><code>$$\begin{aligned}\text{当年累计应预缴税额}_4 &amp;{}= \text{当年累计应纳税所得额}_4 * \text{适用税率} - \text{适用速算扣除数} \\&amp;{}= ¥84,000.00 * 10\% - ¥2,520.00 \\&amp;{}= ¥8,230.00\end{aligned}$$</code></p><h3 id="当月应预缴税额"><a href="#当月应预缴税额" class="headerlink" title="当月应预缴税额"></a>当月应预缴税额</h3><p>计征个税的第四步，是计算当月应预缴税额。它的公式如下：</p><p><code>$$ \text{月应预缴税额}_k = \text{当年累计应预缴税额}_k - \text{当年累计实际已预缴税额}_{k - 1}. $$</code></p><p>因此，续上例，该人前 4 个月每个月的应预缴税额如下表。</p><table><thead><tr><th>月份</th><th>当年累计应预缴税额</th><th>当年累计实际已预缴税额</th><th>当月应预缴税额</th></tr></thead><tbody><tr><td>一月</td><td>¥555.00</td><td>¥0</td><td>¥555.00</td></tr><tr><td>二月</td><td>¥1,180.00</td><td>¥555.00</td><td>¥625.00</td></tr><tr><td>三月</td><td>¥3,530.00</td><td>¥1,180.00</td><td>¥2,350.00</td></tr><tr><td>四月</td><td>¥5,880.00</td><td>¥3,530.00</td><td>¥2,350.00</td></tr></tbody></table><p>由此可见，在年应纳税收入累计升高到新的级数时，从该月开始，月应预缴税额会相应升高。</p><h3 id="当月税后收入"><a href="#当月税后收入" class="headerlink" title="当月税后收入"></a>当月税后收入</h3><p>计征个税完成后，我们就能计算实际税后收入了。它的公式如下：</p><p><code>$$ \text{月税后收入}_k = \text{月税前收入}_k - \text{三险一金（五险一金个人缴存部分）}_k - \text{月应预缴税额}_k. $$</code></p><p>因此，续上例，该人前 4 个月每个月的税后收入如下表。</p><table><thead><tr><th>月份</th><th>税前收入</th><th>三险一金（五险一金个人缴存部分）</th><th>月应预缴税额</th><th>月税后收入</th></tr></thead><tbody><tr><td>一月</td><td>¥30,000.00</td><td>¥4,500.00</td><td>¥555.00</td><td>¥24,945.00</td></tr><tr><td>二月</td><td>¥30,000.00</td><td>¥4,500.00</td><td>¥625.00</td><td>¥24,875.00</td></tr><tr><td>三月</td><td>¥35,000.00</td><td>¥4,500.00</td><td>¥2,350.00</td><td>¥23,150.00</td></tr><tr><td>四月</td><td>¥35,000.00</td><td>¥4,500.00</td><td>¥2,350.00</td><td>¥23,150.00</td></tr></tbody></table><p>由此可见，在年应纳税收入累计升高到新的级数时，从该月开始，由于月应预缴税额会相应升高，实际月税后收入会相应下降。</p><h2 id="全年一次性奖金"><a href="#全年一次性奖金" class="headerlink" title="全年一次性奖金"></a>全年一次性奖金</h2><p>按上述「通知」</p><blockquote><p>　居民个人取得全年一次性奖金，符合《国家税务总局关于调整个人取得全年一次性奖金等计算征收个人所得税方法问题的通知》（国税发〔2005〕9号）规定的，在2021年12月31日前，不并入当年综合所得，以全年一次性奖金收入除以12个月得到的数额，按照本通知所附按月换算后的综合所得税率表（以下简称月度税率表），确定适用税率和速算扣除数，单独计算纳税。<br><code>$$ \text{应纳税额}_k = \text{全年一次性奖金收入} * \text{适用税率} - \text{速算扣除数}. $$</code></p></blockquote><p>其中月度税率表如下。</p><table><thead><tr><th>级数</th><th>全月应纳税所得额</th><th>税率（%）</th><th>速算扣除数</th></tr></thead><tbody><tr><td>1</td><td>不超过 3000 元的</td><td>3</td><td>0</td></tr><tr><td>2</td><td>超过 3000 元至 12000 元的部分</td><td>10</td><td>210</td></tr><tr><td>3</td><td>超过 12000 元至 25000 元的部分</td><td>20</td><td>1410</td></tr><tr><td>4</td><td>超过 25000 元至 35000 元的部分</td><td>25</td><td>2660</td></tr><tr><td>5</td><td>超过 35000 元至 55000 元的部分</td><td>30</td><td>4410</td></tr><tr><td>6</td><td>超过 55000 元至 80000 元的部分</td><td>35</td><td>7160</td></tr><tr><td>7</td><td>超过 80000 元的部分</td><td>45</td><td>1516</td></tr></tbody></table><p>举例来说，某人获得全年一次性奖金 ¥30,000.00，则其适用税率 3% 和速算扣除数 ¥0.00。因此，它的全年一次性奖金应纳税额是 ¥900.00，税后奖金收入 ¥29,100.00。</p><h2 id="Excel-版个税计算器"><a href="#Excel-版个税计算器" class="headerlink" title="Excel 版个税计算器"></a>Excel 版个税计算器</h2><p>按上述个税计征逻辑，我制作了一个 Excel 版个税计算器。你可以在这里<a href="/uploads/xlsx/personal_income_tax_2018.xlsx">下载</a>。</p><p>由于每个人的税前收入和专项附加扣除不一致，因此这两列需要按实际情况填写。此外，每个人缴存的三险一金基数及缴存比例也不一样，因此这一列也需要按实际情况填写。填写完成后，Excel 表格会自动计算出每个月应预缴的个人所得税额及实际税后收入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 年颁布的个税新法于 2019 年 1 月 1 日起施行。个税新法的个税计征办法，相较个税旧法的改变主要有以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计征周期发生变化：旧法按月计征工资和薪金的个税；新法按年计征工资和薪金的个税，按月预缴。&lt;/li&gt;
&lt;li&gt;起征点发生变化：旧法按月计征个税的起征点是 ¥3,500.00；新法按月预缴个税的起征点是 ¥5,000.00。&lt;/li&gt;
&lt;li&gt;计算应纳税所得额时，增加专项附加扣除：新法在子女教育、继续教育、大病医疗、（首套）住房贷款利息、住房租金、赡养老人等六个方面新增了专项附加扣除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，按个税新法，个税旧法中全年一次性奖金收入（年终奖即属此类）的优惠将被取消，全年一次性奖金收入也将纳入全年累计收入进行个税计征。不过，按财政部税务总局发布的&lt;a href=&quot;http://www.chinatax.gov.cn/n810341/n810755/c3978994/content.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通知（关于个人所得税法修改后有关优惠政策衔接问题的通知，财税（2018）164 号）&lt;/a&gt;，个税旧法中的优惠政策将在一定程度上延续至 2022 年 1 月 1 日。&lt;/p&gt;
&lt;p&gt;对于我等升斗小民，赚点钱真的不容易。个税改革的细节又很多，想想就脑壳疼。为此，我将个税新法的计征办法归纳总结了一下，形成此文。此外，我制作了一个 Excel 表格（后附），大家可据此自行计算。若有不正确的地方，欢迎指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Tax" scheme="https://liam.page/tags/Tax/"/>
    
      <category term="Excel" scheme="https://liam.page/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>解决 Windows 7 上的图标异常</title>
    <link href="https://liam.page/2018/12/28/fixing-icon-missing-on-Windows-7/"/>
    <id>https://liam.page/2018/12/28/fixing-icon-missing-on-Windows-7/</id>
    <published>2018-12-28T11:53:07.000Z</published>
    <updated>2019-01-13T10:52:46.159Z</updated>
    
    <content type="html"><![CDATA[<p>话说 Windows 的小毛病是真的多。配置电脑一段时间之后，Micorsoft Word 的图标就变成了白板（如下图）。这篇文章解释这个现象是哪里出了问题，以及要如何解决。</p><a id="more"></a><p><img src="/uploads/images/computer-skills/bad_icon.png" alt=""></p><p>上图即是又遇见的奇怪的图标——咦，为什么要说又。看见它就很不爽对吧？</p><p>Windows 对不同文件类型/文件的图标是有一个图标缓存的。这个缓存的文件名叫做 <code>IconCache.db</code>。如果缓存中存在这个文件类型/文件的图标，就会以缓存中的图标来标示文件类型/文件；如果缓存中不存在，则从原始路径去读取图标资源。</p><p>问题就处在这个 <code>IconCache.db</code> 上。它可能被各种奇怪的操作修改、破坏。如果它被修改破坏了，那么我们看到的图标就会有异常。</p><p>解决问题的办法也很简单——删掉缓存，让 Windows 重建缓存即可。以下是解决这一问题的批处理文件内容。你可以将它保存为 <code>refresh_thumbnail_cache.bat</code> 或者直接从<a href="/uploads/codes/bat/refresh_thumbnail_cache.bat">这里下载</a>，而后双击执行。执行时，Windows 资源管理器会被杀死，而后重启。因此，你可能会观察到计算机会「闪」几下。这是正常现象，无需担心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">cd /d %userprofile%\AppData\Local</span><br><span class="line">del IconCache.db /a</span><br><span class="line">start explorer.exe</span><br><span class="line">echo done.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说 Windows 的小毛病是真的多。配置电脑一段时间之后，Micorsoft Word 的图标就变成了白板（如下图）。这篇文章解释这个现象是哪里出了问题，以及要如何解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Windows 7" scheme="https://liam.page/tags/Windows-7/"/>
    
      <category term="Windows" scheme="https://liam.page/tags/Windows/"/>
    
      <category term="BAT" scheme="https://liam.page/tags/BAT/"/>
    
  </entry>
  
  <entry>
    <title>禁止 Tmux 自动修改 window 的名字</title>
    <link href="https://liam.page/2018/12/13/disallow-tmux-to-rename-window/"/>
    <id>https://liam.page/2018/12/13/disallow-tmux-to-rename-window/</id>
    <published>2018-12-13T08:36:42.000Z</published>
    <updated>2019-01-13T10:52:46.159Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Tmux 也有很长时间了，基础配置一直没动，用起来也很顺手。今天在新的服务器上编译安装 Tmux 之后，使用了一段时间发现 Tmux 的 window 名字一直随着执行命令而不断变化。哪怕是强行设置了 window name 也不管用。经过一番搜索，<a href="https://stackoverflow.com/questions/6041178/keep-the-windows-name-fixed-in-tmux#comment26641702_6041178" target="_blank" rel="noopener">找到解决方案</a>。</p><a id="more"></a><p>只需将如下代码，贴近 <code>~/.tmux.conf</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-option -g allow-rename off</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Tmux 也有很长时间了，基础配置一直没动，用起来也很顺手。今天在新的服务器上编译安装 Tmux 之后，使用了一段时间发现 Tmux 的 window 名字一直随着执行命令而不断变化。哪怕是强行设置了 window name 也不管用。经过一番搜索，&lt;a href=&quot;https://stackoverflow.com/questions/6041178/keep-the-windows-name-fixed-in-tmux#comment26641702_6041178&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找到解决方案&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Tmux" scheme="https://liam.page/tags/Tmux/"/>
    
  </entry>
  
  <entry>
    <title>谈谈代码的模块化</title>
    <link href="https://liam.page/2018/12/12/writing-modular-codes/"/>
    <id>https://liam.page/2018/12/12/writing-modular-codes/</id>
    <published>2018-12-12T01:23:19.000Z</published>
    <updated>2019-01-13T10:52:46.159Z</updated>
    
    <content type="html"><![CDATA[<p>我们总是说要写模块化的代码。但是到底什么是模块化的代码？怎样写模块化的代码？这两个问题不解决，模块化就不接地气、无法落地。</p><p>这篇谈谈我对代码模块化的一些思考。</p><a id="more"></a><h2 id="模块化是什么"><a href="#模块化是什么" class="headerlink" title="模块化是什么?"></a>模块化是什么?</h2><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>可能在很多人的理解中，要「模块化」就要分割代码。于是他们会把项目分成很多个文件，甚至分割成很多个版本仓库（repository）。但实际上，这种分割只是手段，而不是目的。如果把这种手段错误地当做是目的，那可能不会带来什么好处，反而会带来很多麻烦。</p><p>例如说，我曾经参与过一个项目的开发。对于运行在网络通信框架上的业务逻辑插件，人们为之写了一个基类，命名为 <code>PluginBase</code>。而后，人们把它单独拉出去，作为一个单独的版本仓库。在实际编写插件时，再通过二进制依赖的方式，将 <code>PluginBase</code> 的共享对象（<code>.so</code>）动态链接到进程中去。这种做法其实完全没必要，就属于典型的错把手段当目的。<code>PluginBase</code> 与 <code>PluginFooBar</code> 在逻辑上的结合是很紧密的——基类和派生类，因此将它们分开不合适。打个比方，在开发 <code>PluginFooBar</code> 时，我们可能发现之前在设计 <code>PluginBase</code> 时不够完善，需要再添加一个接口。此时，我们就需要：</p><ul><li>修改 <code>PluginBase</code> 的代码；</li><li>编译之后发版；</li><li>在 <code>PluginFooBar</code> 的版本仓库中修改依赖配置；</li><li>编译 <code>PluginFooBar</code>；</li><li>将新版本的 <code>libPluginBase.so</code> 和 <code>libPluginFooBar.so</code> 都拷贝到执行环境。</li></ul><p>而如果我们能发现 <code>PluginBase</code> 和 <code>PluginFooBar</code> 在逻辑上结合很紧密，而不把它们分开在两个版本仓库中，这样的修改就简单多了：</p><ul><li>修改 <code>PluginBase</code> 的代码；</li><li>编译；</li><li>将新版本的 <code>libPlugins.so</code> 拷贝到执行环境。</li></ul><h3 id="按逻辑分块"><a href="#按逻辑分块" class="headerlink" title="按逻辑分块"></a>按逻辑分块</h3><p>如此我们可以发现，所谓模块化，分割是手段而非目的。那么究竟要怎么模块化呢？上面的讨论已经提到了一点——跟逻辑相关。这里继续讨论。</p><p>要搞清楚模块化，首先要搞清楚什么是模块。模块其实是一个逻辑层面的定义。它是说：如果一个东西，它有定义良好的输入和输出，那么它就是一个模块。再详细说一点，这里所谓的「定义良好」有两个方面需要定义：一方面指输入和输出的格式，一方面指输入和输出的含义。</p><p>因此，只要一个东西的行为，在逻辑上满足这个阐述，那么它就是一个模块。例如一块电路板是一个模块；因为它接受固定格式的输入，根据固定逻辑产出输出。又例如一个定义良好的函数是一个模块；因为它接受固定格式的输入（函数参数），根据固定逻辑产出输出。</p><p>回到上一小节举的例子。<code>PluginBase</code> 在逻辑上并没有良好的输入和输出——它是基类，通常实际功能由子类完成。因此，强行把它提出去单独管理是不合适的。</p><h2 id="怎样写模块化的代码？"><a href="#怎样写模块化的代码？" class="headerlink" title="怎样写模块化的代码？"></a>怎样写模块化的代码？</h2><p>具体到写代码时，模块化这个命题主要就落在如何设计函数上了——毕竟，在代码的世界里，函数是最小的模块单元。这里提炼一些实践中的经验。</p><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>设计函数时，最好让函数的职责足够简单，只有一个。</p><p>为什么这么说呢？我们可以考虑一下，如果一个函数既可以做这个，又可以做那个，这种函数需要怎样设计？显然，函数需要根据某些变量的值，或者某种条件，来选择走哪个逻辑分支。比如可能有如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bool flag;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">    bar_a();</span><br><span class="line">    baz_a();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bar_b();</span><br><span class="line">    baz_b();</span><br><span class="line">  &#125;</span><br><span class="line">  qux();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 <code>flag</code> 用来表示影响函数行为的外部因素。函数 <code>foo</code> 内，根据 <code>flag</code> 取值的不同，会走不同的分支。这种设计看起来不错。比如，有人可能会认为它节省了代码行数，写起来爽快。但是实际上这个函数的行为某种程度上就不是良定义的了——它取决于一个外部变量。试想，一个刚接手这段代码的人，调用 <code>foo</code> 函数，TA 就必须不断去追踪 <code>flag</code> 变量代表的外部环境。如果你觉得追踪某个变量还算好的话，可以试想一下如果这个变量代表「打印机有没有连上」这种在代码中完全不可控的外部因素会怎样。</p><p>对于这种代码，就不如把两种不同情形分开，写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bool flag;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bar_a();</span><br><span class="line">  baz_a();</span><br><span class="line">  quz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bar_b();</span><br><span class="line">  baz_b();</span><br><span class="line">  quz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (flag == true) &#123;</span></span><br><span class="line"><span class="comment">  foo_a();</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">  foo_b();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如此一来，<code>foo_a</code> 和 <code>foo_b</code> 的职责都很明确，接手维护的人再也不会疑惑函数的行为了。</p><h3 id="输入决定（input-dominated）"><a href="#输入决定（input-dominated）" class="headerlink" title="输入决定（input dominated）"></a>输入决定（input dominated）</h3><p>设计函数时，尽可能使函数的行为完全由其输入参数决定。特别地，尽可能不要让函数的行为受到全局变量、类的成员变量的取值影响。某种意义上，这和「可重入」的概念比较像。</p><p>这一点应该比较好理解。如果一个函数的行为取决于入参之外的因素，那么相当于这个函数在参数之外还有其他输入。显然，这和「输入良定义」是矛盾的。特别地，如果一个类的成员函数的行为依赖类的成员变量的取值，那么使用这个成员函数时，我们就不得不胆战心惊，逐个推演其他的成员函数有可能在某些情况下修改这些成员变量的值。</p><h3 id="自我限制"><a href="#自我限制" class="headerlink" title="自我限制"></a>自我限制</h3><p>这部分完全是经验之谈。</p><p>写代码的时候，可以做一些自我限制。例如说：不写超过 50 行的代码；不超过 5 行的通用功能也要拉出去做工具函数。</p><p>人总是爱偷懒的。因此，写代码写 high 的时候，往往就会忘记很多最佳实践。因此，给自己做一些自我限制，有一些强迫症还是很有必要的。据我自己的经验，超过 50 行的代码，往往就会把逻辑写得像面条一样，同时输入和输出的定义就不那么明朗了。因此 50 行虽然没有什么别的意义，但是仅仅将它作为是一个强迫症式的自我限制也是不错的。当然，你可以根据你的习惯，调整这个限制的大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们总是说要写模块化的代码。但是到底什么是模块化的代码？怎样写模块化的代码？这两个问题不解决，模块化就不接地气、无法落地。&lt;/p&gt;
&lt;p&gt;这篇谈谈我对代码模块化的一些思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Modular" scheme="https://liam.page/tags/Modular/"/>
    
  </entry>
  
  <entry>
    <title>CTeXUG 的 LOGO</title>
    <link href="https://liam.page/2018/12/11/logo-of-CTeXUG/"/>
    <id>https://liam.page/2018/12/11/logo-of-CTeXUG/</id>
    <published>2018-12-11T10:20:03.000Z</published>
    <updated>2019-01-13T10:52:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>手残党设计的 LOGO。<code>XD</code></p><p><code>CTeXUG</code> 用到的的字体是「Quicksand」，<code>OVERFLOW</code> 用到的的字体是「Coda」。</p><a id="more"></a><p><img src="/uploads/images/logo/CTeXUG_logo.png" alt=""></p><p><img src="/uploads/images/logo/CTeXUG_overflow_logo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手残党设计的 LOGO。&lt;code&gt;XD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CTeXUG&lt;/code&gt; 用到的的字体是「Quicksand」，&lt;code&gt;OVERFLOW&lt;/code&gt; 用到的的字体是「Coda」。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="LOGO" scheme="https://liam.page/tags/LOGO/"/>
    
      <category term="CTeXUG" scheme="https://liam.page/tags/CTeXUG/"/>
    
  </entry>
  
  <entry>
    <title>Windows 中的 mklink 命令</title>
    <link href="https://liam.page/2018/12/10/mklink-in-Windows/"/>
    <id>https://liam.page/2018/12/10/mklink-in-Windows/</id>
    <published>2018-12-10T07:59:45.000Z</published>
    <updated>2019-01-13T10:52:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>日常使用 Linux 的用户，想必对 <code>ln</code> 命令不会陌生。使用该命令，可以在 Linux 系统上创建针对文件或目录的符号链接，实现一个文件（目录）两个名字的功能。</p><p>Windows 上也有一个类似功能的命令，它是 <code>mklink</code>。不过它的行为和 <code>ln</code> 不太一样。此外，Windows 上还有「快捷方式」这种东西，也能实现一个文件（目录）两个名字的功能。但它和 <code>mklink</code> 建立的符号链接不一样，它是 Windows 上特有的一种文件格式，专门用来指向其它文件（目录）。</p><p>此篇讲讲 Windows 上的 <code>mklink</code> 命令。</p><a id="more"></a><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><table><thead><tr><th></th><th>不带参数</th><th><code>/D</code> 参数</th><th><code>/H</code> 参数</th><th><code>J</code> 参数</th></tr></thead><tbody><tr><td>中文名称</td><td>符号链接</td><td>符号链接</td><td>硬链接</td><td>联接</td></tr><tr><td>英文名称</td><td>Symbolic Link</td><td>Symbolic Link</td><td>Hard Link</td><td>Junction</td></tr><tr><td>作用对象</td><td>文件</td><td>目录</td><td>文件</td><td>目录</td></tr><tr><td>是否一定指向路径</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td><code>dir</code> 类型</td><td><code>SYMLINK</code></td><td><code>SYMLINK</code></td><td>无特殊显示</td><td><code>JUNCTION</code></td></tr><tr><td>资源管理器类型</td><td><code>.symlink</code></td><td>文件夹</td><td>无特殊显示</td><td>文件夹</td></tr><tr><td>资源管理器图标</td><td>快捷方式</td><td>文件夹快捷方式</td><td>无特殊显示</td><td>文件夹快捷方式</td></tr><tr><td>修改同步</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>删除同步</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>彻底删除源</td><td>删除源路径</td><td>删除源路径</td><td>删除所有硬链接</td><td>删除源路径</td></tr><tr><td>引用错误报错</td><td>无</td><td>引用了一个不可用的位置</td><td>-</td><td>引用了一个不可用的位置</td></tr></tbody></table><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p><code>mklink</code> 命令需要使用管理员权限，在 <code>cmd.exe</code> 中运行。在 Windows 7 中，可以在开始菜单中搜索 <code>cmd</code>，而后右键搜索结果，选择「以管理员身份运行」。</p><p><img src="/uploads/images/windows/cmd_administrator.png" alt=""></p><p>执行 <code>mklink</code> 命令，不带任何 flags 及 arguments，可以查看它的语法说明（官方网页版<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/mklink" target="_blank" rel="noopener">说明</a>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D:\test&gt;mklink</span><br><span class="line">创建符号链接。</span><br><span class="line"></span><br><span class="line">MKLINK [[/D] | [/H] | [/J]] Link Target</span><br><span class="line"></span><br><span class="line">        /D      创建目录符号链接。默认为文件</span><br><span class="line">                符号链接。</span><br><span class="line">        /H      创建硬链接，而不是符号链接。</span><br><span class="line">        /J      创建目录联接。</span><br><span class="line">        Link    指定新的符号链接名称。</span><br><span class="line">        Target  指定新链接引用的路径</span><br><span class="line">                (相对或绝对)。</span><br></pre></td></tr></table></figure><h3 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h3><p>不带参数的 <code>mklink</code> 命令可以为文件创建符号链接。当源路径是目录时，不带参数的 <code>mklink</code> 不会报错，但是实际产生的符号链接不可用。在 <code>cmd</code> 中使用 <code>dir</code> 列出当前目录的文件列表时，符号链接显示为 <code>SYMLINK</code>，同时在文件名后以方括号表示链接的源地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">D:\test&gt;mklink source_link.txt source.txt</span><br><span class="line">为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建的符号链接</span><br><span class="line"></span><br><span class="line">D:\test&gt;mklink source_link source</span><br><span class="line">为 source_link &lt;&lt;===&gt;&gt; source 创建的符号链接</span><br><span class="line"></span><br><span class="line">D:\test&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 22FA-F6AC</span><br><span class="line"></span><br><span class="line"> D:\test 的目录</span><br><span class="line"></span><br><span class="line">2018/12/10  16:18    &lt;DIR&gt;          .</span><br><span class="line">2018/12/10  16:18    &lt;DIR&gt;          ..</span><br><span class="line">2018/12/10  16:17    &lt;DIR&gt;          source</span><br><span class="line">2018/12/10  16:17                 0 source.txt</span><br><span class="line">2018/12/10  16:18    &lt;SYMLINK&gt;      source_link [source]</span><br><span class="line">2018/12/10  16:18    &lt;SYMLINK&gt;      source_link.txt [source.txt]</span><br><span class="line">               3 个文件              0 字节</span><br><span class="line">               3 个目录 241,024,643,072 可用字节</span><br></pre></td></tr></table></figure><p>不带参数的 <code>mklink</code> 创建的符号链接，展现在 Windows 资源管理器中的样式与普通的快捷方式没有两样——在图标的左下角有一个小箭头。不过，在资源管理器中，符号链接的文件类型是 <code>.symlink</code>。对于源路径是目录的情况，图标显示为一块白板。</p><p><img src="/uploads/images/windows/mklink_void.png" alt=""></p><p>删除不带参数的 <code>mklink</code> 创建的符号链接，不会影响源路径指向的文件。删除不带参数的 <code>mklink</code> 创建的符号链接指向的源文件，访问符号链接时无法访问。</p><h3 id="参数-D"><a href="#参数-D" class="headerlink" title="参数 /D"></a>参数 <code>/D</code></h3><p>参数 <code>/D</code> 版本的 <code>mklink</code> 命令可以为目录创建符号链接。当源路径是文件时，不带参数的 <code>mklink</code> 不会报错，但是实际产生的符号链接不可用；访问时会提示「目录名称无效」。在 <code>cmd</code> 中使用 <code>dir</code> 列出当前目录的文件列表时，符号链接显示为 <code>SYMLINK</code>，同时在文件名后以方括号表示链接的源地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">D:\test&gt;mklink /D source_link source</span><br><span class="line">为 source_link &lt;&lt;===&gt;&gt; source 创建的符号链接</span><br><span class="line"></span><br><span class="line">D:\test&gt;mklink /D source_link.txt source.txt</span><br><span class="line">为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建的符号链接</span><br><span class="line"></span><br><span class="line">D:\test&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 22FA-F6AC</span><br><span class="line"></span><br><span class="line"> D:\test 的目录</span><br><span class="line"></span><br><span class="line">2018/12/10  16:27    &lt;DIR&gt;          .</span><br><span class="line">2018/12/10  16:27    &lt;DIR&gt;          ..</span><br><span class="line">2018/12/10  16:17    &lt;DIR&gt;          source</span><br><span class="line">2018/12/10  16:17                 0 source.txt</span><br><span class="line">2018/12/10  16:27    &lt;SYMLINKD&gt;     source_link [source]</span><br><span class="line">2018/12/10  16:27    &lt;SYMLINKD&gt;     source_link.txt [source.txt]</span><br><span class="line">               1 个文件              0 字节</span><br><span class="line">               5 个目录 241,024,618,496 可用字节</span><br></pre></td></tr></table></figure><p>参数 <code>/D</code> 版本的 <code>mklink</code> 命令创建的符号链接，展现在 Windows 资源管理器中的样式与普通的快捷方式没有两样——在图标的左下角有一个小箭头。不过，在资源管理器中，符号链接的文件类型是「文件夹」。对于源路径是文件的情况，图标显示为空目录的样式。</p><p><img src="/uploads/images/windows/mklink_d.png" alt=""></p><p>删除参数 <code>/D</code> 版本的 <code>mklink</code> 命令创建的符号链接，不会影响源路径指向的文件。删除参数 <code>/D</code> 版本的 <code>mklink</code> 命令创建的符号链接指向的源文件，访问符号链接时无法访问；提示「引用了一个不可用的位置」。</p><h3 id="参数-H"><a href="#参数-H" class="headerlink" title="参数 /H"></a>参数 <code>/H</code></h3><p>参数 <code>/H</code> 版本的 <code>mklink</code> 命令可以为文件创建硬链接。当源路径是目录时，不带参数的 <code>mklink</code> 会报错「拒绝访问」。在 <code>cmd</code> 中使用 <code>dir</code> 列出当前目录的文件列表时，硬链接的样式与正常文件没什么不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:\test&gt;mklink /H source_link.txt source.txt</span><br><span class="line">为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建了硬链接</span><br><span class="line"></span><br><span class="line">D:\test&gt;mklink /H source_link source</span><br><span class="line">拒绝访问。</span><br><span class="line"></span><br><span class="line">D:\test&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 22FA-F6AC</span><br><span class="line"></span><br><span class="line"> D:\test 的目录</span><br><span class="line"></span><br><span class="line">2018/12/10  16:38    &lt;DIR&gt;          .</span><br><span class="line">2018/12/10  16:38    &lt;DIR&gt;          ..</span><br><span class="line">2018/12/10  16:35    &lt;DIR&gt;          source</span><br><span class="line">2018/12/10  16:17                 0 source.txt</span><br><span class="line">2018/12/10  16:17                 0 source_link.txt</span><br><span class="line">               2 个文件              0 字节</span><br><span class="line">               3 个目录 241,024,421,888 可用字节</span><br></pre></td></tr></table></figure><p>参数 <code>/H</code> 版本的 <code>mklink</code> 命令创建的硬链接，展现在 Windows 资源管理器中的样式与源文件一致。</p><p><img src="/uploads/images/windows/mklink_h.png" alt=""></p><p>删除参数 <code>/H</code> 版本的 <code>mklink</code> 命令创建的硬链接，不会影响源路径指向的文件。删除参数 <code>/H</code> 版本的 <code>mklink</code> 命令创建的硬链接指向的源文件，也不会影响硬链接。只有当一个文件的所有硬链接都被删除时，文件才被真正删除。</p><h3 id="参数-J"><a href="#参数-J" class="headerlink" title="参数 /J"></a>参数 <code>/J</code></h3><p>参数 <code>/J</code> 版本的 <code>mklink</code> 命令可以为目录创建联接。当源路径是文件时，不带参数的 <code>mklink</code> 不会报错，但是实际产生的联接不可用；访问时会提示「目录名称无效」。在 <code>cmd</code> 中使用 <code>dir</code> 列出当前目录的文件列表时，联接显示为 <code>JUNCTION</code>，同时在文件名后以方括号表示链接的源地址的绝对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">D:\test&gt;mklink /J source_link.txt source.txt</span><br><span class="line">为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建的联接</span><br><span class="line"></span><br><span class="line">D:\test&gt;mklink /J source_link source</span><br><span class="line">为 source_link &lt;&lt;===&gt;&gt; source 创建的联接</span><br><span class="line"></span><br><span class="line">D:\test&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 22FA-F6AC</span><br><span class="line"></span><br><span class="line"> D:\test 的目录</span><br><span class="line"></span><br><span class="line">2018/12/10  16:43    &lt;DIR&gt;          .</span><br><span class="line">2018/12/10  16:43    &lt;DIR&gt;          ..</span><br><span class="line">2018/12/10  16:35    &lt;DIR&gt;          source</span><br><span class="line">2018/12/10  16:41                 2 source.txt</span><br><span class="line">2018/12/10  16:43    &lt;JUNCTION&gt;     source_link [D:\test\source]</span><br><span class="line">2018/12/10  16:43    &lt;JUNCTION&gt;     source_link.txt [D:\test\source.txt]</span><br><span class="line">               1 个文件              2 字节</span><br><span class="line">               5 个目录 241,024,319,488 可用字节</span><br></pre></td></tr></table></figure><p>参数 <code>/J</code> 版本的 <code>mklink</code> 命令创建的联接，展现在 Windows 资源管理器中的样式与普通的快捷方式没有两样——在图标的左下角有一个小箭头。不过，在资源管理器中，联接的文件类型是「文件夹」。对于源路径是文件的情况，图标显示为空目录的样式。</p><p><img src="/uploads/images/windows/mklink_j.png" alt=""></p><p>删除参数 <code>/J</code> 版本的 <code>mklink</code> 命令创建的联接，不会影响源路径指向的文件。删除参数 <code>/J</code> 版本的 <code>mklink</code> 命令创建的联接指向的源文件，访问联接时无法访问；提示「引用了一个不可用的位置」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常使用 Linux 的用户，想必对 &lt;code&gt;ln&lt;/code&gt; 命令不会陌生。使用该命令，可以在 Linux 系统上创建针对文件或目录的符号链接，实现一个文件（目录）两个名字的功能。&lt;/p&gt;
&lt;p&gt;Windows 上也有一个类似功能的命令，它是 &lt;code&gt;mklink&lt;/code&gt;。不过它的行为和 &lt;code&gt;ln&lt;/code&gt; 不太一样。此外，Windows 上还有「快捷方式」这种东西，也能实现一个文件（目录）两个名字的功能。但它和 &lt;code&gt;mklink&lt;/code&gt; 建立的符号链接不一样，它是 Windows 上特有的一种文件格式，专门用来指向其它文件（目录）。&lt;/p&gt;
&lt;p&gt;此篇讲讲 Windows 上的 &lt;code&gt;mklink&lt;/code&gt; 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Symbolic Link" scheme="https://liam.page/tags/Symbolic-Link/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 黑魔法（七）：TeX 中作为参数的 dimen 和 skip</title>
    <link href="https://liam.page/2018/12/10/dimen-and-skip-as-argument-in-TeX/"/>
    <id>https://liam.page/2018/12/10/dimen-and-skip-as-argument-in-TeX/</id>
    <published>2018-12-10T02:32:37.000Z</published>
    <updated>2019-01-13T10:52:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>接触 TeX 稍久的用户，应该多少都接触过 <code>\kern</code> 和 <code>\hskip</code> 两个命令。那么不知你是否会好奇，TeX 是如何获取它们的参数的呢？要知道，像 <code>I\kern37ptlike\hskip100ptcake</code> 这种看上去奇奇怪怪的写法，能正常工作，但 <code>\hskip 2pt minuscule chances of error</code> 这种看起来正常的写法却会报错。</p><p>此篇介绍一下 TeX 中作为参数的 dimen 和 skip。</p><a id="more"></a><h2 id="作为参数的-dimen"><a href="#作为参数的-dimen" class="headerlink" title="作为参数的 dimen"></a>作为参数的 dimen</h2><p>命令 <code>\kern</code> 的参数是 ⟨dimen⟩，因此我们以它为例。具体来说，TeX 在读入 <code>\kern</code> 这个 token 之后，会先去寻找一个十进制分数（⟨decimal number⟩），而后寻找合法的单位（⟨unit of measure⟩）。在十进制分数和单位之间的空格都会被忽略。在单位之后，则有一个可选空格。</p><p>这里，十进制分数可以是：</p><ul><li>任意在 TeX 中合法的整数；</li><li>任意合法的十进制分数（以句点或逗号作为整数与小数部分的分隔）。</li></ul><p>特别说明一下以逗号作为整数与小数部分的分隔的问题。在中国，大多数时候，我们都以句点作为小数点，来分隔十进制分数的整数与小数部分；例如 <code>1.25</code>。同时，逗号通常用于大数记录时的千分标记；例如 <code>1, 000.25</code>。但是，在部分国家（例如法国和德国），在表示十进制分数时，句点和逗号的用法正好颠倒。因此，<code>1, 000.25</code> 在法国和德国记作 <code>1. 000,25</code>。有趣的是，<code>\kern , pt</code> 是一个合法的铅空。它会产生一个宽度为 <code>0pt</code> 的铅空。这是因为，逗号在此被当做是小数点。而小数点前后的数字是零时，是可以省略的。</p><p>这里的单位，指得是 TeX 接受的，以两个字符表达的长度单位。包括：<code>pt</code>, <code>cm</code>, <code>mm</code>, <code>in</code>, <code>dd</code>, <code>pc</code>, <code>cc</code>, <code>bp</code>, <code>sp</code>, <code>em</code>, <code>ex</code>。对于 pdfTeX 来说，还包括 <code>px</code>。如果 TeX 在读入一个合法的十进制分数之后，没有找到合法的单位，则会报错：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! Illegal unit of measure (pt inserted).</span><br></pre></td></tr></table></figure><p>因此，<code>\kern37ptlike</code> 是合法的。它与 <code>\kern 37 pt like</code> 等价。</p><h2 id="作为参数的-skip"><a href="#作为参数的-skip" class="headerlink" title="作为参数的 skip"></a>作为参数的 skip</h2><p>命令 <code>\hskip</code> 的参数是 ⟨skip⟩，因此我们以它为例。具体来说，TeX 在读入 <code>\hskip</code> 这个 token 之后，会先和上述步骤一样，寻找一个 ⟨dimen⟩，作为 ⟨skip⟩ 的自然长度。而后，TeX 会在展开得到的 token list 当中继续寻找 <code>plus</code>。如果 TeX 找到了 <code>plus</code>，则 TeX 又会去寻找一个 ⟨dimen⟩。不过，此时十进制分数之后，除了长度单位，还可以是 <code>fil</code>, <code>fill</code> 或者 <code>filll</code>。其中 <code>fil(|l|ll)</code> 之后的可选空格会被忽略。特别地，如果没有找到 <code>plus</code>，TeX 也会继续寻找 <code>minus</code>。找到 <code>minus</code> 之后的规则，就跟 <code>plus</code> 的情况一样了。</p><p>因此，在 <code>\hskip 2pt minuscule chances of errors</code> 这个例子中，TeX 读入 <code>2pt</code> 作为 <code>\hskip</code> 的自然长度。而后，尽管没有找到 <code>plus</code>，但找到了 <code>minus</code>——它藏在 <code>minuscule</code> 这个单词中。很不幸，此时在 <code>minus</code> 之后没有一个合法的 ⟨dimen⟩，于是 TeX 会报错。如果你不了解 TeX 读入 ⟨skip⟩ 的规则，那这种报错还是蛮令人挠头的。</p><p>为了避免这些问题，在 ⟨skip⟩ 之后，果断地加一个 <code>\relax</code> 总归是个好主意。</p><h2 id="bonus-奇怪的-fil-l-ll"><a href="#bonus-奇怪的-fil-l-ll" class="headerlink" title="bonus! 奇怪的 fil(|l|ll)"></a>bonus! 奇怪的 <code>fil(|l|ll)</code></h2><p>首先我们来看一个例子。你认为下面的写法是合法的吗？</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">hskip</span></span> 0pt plus 1 fil L l minus 2 fiLL</span><br></pre></td></tr></table></figure><p>答案是合法的……</p><p>事实上，<code>fill</code> 和 <code>filll</code> 并不是 TeX 的关键字。真实情况是，<code>fil</code> 和 <code>l</code> 是 TeX 关键字。而 TeX 在读入 <code>fil</code> 之后，会尝试继续寻找 <code>l</code> 这个关键字。如果找到了，就拼在一起，作为弹力更大的弹簧。此外，TeX 的关键字是不区分大小写的。</p><p>因此，<code>fil L l</code> 就相当于 <code>filll</code>；而 <code>fiLL</code> 就相当于是 <code>fill</code>。也因此，如果你不了解这一点，下面的例子可能会让你很伤脑筋——<code>Let&#39;s Go</code> 当中的 <code>L</code> 怎么不输出了？</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">hskip</span></span> 0pt plus 1fil Let's go</span><br></pre></td></tr></table></figure><p>通常，我们（雾）把这种情况称之为「神秘的 L」。<code>←_←</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触 TeX 稍久的用户，应该多少都接触过 &lt;code&gt;\kern&lt;/code&gt; 和 &lt;code&gt;\hskip&lt;/code&gt; 两个命令。那么不知你是否会好奇，TeX 是如何获取它们的参数的呢？要知道，像 &lt;code&gt;I\kern37ptlike\hskip100ptcake&lt;/code&gt; 这种看上去奇奇怪怪的写法，能正常工作，但 &lt;code&gt;\hskip 2pt minuscule chances of error&lt;/code&gt; 这种看起来正常的写法却会报错。&lt;/p&gt;
&lt;p&gt;此篇介绍一下 TeX 中作为参数的 dimen 和 skip。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Arguments" scheme="https://liam.page/tags/Arguments/"/>
    
      <category term="TeX-core" scheme="https://liam.page/tags/TeX-core/"/>
    
  </entry>
  
  <entry>
    <title>谈谈由异常输入导致的 ReLU 神经元死亡的问题</title>
    <link href="https://liam.page/2018/11/30/vanishing-gradient-of-ReLU-due-to-unusual-input/"/>
    <id>https://liam.page/2018/11/30/vanishing-gradient-of-ReLU-due-to-unusual-input/</id>
    <published>2018-11-30T07:04:41.000Z</published>
    <updated>2019-01-13T10:52:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>最近在阅读 Airbnb 的论文 <a href="https://arxiv.org/abs/1810.09591" target="_blank" rel="noopener">Applying Deep Learning to Airbnb Search</a>。阅读的过程中，我发现作者在谈及特征归一化的必要性时，有如下表述：</p><blockquote><p>Feeding values that are outside the usual range of features can cause large gradients to back propagate. This can permanently shut of activation functions like ReLU due to vanishing gradients.</p></blockquote><p>翻译成中文：</p><blockquote><p>神经网络接受异于常值范围的输入时，在反向传播过程中会产生大的梯度。这种大的梯度，会因梯度消失而永久关闭诸如 ReLU 的激活函数。</p></blockquote><p>我感到有些疑惑。ReLU 正是为了解决梯度消失问题而设计的。为什么这里会提到「因梯度消失而永久关闭诸如 ReLU 的激活函数」呢？</p><p>此篇来讨论这个问题。</p><a id="more"></a><h2 id="ReLU-函数"><a href="#ReLU-函数" class="headerlink" title="ReLU 函数"></a>ReLU 函数</h2><p>ReLU 的全称是 Rectified Linear Unit，即：线性整流单元。对于输入 $x$，它有输出</p><p>$$y = \max(0, x).$$</p><p>相应地，有导数</p><p><code>$$y&#39; = \begin{cases}1 &amp; x &gt; 0, \\ 0 &amp; x &lt; 0.\end{cases}$$</code></p><p>由于 ReLU 在 $x &gt; 0$ 时，导数恒为 1。因此在反向传播的过程中，不会因为导数连乘，而使得梯度特别小，以至于参数无法更新。在这个意义上，ReLU 确实避免了梯度消失问题。</p><h2 id="异常输入杀死神经元"><a href="#异常输入杀死神经元" class="headerlink" title="异常输入杀死神经元"></a>异常输入杀死神经元</h2><p><img src="/uploads/images/MachineLearning/cell.jpg" alt="一个典型的神经元"></p><p>上图是一个典型的神经元。</p><p>现在假设，这个神经元已经经过若干次迭代，其参数 $(\vec w, b)$ 已经迭代得趋于稳定。现在，神经元接收到了一个异常的输入 $\vec x$。比方说，它的某一维特征 <code>$x_i$</code> 与对应的权重 <code>$w_i$</code> 的乘积 <code>$w_ix_i$</code> 非常大。一般来说，这意味着 <code>$x_i$</code> 的绝对值非常大。于是，ReLU 的输入就会很大，对应 ReLU 的输出 $y$ 也就会很大。好了，假设这个 ReLU 神经元期望的输出（ground truth）是 $\hat y$，这个时候损失就会很大——损失一般是 $\lvert y - \hat y\rvert$ 的增函数，记为 $f\bigl(\lvert y - \hat y\rvert\bigr)$。</p><p>于是，在反向传播过程中，传递到 ReLU 的输入时的梯度就是 $g = f\bigl(\lvert y - \hat y\rvert\bigr)$。考虑对于偏置 $b$ 有更新</p><p>$$b \gets b - g\eta.$$</p><p>考虑到 $g$ 是一个很大的正数，于是 $b$ 可能被更新为一个很小的负数。此后，对于常规输入来说，ReLU 的输入大概率是个负数。这也就是说，ReLU 大概率是关闭的。这时，梯度无法经 ReLU 反向传播至 ReLU 的输入函数。也就是说，这个神经元的参数再也不会更新了。这就是所谓的「神经元死亡」。</p><p>如此看来，尽管 ReLU 解决了因激活函数导数的绝对值小于 1，在反向传播连乘的过程中迅速变小消失至 0 的问题，但由于它在输入为负的区段导数恒为零，而使得它对异常值特别敏感。这种异常值可能会使 ReLU 永久关闭，而杀死神经元。</p><h2 id="梯度消失？"><a href="#梯度消失？" class="headerlink" title="梯度消失？"></a>梯度消失？</h2><p>梯度消失（gradient vanishing）是深度神经网络中的一种现象。导致它的原因有很多。由于激活函数导数连乘导致的梯度消失问题最为出名。因此，在很多人心里（包括我过去也是），梯度消失指得就是这种现象。故而对原文的表述有困惑。这种理解实际上是一种不完全的、很偷懒的做法。因此，对概念的理解要着重深入到实际情况中去，而不能囫囵吞枣。</p><p>共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在阅读 Airbnb 的论文 &lt;a href=&quot;https://arxiv.org/abs/1810.09591&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Applying Deep Learning to Airbnb Search&lt;/a&gt;。阅读的过程中，我发现作者在谈及特征归一化的必要性时，有如下表述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Feeding values that are outside the usual range of features can cause large gradients to back propagate. This can permanently shut of activation functions like ReLU due to vanishing gradients.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成中文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;神经网络接受异于常值范围的输入时，在反向传播过程中会产生大的梯度。这种大的梯度，会因梯度消失而永久关闭诸如 ReLU 的激活函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我感到有些疑惑。ReLU 正是为了解决梯度消失问题而设计的。为什么这里会提到「因梯度消失而永久关闭诸如 ReLU 的激活函数」呢？&lt;/p&gt;
&lt;p&gt;此篇来讨论这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="ReLU" scheme="https://liam.page/tags/ReLU/"/>
    
      <category term="Dead" scheme="https://liam.page/tags/Dead/"/>
    
      <category term="Gradient" scheme="https://liam.page/tags/Gradient/"/>
    
      <category term="Vanishing" scheme="https://liam.page/tags/Vanishing/"/>
    
  </entry>
  
  <entry>
    <title>TeX 引擎、格式、发行版之介绍</title>
    <link href="https://liam.page/2018/11/26/introduction-to-TeX-engine-format-and-distribution/"/>
    <id>https://liam.page/2018/11/26/introduction-to-TeX-engine-format-and-distribution/</id>
    <published>2018-11-26T04:37:17.000Z</published>
    <updated>2019-01-13T10:52:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>近日被邀请在知乎上回答<a href="https://www.zhihu.com/question/55137880" target="_blank" rel="noopener">问题</a>。鉴于这个问题已经被答烂了，所以将其存档在博客，以供后享。</p><a id="more"></a><blockquote><p>问题：新手学习 TeX，推荐用什么编译器，是 LaTeX 还是 CTeX？或者说别的什么？<br>原回答：<a href="https://www.zhihu.com/question/55137880/answer/539242148" target="_blank" rel="noopener">https://www.zhihu.com/question/55137880/answer/539242148</a></p></blockquote><p>十秒版本：</p><ol><li>安装 TeX Live：<a href="/texlive/">TeX Live 下载及安装说明</a></li><li>开始菜单中找到随附 TeX Live 安装的 TeXworks，打开。这是一个「TeX 编辑器」。</li><li>阅读入门教程：<a href="/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档</a></li></ol><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><p>与通常用的编程语言的编译器相对应——如 C++ 的 gcc/icc/cl、Java 的 javac——TeX 的「编译器」的真名叫做「TeX 引擎」。TeX 引擎大概有如下一些选择：</p><ul><li>Knuth TeX</li><li>e-TeX</li><li>pdfTeX</li><li>LuaTeX</li><li>XeTeX</li><li>pTeX</li><li>upTeX</li><li>e-upTeX</li><li>pTeX-ng</li></ul><p>其中，Knuth TeX 是高德纳的原版 TeX，现在你基本已经找不到它了。</p><p>e-TeX 是目前事实上的「标准」TeX。尽管它名字中的「e」表示的是「extended」。几乎所有的后续的 TeX 编译器都是在 e-TeX 基础上开发的。</p><p>pdfTeX 是西文世界最常用的 TeX 编译器。通常来说，西文期刊的模板，用 pdfTeX 作为编译器编译不会错。</p><p>LuaTeX 则是作为 pdfTeX 正统后继者出现的。它给 TeX 加入了 Lua 脚本的支持，同时原生支持 Unicode。它可以通过 Lua 回调加入编译器级别的 CJK 字符支持；虽然这样子处理，编译起来效率很低速度很慢。</p><p>XeTeX 是 e-TeX 的另一个分支扩展。它也原生支持 Unicode，并且和 LuaTeX 一样，支持直接调用系统里的字体。目前推荐的中文支持办法，是在 XeTeX 引擎上，使用宏的方式解决的。（xeCJK宏包）</p><p>pTeX 及后续的 TeX 引擎，我们习惯称之为「pTeX 系引擎」。这里的「p」是「publish」的缩写。看得出来，pTeX 的日本作者们「野心」很大的，想要做成一个出版工业级的引擎。pTeX 系引擎里，目前用得最广泛的是 e-upTeX。它可以较好地支持 CJK 字符。不过由于是日本人开发的，所以对日语支持是最好的。用来撰写中文文档，跟我们的习惯有些出入，需要有丰富的经验才能驾驭。pTeX-ng 则是 pTeX 系引擎的新贵，它是由国人Clerk Ma 开发的引擎。其中「ng」是「next generation」的缩写。从命名来看，果然还是要「秒杀」一下我们的邻居的。pTeX-ng 已经相对成熟，不过我用得很少，故不展开。关于 pTeX 系引擎，我有翻译过一系列文章（在此）。</p><p>小结一下。Knuth TeX 是祖宗，目前已被供起来，不太会被用到。e-TeX 开创了新世纪，不过裸用 e-TeX 也很少。pdfTeX 在西文世界里被广泛使用，也很稳定。LuaTeX 是 pdfTeX 的「正统」继承者，不过编译起来慢慢慢。用 XeTeX 来支持中文比较成熟，在中文世界里被推荐使用。pTeX 系引擎源自日本，感兴趣的可以玩一玩。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>TeX 是一个「宏语言」。当你制作了一些特别基础的宏，那么你可以将其发布为一个「格式」（format）。建立在 TeX 之上，有常用的格式：</p><ul><li>plain TeX：这是 Knuth 搞出来的格式，最为基础。</li><li>LaTeX：这是兰伯特搞出来的格式，使用最为广泛。</li><li>ConTeXt：这也是一个格式。不过我基本没用过。</li></ul><p>你在某个格式之上写作文档（manuscript）时，你需要先告诉 TeX 引擎你要载入哪个格式。因为格式使用得太频繁了，所以人们倾向于把格式和引擎打包在一起。这样，就不用每次都告诉 TeX 引擎这件事情了。以 LaTeX 为例，将它与上述引擎打包在一起之后，我们有了：</p><ul><li>e-TeX -&gt; LaTeX</li><li>pdfTeX -&gt; pdfLaTeX</li><li>LuaTeX -&gt; LuaLaTeX</li><li>XeTeX -&gt; XeLaTeX</li><li>pTeX -&gt; pLaTeX</li><li>upTeX -&gt; upLaTeX</li><li>e-upTeX -&gt; e-upLaTeX</li><li>pTeX-ng -&gt; pLaTeX-ng</li></ul><p>尽管真正的「编译器」应该是「TeX 引擎」这一概念。但实际上，在日常沟通中，我们说的「怎么编译」，应当指的是这些「格式与引擎相结合」的产物。</p><p>于是，再小结一下：</p><ul><li>西文文档：pdfLaTeX、XeLaTeX</li><li>中文文档：XeLaTeX</li><li>考古者：LaTeX</li><li>好奇心者：LuaLaTeX、pLaTeX-ng</li><li>好奇心爆棚者：pLaTeX、upLaTeX、e-upLaTeX</li></ul><h2 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h2><p>回到「宏」的问题上来。当你写了一些具有特定功能的宏，你会考虑将其发布为宏包（style package）或者文档类（document class）。也因此，当你想要用某些特定功能，你会倾向于去寻找宏包或者文档类，而不是自己造轮子。若是你每次寻找宏包，都要去互联网上爬文、下载、安装、调试、使用。那么多试几次，你一定会崩溃。</p><p>这引出了「TeX 发行版（distribution）」或者「TeX 系统（system）」或者「TeX 套装（suite）」的概念，表示上述所有引擎、格式、宏包，还有一些为了简便未在此处介绍的驱动、辅助工具，的集合。一般来说 TeX 发行版是用户真正需要安装的东西。也就是说，讨论「新手应该安装什么」的时候，我们实际上讨论的是「新手应该安装什么 TeX 发行版」。</p><p>对于任何阶段的 TeX 用户，这里都推荐安装 TeX Live 这一发行版。若你使用 macOS，则推荐安装基于 TeX Live 开发的 macTeX 这一发行版。</p><p>注意：<strong>不推荐 CTeX 发行版</strong>。没有理由，不听解释。</p><p>注意：名为 CTeX 的，除了发行版，还有一个宏集（多个宏包组成的集合）。它们不是一个东西。尽管我们不推荐 CTeX 发行版，但我们<strong>强烈推荐使用 CTeX 宏集解决中文支持和版式设定的问题</strong>。</p><p>最后，对于新人：<a href="/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日被邀请在知乎上回答&lt;a href=&quot;https://www.zhihu.com/question/55137880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题&lt;/a&gt;。鉴于这个问题已经被答烂了，所以将其存档在博客，以供后享。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Format" scheme="https://liam.page/tags/Format/"/>
    
      <category term="System" scheme="https://liam.page/tags/System/"/>
    
      <category term="Engine" scheme="https://liam.page/tags/Engine/"/>
    
      <category term="Distribution" scheme="https://liam.page/tags/Distribution/"/>
    
      <category term="Compiler" scheme="https://liam.page/tags/Compiler/"/>
    
      <category term="Suite" scheme="https://liam.page/tags/Suite/"/>
    
  </entry>
  
  <entry>
    <title>谈谈二分搜索及其变体</title>
    <link href="https://liam.page/2018/11/23/binary-search-and-its-variants/"/>
    <id>https://liam.page/2018/11/23/binary-search-and-its-variants/</id>
    <published>2018-11-23T10:14:25.000Z</published>
    <updated>2019-01-13T10:52:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>在前作讨论<a href="/2018/08/28/lower-bound-of-comparation-based-sort-algorithm/">基于比较的排序算法的复杂度下界</a>时，我们提及了二分搜索算法。</p><p>二分搜索是一个效率很高的算法。一个良好实现的二分搜索算法，其时间复杂度可以达到 $\Theta(\log n)$，而空间复杂度只有 $O(1)$。特别地，二分搜索算法的描述十分简洁。作为程序员，总是喜欢 clean and powerful 的东西。因此，二分搜索无疑对程序员有巨大的吸引力。</p><p>按照 Knuth 的说法，「尽管第一个二分搜索算法早在1946年就被发表，但第一个没有bug的二分搜索算法却是在12年后才被发表出来」。</p><p>此篇我们讨论二分搜索算法的原理及其各种变体的实现。</p><a id="more"></a><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>二分搜索是针对支持随机访问的有序数据集进行查找操作的算法。最基本的二分搜索，查找的是等于目标元素的元素在数据集中的位置。它的描述十分简单：</p><ul><li>折半取中，判断元素与目标元素的大小关系<ul><li>小于——往前继续折半</li><li>大于——往后继续折半</li><li>等于——返回</li></ul></li></ul><p>此处要注意二分搜索的适用场景：</p><ul><li>依赖顺序表结构</li><li>数据本身必须有序</li><li>数据量相对比较元素的开销要足够大——不然遍历即可</li><li>数据量相对内存空间不能太大——不然顺序表装不下</li></ul><h2 id="二分搜索的实现"><a href="#二分搜索的实现" class="headerlink" title="二分搜索的实现"></a>二分搜索的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,</span><br><span class="line">          <span class="keyword">typename</span> ValueT = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> Compare = <span class="built_in">std</span>::less&lt;ValueT&gt;&gt;</span><br><span class="line">IterT bsearch(IterT first,</span><br><span class="line">              IterT last,</span><br><span class="line">             ValueT target,</span><br><span class="line">            Compare comp = Compare()) &#123;</span><br><span class="line">    IterT result = last;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::distance(first, last) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        IterT mid = first + <span class="built_in">std</span>::distance(first, last) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (comp(*mid, target)) &#123;</span><br><span class="line">            first = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comp(target, *mid)) &#123;</span><br><span class="line">            last = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// equal</span></span><br><span class="line">            result = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一实现有一些技巧值得说一说。</p><p>首先，搜索范围是由 <code>first</code> 和 <code>last</code> 构成的左闭右开区间。在编程中，坚持使用左闭右开区间，能够避免大多数索引越界的问题。这是个好习惯，值得一说。</p><p>其次，这一实现以 <code>mid = low + (high - low) / 2</code> 的方式来确定折半点。与之相对，还有一种写法是 <code>mid = (low + high) / 2</code>。在数学的角度，这两种写法完全相同。但是在计算机的角度，后者可能涉及到整数的溢出。因此，为了避免溢出，我们应当优先采用实现当中的写法。</p><p>最后，这一实现以 <code>while</code> 循环替代递归，节省了函数的递归调用带来的开销。与之搭配，在未能找到目标时，通过调整区间首尾实现折半动作。这种实现方式是处于效率的考量。</p><h2 id="二分搜索的变体"><a href="#二分搜索的变体" class="headerlink" title="二分搜索的变体"></a>二分搜索的变体</h2><p>单就查找等于目标的元素来说，这一任务还有哈希表和查找树等数据结构能高效地完成。相较二分搜索，它们的限制更少——不需要数据集本身有序，也不需要分配连续的大块内存。如此看来，二分搜索似乎只是看起来美好，实际用途应该不广。</p><p>但事实上，二分搜索还有若干变体。这些变体实现的功能，上述这些数据结构通常很难以较低的时间复杂度完成。这些变体才是最能体现二分搜索威力的场景。这里介绍常见的四个变体：</p><ul><li>查找支持随机访问的有序数据集中，第一个等于给定值的元素</li><li>查找支持随机访问的有序数据集中，最后一个等于给定值的元素</li><li>查找支持随机访问的有序数据集中，第一个不小于给定值的元素</li><li>查找支持随机访问的有序数据集中，最后一个不大于给定值的元素</li></ul><p>这些变体的实现也不难。在上述标准二分搜索的基础上，只需要稍加改造即可。需要关注的核心点，就是在不同条件下，区间的首尾应该如何变化。以下是我以 C++ 实现的这些变体。这份实现里值得一提的地方，在基础款的二分搜索实现中已经提过，便不再赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">BsearchPolicy</span> &#123;</span> UNSPECIFIED, FIRST, LAST, FIRST_NOT_LESS, LAST_NOT_GREATER &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,</span><br><span class="line">          <span class="keyword">typename</span> ValueT = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> Compare&gt;</span><br><span class="line">IterT bsearch(IterT first,</span><br><span class="line">              IterT last,</span><br><span class="line">             ValueT target,</span><br><span class="line">            Compare comp,</span><br><span class="line">      BsearchPolicy policy = BsearchPolicy::UNSPECIFIED) &#123;</span><br><span class="line">    IterT result = last;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::distance(first, last) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        IterT mid = first + <span class="built_in">std</span>::distance(first, last) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (policy == BsearchPolicy::FIRST_NOT_LESS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!comp(*mid, target)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == first <span class="keyword">or</span> comp(*(mid - <span class="number">1</span>), target)) &#123;</span><br><span class="line">                    result = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (policy == BsearchPolicy::LAST_NOT_GREATER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp(target, *mid)) &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">std</span>::distance(mid, last) == <span class="number">1</span> <span class="keyword">or</span> comp(target, *(mid + <span class="number">1</span>))) &#123;</span><br><span class="line">                    result = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    first = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// policy == UNSPECIFIED or FIRST or LAST</span></span><br><span class="line">            <span class="keyword">if</span> (comp(*mid, target)) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comp(target, *mid)) &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// equal</span></span><br><span class="line">                <span class="keyword">if</span> (policy == BsearchPolicy::FIRST) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mid == first <span class="keyword">or</span> comp(*(mid - <span class="number">1</span>), *mid)) &#123;</span><br><span class="line">                        result = mid;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        last = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (policy == BsearchPolicy::LAST) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">std</span>::distance(mid, last) == <span class="number">1</span> <span class="keyword">or</span> comp(*mid, *(mid + <span class="number">1</span>))) &#123;</span><br><span class="line">                        result = mid;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        first = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,</span><br><span class="line">          <span class="keyword">typename</span> ValueT = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> Compare = <span class="built_in">std</span>::less&lt;ValueT&gt;&gt;</span><br><span class="line">IterT bsearch(IterT first,</span><br><span class="line">              IterT last,</span><br><span class="line">             ValueT target,</span><br><span class="line">      BsearchPolicy policy = BsearchPolicy::UNSPECIFIED) &#123;</span><br><span class="line">        <span class="keyword">return</span> bsearch(first, last, target, Compare(), policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前作讨论&lt;a href=&quot;/2018/08/28/lower-bound-of-comparation-based-sort-algorithm/&quot;&gt;基于比较的排序算法的复杂度下界&lt;/a&gt;时，我们提及了二分搜索算法。&lt;/p&gt;
&lt;p&gt;二分搜索是一个效率很高的算法。一个良好实现的二分搜索算法，其时间复杂度可以达到 $\Theta(\log n)$，而空间复杂度只有 $O(1)$。特别地，二分搜索算法的描述十分简洁。作为程序员，总是喜欢 clean and powerful 的东西。因此，二分搜索无疑对程序员有巨大的吸引力。&lt;/p&gt;
&lt;p&gt;按照 Knuth 的说法，「尽管第一个二分搜索算法早在1946年就被发表，但第一个没有bug的二分搜索算法却是在12年后才被发表出来」。&lt;/p&gt;
&lt;p&gt;此篇我们讨论二分搜索算法的原理及其各种变体的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Binary Search" scheme="https://liam.page/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Windows 上的 GIF 动画录像机和浏览器</title>
    <link href="https://liam.page/2018/11/23/GIF-aminate-recoder-and-viewer-on-Windows/"/>
    <id>https://liam.page/2018/11/23/GIF-aminate-recoder-and-viewer-on-Windows/</id>
    <published>2018-11-23T03:16:36.000Z</published>
    <updated>2019-01-13T10:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p>继续配置电脑的旅程。</p><p>此篇推荐两个小工具。它们的大小都不足 1MiB，但是都非常好用。一个是 GIF 录屏工具，一个是 GIF 查看器。</p><a id="more"></a><h2 id="LICECap"><a href="#LICECap" class="headerlink" title="LICECap"></a>LICECap</h2><p>LICECap 是一款小巧的 GIF 录屏工具，其安装包大小只有 282KiB。它的下载地址是：<a href="https://licecap.en.softonic.com/?ex=BB-682.0" target="_blank" rel="noopener">https://licecap.en.softonic.com/?ex=BB-682.0</a>。</p><h2 id="GIF-Viewer"><a href="#GIF-Viewer" class="headerlink" title="GIF Viewer"></a>GIF Viewer</h2><p>从 Windows Vista 开始，系统自带的图片查看器不支持查看 GIF 动画。因此在 Windows 上打开 GIF 动画，系统会自动打开臃肿的 Internet Explorer。这实在不能忍。</p><p>在国外论坛上找到了名为 GIF Viewer 的小工具。它的安装包大小只有 134KiB，下载地址是：<a href="https://sourceforge.net/projects/gifviewer/" target="_blank" rel="noopener">https://sourceforge.net/projects/gifviewer/</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续配置电脑的旅程。&lt;/p&gt;
&lt;p&gt;此篇推荐两个小工具。它们的大小都不足 1MiB，但是都非常好用。一个是 GIF 录屏工具，一个是 GIF 查看器。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="GIF" scheme="https://liam.page/tags/GIF/"/>
    
      <category term="Recoder" scheme="https://liam.page/tags/Recoder/"/>
    
      <category term="Viewer" scheme="https://liam.page/tags/Viewer/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 7 的锁屏界面上执行命令/程序</title>
    <link href="https://liam.page/2018/11/22/execute-command-or-executables-on-Windows-login-page/"/>
    <id>https://liam.page/2018/11/22/execute-command-or-executables-on-Windows-login-page/</id>
    <published>2018-11-22T03:07:27.000Z</published>
    <updated>2019-01-13T10:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2018/11/21/replace-the-background-of-login-page/">前作</a>提到了如何在 Windows 7 上更换锁屏界面的背景图片。这就给我创造了一个新的需求——如何为锁屏界面截图？</p><p>此篇以此为例，讲讲如何在锁屏界面上执行命令/程序。</p><a id="more"></a><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在锁屏界面截图需要解决的主要问题是：</p><ul><li>如何在用户没有登录的情况下，执行命令；</li><li>有什么可用的截图工具能够在锁屏界面进行截图？</li></ul><h2 id="在锁屏界面执行命令"><a href="#在锁屏界面执行命令" class="headerlink" title="在锁屏界面执行命令"></a>在锁屏界面执行命令</h2><h3 id="PsExec"><a href="#PsExec" class="headerlink" title="PsExec"></a>PsExec</h3><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec" target="_blank" rel="noopener">PsExec</a> 是 M$ 提供的一款在远程机器上执行命令的小工具。正如 Linux 上常用的 SSH 可以将本机作为「远程机器」登录一样，PsExec 也能完成这个任务。此外，PsExec 的 <code>-x</code> 选项，能够在 Windows 登录页面显示 UI。这样一来，我们就能利用 PsExec 在锁屏界面执行命令了。</p><p>具体操作路径如下：</p><ul><li>下载：<a href="https://download.sysinternals.com/files/PSTools.zip" target="_blank" rel="noopener">https://download.sysinternals.com/files/PSTools.zip</a></li><li>安装：打开 <code>.zip</code> 包，将 <code>PsExec.exe</code> 复制到 <code>C:\Windows\System32</code> 当中</li><li>在开始菜单中搜索 <code>cmd</code>，右键「以管理员身份运行」</li><li>执行命令 <code>psexec -sx cmd.exe</code>；其中 <code>-s</code> 表示以系统权限运行，<code>-x</code> 表示在锁屏界面显示 UR</li><li>按 <code>Win + L</code> 锁屏</li><li>按 <code>Alt + Tab</code> 切换到 <code>cmd.exe</code> 的 UI</li></ul><p><img src="/uploads/images/computer-skills/cmd_on_login.jpg" alt=""></p><h3 id="轻松访问"><a href="#轻松访问" class="headerlink" title="轻松访问"></a>轻松访问</h3><p>事实上，Windows 的轻松访问有各种 bug。利用它可以实现很多 hacky 的功能。此次我们也来利用这一小漏洞。</p><h4 id="直接替换可执行文件"><a href="#直接替换可执行文件" class="headerlink" title="直接替换可执行文件"></a>直接替换可执行文件</h4><p>默认的轻松访问可执行文件位于 <code>C:\Windows\System32\Utilman.exe</code>。我们可以备份它，然后将其替换为其它可执行文件。如此一来，在锁屏界面点击轻松访问按钮，就能执行被替换的可执行文件了。</p><h4 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h4><p>我们也可以通过修改注册表，将轻松访问的可执行文件路径，指向其它可执行文件。</p><ul><li>在开始菜单中搜索 <code>regedit</code>，回车执行</li><li>导航路径<ul><li><code>HKEY_LOCAL_MACHINE</code></li><li><code>SOFTWARE</code></li><li><code>Micorsoft</code></li><li><code>Windows NT</code></li><li><code>CurrentVersion</code></li><li><code>Image File Execution Options</code></li></ul></li><li>右键，新建名为 <code>Utilman.exe</code> 的项</li><li>在右侧新建名为 <code>Debugger</code> 的字符串值</li><li>右键双击 <code>Debugger</code> 字符串值，将其值设置为目标可执行文件的完整路径</li></ul><h2 id="实际截图试试看"><a href="#实际截图试试看" class="headerlink" title="实际截图试试看"></a>实际截图试试看</h2><p>这里，我使用 <a href="http://sourceforge.net/projects/login7/" target="_blank" rel="noopener">Win 7 Logon Screen Capture</a> 这个小工具来截图。我将其下载解压到了 <code>E:\Tools\Login Screen Capture.exe</code> 位置。而后，我们只需要通过上述两种方式之任一，在锁屏界面执行截图工具即可。</p><p>以下即是我截图的结果。</p><p><img src="/uploads/images/computer-skills/login_photo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2018/11/21/replace-the-background-of-login-page/&quot;&gt;前作&lt;/a&gt;提到了如何在 Windows 7 上更换锁屏界面的背景图片。这就给我创造了一个新的需求——如何为锁屏界面截图？&lt;/p&gt;
&lt;p&gt;此篇以此为例，讲讲如何在锁屏界面上执行命令/程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Screenshot" scheme="https://liam.page/tags/Screenshot/"/>
    
      <category term="PsExec" scheme="https://liam.page/tags/PsExec/"/>
    
  </entry>
  
  <entry>
    <title>更换 Windows 7 锁屏界面的背景</title>
    <link href="https://liam.page/2018/11/21/replace-the-background-of-login-page/"/>
    <id>https://liam.page/2018/11/21/replace-the-background-of-login-page/</id>
    <published>2018-11-21T05:42:27.000Z</published>
    <updated>2019-01-13T10:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p>Windows 7 在登录时默认的背景图片是一片蓝色。作为一个程序员，我会倾向于认为，这片蓝色是一张图片资源。因此，它是可以被更换的。</p><p>这篇介绍如何更换 Windows 7 锁屏界面的背景。</p><a id="more"></a><h2 id="允许自定义"><a href="#允许自定义" class="headerlink" title="允许自定义"></a>允许自定义</h2><p>经过一番搜索，我并没能找到那一片蓝的资源图。不过，爬文过程中，我发现 OEM 厂往往会将锁屏界面替换为 OME 自定义的图片。而这个开关需要在注册表中打开。具体来说：</p><blockquote><p>开始菜单 -&gt; 搜索 -&gt; Regedit.exe -&gt; 导航至 <code>HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Authentication/LogonUI/Background</code> -&gt; 修改 <code>OEMBackground</code> 的值为 1。</p></blockquote><h2 id="设置-OEM-锁屏背景图片资源"><a href="#设置-OEM-锁屏背景图片资源" class="headerlink" title="设置 OEM 锁屏背景图片资源"></a>设置 OEM 锁屏背景图片资源</h2><p>新建目录 <code>C:\Windows\System32\oobe\info\backgrounds</code>，而后将资源图片保存为 <code>.jpg</code> 格式，并重命名为 <code>backgroundDefault.jpg</code>。特别地，要注意它的体积不能超过 <code>256KiB</code>。</p><h2 id="锁屏查看效果"><a href="#锁屏查看效果" class="headerlink" title="锁屏查看效果"></a>锁屏查看效果</h2><p><img src="/uploads/images/computer-skills/login_photo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows 7 在登录时默认的背景图片是一片蓝色。作为一个程序员，我会倾向于认为，这片蓝色是一张图片资源。因此，它是可以被更换的。&lt;/p&gt;
&lt;p&gt;这篇介绍如何更换 Windows 7 锁屏界面的背景。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Background" scheme="https://liam.page/tags/Background/"/>
    
      <category term="Windows 7" scheme="https://liam.page/tags/Windows-7/"/>
    
      <category term="Login" scheme="https://liam.page/tags/Login/"/>
    
  </entry>
  
  <entry>
    <title>彻底关闭 ThinkPad 的触控板</title>
    <link href="https://liam.page/2018/11/20/turn-off-touchpad-of-ThinkPad/"/>
    <id>https://liam.page/2018/11/20/turn-off-touchpad-of-ThinkPad/</id>
    <published>2018-11-20T13:34:35.000Z</published>
    <updated>2019-01-13T10:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇简单的记录。</p><p>新电脑是 ThinkPad。众所周知，TP 的小红点（TrackPoint）很好用。相应的，TP 的触控板就不怎么好用了。特别地，TP 的触控板在打字的时候，经常会误触导致光标漂移。</p><p>因此，我需要关闭触控板。</p><a id="more"></a><p>网上爬文，大多数结果都告诉要安装 UltraNav 的驱动。从联想官网上下载安装驱动后，TP 提示说找不到相关设备。看起来是驱动与硬件不匹配导致的。遂删除驱动。</p><p>最后想到，BIOS 能控制各种输入输出设备。遂在重启时进入 BIOS 设置（Enter 键），找到触控板（TouchPad）设置，将其设置为 disabled。完成！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reboot</span><br><span class="line">Hold &apos;Enter&apos;</span><br><span class="line">BIOS -&gt; config -&gt; keyboard/mouse -&gt; TouchPad (disabled)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇简单的记录。&lt;/p&gt;
&lt;p&gt;新电脑是 ThinkPad。众所周知，TP 的小红点（TrackPoint）很好用。相应的，TP 的触控板就不怎么好用了。特别地，TP 的触控板在打字的时候，经常会误触导致光标漂移。&lt;/p&gt;
&lt;p&gt;因此，我需要关闭触控板。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="ThinkPad" scheme="https://liam.page/tags/ThinkPad/"/>
    
      <category term="TouchPad" scheme="https://liam.page/tags/TouchPad/"/>
    
  </entry>
  
  <entry>
    <title>博弈论通俗演义：美女的硬币游戏与为啥你炒股总亏</title>
    <link href="https://liam.page/2018/11/14/game-of-beauty-and-stock-market/"/>
    <id>https://liam.page/2018/11/14/game-of-beauty-and-stock-market/</id>
    <published>2018-11-14T02:37:08.000Z</published>
    <updated>2019-01-13T10:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p>这是博弈论通俗演义的第二篇。我们首先分析经典的「美女的硬币游戏」，而后挖掘它背后的模型，再引出「为啥你炒股总亏」的问题。</p><a id="more"></a><h2 id="美女的硬币游戏"><a href="#美女的硬币游戏" class="headerlink" title="美女的硬币游戏"></a>美女的硬币游戏</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>美女的硬币游戏描述如下：</p><p>美女<strong>提议</strong>与你进行一个游戏，规则如下：</p><ul><li>双方各持一枚硬币，同时亮出。<ul><li>若双方均为正面，则美女给你 3 元奖励；</li><li>若双方均为反面，则美女给你 1 元奖励；</li><li>若双方正反不一致，则你输给美女 2 元。</li></ul></li></ul><p>那么现在的问题是：</p><ul><li>如果美女不怀好意，想要在你这里赚钱，她应该怎么做？</li><li>你是否有必胜的策略，能在这个游戏中赚到美女的奖励？</li></ul><h3 id="看似公平"><a href="#看似公平" class="headerlink" title="看似公平"></a>看似公平</h3><p>我们可以用一张表格表示这个游戏可能出现的各种情况下，你的收益。</p><table><thead><tr><th>↓美女·你→</th><th>正</th><th>反</th></tr></thead><tbody><tr><td>正</td><td>3</td><td>-2</td></tr><tr><td>反</td><td>-2</td><td>1</td></tr></tbody></table><p>乍看起来，总共有 4 中情况，每种情况出现的概率都是 $\frac{1}{4}$。于是这个游戏是公平的，不管怎样，一直玩下去你也不会亏钱。对于广大单身男同胞，可能还获得了一个与美女搭讪的机会。看上去不亏。但事实真是这样吗？</p><h3 id="藏在概率里的陷阱"><a href="#藏在概率里的陷阱" class="headerlink" title="藏在概率里的陷阱"></a>藏在概率里的陷阱</h3><p>游戏是公平的，这个推论建立在上述 4 种情况出现的概率均等的前提下。某种程度上，这受到了各种「抛硬币实验」的影响。——大家可能默认硬币出现正反面的概率是均等的，都为 $\frac{1}{2}$。但是这个前提在当前问题中不成立。</p><p>实际上，参与游戏的双方，可以选择以一定的概率亮出正面或反面。我们假设美女亮出正面的概率是 $p$，而你亮出正面的概率是 $q$。于是，对于你来说，参与游戏获得收益的期望是</p><p><code>$$\begin{aligned}    E = {}&amp; 3pq - p(1 - q) - 2(1 - p)q + 2(1 - p)(1 - q) \\      = {}&amp; 8pq - 3p - 3q + 1.\end{aligned}$$</code></p><p>显然，若 $p$, $q$ 不全为 $\frac{1}{2}$ 时，期望不一定为 0。它可能大于 0 也可能小于 0。</p><h3 id="不怀好意的美女"><a href="#不怀好意的美女" class="headerlink" title="不怀好意的美女"></a>不怀好意的美女</h3><p>现在假设美女不怀好意。也就是说，她想从你手中赢钱。那么美女要怎样做呢？</p><p>考虑 $E$ 是你收益的期望。那么，不怀好意的美女希望通过改变 $p$ 的值，使得 $E &lt; 0$。这即是</p><p><code>$$\begin{aligned}                    {}&amp;{} E &lt;  0 \\    \Leftrightarrow {}&amp;{} 8pq - 3p - 3q + 1 &lt;  0 \\    \Leftrightarrow {}&amp;{} p(8q - 3) &lt; 3q - 1.\end{aligned}$$</code></p><p>考虑当 $8q - 3 &gt; 0$，即 $q &gt; \frac{3}{8}$ 时，原式等价于</p><p>$$p &lt; \frac{3q - 1}{8q - 3}.$$</p><p>由于 $f(q) = \frac{3q - 1}{8q - 3}$ 在 $\bigl(\frac{3}{8}, 1\bigr]$ 上是 $q$ 的减函数。因此当 $p &lt; f(1) = \frac{2}{5}$ 时，原式成立。</p><p>再考虑当 $8q - 3 &lt; 0$，即 $q &lt; \frac{3}{8}$ 时，原式等价于</p><p>$$p &gt; \frac{3q - 1}{8q - 3}.$$</p><p>由于 $f(q) = \frac{3q - 1}{8q - 3}$ 在 $\bigl[0, \frac{3}{8}\bigr)$ 上是 $q$ 的减函数。因此当 $p &gt; f(0) = \frac{1}{3}$ 时，原式成立。</p><p>再考虑当 $8q - 3 = 0$，即 $q = \frac{3}{8}$ 时，对任意的 $p \in [0, 1]$ 成立</p><p>$$E = p(8q - 3) - 3q + 1 = -\frac{1}{8}.$$</p><p>综上所述，当 $p \in \bigl(\frac{1}{3}, \frac{2}{5}\bigr)$ 时，无论 $q$ 如何取值，美女都能从你手中赢钱。</p><h3 id="苦苦挣扎的你"><a href="#苦苦挣扎的你" class="headerlink" title="苦苦挣扎的你"></a>苦苦挣扎的你</h3><p>从上一节中，我们已经可以看出，事实上美女是有必胜的策略的。因此原题第二个问题的答案就显而易见了——你没有必胜的策略。不过不死心的你，可能还想要从你的角度来分析一下。</p><p>我们考虑一种极端情况，即「你」的收益最大化的情况，你亮出正面的概率 $q$ 应当满足什么条件。为了让美女无机可乘，你应当调整概率 $q$，使得无论美女亮出正面还是反面，你的收益的期望相等。因为，若不然，美女就可以通过调整概率 $p$，使得正面或反面出现的次数更多，来降低你的总收益。——这与「你的收益最大化」的假设矛盾。</p><p>首先，我们列出当美女亮出正面或反面时，你的收益的期望：</p><p><code>$$\begin{cases}    E_{+} = 3q - 2(1 - q), \\    E_{-} = -2q + (1 - q).\end{cases}$$</code></p><p>现在，令 <code>$E_{+} = E_{-}$</code>，则有一元一次方程的解 $q = \frac{3}{8}$。这就是说，当你亮出正面的概率是 $\frac{3}{8}$ 时，你的收益最大。而最大的收益是多少呢？——我们在上一节已经计算过了</p><p>$$E\Bigl(q = \frac{3}{8}\Bigr) = -\frac{1}{8}.$$</p><p>这也就是说，最好的情况，你平均每一局游戏也得亏 $-\frac{1}{8}$ 元钱。因此，你是没有必胜策略的（相反美女是有的）。</p><h2 id="美女硬币游戏的要义和模型"><a href="#美女硬币游戏的要义和模型" class="headerlink" title="美女硬币游戏的要义和模型"></a>美女硬币游戏的要义和模型</h2><p>美女硬币游戏的要义，其实就是她的「提议」。她的提议看起来是一个公平的游戏，但实际上是她占据了话语权。具体到游戏中，就是占据了游戏规则的制定权。那么，美女硬币游戏中的美女，事实上就具有了[前作]中提及的先发优势。</p><h3 id="更抽象的问题"><a href="#更抽象的问题" class="headerlink" title="更抽象的问题"></a>更抽象的问题</h3><p>我们说，假设越强，结论就越弱；反过来，假设越弱，结论就越强。现在我们削弱美女硬币游戏的假设，让它变得更抽象，从而加强我们已有的结论。</p><p>考虑到硬币的正反面地位等同。我们不妨设「正正」的情况，收益为 $a$；而「反反」的情况，收益为 $b$。为了让游戏「看起来公平」，我们需要保证「正反」和「反正」的情况，收益为 $-\frac{a + b}{2}$。</p><table><thead><tr><th>↓·→</th><th>正</th><th>反</th></tr></thead><tbody><tr><td>正</td><td>$a$</td><td>$-\frac{a + b}{2}$</td></tr><tr><td>反</td><td>$-\frac{a + b}{2}$</td><td>$b$</td></tr></tbody></table><p>这种情况下，对手收益的期望是</p><p><code>$$\begin{aligned}    E = {}&amp; apq - \frac{a + b}{2}p(1 - q) - \frac{a + b}{2}(1 - p)q + b(1 - p)(1 - q) \\      = {}&amp; 2(a + b)pq - \frac{a + 3b}{2}p - \frac{a + 3b}{2}q + b.\end{aligned}$$</code></p><p>因此，你收益最大时应满足</p><p>$$q = \frac{a + 3b}{4(a + b)}.$$</p><p>此时，你收益的期望是</p><p>$$E = -\frac{(a - b)^{2}}{8(a + b)}.$$</p><p>考虑到 $(a - b)^{2} &gt; 0$ 对任意的 $a \neq b$ 总是成立。于是，我们得到了一个假设很弱的结论：</p><blockquote><p>若你的对手巧妙地设置 $a$ 和 $b$ 的值，使得 $a \neq b$ 及 $a + b &gt; 0$，那么你就总是会输。</p></blockquote><p>从这里，我们也能看出，所谓的「先发优势」是何等巨大。先发者只需要稍微设置一下游戏规则，你就只能输输输了。</p><h3 id="炒股还是不炒股？这不是个问题。"><a href="#炒股还是不炒股？这不是个问题。" class="headerlink" title="炒股还是不炒股？这不是个问题。"></a>炒股还是不炒股？这不是个问题。</h3><p>现在我们回到炒股的问题上来。在股市中，有如下对应关系。</p><table><thead><tr><th>美女的硬币</th><th>股市</th></tr></thead><tbody><tr><td>美女</td><td>庄家</td></tr><tr><td>亮正面</td><td>做多</td></tr><tr><td>亮反面</td><td>做空</td></tr><tr><td>收益</td><td>收益</td></tr></tbody></table><p>如此一来，结论就显而易见了。在一个由庄家控盘的股票上，不论你怎么买入卖出，庄家都很容易通过一定的策略让你（和其他散户）的收益期望最大值为负。如此一来，结论就是：庄家总是能赚钱，而散户长远看总是亏钱。</p><p>因此，炒股还是不炒股？这不是个问题。珍爱资产，远离股市——特别是庄家多的题材股。如果你一定要炒股，那么，请在合适的时机投资你了解、看好的基本面良好的股票。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是博弈论通俗演义的第二篇。我们首先分析经典的「美女的硬币游戏」，而后挖掘它背后的模型，再引出「为啥你炒股总亏」的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Game Theory" scheme="https://liam.page/tags/Game-Theory/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 黑魔法（六）：使用比逼格更逼格的定界符</title>
    <link href="https://liam.page/2018/11/09/the-bigger-than-bigger-delimiter-in-LaTeX/"/>
    <id>https://liam.page/2018/11/09/the-bigger-than-bigger-delimiter-in-LaTeX/</id>
    <published>2018-11-09T03:34:49.000Z</published>
    <updated>2019-01-13T10:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p>通常，我们建议在 LaTeX 中使用 LaTeX 提供的 <code>\big</code>, <code>\Big</code>, <code>\bigg</code>, <code>\Bigg</code> 一系列命令，代替 TeX 默认的 <code>\left</code> 和 <code>\right</code> 来调整定界符的大小。然而，尽管最大提供了 <code>\Bigg</code> 的命令，但有时候仍然不够用。</p><p>此篇介绍如何定义 <code>\biggg</code>, <code>\Biggg</code>, <code>\bigggg</code> 和 <code>\Bigggg</code> 系列命令。我们的口号是「比逼格更逼格」（bigger than bigger）！</p><a id="more"></a><h2 id="挖掘代码"><a href="#挖掘代码" class="headerlink" title="挖掘代码"></a>挖掘代码</h2><h3 id="big-系列命令"><a href="#big-系列命令" class="headerlink" title="\big 系列命令"></a><code>\big</code> 系列命令</h3><p>要定义更大的定界符修饰，就必须搞清楚 <code>\big</code> 系列命令是如何定义的。首先，我们使用 <code>kpsewhich amsmath.sty</code> 找到 <code>amsmath.sty</code> 在系统中的路径。而后打开样式文件，搜寻 <code>\big</code> 的定义。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\big&#125;</span><span class="string">&#123;\bBigg@\@ne&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\Big&#125;</span><span class="string">&#123;\bBigg@&#123;1.5&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\bigg&#125;</span><span class="string">&#123;\bBigg@\tw@&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\Bigg&#125;</span><span class="string">&#123;\bBigg@&#123;2.5&#125;</span></span>&#125;</span><br></pre></td></tr></table></figure><h3 id="bBigg-命令"><a href="#bBigg-命令" class="headerlink" title="\bBigg@ 命令"></a><code>\bBigg@</code> 命令</h3><p>显而易见，核心是 <code>\bBigg@</code> 这个命令。它可以根据其后第一个 token 决定定界符的放大程度。注意，这里 <code>\@ne</code> 表示 <code>{1}</code>，而 <code>\tw@</code> 表示 <code>{2}</code>——这是令人讨厌的 LaTeX 内核编程 trick。于是我们继续去寻找 <code>\bBigg@</code> 的定义。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bBigg</span></span>@#1#2&#123;<span class="comment">%</span></span><br><span class="line">  &#123;<span class="tag">\<span class="name">@</span></span>mathmeasure<span class="tag">\<span class="name">z</span></span>@&#123;<span class="tag">\<span class="name">nulldelimiterspace</span></span><span class="tag">\<span class="name">z</span></span>@&#125;<span class="comment">%</span></span><br><span class="line">     &#123;<span class="tag">\<span class="name">left</span></span>#2<span class="tag">\<span class="name">vcenter</span></span> to#1<span class="tag">\<span class="name">big</span></span>@size&#123;&#125;<span class="tag">\<span class="name">right</span></span>.&#125;<span class="comment">%</span></span><br><span class="line">   <span class="tag">\<span class="name">box</span></span><span class="tag">\<span class="name">z</span></span>@&#125;&#125;</span><br></pre></td></tr></table></figure><p>很显然，<code>\bBigg@</code> 命令内部也是通过 TeX 原始的 <code>\left</code> 和 <code>\right</code> 命令来调整定界符（<code>#2</code>）的大小的。不过，它还额外处理了左右的空距。这里我们知道就行了，不去深究。</p><h3 id="bigl-和-bigr-系列命令"><a href="#bigl-和-bigr-系列命令" class="headerlink" title="\bigl 和 \bigr 系列命令"></a><code>\bigl</code> 和 <code>\bigr</code> 系列命令</h3><p>接下来我们继续挖掘 <code>\bigl</code> 和 <code>\bigr</code> 系列命令的定义。它们定义在 LaTeX2e 内核当中，因此我们通过执行 <code>texdoc source2e</code> 就能看到它们的定义了。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigl</span><span class="string">&#123;\mathopen\big&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigm</span><span class="string">&#123;\mathrel\big&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigr</span><span class="string">&#123;\mathclose\big&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigl</span><span class="string">&#123;\mathopen\Big&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigm</span><span class="string">&#123;\mathrel\Big&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigr</span><span class="string">&#123;\mathclose\Big&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggl</span><span class="string">&#123;\mathopen\bigg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggm</span><span class="string">&#123;\mathrel\bigg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggr</span><span class="string">&#123;\mathclose\bigg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggl</span><span class="string">&#123;\mathopen\Bigg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggm</span><span class="string">&#123;\mathrel\Bigg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggr</span><span class="string">&#123;\mathclose\Bigg&#125;</span></span></span><br></pre></td></tr></table></figure><p>很显然，它们就只是用 <code>\mathopen</code>, <code>\mathrel</code> 和 <code>\mathclose</code> 宏来修饰了一下对应的定界符修饰命令。</p><h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><p>据此，我们可以定义更有逼格的定界符修饰命令了。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% \RequirePackage&#123;amsmath&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\biggg&#125;</span><span class="string">&#123;\bBigg@&#123;3&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigggl</span><span class="string">&#123;\mathopen\biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigggm</span><span class="string">&#123;\mathrel\biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigggr</span><span class="string">&#123;\mathclose\biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\Biggg&#125;</span><span class="string">&#123;\bBigg@&#123;3.5&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigggl</span><span class="string">&#123;\mathopen\Biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigggm</span><span class="string">&#123;\mathrel\Biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigggr</span><span class="string">&#123;\mathclose\Biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\bigggg&#125;</span><span class="string">&#123;\bBigg@&#123;4&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggggl</span><span class="string">&#123;\mathopen\bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggggm</span><span class="string">&#123;\mathrel\bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggggr</span><span class="string">&#123;\mathclose\bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\Bigggg&#125;</span><span class="string">&#123;\bBigg@&#123;4.5&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggggl</span><span class="string">&#123;\mathopen\Bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggggm</span><span class="string">&#123;\mathrel\Bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggggr</span><span class="string">&#123;\mathclose\Bigggg&#125;</span></span></span><br></pre></td></tr></table></figure><p>注意，这段代码在普通的 LaTeX 文档中，需要使用 <code>\makeatletter</code> 和 <code>\makeatother</code> 来改变 <code>@</code> 字符的分类码，以便正确定义命令。</p><p>接下来我们实际使用看看。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">makeatletter</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\biggg&#125;</span><span class="string">&#123;\bBigg@&#123;3&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigggl</span><span class="string">&#123;\mathopen\biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigggm</span><span class="string">&#123;\mathrel\biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">bigggr</span><span class="string">&#123;\mathclose\biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\Biggg&#125;</span><span class="string">&#123;\bBigg@&#123;3.5&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigggl</span><span class="string">&#123;\mathopen\Biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigggm</span><span class="string">&#123;\mathrel\Biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Bigggr</span><span class="string">&#123;\mathclose\Biggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\bigggg&#125;</span><span class="string">&#123;\bBigg@&#123;4&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggggl</span><span class="string">&#123;\mathopen\bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggggm</span><span class="string">&#123;\mathrel\bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">biggggr</span><span class="string">&#123;\mathclose\bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\Bigggg&#125;</span><span class="string">&#123;\bBigg@&#123;4.5&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggggl</span><span class="string">&#123;\mathopen\Bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggggm</span><span class="string">&#123;\mathrel\Bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">Biggggr</span><span class="string">&#123;\mathclose\Bigggg&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">makeatother</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">[</span></span></span><br><span class="line">    <span class="tag">\<span class="name">Biggggl</span><span class="string">[\biggggl[\Bigggl[\bigggl[\Biggl[\biggl[\Bigl[\bigl[[ x ]</span></span><span class="tag">\<span class="name">bigr</span></span>]<span class="tag">\<span class="name">Bigr</span></span>]<span class="tag">\<span class="name">biggr</span></span>]<span class="tag">\<span class="name">Biggr</span></span>]<span class="tag">\<span class="name">bigggr</span></span>]<span class="tag">\<span class="name">Bigggr</span></span>]<span class="tag">\<span class="name">biggggr</span></span>]<span class="tag">\<span class="name">Biggggr</span></span>]</span><br><span class="line"><span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="/uploads/images/LaTeX/bigger-than-bigger-delimiters.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常，我们建议在 LaTeX 中使用 LaTeX 提供的 &lt;code&gt;\big&lt;/code&gt;, &lt;code&gt;\Big&lt;/code&gt;, &lt;code&gt;\bigg&lt;/code&gt;, &lt;code&gt;\Bigg&lt;/code&gt; 一系列命令，代替 TeX 默认的 &lt;code&gt;\left&lt;/code&gt; 和 &lt;code&gt;\right&lt;/code&gt; 来调整定界符的大小。然而，尽管最大提供了 &lt;code&gt;\Bigg&lt;/code&gt; 的命令，但有时候仍然不够用。&lt;/p&gt;
&lt;p&gt;此篇介绍如何定义 &lt;code&gt;\biggg&lt;/code&gt;, &lt;code&gt;\Biggg&lt;/code&gt;, &lt;code&gt;\bigggg&lt;/code&gt; 和 &lt;code&gt;\Bigggg&lt;/code&gt; 系列命令。我们的口号是「比逼格更逼格」（bigger than bigger）！&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://liam.page/categories/LaTeX/"/>
    
    
      <category term="Delimiter" scheme="https://liam.page/tags/Delimiter/"/>
    
      <category term="amsmath" scheme="https://liam.page/tags/amsmath/"/>
    
  </entry>
  
  <entry>
    <title>谈谈期望最大算法</title>
    <link href="https://liam.page/2018/11/08/Expectation-Maximization-Algorithm/"/>
    <id>https://liam.page/2018/11/08/Expectation-Maximization-Algorithm/</id>
    <published>2018-11-08T08:53:52.000Z</published>
    <updated>2019-01-13T10:52:46.113Z</updated>
    
    <content type="html"><![CDATA[<p>本篇讨论期望最大算法算法（Expecation Maximization Algorithm，EM 算法）。</p><a id="more"></a><h2 id="从极大似然估计到-EM-算法"><a href="#从极大似然估计到-EM-算法" class="headerlink" title="从极大似然估计到 EM 算法"></a>从极大似然估计到 EM 算法</h2><p>EM 算法和极大似然有着很深的联系。因此在讨论 EM 算法之前，我们首先通过一个例子来回顾极大似然算法。</p><h3 id="极大似然"><a href="#极大似然" class="headerlink" title="极大似然"></a>极大似然</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>假设有一枚硬币 A；投掷硬币 A 后结果为正面的概率记为 $p$。我们将投掷硬币结果为正面的实验记作 $1$，反面的实验记作 $0$。独立重复 $n = 10$ 次实验，观测结果如下：</p><p>$$1, 1, 0, 1, 0, 0, 1, 0, 1, 1.$$</p><p>现在的问题是要估计投掷硬币 A 后结果为正面的概率 $p$。</p><h4 id="整理似然函数和对数似然函数"><a href="#整理似然函数和对数似然函数" class="headerlink" title="整理似然函数和对数似然函数"></a>整理似然函数和对数似然函数</h4><p>显而易见，投掷硬币 A 后的结果应当服从二项分布。于是我们可以整理似然函数：</p><p><code>$$L(\theta) = L(x_1, x_2, \ldots, x_{10} \mid \theta) = \prod_{i = 1}^{10} p(x_i\mid \theta) = p^{6}(1 - p)^{4}.$$</code></p><p>由于连乘不方便分析和优化，因此我们对似然函数取对数，构造对数似然函数，将连乘转换为连加。</p><p><code>$$H(\theta) = \ln L(\theta) = \sum_{i = 1}^{10}\ln p(x_i \mid \theta) = (\ln p)^{6}\cdot\bigl(\ln (1 - p)\bigr)^{4}.$$</code></p><h4 id="求解极大化问题"><a href="#求解极大化问题" class="headerlink" title="求解极大化问题"></a>求解极大化问题</h4><p>根据似然函数或者对数似然函数，构造极大化问题。此处以似然函数为例：</p><p>$$\hat \theta = \underset{\theta}{\arg\,\max} L(\theta).$$</p><p>对于这类简单的似然函数，我们可以对它求导，令导数为 $0$，而后得到参数值；对于复杂的似然函数极大化问题，我们可以用牛顿法、拟牛顿法、梯度上升法等方法求解。此处</p><p><code>$$\frac{\mathop{}\!\mathrm{d}L(\theta)}{\mathop{}\!\mathrm{d}\theta} = \frac{\mathop{}\!\mathrm{d}L}{\mathop{}\!\mathrm{d}p} = 2p^{5}(1 - p)^{3}(3 - 5p).$$</code></p><p>令导函数为 $0$，得到似然方程</p><p>$$2p^{5}(1 - p)^{3}(3 - 5p) = 0$$</p><p>对似然方程的三个不重复解代入原函数依次验证，可知当 $p = \frac{3}{5}$ 时原函数取得极大值。此即为所求。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>极大似然估计的一般方法可以记录如下：</p><ol><li>极大似然估计，估计的目标是随机变量服从分布的参数；因此在使用极大似然估计法之前，必须假定数据服从的分布。</li><li>根据分布和实验结果，列出似然函数或者对数似然函数；</li><li>求解似然函数或者对数似然函数的极大化问题；</li><li>对于不同的（对数）似然函数，采取不同的求解方法——例如可以采用牛顿法、拟牛顿法、梯度上升法等方法，也可以求导直接求解。</li></ol><h3 id="EM-算法"><a href="#EM-算法" class="headerlink" title="EM 算法"></a>EM 算法</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>我们考虑一个复杂一些的问题。</p><p>现在假设我们有 A, B, C 三枚硬币；三枚硬币投掷后结果为正面的概率分别记为 $\pi$, $p$, $q$。现在我们规定这样一种实验：先抛 A 硬币，若 A 硬币为正面，则继续抛 B 硬币并记录结果；若 A 硬币为反面，则继续抛 C 硬币并记录结果。独立重复 $n = 10$ 次实验，观测结果如下：</p><p>$$1, 1, 0, 1, 0, 0, 1, 0, 1, 1.$$</p><p>现在的问题是要估计三枚硬币投掷后结果为正面的概率 $\pi$, $p$, $q$。</p><h4 id="问题分析、生成模型与似然函数"><a href="#问题分析、生成模型与似然函数" class="headerlink" title="问题分析、生成模型与似然函数"></a>问题分析、生成模型与似然函数</h4><p>参考上一节关于极大似然估计法的讨论。如果我们能知道 10 次独立重复实验中，哪一些是由 B 硬币确定的最终结果，哪一些是由 C 硬币确定的最终结果；那么我们就可以对他们分别采用极大似然估计，确定 B、C 两枚硬币的二项分布参数。但是由于硬币 A 的分布参数不确定，反过来我们又必须先知道 B、C 两枚硬币取得正面的分布参数，才能说某一个结果更可能来自 B 硬币还是 C 硬币。</p><p>这是一个鸡生蛋蛋生鸡的问题，看起来不好解决。脑壳疼啊脑壳疼。以下我们用概率的语言来表述这个问题。</p><p>我们引入两个随机变量 $y$ 和 $z$。此处 $y$ 表示一次投币实验的结果，而 $z$ 表示一次投币实验中间硬币 A 的结果。于是，三硬币问题的生成模型是</p><p><code>$$\begin{aligned}    p(y \mid \theta) = {}&amp; \sum_{z} p(y, z\mid \theta) \\                     = {}&amp; \sum_{z} p(z \mid \theta)p(y \mid z, \theta) \\                     = {}&amp; \pi p^{y} (1 - p)^{1 - y} + (1 - \pi)q^{y}(1 - q)^{1 - y}.\end{aligned}\tag{*}\label{star}$$</code></p><p>如此有似然函数</p><p><code>$$\begin{aligned}    L(\theta) = {}&amp; p(Y\mid\theta) \\              = {}&amp; \prod_{i = 1}^{n} \pi p^{y_i} (1 - p)^{1 - y_i} + (1 - \pi)q^{y_i}(1 - q)^{1 - y_i}.\end{aligned}$$</code></p><p>考虑求模型参数 $\theta = (\pi, p, q)$ 的极大似然估计</p><p><code>$$\hat \theta = \underset{\theta}{\arg\,\max} \ln L(\theta).$$</code></p><p>这种「鸡生蛋蛋生鸡」的问题，$(\pi, p, q)$ 参数之间互相制约，因此这个优化问题很难求得解析解。因此，针对极大似然估计法的常用解法在这里都会失效，而只能用迭代的方式求解。EM 算法是其中一种迭代算法。</p><h4 id="EM-迭代"><a href="#EM-迭代" class="headerlink" title="EM 迭代"></a>EM 迭代</h4><p>我们刚才说，如果能确定三硬币模型的参数，那么我们就能知道观测数据 $y_i$ 来自硬币 B 或 C 的概率。知道了这个概率，我们又可以反过来去推算三硬币模型的参数。这种鸡生蛋蛋生鸡的问题，总得有个头啊。因此，在 EM 算法迭代过程中，我们需要为模型参数设置一个初始值，而后不断循环迭代。以下是以三硬币模型为例，表述 EM 算法的迭代过程。</p><ol><li>选取参数的初始值，记为 $\theta^{(0)} = (\pi^{(0)}, p^{(0)}, q^{(0)})$；</li><li>迭代至参数值变化不大为止<ol><li>E 步，根据第 $i - 1$ 轮的参数，计算隐变量 $z$ 的概率 <code>$\mu^{(i)}_j = p\bigl(z_j\mid \theta^{(i - 1)}\bigr)$</code>（即 <code>$y_{j}$</code> 来自硬币 B 的概率）；</li><li>M 步，根据隐变量的概率，计算模型参数新的估计值 <code>$$\begin{aligned} \pi^{(i)} = {}&amp; \frac{1}{n} \sum_{j = 1}^{n}\mu_j^{(i)}; \\ p^{(i)}   = {}&amp; \frac{\sum_{j = 1}^{n}\mu_j^{(i)}y_j}{\sum_{j = 1}^{n}\mu_j^{(i)}}; \\ q^{(i)}   = {}&amp; \frac{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(i)}\bigr)y_j}{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(i)}\bigr)}.\end{aligned}$$</code></li></ol></li></ol><h4 id="实际计算看看"><a href="#实际计算看看" class="headerlink" title="实际计算看看"></a>实际计算看看</h4><p>我们假定初值 $\theta^{(0)} = (\pi^{(0)} = 0.5, p^{(0)} = 0.5, q^{(0)} = 0.5)$。</p><p>第一轮迭代：</p><ul><li>E 步：<code>$\mu^{(1)_j} = p\bigl(z_j\mid \theta^{(0)}\bigr) = \frac{\pi^{(0)} \bigl(p^{(0)}\bigr)^{y_j}\bigl(1-p^{(0)}\bigr)^{1 - y_j}}{\pi^{(0)}\bigl(p^{(0)}\bigr)^{y_j}\bigl(1 - p^{(0)}\bigr)^{1 - y_j} + \bigl(1 - \pi^{(0)}\bigr)\bigl(q^{(0)}\bigr)^{y_j}\bigl(1 - q^{(0)}\bigr)^{1 - y_j}} = 0.5$</code></li><li>M 步：<code>$$\begin{aligned}  \pi^{(1)} = {}&amp; \frac{1}{n} \sum_{j = 1}^{n}\mu_j^{(1)} = 0.5; \\  p^{(1)}   = {}&amp; \frac{\sum_{j = 1}^{n}\mu_j^{(1)}y_j}{\sum_{j = 1}^{n}\mu_j^{(1)}} = 0.6; \\  q^{(1)}   = {}&amp; \frac{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(1)}\bigr)y_j}{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(1)}\bigr)} = 0.6.\end{aligned}$$</code></li></ul><p>第二轮迭代：</p><ul><li>E 步：<code>$\mu^{(2)_j} = p\bigl(z_j\mid \theta^{(1)}\bigr) = \frac{\pi^{(1)} \bigl(p^{(1)}\bigr)^{y_j}\bigl(1-p^{(1)}\bigr)^{1 - y_j}}{\pi^{(1)}\bigl(p^{(1)}\bigr)^{y_j}\bigl(1 - p^{(1)}\bigr)^{1 - y_j} + \bigl(1 - \pi^{(1)}\bigr)\bigl(q^{(1)}\bigr)^{y_j}\bigl(1 - q^{(1)}\bigr)^{1 - y_j}} = 0.5$</code></li><li>M 步：<code>$$\begin{aligned}  \pi^{(2)} = {}&amp; \frac{1}{n} \sum_{j = 1}^{n}\mu_j^{(2)} = 0.5; \\  p^{(2)}   = {}&amp; \frac{\sum_{j = 1}^{n}\mu_j^{(2)}y_j}{\sum_{j = 1}^{n}\mu_j^{(2)}} = 0.6; \\  q^{(2)}   = {}&amp; \frac{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(2)}\bigr)y_j}{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(2)}\bigr)} = 0.6.\end{aligned}$$</code></li></ul><p>考虑到 $\theta^{(1)} = \theta^{(2)} = (\pi = 0.5, p = 0.6, q = 0.6)$，参数已趋于稳定，故而迭代结束。</p><p>注意，EM 算法迭代的结果是对初值敏感的。例如，对于三硬币模型，若初值取 $\theta^{(0)} = (\pi^{(0)} = 0.4, p^{(0)} = 0.6, q^{(0)} = 0.7)$，则迭代结果为 $\hat\theta = \bigl(\hat{\pi}=0.4064, \hat{p}=0.5368, \hat{q} = 0.6432\bigr)$。</p><h2 id="EM-算法的理论推导"><a href="#EM-算法的理论推导" class="headerlink" title="EM 算法的理论推导"></a>EM 算法的理论推导</h2><h3 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h3><h4 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h4><p>定义在实数域上的一元函数 $f(x)$，若对于定义域内的任意自变量都成立不等式 $f’’(x) \geqslant 0$，则称该函数是凸函数；若严格成立不等式 $f’’(x) &gt; 0$，则称该函数是严格凸函数。</p><p>定义在实数域上的多元函数 <code>$f(x_1, x_2, \ldots, x_n)$</code>，若对于定义域内的任意自变量其海森矩阵是半正定的，则称该函数是凸函数；若海森矩阵是正定的，则称该函数是严格凸函数。</p><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p>对于连续随机变量 $X$，若其概率密度函数为 $f(x)$，则其期望定义为</p><p><code>$$E[X] = \int_{-\infty}^{+\infty} x\cdot f(x)\mathop{}\!\mathrm{d}x.$$</code></p><p>设随机变量 $Y = g(X)$，则其期望是</p><p><code>$$E[Y] = \int_{-\infty}^{+\infty} g(x)\cdot f(x)\mathop{}\!\mathrm{d}x.$$</code></p><h4 id="琴生（Jensen）不等式"><a href="#琴生（Jensen）不等式" class="headerlink" title="琴生（Jensen）不等式"></a>琴生（Jensen）不等式</h4><p>假设 $\mu$ 是集合 $\Omega$ 的正测度，并且 $\mu(\Omega) = 1$。又设 $g$ 是勒贝格（Lebesgue）可积的实值函数，而 $\varphi$ 是定义在 $\mathbb{R}$ 上的凸函数，则成立琴生不等式</p><p><code>$$\varphi\Bigl(\int_{\Omega} g\mathop{}\!\mathrm{d}\mu\Bigr) \leqslant \int_{\Omega}\varphi\circ g\mathop{}\!\mathrm{d}\mu.$$</code></p><p>以概率论的语言来说，$\mu$ 显然是个概率测度。此时，若 $g$ 表示随机变量 $X$，则在 $\Omega$ 上，随机变量相对概率测度的积分其实是期望。此时，琴生不等式转化为</p><p><code>$$\varphi\bigl(E[X]\bigr) \leqslant E\bigl(\varphi[X]\bigr).$$</code></p><h3 id="问题的数学表述"><a href="#问题的数学表述" class="headerlink" title="问题的数学表述"></a>问题的数学表述</h3><p>对于 $m$ 个相互独立的样本 <code>$x_1$</code>, <code>$x_2$</code>, …, <code>$x_m$</code>，有观测数据 <code>$y_1$</code>, <code>$y_2$</code>, …, <code>$y_m$</code>，以及隐含数据 <code>$z_1$</code>, <code>$z_2$</code>, …, <code>$z_m$</code>。此时，$(y)$ 为不完全数据，而 $(y, z)$ 是完全数据。</p><p>面对不完全数据建立的概率模型（\ref{star} 式）会含有隐变量：</p><p><code>$$\begin{aligned}    H(\theta) = {}&amp; L(\theta) \\              = {}&amp; \ln p(Y \mid \theta) \\              = {}&amp; \ln \sum_{z} p(Y, Z\mid \theta) \\              = {}&amp; \ln \Bigl(\sum_{z} p(Z \mid \theta)p(Y \mid Z, \theta)\Bigr)\end{aligned}$$</code></p><p>因此，极大化问题事实上变成了</p><p><code>$$\hat\theta, \hat z = \underset{\theta, z}{\arg\,\max}H(\theta, z).$$</code></p><p>此时，若以极大似然估计的解法思路，对 $\theta$ 和 $z$ 求导，而后直接求解极大似然方程或者梯度上升，其表达式会非常复杂。因此，很难求得它的解析解。</p><h3 id="构造似然函数下界"><a href="#构造似然函数下界" class="headerlink" title="构造似然函数下界"></a>构造似然函数下界</h3><p>我们的目的是极大化（对数）似然函数 $H(\theta)$。因此对于第 $i + 1$ 轮迭代，我们希望找到新的 $\theta$ 使得 $H\bigl(\theta\bigr) &gt; H\bigl(\theta^{(i)}\bigr)$。</p><p>因此，我们考虑（凹函数的）琴生不等式</p><p><code>$$\begin{aligned}    H(\theta) = {}&amp; \ln \Bigl(\sum_{z} p(Z \mid \theta)p(Y \mid Z, \theta)\Bigr) \\              = {}&amp; \ln \biggl(\sum_{z}p(Z\mid Y, \theta^{(i)}) \cdot \frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)})}\biggr) \\              \geqslant {}&amp; \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)})}\biggr).\end{aligned}$$</code></p><p>注意到 $\sum_{z} p(Z\mid Y, \theta^{(i)}) = 1$，于是考虑做差</p><p><code>$$\begin{aligned}    H(\theta) - H(\theta^{(i)}) \geqslant {}&amp; \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)})}\biggr) - \ln p(Y\mid \theta^{(i)}) \\                                = {}&amp; \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})}\biggr).\end{aligned}$$</code></p><p>于是，令</p><p><code>$$B\bigl(\theta,\theta^{(i)}\bigr) \overset{\text{def}}{=} H(\theta^{(i)} + \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})}\biggr),$$</code></p><p>则有 $H(\theta) \geqslant B\bigl(\theta,\theta^{(i)}\bigr)$，并且有 $H\bigl(\theta^{(i)}\bigr) = B\bigl(\theta^{(i)},\theta^{(i)}\bigr)$。因此，实际上我们已经构造了 $H(\theta)$ 的一个下界 $B\bigl(\theta,\theta^{(i)}\bigr)$，即完成了 E 步。接下来，我们要想办法提升这个下界（M 步）。</p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>考虑到提升 $B\bigl(\theta,\theta^{(i)}\bigr)$ 就能提升 $H(\theta)$。原始的优化问题转化为：</p><p><code>$$\begin{aligned}    \theta^{(i + 1)} = {}&amp; \underset{\theta}{\arg\,\max} B\bigl(\theta,\theta^{(i)}\bigr) \\                     = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[H\bigl(\theta^{(i)}\bigr) + \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})}\biggr)\Biggr] \\                     = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[\sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \bigl(p(Z \mid \theta)p(Y \mid Z, \theta)\bigr) + H\bigl(\theta^{(i)}\bigr) - \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \bigl(p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})\bigr)\Biggr] \\                     = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[\sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \bigl(p(Z \mid \theta)p(Y \mid Z, \theta)\bigr) \Biggr] \qquad\text{// 省略相对 $\theta$ 的常数项} \\                     = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[\sum_{z} p(Z\mid Y, \theta^{(i)}) \ln p(Y, Z \mid \theta) \Biggr]\end{aligned}$$</code></p><p>于是，令</p><p><code>$$Q(\theta, \theta^{(i)}) \overset{\text{def}}{=} \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln p(Y, Z \mid \theta).$$</code></p><p>这即是在 M 步我们需要优化的目标。</p><h3 id="EM-迭代算法"><a href="#EM-迭代算法" class="headerlink" title="EM 迭代算法"></a>EM 迭代算法</h3><ul><li>输入：观测变量数据 $Y$，隐变量数据 $Z$，给定参数 $\theta$ 时观测变量和隐变量的联合分布 $p(Y, Z\mid\theta)$，给定观测变量和参数 $\theta$ 时隐变量 $Z$ 的条件分布 $p(Z\mid Y, \theta)$。</li><li>输出：模型参数 $\theta$。</li><li>设置参数初值 $\theta^{(0)}$。</li><li>开始迭代，直至 $\theta$ 收敛：<ul><li>E 步，计算 $$Q(\theta, \theta^{(i)}) \overset{\text{def}}{=} \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln p(Y, Z \mid \theta).$$</li><li>M 步，解最优化问题 $$\theta^{(i + 1)} = \underset{\theta}{\arg\,\max} Q(\theta, \theta^{(i)}).$$</li></ul></li></ul><p>可见，在模型输入中包含联合分布和条件分布。这印证了我们之前说的：「EM 算法同极大似然法一样，需要预先假定分布」。</p><h3 id="EM-算法的收敛性"><a href="#EM-算法的收敛性" class="headerlink" title="EM 算法的收敛性"></a>EM 算法的收敛性</h3><p>考虑 EM 算法在迭代过程中产生的参数估计序列 ${\theta^{(i)}}$，以及据此计算的对数似然函数序列 ${H(\theta^{(i)}) = \ln p(Y\mid\theta^{(i)} = B(\theta^{(i)}, \theta^{(i)})}$。</p><p>考虑到在 EM 迭代算法中有：</p><p><code>$$B(\theta^{(i + 1)}, \theta^{(i + 1)}) \geqslant B(\theta^{(i + 1)}, \theta^{(i)}) \geqslant B(\theta^{(i)}, \theta^{(i)}).$$</code></p><p>因此，上述对数似然函数序列是单调递增的。又考虑到似然函数是概率，故而上述对数似然函数序列有上界。根据单调有界原理，上述对数似然函数序列必然收敛。不过，这并不意味着参数的估计序列 ${\theta^{(i)}}$ 必然收敛。因此，在实际使用过程中，EM 算法的终止条件除了 <code>$\bigl\lVert\theta^{(i + 1)} - \theta^{(i)}\bigr\rVert &lt; \varepsilon_1$</code> 之外，还应包含 <code>$\bigl\lVert Q\bigl(\theta^{(i + 1)}, \theta^{(i)}\bigr) - Q\bigl(\theta^{(i)}, \theta^{(i)}\bigr)\bigr\rVert &lt; \varepsilon_2$</code>。</p><p>此外，由于 EM 算法对初值敏感。故而，尽管 EM 算法能保证收敛，但不保证一定能收敛到全局最优解。因此，使用 EM 算法时，往往需要设置多个初值，估计多套模型参数。最后再将模型参数代入模型，比较模型的效果，选出其中最好的作为最终结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇讨论期望最大算法算法（Expecation Maximization Algorithm，EM 算法）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="EM" scheme="https://liam.page/tags/EM/"/>
    
  </entry>
  
  <entry>
    <title>博弈论通俗演义：海盗分金问题与特朗普当选</title>
    <link href="https://liam.page/2018/11/07/pirates-and-golds-and-president-Trump/"/>
    <id>https://liam.page/2018/11/07/pirates-and-golds-and-president-Trump/</id>
    <published>2018-11-07T07:37:46.000Z</published>
    <updated>2019-01-13T10:52:46.113Z</updated>
    
    <content type="html"><![CDATA[<p>此篇开始，讲讲博弈论通俗演义。这是第一篇，谈谈海盗分金问题。</p><a id="more"></a><h2 id="海盗分金"><a href="#海盗分金" class="headerlink" title="海盗分金"></a>海盗分金</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>海盗分金的问题描述如下：</p><p>三个聪明的海盗 A, B, C 分抢来的 100 枚金币。关于如何分赃，三人并未达成一致；于是三人按照「海盗之神」的指示，以这样的方式决定如何分赃：</p><ul><li>按 A, B, C 的顺序，依次提出自己分赃的方案。</li><li>尚存活的人，对刚刚提出的方案进行表决<ul><li>如若分赃方案得到过半（不包含一半）人的认可，则按方案执行，而后分赃结束；</li><li>否则，立即把提出方案的人丢到船下喂鲨鱼，剩下的人继续依次提出自己的方案。</li></ul></li></ul><p>海盗总是谨慎而贪婪的：</p><ul><li>他们首先总是想要保全自己的性命；</li><li>他们总是想得到尽可能多的金币；</li><li>并且在得到金币数量相等的情况下希望干掉更多的对手（某种意义上，这是一种短视；因为干掉分赃的对手后，将来没有帮手再也抢不到金币了）。</li></ul><p>那么现在的问题是：海盗 A 是否有办法保住自己的性命，并且获得尽可能多的金币？</p><h3 id="逆向推理"><a href="#逆向推理" class="headerlink" title="逆向推理"></a>逆向推理</h3><p>乍看起来，不论 A 怎样提出建议，B 和 C 都有可能不满而否决 A 的提议，从而「票死」A。因此 A 是危险的。但是这个问题不能简单地凭感觉，而需要逆向去推理。</p><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>首先我们假设，A 和 B 都因为提议不通过而被票死了。现在只剩下了 C。那么毫无疑问，C 是最后的赢家：他不仅独得 100 枚金币，而且干掉了所有的竞争对手。</p><h4 id="B-和-C"><a href="#B-和-C" class="headerlink" title="B 和 C"></a>B 和 C</h4><p>接下来我们假设 A 因为提议不通过而被票死了。现在剩下了 B 和 C。</p><p>考虑到 B 是聪明谨慎而贪婪的：他希望自己活下去，而不希望自己死掉 C 独得 100 枚金币。但是，不论 B 提出何等建议——哪怕 B 将金币全都分给 C——C 都会否决提议而票死 B。因此，B 如果想要活下去，就不能让 A 被票死。</p><h4 id="A-B-和-C"><a href="#A-B-和-C" class="headerlink" title="A, B 和 C"></a>A, B 和 C</h4><p>现在我们回到原始问题。</p><p>考虑到 A 是聪明谨慎而贪婪的，B 能分析得到的结果，A 也能分析得出。因此 A 明白，不论 A 提出何等苛刻的提议，B 为了保全自己，都必须同意——哪怕 A 不给 B 哪怕一枚金币。而有了 B 的支持，A 自己必然支持自己的提议，因此 A 不会被票死，同时能提出任何可能的提议从而确保自己的利益。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>A 可以选择独吞 100 枚金币，B 出于保全自身的目的必然同意 A 的提议，此时 C 的选择不重要。结局是 A 不会死，并且可以独吞 100 枚金币。</p><h2 id="扩展一下问题"><a href="#扩展一下问题" class="headerlink" title="扩展一下问题"></a>扩展一下问题</h2><p>现在假设有一个新人 M 加入了分赃的行列，并且 M 在 A 之前提议。情况又会发生怎样的变化呢？</p><p>我们同样从逆向推理。那么若 M 被票死，问题就回退到了原始问题。此时 A 独吞所有金币而 B 与 C 毫无所得。这个结局是 M, A, B 和 C 都能预见到的。因此出于自保，M 不希望自己被票死；出于贪婪，B 和 C 希望不要毫无所得。于是 M 可以提议给 B 和 C 各 1 枚金币——这至少比票死 M 而后什么都得不到要好——而后 M 自己得到剩下的 98 枚金币。在这种情况下，B 和 C 会支持 M 的提议，而 A 什么都得不到。</p><h2 id="海盗分金的要义和模型"><a href="#海盗分金的要义和模型" class="headerlink" title="海盗分金的要义和模型"></a>海盗分金的要义和模型</h2><p>海盗分金问题，实际上是建立在人性本恶基础上，对这个世界的黑暗进行的一次建模。海盗分金问题里，所有的要点在真实世界里都有东西与之对应。因此，海盗分金这个游戏本身，能说明真实世界的很多问题。</p><table><thead><tr><th>海盗分金</th><th>真实世界</th></tr></thead><tbody><tr><td>提议顺序</td><td>话语权顺序</td></tr><tr><td>海盗之神</td><td>法律以及约定俗成的规约</td></tr><tr><td>金币</td><td>（各种形式的）利益</td></tr><tr><td>投票</td><td>（人人均等的）投票权</td></tr><tr><td>分赃</td><td>利益分配</td></tr><tr><td>分赃提议</td><td>利益分配的方式</td></tr><tr><td>提议顺序与投票致死</td><td>话语权不同的人有对等的投票权</td></tr></tbody></table><h3 id="先发优势"><a href="#先发优势" class="headerlink" title="先发优势"></a>先发优势</h3><p>不论是原始的海盗分金问题还是扩展后的海盗分金问题，最终的「大赢家」实际上都是首先提议的海盗。我们将这种现象称之为先发优势。具有先发优势的人，能尽可能多地权衡各个利益相关方的心思，从而决定对自己最有利的利益分配方式，从而最终获得最大的利益。</p><h3 id="拉拢底层"><a href="#拉拢底层" class="headerlink" title="拉拢底层"></a>拉拢底层</h3><p>在扩展的海盗分金问题当中，M 不能像原始问题当中的 A 一样独吞所有金币。这是因为尽管话语权有大小，但是人人都有公平的投票权。这实际上形成了对先发优势的一种制衡。因此，M 为了保全自身，必须拉拢话语权最低的 B 和 C，获取他们的支持，以便在投票中获胜。</p><p>而另一方面，由于 B 和 C 的话语权最低，所以某种意义上说，他们是「最惨」的那一批。也因而，他们是最容易拉拢的（最短视的、最容易小富即安的）。</p><p>特朗普当选美国总统，用的就是这种策略。在「让美国再次强大」、「美国优先」和「降低失业率」等口号下，暗藏的其实是对基数庞大的底层人民的拉拢。于是，他其实只需要付出很少的利益给底层人民，就能获取大量的票数支持——甚至赢下了很多传统蓝州，从而最终赢得选举。</p><h3 id="报团取暖"><a href="#报团取暖" class="headerlink" title="报团取暖"></a>报团取暖</h3><p>在扩展的海盗分金问题当中，最尴尬的就是原本能独得 100 枚金币的 A 了。话语权的降低，让他丧失先发优势；话语权不够高，又让他失去了被拉拢的价值——因为拉拢他代价很大，但获得的票数很少。这种「不上不下」地位的人，在利益分配面前，往往是最尴尬的。也所以，创业艰难，共苦容易同甘难。</p><p>那么 A 是否有机会「翻身」呢？这就需要所谓的「报团取暖」了。但是抱团取暖的策略总是能生效吗？</p><p>——关于这个问题以及更多关联相似问题分析讨论过于暗黑；因此留待读者自己分析。分析完成后，你也就能明白为什么这类人总是「战战兢兢」了<!-- ，也就会看明白毛主席的「敌人朋友论」了 -->。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇开始，讲讲博弈论通俗演义。这是第一篇，谈谈海盗分金问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Game Theory" scheme="https://liam.page/tags/Game-Theory/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中的 switch-case 语句中使用 C 风格字符串</title>
    <link href="https://liam.page/2018/11/05/apply-C-style-string-in-switch-case-clause/"/>
    <id>https://liam.page/2018/11/05/apply-C-style-string-in-switch-case-clause/</id>
    <published>2018-11-05T07:18:16.000Z</published>
    <updated>2019-01-13T10:52:46.113Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，C/C++ 语言中的 <code>switch</code>-<code>case</code> 语句只支持整型数字的逻辑分支。因此，当我们需要对整型数字之外的变量进行分支判断时，就只能依赖 <code>if</code>-<code>else</code> 语句了。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (policy == <span class="string">"SINGLE"</span>) &#123;</span><br><span class="line">    ;  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (policy == <span class="string">"MULTIPLE"</span>) &#123;</span><br><span class="line">    ;  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// UNSPECIFIED</span></span><br><span class="line">    ;  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，虽然我们用 <code>if</code>-<code>else</code> 语句实现了类似 <code>switch</code>-<code>case</code> 语句的功能。但一方面写起来未免麻烦，分支多了难以维护；另一方面如果分支很多，那么执行起来需要注意进行字符串相等性判断，效率很低。因此，这篇文章尝试通过一些取巧的方式来解决这个问题。</p><a id="more"></a><h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p>无论如何，语言层面的 <code>swtch</code>-<code>case</code> 限制是绕不开的。因此，我们需要找到一个有效的办法，将字符串与整形数字对应起来。虽然不甚完美，但是 Hash 是一种解决办法。于是我们针对 C 风格的字符串定义 Hash 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">hash_t</span> = <span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">hash_t</span> prime = <span class="number">0x100000001B3</span>ull;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">hash_t</span> basis = <span class="number">0xCBF29CE484222325</span>ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">hash_t</span> hash_run_time(<span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">    <span class="keyword">hash_t</span> ret = basis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        ret ^= *str;</span><br><span class="line">        ret *= prime;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们「似乎」便可以针对字符串使用 <code>switch</code>-<code>case</code> 语句了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_switch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (hash_run_time(str)) &#123;</span><br><span class="line">        case hash_run_time("first"):</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1st"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case hash_run_time("second"):</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case hash_run_time("third"):</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3rd"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Default..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><code>constexpr</code> 函数</h2><p>然而，如果你编译这段代码，编译器就会提醒你在 <code>case</code> 处必须使用常量表达式。因此，对于 <code>case</code> 的分支选项，我们不仅要将他们转换为整型 <code>hash_t</code>，还必须保证它们在编译期就能运算完成，从而作为常量表达式。考虑到，在 C++11 中常量表达式函数必须只能有一个 <code>return</code> 语句（在 C++14 之后就没有这个限制了），因此我们需要借助 C++ 中的三元运算符 <code>?:</code> 将 <code>hash_run_time</code> 函数改造为递归形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> hash_t <span class="title">hash_compile_time</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">hash_t</span> last_value = basis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *str ? hash_compile_time(str + <span class="number">1</span>, (*str ^ last_value) * prime) : last_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，<code>simple_switch</code> 函数也需要改造一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_switch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (hash_run_time(str)) &#123;</span><br><span class="line">        case hash_compile_time("first"):</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1st"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case hash_compile_time("second"):</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case hash_compile_time("third"):</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3rd"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Default..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>simple_switch</code> 函数已可通过编译。</p><blockquote><p>事实上，用于处理输入的 <code>hash_run_time</code> 也可以被 <code>hash_compile_time</code> 替代。</p></blockquote><h2 id="用户定义的字面值常量后缀"><a href="#用户定义的字面值常量后缀" class="headerlink" title="用户定义的字面值常量后缀"></a>用户定义的字面值常量后缀</h2><p>尽管此时代码已经可以通过编译并使用，但在每个 <code>case</code> 处都写一个函数调用未免麻烦。于是我们需要引入<a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_blank" rel="noopener">用户定义的字面值常量后缀（User-defined suffix）</a>简化代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">hash_t</span> <span class="keyword">operator</span> <span class="string">""</span> _hash(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">size_t</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash_compile_time(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，<code>simple_switch</code> 函数可被简化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_switch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (hash_run_time(str)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"first"</span>_hash:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1st"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"second"</span>_hash:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"third"</span>_hash:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3rd"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Default..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的测试代码可见：<a href="https://gist.github.com/25dcb10e55b3cb2306931aa277355bbf" target="_blank" rel="noopener">https://gist.github.com/25dcb10e55b3cb2306931aa277355bbf</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，C/C++ 语言中的 &lt;code&gt;switch&lt;/code&gt;-&lt;code&gt;case&lt;/code&gt; 语句只支持整型数字的逻辑分支。因此，当我们需要对整型数字之外的变量进行分支判断时，就只能依赖 &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; 语句了。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (policy == &lt;span class=&quot;string&quot;&gt;&quot;SINGLE&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ;  &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (policy == &lt;span class=&quot;string&quot;&gt;&quot;MULTIPLE&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ;  &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;  &lt;span class=&quot;comment&quot;&gt;// UNSPECIFIED&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ;  &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种情况下，虽然我们用 &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; 语句实现了类似 &lt;code&gt;switch&lt;/code&gt;-&lt;code&gt;case&lt;/code&gt; 语句的功能。但一方面写起来未免麻烦，分支多了难以维护；另一方面如果分支很多，那么执行起来需要注意进行字符串相等性判断，效率很低。因此，这篇文章尝试通过一些取巧的方式来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="C++" scheme="https://liam.page/tags/C/"/>
    
      <category term="constexpr" scheme="https://liam.page/tags/constexpr/"/>
    
      <category term="user-defined suffix" scheme="https://liam.page/tags/user-defined-suffix/"/>
    
  </entry>
  
</feed>
