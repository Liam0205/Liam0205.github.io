<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2023-04-13T12:57:08.138Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过 Apple Configurator 安装 TrollStore</title>
    <link href="https://liam.page/2023/04/04/Install-TrollStore-by-Apple-Configurator/"/>
    <id>https://liam.page/2023/04/04/Install-TrollStore-by-Apple-Configurator/</id>
    <published>2023-04-04T03:39:46.000Z</published>
    <updated>2023-04-13T12:57:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>近日有朋友问到，当无法通过<a href="https://github.com/opa334/TrollStore">标准的网页安装</a>的方式安装 TrollStore 时，应当怎么办。</p><p>这里提供一个利用 Apple Configurator 安装的办法。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>一台 Mac（此处测试的是 macOS 12.6.1）</li><li>一台可安装 TrollStore 的 iDevice（此处测试的是 iPhone Xʀ, iOS 15.1）</li><li>一根可以连接 Mac 和 TrollStore 的线缆</li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>打开 Mac，并打开 App Store.app</li><li>搜索并安装：Apple Configurator</li><li>打开 Apple Configurator，将手机和 Mac 连接</li><li>在 Apple Configurator 中，选中你的手机，然后在上方点 + 号，选择 App</li><li>左下角，选择「从我的 Mac 选取」，找到 GTA Car Tracker.ipa，等待安装</li><li>等待手机上安装好 GTA Car Tracker 后，打开它，选择 Install TrollStore</li><li>打开 TrollStore，install ldid</li><li>在 TrollStore 的设置页选择 Install Presistence Helper，选一个你不会用到的系统 App（我选的是 Home&#x2F;家庭）</li><li>如常使用</li></ol><p>这种方法因为 GTA Car Tracker 的权限不够，所以不能被选为 Presistence Helper，只能选择一个平常不用的系统 App。之后，如果 TrollStore 及其安装的 App 闪退&#x2F;无法打开，则可以打开 Home&#x2F;家庭 App，刷新 App。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日有朋友问到，当无法通过&lt;a href=&quot;https://github.com/opa334/TrollStore&quot;&gt;标准的网页安装&lt;/a&gt;的方式安装 TrollStore 时，应当怎么办。&lt;/p&gt;
&lt;p&gt;这里提供一个利用 Apple Configurator 安装的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="TrollStore" scheme="https://liam.page/tags/TrollStore/"/>
    
      <category term="Configurator" scheme="https://liam.page/tags/Configurator/"/>
    
  </entry>
  
  <entry>
    <title>越狱后 iDevice 的重启、重启用户空间、软重启、注销、重建图标之间的关系</title>
    <link href="https://liam.page/2023/03/17/difference-between-reboot-reboot-userspace-ldrestart-respring-and-unicache/"/>
    <id>https://liam.page/2023/03/17/difference-between-reboot-reboot-userspace-ldrestart-respring-and-unicache/</id>
    <published>2023-03-17T03:39:50.000Z</published>
    <updated>2023-04-13T12:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<p>越狱用户在将 iDevice 越狱后往往会接触到重启、重启用户空间、软重启、注销、重建图标这些概念。但中文互联网圈子内似乎还没有对它们做完整解释的帖子，故有此篇。</p><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h3><p>内存对于程序的运行是必不可少的。程序需要将自身的可执行代码以及运行过程中处理的数据结构存放在内存当中。操作系统内核也是一种程序，因此也和普通的用户应用程序一样需要内存。</p><p>为了安全起见，防止普通的用户应用程序不小心地（当然，也防止恶意地）访问并修改内核保存在内存中的内容，现代计算机的操作系统（iDevice 等手持设备也属于广义的计算机）会将整个内存寻址空间（这里的内存指得是虚拟内存）切出一块来单独给内核使用。这块空间就是所谓的内核空间。普通用户程序的权限较低，无权访问内核空间的内容，只能通过系统调用（System Call）来与内核进行交互。</p><p>与此相对应地，内核之外的所有其他用户应用程序都运行在内核空间之外的部分，即用户空间。</p><h3 id="launchd"><a href="#launchd" class="headerlink" title="launchd"></a><code>launchd</code></h3><p>在 macOS 和 iOS (包括衍生的 iPad OS 和 TVOS) 中，进程 ID（PID）为 1 的进程即是 <code>launchd</code>。这是操作系统内核启动后启动的第一个程序。它负责按需启动守护进程（不运行在前台的进程）和应用程序，并负责监控守护进程。操作系统启动后，所有后续启动的进程都是它的子子孙孙（直接或间接 <code>fork</code> 自 <code>launchd</code>）。</p><p><code>launchd</code> 还有一个配套的命令行应用程序 <code>launchctl</code>。它可以与 <code>launchd</code> 通讯，以便管理系统的各个守护进程。</p><h3 id="SpringBoard"><a href="#SpringBoard" class="headerlink" title="SpringBoard"></a>SpringBoard</h3><p>SpringBoard 是 iDevice 上管理主屏幕界面的标准应用程序。它也负责启动 WindowServer、启动 App 等工作。因此它也成为越狱后众多 Tweak 的注入目标。</p><h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><p>有了这些前置知识，我们就能对这些概念进行辨析了。</p><ul><li>重启（Reboot）：和普通意义上的「重启计算机」是同样的含义。它几乎相当于给设备断电，然后从零开始启动系统和其他应用程序。因此，如果你的 iDevice 运行的越狱不是完美越狱（Untethered Jailbreak），那么重启后将会丢掉越狱状态。在 iDevice 命令行中运行 <code>reboot</code> 可使设备重启。</li><li>重启用户空间（Reboot Userspace）：保持内核持续运行，但杀死所有运行在用户空间的进程，包括 <code>launchd</code>，然后重启。这种情况下，因为内核未受影响，所以重启用户空间后仍处于越狱状态。在 iDevice 命令行中运行 <code>launchctl reboot userspace</code> 可使设备重启用户空间。</li><li>软重启（<code>ldrestart</code>）：这是 Apple 官方提供的能力。和重启用户空间类似，但 <code>launchd</code> 本身并不会杀死然后重启。同样，为内核未受影响，所以重启用户空间后仍处于越狱状态。在 iDevice 命令行中运行 <code>ldrestart</code> 可使设备软重启。</li><li>注销（Respring）：杀死 SpringBoard，然后重启它。我们通常会在一些影响到 SpringBoard 的设置之后执行注销指令。显然，注销不会掉出越狱状态。在 iDevice 命令行中运行 <code>killall -9 backboardd</code> 可使设备注销。</li><li>重建图标（UICache）：SpringBoard 存有一份 App 图标、状态栏、Dock 等的缓存（UICache）。若你修改了这些内容，那么可能需要重建这一缓存来使你的变更生效。显然，重建图标不会掉出越狱状态。在 iDevice 命令行中运行 <code>uicache</code> 可使设备重建图标。</li></ul><p>注意，在重启用户空间和软重启的过程中，你可能有一定概率遇见内核错误（Kernel Panic），从而导致 iDevice 从重启用户空间&#x2F;软重启 fallback 到直接重启。这种情况，是会丢掉越狱状态的。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Netskao 开发的 PowerSelector 插件可在控制中心（Control Center）中添加一个插件。点按该插件的图标后会弹出一个窗口。在窗口中可以按需选择关机、重启、重启用户空间、软重启、注销、重建图标等操作。可谓十分方便，在此推荐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越狱用户在将 iDevice 越狱后往往会接触到重启、重启用户空间、软重启、注销、重建图标这些概念。但中文互联网圈子内似乎还没有对它们做完整解释的帖子，故有此篇。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Reboot" scheme="https://liam.page/tags/Reboot/"/>
    
      <category term="Userspace" scheme="https://liam.page/tags/Userspace/"/>
    
      <category term="LDRestart" scheme="https://liam.page/tags/LDRestart/"/>
    
      <category term="Respring" scheme="https://liam.page/tags/Respring/"/>
    
      <category term="UICache" scheme="https://liam.page/tags/UICache/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 14.5.1/unc0ver 8.0.2 上解决电池用量信息无法载入的问题</title>
    <link href="https://liam.page/2023/02/12/fix-battery-usage-graph-on-iOS-14-5-1-unc0ver-8-0-2/"/>
    <id>https://liam.page/2023/02/12/fix-battery-usage-graph-on-iOS-14-5-1-unc0ver-8-0-2/</id>
    <published>2023-02-12T11:01:30.000Z</published>
    <updated>2023-04-13T12:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<p>手头的 iOS 14.5.1 自使用 unc0ver 8.0.2 越狱起就一直困扰于无法正确载入电池用量信息。今日终于无法忍受这一问题，遂解决它。</p><span id="more"></span><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>经过一番检索，在 <a href="https://github.com/SongXiaoXi">@SongXiaoXi</a> 的<a href="https://github.com/LinusHenze/Fugu14/pull/242#issue-1242075829">这篇帖子</a>中找到了问题的原因。具体来说，Fugu14 在越狱过程中，将用户名 <code>_analyticsd</code> 改为了 <code>_nanalyticsd</code>，但其 ID 和 <code>$HOME</code> 则保持不变。但随后其他的某个守护进程将 <code>/private/var/db/analyticsd</code> 及其子目录的所有者改为了 <code>_analyticsd</code>（ID 变更为 <code>264</code>）。这造成 <code>_analyticsd.back</code> 以 <code>263</code> 启动时无法读取 <code>/private/var/db/analyticsd</code> 下的数据库信息，导致电池用量信息无法渲染。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决起来也很简单。我写了一个插件来完成所有需要的工作。你需要添加以下两个源，然后搜索安装 <code>FixBetteryUsageFugu14</code>：</p><ul><li><code>https://liam.page/apt/</code></li><li><code>https://liam.page/apt-beta/</code></li></ul><p>插件会在每次 SpringBoard 启动时执行一些 Shell 命令。</p><blockquote><p>你也可以手工执行这些命令观察其效果。但请确认你知道每一步在做什么之后再操作。</p><p>首先，你需要在 Cydia&#x2F;Zebra 等包管理器中安装 <code>file-cmds</code> 这一软件包。它提供了 <code>chflags</code> 命令。（或者，对于高级用户，也可以考虑安装 <a href="http://newosxbook.com/tools/iOSBinaries.html"><code>binpack64</code></a>）。</p><p>而后，你需要在 iOS 命令行（或者 SSH 过去）中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/mobile/Containers/Data/Fugu14Untether/Library/Caches/com.apple.dyld/</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo chflags -v noschg,nouchg *.closure</span><br><span class="line">sudo <span class="built_in">chown</span> 263:263 *.closure</span><br><span class="line">sudo chflags -v schg,uchg *.closure</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/mobile/Containers/Data/Fugu14Untether</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo <span class="built_in">chown</span> -h 263:263 /var/mobile/Containers/Data/Fugu14Untether/Library <span class="comment"># 只修改 Library 这一 symlink 的所有者</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/db</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo <span class="built_in">chown</span> -R 263:263 /var/db/analyticsd/</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line">sudo launchctl stop com.apple.analyticsd</span><br><span class="line"><span class="built_in">sleep</span> 3</span><br><span class="line">sudo launchctl start com.apple.analyticsd</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头的 iOS 14.5.1 自使用 unc0ver 8.0.2 越狱起就一直困扰于无法正确载入电池用量信息。今日终于无法忍受这一问题，遂解决它。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Fixing" scheme="https://liam.page/tags/Fixing/"/>
    
  </entry>
  
  <entry>
    <title>TrollStore 及常用 IPA 官方下载</title>
    <link href="https://liam.page/2023/02/08/TrollStore-and-useful-IPA-files/"/>
    <id>https://liam.page/2023/02/08/TrollStore-and-useful-IPA-files/</id>
    <published>2023-02-08T09:39:04.000Z</published>
    <updated>2023-04-13T12:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<p>TrollStore 是一个永久签名的非越狱 App。通过它，我们可以安装任意未签名的 IPA 文件。它基于一个存在于 iOS 14.0 -- iOS 15.4.1 当中的 AMFI&#x2F;CoreTrust 漏洞：iOS 不验证用于签署二进制文件的根证书是否合法。因此，如果你的 i-设备的系统版本在这个范围内，则可以安装 TrollStore，而不论是否越狱。</p><span id="more"></span><h2 id="TrollStore"><a href="#TrollStore" class="headerlink" title="TrollStore"></a>TrollStore</h2><p>TrollStore 由社区著名开发者 opa334 开发，安装方法及完整的支持列表可见其<a href="https://github.com/opa334/TrollStore#installation-guides">官方 GitHub 页面</a>。</p><h2 id="常用-IPA-官方下载"><a href="#常用-IPA-官方下载" class="headerlink" title="常用 IPA 官方下载"></a>常用 IPA 官方下载</h2><ul><li><a href="https://github.com/powenn/ModMyIPA/releases/">ModMyIPA</a>：它可以修改 IPA 文件的 Package 名字等信息。于是你可以利用它做 App 多开。</li><li><a href="https://github.com/sourcelocation/DebToIPA">DebToIPA</a>：它可以将 <code>.deb</code> 格式的 App 转成 <code>.ipa</code> 格式。</li><li><a href="https://www.tigisoftware.com/default/?p=439">Filza</a>：iOS 平台上著名的文件管理器。特别地，它可以访问系统根目录下的文件。（当然，最好不要在不熟悉的情况下对其中文件进行修改）</li><li><a href="https://github.com/D0m0/CocoaTop/releases/">CocoaTop</a>：iOS 平台上著名的进程管理器。</li><li><a href="https://github.com/CokePokes/AppStorePlus-TrollStore">AppStore++</a>：允许你自由降级从 AppStore 安装的 App。</li><li><a href="https://github.com/SmileZXLee/IpaDownloadTool">IPA 提取器</a>：允许你捕获网页安装的 IPA。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TrollStore 是一个永久签名的非越狱 App。通过它，我们可以安装任意未签名的 IPA 文件。它基于一个存在于 iOS 14.0 -- iOS 15.4.1 当中的 AMFI&amp;#x2F;CoreTrust 漏洞：iOS 不验证用于签署二进制文件的根证书是否合法。因此，如果你的 i-设备的系统版本在这个范围内，则可以安装 TrollStore，而不论是否越狱。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="TrollStore" scheme="https://liam.page/tags/TrollStore/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：给 App 砸壳</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-dumpdecrypted-IPA/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-dumpdecrypted-IPA/</id>
    <published>2023-01-21T14:47:07.000Z</published>
    <updated>2023-01-25T13:16:25.236Z</updated>
    
    <content type="html"><![CDATA[<p>在真正开始编写插件之前，我们还必须要分析我们的目标对象。只有进行了妥善的分析之后，我们才能确定要在何处进行注入、修改。</p><p>现代软件通常会加上一层加密的壳，必须经过脱壳才能分析。脱壳也常被戏称为砸壳。此篇我们介绍可用于 iOS 平台的脱壳工具。</p><span id="more"></span><h2 id="iOS-端：安装-frida-server"><a href="#iOS-端：安装-frida-server" class="headerlink" title="iOS 端：安装 frida-server"></a>iOS 端：安装 frida-server</h2><p>Frida 是跨平台的脱壳工具。首先我们需要在 iOS 上安装其服务端。</p><ul><li>源：<code>https://build.frida.re/</code></li><li>搜索 Frida 安装即可。</li></ul><blockquote><p>目前最新版本的 Frida (16.0.8) 存在 bug 会导致无法安装。蜗牛源（<code>https://repo.snailovet.com/</code>）提供了其早先版本（15.2.2）。经测试可用。</p></blockquote><h2 id="macOS-端：安装-frida-tools"><a href="#macOS-端：安装-frida-tools" class="headerlink" title="macOS 端：安装 frida-tools"></a>macOS 端：安装 frida-tools</h2><p>Terminal 中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-tools</span><br></pre></td></tr></table></figure><blockquote><p>为与 15.2.2 版本的 frida-server 匹配，你可能需要安装指定版本的 frida-tools。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-tools==11.0.0</span><br></pre></td></tr></table></figure></blockquote><p>而后，我们可以下载 dump 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump</span><br></pre></td></tr></table></figure><h2 id="Dumpdecrypting"><a href="#Dumpdecrypting" class="headerlink" title="Dumpdecrypting"></a>Dumpdecrypting</h2><p>使用 USB 线缆，连接手机和电脑。以不加载任何插件的方式启动你要砸壳的 App。（你可能需要 Choicy 这一插件来实现）</p><p>在 macOS 的 Terminal 中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/frida-ios-dump</span><br><span class="line">python3 dump.py -H 192.168.1.3 -p 22 -u root -P <span class="string">&#x27;alpine&#x27;</span> <span class="string">&quot;健康&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>-H</code> 指定你手机的 IP 地址，<code>-p</code> 指定 ssh 的端口，<code>-P</code> 指定 <code>root</code> 账户的密码（默认是 <code>alpine</code>）。<br>最后的程序名字，可以是显示在你手机上的名字，也可以是它的 Package ID。所有可用的 name&#x2F;ID 可以通过下列命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dump.py -H 192.168.1.3 -p 22 -u root -P <span class="string">&#x27;alpine&#x27;</span> -l</span><br></pre></td></tr></table></figure></blockquote><p>如此，即可在当前目录下生成 <code>健康.ipa</code> 可供后续分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真正开始编写插件之前，我们还必须要分析我们的目标对象。只有进行了妥善的分析之后，我们才能确定要在何处进行注入、修改。&lt;/p&gt;
&lt;p&gt;现代软件通常会加上一层加密的壳，必须经过脱壳才能分析。脱壳也常被戏称为砸壳。此篇我们介绍可用于 iOS 平台的脱壳工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Dumpdecrypting" scheme="https://liam.page/tags/Dumpdecrypting/"/>
    
  </entry>
  
  <entry>
    <title>解决 cisco.anyconnect.macos.acsockext 大量消耗 CPU 资源的问题</title>
    <link href="https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/"/>
    <id>https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/</id>
    <published>2023-01-21T09:47:04.000Z</published>
    <updated>2023-01-21T10:00:26.987Z</updated>
    
    <content type="html"><![CDATA[<p>最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。</p><span id="more"></span><p><img data-src="/uploads/images/computer-skills/acsockext-cpu-usage.jpg"></p><p>检查发现，这是因为在 4.10 版本开始，思科的 VPN 加入了 Socket 过滤功能。从现象来看，它几乎无时无刻不在 buzy loop（哪怕把所有网络连接都断掉），这应当是个 bug。从功能来看，这种全方位的过滤功能，实在令人担忧其安全性。因此决定干掉他。以下是步骤：</p><ul><li>打开系统设置 -&gt; 网络</li><li>应能观察到三个以 <code>Cisco...</code> 开头的网络配置</li><li>选中它们，然后点下方的 <code>-</code>，删除他们</li><li>右下角，应用</li><li>应能观察到 CPU 利用率立刻下降</li><li>删除 <code>/Applications/Cisco/Cisco AnyConnect Socket Filter.app</code> 以免将来之虞</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="CPU" scheme="https://liam.page/tags/CPU/"/>
    
      <category term="Cisco" scheme="https://liam.page/tags/Cisco/"/>
    
      <category term="VPN" scheme="https://liam.page/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：速览 Objective-C</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/</id>
    <published>2023-01-21T01:32:37.000Z</published>
    <updated>2023-01-21T14:47:48.481Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。</p><p>这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&#x2F;C++ 的熟练使用者则更好。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 是 C 语言的严格超集。即是说，在 C 编译器下能够编译的代码，应当可以不加修改地使用 Objective-C 的编译器来编译。（尽管可能行为不完全相同）另一方面，在 Objective-C 当中，可以混合使用 C 风格的代码。</p><h2 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h2><table><thead><tr><th></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td>C</td><td><code>.h</code></td><td><code>.c</code></td></tr><tr><td>C++</td><td><code>.h</code>&#x2F;<code>.hpp</code></td><td><code>.cc</code>&#x2F;<code>.cpp</code>&#x2F;<code>.cxx</code></td></tr><tr><td>Objective-C</td><td><code>.h</code></td><td><code>.m</code></td></tr><tr><td>Objective-C++</td><td><code>.h</code></td><td><code>.mm</code></td></tr></tbody></table><p>为了兼容 C，我们依然可以使用预处理器指令 <code>#include</code> 来包含头文件。但是 Objective-C 提供了另一选项 <code>#import</code>。它与 <code>#include</code> 的作用几乎完全相同，但可以保证在一个编译单元中每个头文件都只被引入一次。即是说，它起到了传统 C&#x2F;C++ 变成中 <code>#pragma once</code> 或是 Guard Macro 的作用。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Objective-C&#x2F;C++ 中的基本类型和 C&#x2F;C++ 中的差不多。几种基本类型在 Objective-C&#x2F;C++ 中的长度分别是：</p><ul><li><code>char</code>: 1B</li><li><code>int</code>: 4B</li><li><code>float</code>: 4B</li><li><code>double</code>: 8B</li></ul><p>此外，Objective-C&#x2F;C++ 中也有 <code>short</code>&#x2F;<code>long</code>&#x2F;<code>long long</code>&#x2F;<code>signed</code>&#x2F;<code>unsigned</code> 之类的修饰。含义也和 C&#x2F;C++ 中的相同。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Objective-C 支持 C-style 字符串，并且也遵循 C 语言当中对引号使用的约定。亦即，使用单引号表示字符（例 <code>&#39;c&#39;</code>），使用双引号表示字符串（null termination）。但在 Objective-C 中也有实现 <code>NSString</code> 类（类似 C++ 中的 <code>std::string</code> 但更强大）。它更常用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>;  <span class="comment">// 字符类型字面量</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span>;  <span class="comment">// C-style string</span></span><br><span class="line"><span class="string">@&quot;hello world&quot;</span>;  <span class="comment">// Objective-C NSString</span></span><br></pre></td></tr></table></figure><p>此外，<code>NSString</code> 也支持 <code>printf</code> 风格的字符串构造方法，以及支持从 C-style 字符串中构造。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a NSString object from literal</span></span><br><span class="line"><span class="built_in">NSString</span>* myString = <span class="string">@&quot;My String\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from printf formatter</span></span><br><span class="line"><span class="built_in">NSString</span>* anotherString = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@&quot;%d %s&quot;</span>, <span class="number">1</span>, <span class="string">@&quot;String&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from C-style string</span></span><br><span class="line"><span class="built_in">NSString</span>*  fromCString = [<span class="built_in">NSString</span> stringWithCString: <span class="string">&quot;A C string&quot;</span> encoding: <span class="built_in">NSASCIIStringEncoding</span>];</span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><p>Objective-C 中的 <code>if</code> 语句和 C&#x2F;C++ 中的基本一致。唯独，在 Objective-C 中以 <code>0</code> 表示 <code>false</code>，而以其他值表示 <code>true</code>。例如说，其他任何数值，或是任何字符串，在 <code>Objective-C</code> 中都会被认为是 <code>true</code>。</p><h3 id="for-x2F-while"><a href="#for-x2F-while" class="headerlink" title="for&#x2F;while"></a><code>for</code>&#x2F;<code>while</code></h3><p>Objective-C 中的 <code>for</code>&#x2F;<code>while</code> 和 C 中的完全一致。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><table><thead><tr><th></th><th>名称</th><th>代码风格</th></tr></thead><tbody><tr><td>C&#x2F;C++</td><td>对象成员函数调用</td><td><code>obj.method(args)</code></td></tr><tr><td>Objective-C&#x2F;C++</td><td>向对象传递消息</td><td><code>[obj method: args]</code></td></tr></tbody></table><p>在 C++&#x2F;Java 中，类中定义有成员函数&#x2F;成员方法。我们可以通过类似 <code>obj.method(args)</code> 的方式调用 <code>obj</code> 对象的 <code>method</code> 成员函数。如果 <code>method</code> 在 <code>obj</code> 所属的类中没有定义，则在编译期就会报错。</p><p>Objective-C 则继承了 Smalltalk 的消息传递模型。在这一模型中，调用成员函数被视作是向对象发送一个消息。例如，<code>obj.method(args)</code> 式的调用会被写作是 <code>[obj method: args]</code>。这种写法的意思是，向 <code>obj</code> 这个对象发送名为 <code>method</code> 的消息，<code>args</code> 则是消息附带的参数。与 C++&#x2F;Java 风格的调用不同，<code>obj</code> 所属的类即便没有定义名为 <code>method</code> 的成员函数，我们在代码中依旧可以向 <code>obj</code> 发送这一消息。Objective-C 的编译器不会为此报错，但在程序执行时则会抛出一个异常。</p><p>对比下来，消息传递模型中类和成员函数的关系较为松散，这种调用方式总是在运行期动态绑定。于是，它不需要 C++ 当中的 <code>virtual</code>&#x2F;<code>override</code> 关键字。当然，这种做法也存在一定额外开销。（显然）</p><blockquote><p>空对象（<code>nil</code>）接受消息后默认不做任何事情。因此向 <code>nil</code> 传递消息是安全的。</p></blockquote><h2 id="类的声明与数据成员"><a href="#类的声明与数据成员" class="headerlink" title="类的声明与数据成员"></a>类的声明与数据成员</h2><p>在 C++ 中，我们称之为「声明一个类」。在 Objective-C&#x2F;C++ 中，我们说「定义类的接口（interface）」。</p><hr><p>在 C++ 中，定义一个空的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>注意，它不需要继承自一个作为占位符的父类。在 Objective-C&#x2F;C++ 中，定义一个空类形如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意，和 Python 中所有类都继承自 <code>object</code> 类似，Objective-C 中所有类都继承自 <code>NSObject</code>。</p><hr><p>在 C++ 中，定义一个包含有数据成员的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C&#x2F;C++ 中则是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Objective-C 的类分为接口（interface）和实现（implementation）。接口部分通常包含了类声明以及其中数据成员的定义，以及相关成员函数的声明。实现部分通常包含了成员函数的实现代码。</p><p>注意，C++ 中，<code>class</code> 中的数据成员默认是 <code>private</code> 的；在 Objective-C&#x2F;C++ 中，<code>@interface</code> 段定义的数据成员默认是 <code>protected</code> 的，<code>@implementation</code> 段定义的数据成员默认是 <code>private</code> 的。为了保持访问控制一致，额外在 C++ 代码中加上了 <code>protected</code> 关键字来指定 <code>data</code> 的访问控制类型。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在 C++ 中，成员函数的声明形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">class_method</span><span class="params">()</span></span>;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method1</span><span class="params">()</span></span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method2</span><span class="params">(<span class="type">int</span> p1)</span></span>;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method3</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span>;  <span class="comment">// 4.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C 中，则是如下形式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">Bar</span></span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line">+(<span class="type">void</span>) class_method;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>) instance_method1;  <span class="comment">// 3.a</span></span><br><span class="line">-(<span class="type">void</span>) instance_method2: (<span class="type">int</span>) p1;  <span class="comment">// 3.b</span></span><br><span class="line">-(<span class="type">void</span>) instance_method3: (<span class="type">int</span>) p1 and: (<span class="type">int</span>) p2;  <span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>首先关注 (1)。在 C++ 中，<code>class</code> 内的访问控制默认是 <code>private</code>。因此，要使声明的成员函数可用，我们需要显式地指明 <code>public</code>。在 Objective-C 中，<code>@interface</code> 段的方法默认是 <code>@public</code> 的。</p><p>接下来关注 (2)。在 C++ 中有所谓的 <code>static</code>-成员函数。此类成员函数是属于整个类的，不能修改类的对象内部的数据成员。Objective-C 中也有类似设定，即所谓的类方法（class method）。具体形式是在方法前加上一个 <code>+</code> 记号。</p><p>现在关注 (3)。这是典型的成员函数的声明方式。这样的成员函数是与具体的类的对象绑定的，必须要有一个构造好的对象才能执行这些成员函数。在 Objective-C 中，这是所谓的对象方法（instance method），也称为一般方法。</p><p>(4) 处也声明了一般意义上的成员函数，但在 Objective-C 这里稍有不同。对 Objective-C 的版本，它的函数全名（签名）是 <code>instance_method3:and:</code>。即是说，在声明时，函数的名称和参数列表交织在一起；每个冒号后面都带有一次参数传递。调用它的时候则类似：<code>[obj instance_method3: 0 and: 1]</code>。这是 Objective-C&#x2F;C++ 特有的。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>尽管我们也可以在 Objective-C 中定义数据成员，但实际上更好的方式是使用属性。例如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它等价于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;  <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;  <span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里，(1) 声明了类 <code>Foo</code> 的一个属性。它的类型是 <code>int</code>，名字是 <code>age</code>。如果没有显式地如 (2) 这样将属性和变量关联起来，则编译器会自动产生一个变量，并做这样的关联。注意，属性的声明应当位于 <code>@interface</code> 段，属性与变量的关联则应放在 <code>@implementation</code> 段。</p><p>你也可以使用别的变量与属性进行关联。例如 <code>@synthesize age = internal_age;</code>。这样会将 <code>age</code> 这个属性与 <code>internal_age</code> 这个数据成员进行关联。</p><p>声明属性，则编译器会为我们自动生成相应的 setter&#x2F;getter 方法。例如说，上面的代码，大致相当于会生成这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line">-(<span class="type">void</span>) setAge: (<span class="type">int</span>) n &#123;</span><br><span class="line">  <span class="keyword">self</span>-&gt;_age = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">int</span>) age &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说，通过属性，我们将类的数据成员封装了起来。外部不能直接操作类的数据成员，而要通过 setter&#x2F;getter 来操作。此外，Objective-C 还为此提供了类似 C++ 中成员访问运算符（<code>.</code>）的语法糖。我们可以写出类似下面的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.age = <span class="number">10</span>;  <span class="comment">// 1.a</span></span><br><span class="line">[p setAge: <span class="number">10</span>];  <span class="comment">// 1.b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, p.age);  <span class="comment">// 2.a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, [p age]);  <span class="comment">// 2.b</span></span><br></pre></td></tr></table></figure><p>其中 (1.a) 和 (1.b) 的含义相同，(2.a) 和 (2.b) 的含义也相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。&lt;/p&gt;
&lt;p&gt;这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&amp;#x2F;C++ 的熟练使用者则更好。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Language" scheme="https://liam.page/tags/Language/"/>
    
      <category term="Objective-C" scheme="https://liam.page/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS 上 VSCode 当中终端环境变量重复问题</title>
    <link href="https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/"/>
    <id>https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/</id>
    <published>2023-01-20T14:02:11.000Z</published>
    <updated>2023-01-20T14:06:49.900Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，<code>PATH</code> 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，<code>PATH</code> 变量则是正常的。</p><span id="more"></span><p>举例来说，VSCode 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin:/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>同期 Terminal 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>检查各种 <code>profile</code>&#x2F;<code>bashrc</code> 文件，均未发现异常。后查明是在 VSCode 当中启动嵌入的终端时，默认会继承 VSCode 启动时的环境变量。这导致后续在使用 <code>PATH = &quot;/path/to/foo/bar:$PATH&quot;</code> 这样的语法时，会将 <code>PATH</code> 复制一份。只需将 VSCode 中的下列设置改为 <code>false</code> 即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.inheritEnv&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，&lt;code&gt;PATH&lt;/code&gt; 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，&lt;code&gt;PATH&lt;/code&gt; 变量则是正常的。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="Terminal" scheme="https://liam.page/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：从 NIC 中创建项目</title>
    <link href="https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/"/>
    <id>https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/</id>
    <published>2023-01-19T16:21:45.000Z</published>
    <updated>2023-01-21T14:47:54.899Z</updated>
    
    <content type="html"><![CDATA[<p>安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。</p><span id="more"></span><h2 id="执行-NIC"><a href="#执行-NIC" class="headerlink" title="执行 NIC"></a>执行 NIC</h2><p>在安装好 Theos 的基础上，可以执行下列命令启动 NIC 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/nic.pl</span><br></pre></td></tr></table></figure><p>之后，NIC 会在终端上打印出一个列表，询问你想要创建何种类型的项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="variable">$THEOS</span>/bin/nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/control_center_module-11up</span><br><span class="line">  [6.] iphone/cydget</span><br><span class="line">  [7.] iphone/flipswitch_switch</span><br><span class="line">  [8.] iphone/framework</span><br><span class="line">  [9.] iphone/library</span><br><span class="line">  [10.] iphone/notification_center_widget</span><br><span class="line">  [11.] iphone/notification_center_widget-7up</span><br><span class="line">  [12.] iphone/preference_bundle</span><br><span class="line">  [13.] iphone/preference_bundle_swift</span><br><span class="line">  [14.] iphone/theme</span><br><span class="line">  [15.] iphone/tool</span><br><span class="line">  [16.] iphone/tool_swift</span><br><span class="line">  [17.] iphone/tweak</span><br><span class="line">  [18.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [19.] iphone/xpc_service</span><br><span class="line">  [20.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required):</span><br></pre></td></tr></table></figure><p>我们主要关注的是其中的 <code>iphone/tweak</code> 和 <code>iphone/tweak_with_simple_preferences</code>。后者会构造一个 <code>Preferences.plist</code> 文件，以便我们能在 iOS 的系统设置中配置该插件的行为。</p><p>这里我们选择 18。接下来，NIC 会交互式地要求我们键入一些插件的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Choose a Template (required): 18</span><br><span class="line">Project Name (required): PhantomSteps</span><br><span class="line">Package Name [com.yourcompany.phantomsteps]: page.liam.phantom_steps</span><br><span class="line">Author/Maintainer Name [Liam Huang]:</span><br><span class="line">[iphone/tweak_with_simple_preferences] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.Health</span><br><span class="line">[iphone/tweak_with_simple_preferences] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: com.apple.Health</span><br><span class="line">Instantiating iphone/tweak_with_simple_preferences <span class="keyword">in</span> phantomsteps/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>这里，我们给项目起名为 <code>PhantomSteps</code>，其包名称为 <code>page.liam.phantom_steps</code>。你可以按需修改。MobileSubstrate Bundle filter 这一项是说，你可能影响的 App 的名字。List of applications to terminate upon installation 这一项则是说，在安装你的插件时，需要杀死的程序的名字。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>创建成功后，目录结构应该类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── PhantomSteps.plist</span><br><span class="line">├── Tweak.x</span><br><span class="line">├── control</span><br><span class="line">└── layout</span><br><span class="line">    └── Library</span><br><span class="line">        └── PreferenceLoader</span><br><span class="line">            └── Preferences</span><br><span class="line">                └── PhantomSteps</span><br><span class="line">                    └── Preferences.plist</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure><p>这里</p><ul><li><code>PhantomSteps.plist</code> 记录了需要杀死的包的名称。</li><li><code>control</code> 包含了先前在 NIC 交互式环境中填写的信息。</li><li><code>Makefile</code> 是对应 GNU make 的文件。</li><li><code>Tweak.x</code> 是插件自身的代码。Theos 会从模板中创建一个带有各种注释的文件供参考。</li></ul><blockquote><p>通过 NIC 模板创建的项目可见：<a href="https://github.com/Liam0205/PhantomSteps/tree/c48a76ae16ea761b24bfa94524331a1b7523d0b0">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：安装 Theos</title>
    <link href="https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/"/>
    <id>https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/</id>
    <published>2023-01-19T15:16:51.000Z</published>
    <updated>2023-01-21T14:47:57.362Z</updated>
    
    <content type="html"><![CDATA[<p>Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。</p><blockquote><p>你也可以直接参考官方英文文档：<a href="https://theos.dev/docs/installation-macos">https://theos.dev/docs/installation-macos</a></p></blockquote><span id="more"></span><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><h3 id="安装-XCode"><a href="#安装-XCode" class="headerlink" title="安装 XCode"></a>安装 XCode</h3><p>打开 MAS，搜索 XCode，安装&#x2F;更新到最新。</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>打开 Terminal，执行下列命令（来自<a href="https://brew.sh/">Homebrew 官网</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="通过-brew-安装依赖库"><a href="#通过-brew-安装依赖库" class="headerlink" title="通过 brew 安装依赖库"></a>通过 brew 安装依赖库</h3><p>在 Terminal 中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid xz</span><br></pre></td></tr></table></figure><h2 id="下载和安装-Theos"><a href="#下载和安装-Theos" class="headerlink" title="下载和安装 Theos"></a>下载和安装 Theos</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export THEOS=~/theos&quot;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="comment"># 早期的系统应该加至 ~/.profile</span></span><br></pre></td></tr></table></figure><h3 id="下载-Theos"><a href="#下载-Theos" class="headerlink" title="下载 Theos"></a>下载 Theos</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/theos/theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，你也可以将 <code>$THEOS/bin/</code> 加到环境变量 <code>$PATH</code> 中去。</p></blockquote><h2 id="安装-SDK"><a href="#安装-SDK" class="headerlink" title="安装 SDK"></a>安装 SDK</h2><p>新版的 XCode 不提供插件可能使用到的私有框架，因此我们需要安装 Theos 维护的补丁版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/theos/sdks/archive/master.zip</span><br><span class="line">TTT=$(<span class="built_in">mktemp</span> -d)</span><br><span class="line">unzip master.zip -d <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$TTT</span>/sdks-master/*.sdk <span class="variable">$THEOS</span>/sdks</span><br><span class="line"><span class="built_in">rm</span> -r master.zip <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">unset</span> <span class="variable">$TTT</span></span><br></pre></td></tr></table></figure><h2 id="更新-Theos"><a href="#更新-Theos" class="headerlink" title="更新 Theos"></a>更新 Theos</h2><p>将来需要更新 Theos 时，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/update-theos</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你也可以直接参考官方英文文档：&lt;a href=&quot;https://theos.dev/docs/installation-macos&quot;&gt;https://theos.dev/docs/installation-macos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>iOS 越狱后插件推荐</title>
    <link href="https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/"/>
    <id>https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/</id>
    <published>2023-01-19T02:53:10.000Z</published>
    <updated>2023-04-14T01:31:56.692Z</updated>
    
    <content type="html"><![CDATA[<p>手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。</p><span id="more"></span><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><ul><li>iPhone Xʀ</li><li>iOS 14.5.1</li><li>unc0ver 8.0.2</li></ul><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>首先是介绍一下我订阅的软件源。</p><ul><li>Zebra：<code>https://getzbra.com/repo/</code></li><li>BigBoss：<code>http://apt.thebigboss.org/repofiles/cydia/</code></li><li>Bingner&#x2F;Elucubratus：<code>https://apt.bingner.com/</code></li><li>Limneos Repo：<code>https://limneos.net/repo/</code></li><li>MERONA Repo：<code>https://repo.co.kr/</code></li><li>Chariz：<code>https://repo.chariz.io/</code></li><li>Havoc：<code>https://havoc.app/</code></li><li>jjolano：<code>https://ios.jjolano.me/</code></li><li>opa334&#39;s Repo：<code>https://opa334.github.io/</code></li><li>ichitaso repository：<code>http://cydia.ichitaso.com/</code></li><li>蜗牛源：<code>https://repo.snailovet.com/</code></li><li>AutoTouch：<code>https://repo.autotouch.net/</code></li><li>Packix：<code>https://repo.packix.com/</code></li><li>Ginsu Tweaks：<code>https://repo.ginsu.dev/</code></li><li>Liam-apt：<code>https://liam.page/apt/</code>&#x2F;<code>https://liam.page/apt-beta/</code></li><li>Karen&#39;s Repo：<code>https://cydia.akemi.ai/</code></li><li>subdiox&#39;s Repo：<code>https://subdiox.com/cydia/</code></li><li>Cydiakk：<code>https://apt.cydiakk.com/</code></li><li>CokePokes：<code>https://www.ios-repo-updates.com/repository/cokepokes/</code></li><li>Fouadraheb：<code>https://apt.fouadraheb.com/</code></li><li>电话助手作者源：<code>https://apt.htv123.com/</code></li><li>老牌猫源：<code>https://apt.25mao.com/</code></li><li>Netskao：<code>https://repo.initnil.com/</code></li><li>Procursus：<code>https://apt.procursus.us/</code></li><li>Acreson：<code>https://repo.acreson.cn/</code></li><li>Lenglengyu：<code>https://lenglengyu.com/</code></li><li>SOPPPra：<code>https://sopppra.mooo.com/</code></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里按照大致的安装时间顺序介绍我目前还在使用的插件。其中，插件名字后面带有星号标记的表示已适配 Fugu15 Rootless 越狱。</p><ul><li>CCPower⭐️（Netskao）：控制中心插件。点按后会弹出菜单。菜单上部显示电池状况、运行时间、闪存、运存等情况。下部允许进行重启、重新载入 SpringBoard 等动作。来源：BigBoss。</li><li>OpenSSH CC Toggle：控制中心插件，点按后可以切换手机中 sshd 的运行状态。来源：BigBoss。</li><li>iPonCC：控制中心插件。在控制中心显示 IP 地址。来源：BigBoss。</li><li>CCBadgeClear⭐️（Netskao）：控制中心插件。点按后可以清除 App 图标右上角的角标数字。来源：BigBoss。</li><li>CCVPN⭐️（Acreson）：控制中心插件。点按后可以切换 VPN 的状态。来源：BigBoss。</li><li>CCNC：控制中心插件，点按后可以切换 AirPods Pro 的降噪状态。来源：BigBoss。</li><li>CCSwitchData⭐️（Netskao）：控制中心插件，可以切换用来访问移动网络的 Sim 卡。来源：BigBoss。</li><li>Filza File Manager⭐️（TrollStore）：著名的文件管理器。来源：BigBoss。</li><li>Activator：著名的手势操作插件。来源：BigBoss。</li><li>SmartVPN：它可以按照 App 维度进行设置，在 App 运行时自动启动 VPN，在所有白名单 App 关闭时自动关闭 VPN。来源：BigBoss。</li><li>左滑返回：允许从屏幕右侧向中间单指滑动执行返回操作（类似于系统默认提供的从屏幕左侧向中间单指滑动的操作）。对于大屏幕的机器，单手操作十分友好。来源：BigBoss。</li><li>FLEXList⭐️（Netskao）：开发者工具。著名的开发者动态调试工具 FLEX 的包装。它允许你在任意 App 运行时动态加载 FLEX 库以调试其界面元素。来源：BigBoss。</li><li>ColorBadge：让右上角的数字角标染上颜色。来源：BigBoss。</li><li>MTerminal：著名的终端模拟器。来源：Bingner&#x2F;Elucubratus。</li><li>Vi Improved⭐️（Procursus）：著名的命令行编辑器。来源：Bingner&#x2F;Elucubratus。</li><li>kai：可以在锁屏界面和通知中心界面显示各个关联设备（耳机、Apple Watch 等）的电量状态。来源：Chariz。</li><li>Aemulo：可能是最好的 NFC 模拟&#x2F;写入 App。它的功能和 NFCWriter XS 类似，但还额外提供了将 NFC tag 保存入 Apple Wallet 的功能。这使得我们可以在锁屏界面调出 NFC tag，解开小区门禁。来源：Chariz。</li><li>IAmLazy：备份和恢复插件的插件。来源：Chariz。</li><li>AltDeamon：一个 AltServer 的守护进程。安装后可以不借助电脑实用 AltStore 对应用进行自签 Side load。来源：Chariz。</li><li>Appaze 2：在 Haptic Touch 菜单中添加 Appaze 选项，支持对 App 做个性化的设置。来源：Chariz。</li><li>AppStore++⭐️（TrollStore）：允许你对来自 AppStore 的 App 进行指定版本的升降级操作，还能设置屏蔽某些 App 的升级。来源：CokePokes。</li><li>zfbbs⭐️（Liam-apt，改名 zfbstep）：随机生成支付宝步数，蚂蚁森林好帮手。来源：Cydiakk。</li><li>DumpDecrypter：砸壳工具。来源：Cydiakk。</li><li>ShowTouch⭐️（Acreson）：显示触碰手势，在录屏时很有用。来源：Cydiakk。<!-- * InApp Purchase 内购破解：可以破解大部分软件的内购，从而可以获得免费试用的机会。来源：Cydiakk。 --></li><li>EnableBatteryPercent：在屏幕顶栏电量标志中显示具体的电量剩余百分比。来源：Ginsu Tweaks。</li><li>Crane：允许你创建 App 的分身，且每次运行前可以选择运行哪个分身。来源：Havoc。</li><li>OneHandWizard 2：通过自上向下扫过 iPhone 全面屏底部的 Gesture Bar 触发真·单手操作模式。来源：Havoc。</li><li>LocationService (CCSupport)：控制中心插件。点按后可以切换系统定位服务的状态。来源：ichitaso repository。</li><li>iCleaner Pro⭐️（Acreson）：可以清理 iPhone 上的闪存空间的插件。它还可以对启动项进行调整。来源：Karen&#39;s Repo。</li><li>SettingsRevamp⭐️：重新组织设置 App 中的项目，将系统 App、Tweak、用户 App 分别收至单独的二级目录中。来源：SOPPPra。</li><li>NFCWriter XS：著名的 NFC 模拟&#x2F;写入 App。它可以读取外部的 NFC tag，然后模拟出来。例如，可以用来模拟小区门禁卡。来源：Limneos Repo。</li><li>BioProtect XS：著名的生物信安保护插件。它可以按照 App、Folder 等维度，设置是否需要验证生物信安（Face ID&#x2F;Touch ID）。来源：Limneos Repo。</li><li>AudioRecoder XS：著名的通话录音插件。它能自动录制呼入呼出的电话并保存在手机本地，还支持自动上传到云（Google Drive&#x2F;Dropbox）。来源：Limneos Repo。</li><li>VoiceChanger XS：著名的变声器插件。来源：Limneos Repo。</li><li>PhantomSteps⭐️（Liam-apt）：自研的生成虚拟步数的插件。来源：Liam-apt。</li><li>FixBatteryUsageFugu14：解决 Fugu14 越狱导致无法查看电池用量信息的问题。来源：Liam-apt。</li><li>Choicy⭐️（opa334）：注入管理插件。它可以按照 App 维度，以白名单&#x2F;黑名单的方式禁用插件。来源：opa334&#39;s Repo。</li><li>Frida：开发者工具。著名的 Frida 的服务端。来源：蜗牛源。</li><li>Zebra⭐️：替代 Cydia 的包管理器。其运行效率和操作流畅度远胜 Cydia。来源：Zebra。</li><li>Shadow⭐️：越狱检测屏蔽插件。是已安装四个同类插件中整体效果最好者。来源：jjolano。</li><li>位置自动允许一次 &#x2F;&#x2F; AllowLocationOnce⭐️：在 App 请求系统位置服务时，自动点选「允许一次」。来源：蜗牛源。</li><li>AppData⭐️（Netskao）：允许你在主屏幕状态下，通过单指向上扫 App icon 来打开菜单。允许你修改 App 在主屏幕上展示的名字，也允许你做一些清理工作。来源：Fouadraheb。</li><li>StoreSwitcher 2⭐️（Lenglengyu）：允许在 AppStore 中快速切换账号。在需要跨区下载 App 时非常实用。来源：subdiox&#39;s Repo。</li><li>电话助手⭐️：一个集成式的强大插件。它的功能涵盖系统电话增强、系统短信增强、通话录音、状态栏美化等等，是优秀的国产插件。来源：电话助手作者源。</li><li>魔术师⭐️：电话助手作者退出的越狱屏蔽插件。来源：电话助手作者源。</li><li>微信净化⭐️：还原微信聊天本质。来源：Netskao。</li><li>微信助手⭐️：给微信添加强大的功能。来源：老牌猫源。</li><li>斗图助手⭐️：给微信添加斗图功能。来源：老牌猫源。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
      <category term="Tweaks" scheme="https://liam.page/tags/Tweaks/"/>
    
  </entry>
  
  <entry>
    <title>清理加湿器振动片上的水垢以减小其噪声</title>
    <link href="https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/"/>
    <id>https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/</id>
    <published>2022-11-24T11:03:55.000Z</published>
    <updated>2022-11-24T11:23:55.081Z</updated>
    
    <content type="html"><![CDATA[<p>生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。</p><p>常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。</p><p>此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。</p><span id="more"></span><h2 id="水垢的成因"><a href="#水垢的成因" class="headerlink" title="水垢的成因"></a>水垢的成因</h2><p>自来水中不可避免会溶解一些无机盐。特别地，其中的钙盐和镁盐（以碳酸钙、碳酸镁为主，辅有硫酸钙、硫酸镁、氯化钙、氯化镁等）因溶解度较小，容易沉积形成水垢。</p><p>加湿器振动片使水雾化，导致振动片附近的水相对减少、无机盐浓度升高。溶解度较小的钙盐、镁盐便容易在振动片附近沉积。这些沉积的水垢附着在振动片上，导致振动片工作时发出噪声。</p><h2 id="去除水垢的原理和方法"><a href="#去除水垢的原理和方法" class="headerlink" title="去除水垢的原理和方法"></a>去除水垢的原理和方法</h2><p>既已知水垢的成因和主要成分，想要去除水垢便不难。此处我们只需用到初中化学和物理知识即可。</p><p>水垢的主要成分是碳酸、硫酸、盐酸对应的钙盐和镁盐。要软化、去除这些水垢，只需找一合适的阴离子对应的酸性溶液即可。此处我们可以选择生活中常见的醋酸。</p><p>醋酸容易获得，且醋酸是弱酸操作安全。最主要的是，醋酸钙和醋酸镁的溶解度较高，算是易溶解的物质。因此，醋酸与水垢反应，可有效软化、溶解水垢。</p><p>操作步骤：</p><ol><li>购买白醋一瓶（普通使用陈醋也可，但是黑乎乎一片看不清楚效果）。</li><li>将加湿器水槽取下，加湿器底座内余水倾倒干净。</li><li>将白醋倒入加湿器底座，覆盖、没过振动片及其周围水垢区域。</li><li>加入温水（温度不需要太高），以加快反应速度。</li><li>静置 10 -- 20 分钟。此过程可见水槽底座内不断有小气泡产生（二氧化碳），水垢逐渐脱落翻滚（被二氧化碳气体推动而翻滚运动）和逐渐溶解。</li><li>将底座内的醋酸溶液倾倒干净，用手指或软刷将剩余软化的水垢清理干净。</li><li>用清水反复冲洗三至五次底座，减少醋酸残留。（残留醋酸挥发，可能对呼吸道黏膜产生刺激，导致不适）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。&lt;/p&gt;
&lt;p&gt;常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。&lt;/p&gt;
&lt;p&gt;此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Scale" scheme="https://liam.page/tags/Scale/"/>
    
      <category term="Noise" scheme="https://liam.page/tags/Noise/"/>
    
      <category term="Humidifier" scheme="https://liam.page/tags/Humidifier/"/>
    
  </entry>
  
  <entry>
    <title>羽毛球步伐①：启动步</title>
    <link href="https://liam.page/2022/11/20/badminton-footwork-the-start-step/"/>
    <id>https://liam.page/2022/11/20/badminton-footwork-the-start-step/</id>
    <published>2022-11-20T06:29:26.000Z</published>
    <updated>2022-11-20T11:26:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。</p><p>从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。</p><span id="more"></span><h2 id="为什么需要启动步"><a href="#为什么需要启动步" class="headerlink" title="为什么需要启动步"></a>为什么需要启动步</h2><p>羽毛球运动的特点、基本的物理学定律、人的生理结构，三者共同决定了启动步的重要性和必要性。</p><p>羽毛球是速度最快的球类运动之一。若是限定在初始速度的概念上，我们还可以将「之一」去掉。因其速度快、场地小，所以从你击球结束到下一次击球之间的间隔十分短暂。即便在较为缓和的对抗中，这一时间间隔通常也不会超过 3s。在这短暂的间隔中，你需要完成收拍、移动回位、移动到位、准备击球的若干步骤，时间紧迫。此外，在对手击球之前，你无法判断对手回球的落点位置。因此，羽毛球的步伐移动同时具有快速和方向不确定两个重要特点。</p><p>基本的物理学定律告诉我们：若你想要向前加速运动，则势必要让外界对你有向前的合力；向后同理。若你想要相左加速运动，则势必要让外界对你有相左的合力；向右同理。这一合力越大，加速度就越大。在运动上就体现为移动的爆发力越大、突然性越强。在不打滑的情况下，这一水平反向的合力由地面给脚的静摩擦力提供。而静摩擦力的极限大小可由公式 <code>$f_&#123;\text&#123;静&#125;&#125; = \mu_&#123;\text&#123;静&#125;&#125; \cdot F_N$</code> 给出。这也就是说，</p><ul><li>穿一双好的羽毛球鞋（增大抓地力）有助于你快速移动；</li><li>你必须<strong>向斜下方蹬地发力</strong>，才能获得更大的静摩擦力和提供更大的加速度。</li></ul><p>人的生理结构决定了，若要向斜下方蹬地发力，则必须让发力腿的小腿和地面呈现一个 30° 至 60° 的夹角。最典型的例子是 100 米短跑。跑步项目的一个特点是它永远向前跑。因此运动员们在起步阶段会采用蹲立式起跑的方式获得极大的向前的加速度。但羽毛球的启动方向不确定，于是你必须用合理的方式启动，以便能够照顾尽可能多的潜在移动方向。这种合理的方式，即是所谓的「启动步」；具体来说，又有细分：</p><ul><li>当你预期主要向左右方向移动时，应做小跳&#x2F;分腿动作，将腿左右分开，以便向斜下方蹬地发力获得左右方向的加速度。一般而言，起高球应对对方进攻时应采用这种方式。</li><li>当你预期主要向前后方向移动时，应做小跳&#x2F;分腿动作，将腿前后分开，以便向斜下方蹬地发力获得前后方向的加速度。一般而言，自己处在仅供状态时应采用这种方式。</li></ul><p>总结一下。由于羽毛球运动移动的快速和不定向的特性、向斜下方蹬地发力的原理、人的生理结构特点，羽毛球的启动步是重要且必要的。若无合理的启动步，则往往无法击打到球，或只能陷入被动击球。</p><h2 id="启动步要领"><a href="#启动步要领" class="headerlink" title="启动步要领"></a>启动步要领</h2><p>此节我们讲解启动步的要领。首先我们从最简单的静止启动开始讲起，然后再过度到移动中的连贯启动步。</p><h3 id="从静止启动"><a href="#从静止启动" class="headerlink" title="从静止启动"></a>从静止启动</h3><p>首先是准备动作。</p><p>在对手可能击出攻击性的下压球的情况（你发后场高球、挑高球、击平高球、击高远球等），你应当采取双脚左右分立的防守站姿。具体来说，应当</p><ul><li>面向对手击球的方向，双腿左右分立与肩同宽，右脚可以适当向前半步；</li><li>双脚微踮，前脚掌着地、后脚跟微抬；</li><li>膝盖微屈、髋关节微屈；</li><li>上半身向前微弓；</li><li>左右大臂下垂、向外微张，持拍手在胸腹前，拍头在胸口正面前上方位置。</li></ul><p>在对手大概率作出防守的情况，你应当采取双脚前后分立的进攻站姿。具体来说，应当侧身使持拍手在前，面向对手击球方向，双腿前后分立与肩同宽，脚尖朝向斜前方向。其余身体姿态与防守站姿基本相同。</p><p>在对手引拍即将击球的瞬间，开始启动。具体来说：</p><ul><li>双腿分开（可以视情况带有一些小跳）到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里做一些额外说明。</p><ul><li>双腿分开的目的，是为了让小腿与地面呈现的角度便于蹬地发力。因此双腿分开的幅度不应过大（导致发力不便），也不应过小（导致更大比例的发力是水平向上而非水平）。</li><li>分腿&#x2F;小跳的瞬间，你尚未知晓对方的球路。因此<ul><li>在没有把握的情况下，不应做额外假设。也就是说，双腿分开应该基本呈现左右（防守站姿）或前后（进攻站姿），而非是斜前、斜后方向。若不然，将导致二次启动。</li><li>膝盖弯曲、降低重心的过程，需要紧盯对手击球动作和球路，迅速判断落点。</li></ul></li><li>前脚掌着地瞬间发力，不能迟疑。若不然，重心完全下沉后，反而不容易发力，造成二次启动。<ul><li>发力动作当是保证脚踝稳定性的前提下，使用小腿后侧肌肉群和大腿前侧肌肉群协同发力</li></ul></li></ul><h3 id="移动中连贯启动"><a href="#移动中连贯启动" class="headerlink" title="移动中连贯启动"></a>移动中连贯启动</h3><p>从静止启动是较为理想的情况，在实际对抗中较少出现。羽毛球球速极快，对手不可能等你回动到位后、站定后再击球。因此，更多的启动情况发生在回动的过程中的顺势连贯启动。</p><p>举例来说，当你在后场击出高远、平高球，你应当迅速回动至球场中部区域。在回动的过程，应密切注意观察对手击球情况，随时准备启动。此时，可能你尚在回动过程中。例如说，右手持拍的你，重心放在左腿上，而右腿正处在委屈膝盖向前迈步的阶段。此时你的启动应当是（其他情况类比即可）：</p><ul><li>右腿发力，顺势向左垫出一小步；右腿同时协同分开，双腿分开到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里着重讲一下顺势的含义。顺势在此处有几层含义：</p><ul><li>首先，你尚在从后向前回动的过程中，身体具有向前运动的惯性。因此，你主观上向左垫出的一小步，实际效果应当是向左前方垫出一小步。若是刻意在垫布的过程中改变方向向后垫步，则是一个容易导致受伤的动作。</li><li>其次，顺势表示不做过多调整。特别地，不能等待右脚落地，再从静止启动。这是因为你尚在向前回动过程中，若要让身体静止下来，势必要双脚着地、下沉重心。这实际上已经是一次启动，只不过是一次对抗自身惯性的一次启动而已。于是，这会事实上造成二次启动。</li></ul><p>为了做到这一点，我个人总结了四个字：<strong>快回·慢踩</strong>。也就是，</p><ul><li>在击球完成后瞬间，应当爆发式地回动。体现在后场正手击球上，就是（以右手持拍为例）左腿应该向后蹬直发力、同时收紧核心，以便快速抵消向后的冲力而后向前回动。这是「快回」。</li><li>「慢踩」是说，在回动的过程中，不用过于着急，而要保持重心稳定、适度慢踩，给移动中连贯启动留下空间。当然，「两步一冲」的李矛步除外。——那是杀上网、吊上网的连贯动作。</li></ul><h2 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h2><p>启动步本身值得持续练习。以下是从入门到高阶的一些练习方式。</p><ul><li>左右开合跳。<ul><li>起始姿势：双脚与肩同宽，前脚掌着地，膝盖微屈，双手向上合掌</li><li>动作（开跳）：发力向上跳，双脚分开至两倍肩宽，前脚掌着地，膝盖弯屈下沉重心，双手两侧分开平举</li><li>复位动作（合跳）：发力向上跳，双脚合拢至一倍肩宽，前脚掌着地，膝盖微屈，双手向上击掌</li><li>目的：强壮踝关节，锻炼小腿后侧肌肉群爆发力</li><li>30 个&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步）：双腿分开至两倍肩宽，膝盖弯曲下沉重心。</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地，回归起始姿势。</li><li>目的：启动步肌肉记忆。</li><li>15 慢速 + 15 快速&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动，左右蹬跨接杀步伐。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步 + 蹬跨）：双腿分开至两倍肩宽，膝盖弯曲下沉重心；单侧腿发力，转髋蹬跨。（注意弓箭步着地动作，避免受伤）</li><li>复位动作：蹬转回位。</li><li>目的：启动步肌肉记忆 + 左右蹬跨肌肉记忆。</li><li>15 个&#x2F;组，间隔 20s 做 3 组。</li></ul></li><li>交叉步行进间启动步（两步一启动为例，还可做一步一启动、交叉步后退中启动）。<ul><li>起始动作：先左后右分别迈步向前（击后场球回动）。</li><li>动作（行进间启动步）：重心在右腿，左腿微屈（第三步尚未踩下），右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：交叉步行进间启动连贯。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li><li>并步行进间启动步（两步一启动为例，还可做并步后退中启动）。<ul><li>起始动作：右脚在前，左脚在后，向前做一次并步（出右脚，左脚并步跟上）。</li><li>动作（行进间启动步）：第二次并步做一半，即是说出右脚，在左脚并步跟上的同时，右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：并步行进间启动丽娜管。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li></ul><!-- 谨以此文，献给我曾爱过的刘曼沁女士，祝她 30 周岁生日快乐~！ -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Footwork" scheme="https://liam.page/tags/Footwork/"/>
    
      <category term="Start Step" scheme="https://liam.page/tags/Start-Step/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上双开微信</title>
    <link href="https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/"/>
    <id>https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/</id>
    <published>2022-11-02T09:53:57.000Z</published>
    <updated>2022-11-20T06:16:50.322Z</updated>
    
    <content type="html"><![CDATA[<p>特点：</p><ul><li>不安装第三方插件，无封号之虞。</li><li>双击即可启动。</li><li>启动后不需要维持「终端」；事实上它会自动关闭。</li></ul><span id="more"></span><p>解法：</p><ul><li>打开终端，执行下列代码，而后在桌面双击 <code>WeChat.command</code> 即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将启动命令写入桌面上的文件 WeChat.<span class="built_in">command</span>；如果已有重名文件，请注意修改。</span></span><br><span class="line">echo &quot;nohup /Applications/WeChat.app/Contents/MacOS/WeChat &gt;/dev/null 2&gt;&amp;1 &amp;&quot; &gt; ~/Desktop/WeChat.command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予其可执行属性</span></span><br><span class="line">chmod +x ~/Desktop/WeChat.command</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不安装第三方插件，无封号之虞。&lt;/li&gt;
&lt;li&gt;双击即可启动。&lt;/li&gt;
&lt;li&gt;启动后不需要维持「终端」；事实上它会自动关闭。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="WeChat" scheme="https://liam.page/tags/WeChat/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Yonex AX100zz 打感自测</title>
    <link href="https://liam.page/2022/10/29/Yonex-AX100zz/"/>
    <id>https://liam.page/2022/10/29/Yonex-AX100zz/</id>
    <published>2022-10-29T10:48:51.000Z</published>
    <updated>2022-10-29T11:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是 Yonex AX100zz 的打感自测。</p><span id="more"></span><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>新入手的球拍（简写 AX100zz）情况：</p><ul><li>Yonex Astrox 100zz（老色，藏青色）</li><li>4U&#x2F;G6</li><li>保留底胶 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><p>作为对比，过去六年常用的球拍（简写 Arc11）情况：</p><ul><li>Yonex ArcSaber 11（老色，带亮黄色带）</li><li>3U&#x2F;G5</li><li>去除底胶 + 缓震膜 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><h2 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h2><p>挥重方面，实测 AX100zz 和 Arc11 的挥重接近。大约是因为 Arc11 去除底胶的缘故，实际平衡点有所前移。</p><p>挥速方面，相同发力的条件下，AX100zz 的挥速较 Arc11 慢。这主要应该是 AX100zz 采用盒式拍框而 Arc11 采用破风拍框的缘故。</p><p>中杆方面，AX100zz 的中杆相对较硬，但硬得有限。传统上，我们习惯用软硬来评价中杆。但 AX100zz 的中杆更为显著的特性是回弹快。这一特性是建立在实心中杆 + 钨丝的黑科技结构上的。这一特性要求你能用 AX100zz 做出足够快的挥速。若然，相较 Arc11，击球感明显更加干脆；若不然，AX100zz 的击球会显得有一些「木」。</p><p>这即是说，AX100zz 对小臂内旋和屈指发力的技术动作要求更高。而一旦动作到位，AX100zz 的击球球速会比 Arc11 要更快。</p><h2 id="后场击球"><a href="#后场击球" class="headerlink" title="后场击球"></a>后场击球</h2><p>高远方面，步伐到位的情况下，AX100zz 的击球感和 Arc11 差别不算很大；被动的情况下，AX100zz 会稍微更废力一些。</p><p>重杀方面，第一次杀球用的还是 Arc11 的发力习惯。相较而言，球路稍微有些发飘，落点更长。稍作调整后，能够感受到更明显的下压感，暴击音也不出期待地非常舒爽。按对手的反馈，球速有区别，但不大。</p><p>点杀方面。有重杀的经验，点杀时加大了屈指的力量，效果喜人。实战中，头顶突击点杀对角，落点可以比较轻松做到在发球线附近。相同的条件，Arc11 打出同样的落点个人感觉更困难一些。</p><p>劈杀方面，这本身不是我可称擅长的技术，平时用得也偏少。实战中，尝试正手区劈杀斜线，许是还没有完全适应发力变化的缘故，总体感觉和 Arc11 区别不算大。</p><p>吊球方面，劈吊和 Arc11 区别不大；而滑板吊的动作由于本身发力更难，使用 AX100zz 的失误率比 Arc11 要明显高一些。</p><p>反手高远方面，AX100zz 对发力的要求明显更高。前三拍感觉都没能很好发力，打得有点木木的。调整后整体感觉 AX100zz 明显吃力一些。</p><h2 id="前场击球"><a href="#前场击球" class="headerlink" title="前场击球"></a>前场击球</h2><p>个人感觉，前场的搓放由于发力小而巧，影响回球质量更多的是拍面大小和拍线（型号和磅数）。实际 AX100zz 的拍面和 Arc11 相比只是稍微小一些，而拍线又完全相同（穿线师傅都是同一个），整体感觉前场搓放差异不大。但是，不知是不是错觉，使用 AX100zz 做假动作搓放时，感觉更得心应手一些。</p><p>挑推方面，个人感觉差异不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>4U 版本的 AX100zz 属于相对容易上手的高端拍。但其对发力的要求，不那么糖水，需要更短粗的爆发发力才能驾驭。</p><p>个人意见，可以视作是 3U 版本 Arc11 的进攻加强版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇是 Yonex AX100zz 的打感自测。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Yonex" scheme="https://liam.page/tags/Yonex/"/>
    
      <category term="Racket" scheme="https://liam.page/tags/Racket/"/>
    
  </entry>
  
  <entry>
    <title>为英文信件选用合适的结束语</title>
    <link href="https://liam.page/2022/06/19/Email-Closing-Lines/"/>
    <id>https://liam.page/2022/06/19/Email-Closing-Lines/</id>
    <published>2022-06-19T09:55:23.000Z</published>
    <updated>2022-06-20T04:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。</p><span id="more"></span><h2 id="对熟人"><a href="#对熟人" class="headerlink" title="对熟人"></a>对熟人</h2><p>从自然到刻意，可选项有：</p><ul><li>什么都不留：都已经比较熟悉了，还留啥结束语呢？</li><li>XOXO：这是表示好友间拍对方屁股那种熟稔的情感表达。</li><li>Tnx：Thanks 的缩写，因为是熟人，所以缩写也没毛病。</li><li>Love&#x2F;With Love&#x2F;Much love：刻意程度依次增加，但都还好。</li><li>Sincerely：熟人用 Sincerely 还是可以的，但是显得刻意。</li><li>Yours truly&#x2F;Yours sincerely：就很刻意有没有！</li></ul><h2 id="对不熟悉的人"><a href="#对不熟悉的人" class="headerlink" title="对不熟悉的人"></a>对不熟悉的人</h2><p>从自然到刻意，可选项有：</p><ul><li>Best&#x2F;Best regards：万金油，如果拿捏不准，就一个 Best 完事儿就好了。完全体的 Best regards 会显得有些生分，初次沟通可以用。</li><li>Cheers：好像是和不熟悉的人，远远干一杯的感觉。</li><li>Sincerely：跟不熟悉的人说 Sincerely 也是合适的，而且因为不熟悉，所以也不会显得那么刻意。</li><li>All the best：不那么自然，但是也不会显得刻意。相对来说比较正式。</li><li>Thank you：正常人谁说「Thank you」呀！</li><li>With warm regards：艾玛，老古板的形象跃然纸上啊哈哈哈！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Mail" scheme="https://liam.page/tags/Mail/"/>
    
      <category term="E-Mail" scheme="https://liam.page/tags/E-Mail/"/>
    
      <category term="Closing" scheme="https://liam.page/tags/Closing/"/>
    
  </entry>
  
  <entry>
    <title>提升时间机器（Time Machine）的备份速度</title>
    <link href="https://liam.page/2022/05/07/speed-up-time-machine-backup/"/>
    <id>https://liam.page/2022/05/07/speed-up-time-machine-backup/</id>
    <published>2022-05-07T09:47:17.000Z</published>
    <updated>2022-05-07T09:56:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。</p><span id="more"></span><p>经查，类似时间机器备份或是自 MAS 下载和安装软件的行为，苹果将其优先级调低，并设置有限流（throttle）这一设定。这是为了保证这些优先级较低的行为不会占用过多的系统资源，干扰正常的工作。</p><p>这个设定的出发点是好的，但存在一个问题。比如说，对我而言，使用时间机器备份通常发生在无需使用电脑工作的时间段。此时，限流的这个设定就十分让人蛋疼了。为此，我们可以在命令行暂时关闭限流，待备份完成后再重新打开。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭限流功能，加速备份</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=0</span><br><span class="line"><span class="comment"># 备份完成，重新打开限流功能，避免意外的干扰</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="Time Machine" scheme="https://liam.page/tags/Time-Machine/"/>
    
  </entry>
  
  <entry>
    <title>设计一个线程池</title>
    <link href="https://liam.page/2022/05/05/design-a-thread-pool/"/>
    <id>https://liam.page/2022/05/05/design-a-thread-pool/</id>
    <published>2022-05-05T12:30:35.000Z</published>
    <updated>2022-05-05T15:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。</p><span id="more"></span><h2 id="初步讨论"><a href="#初步讨论" class="headerlink" title="初步讨论"></a>初步讨论</h2><h3 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h3><p>自 C++11 起，在 C++ 中使用线程就变得很简单。最基本地，可以用 <code>std::thread</code> 来管理一个线程。若是要异步地执行任务，搭配使用 <code>std::async</code> 和 <code>std::future</code> 也很方便。在有这些基础设施的基础上，我们为什么还需要线程池？或者说，我们什么时候需要线程池？</p><p>众所周知，线程作为一种系统资源，其创建和销毁是需要时间的。因此，如果创建和销毁线程的时间和执行任务所需的时间处在同一个数量级，那么频繁地创建和销毁线程带来的性能损耗就会变得十分可观。此时，我们就要考虑使用线程池。</p><h3 id="线程池应有哪些特点？"><a href="#线程池应有哪些特点？" class="headerlink" title="线程池应有哪些特点？"></a>线程池应有哪些特点？</h3><p>线程池的本质就是一组待用的线程。在 C++ 中，它可以表示为一个 <code>std::thread</code> 的数组或是向量。在实际工程中，为便于进行可能的扩展，使用 <code>std::vector&lt;std::thread&gt;</code> 显然会更加合适。</p><p>对于线程池中的每个线程，它都可能在某个时刻接收到一个任务。而这个任务具体是什么，在线程创建时并不知道。用 C++ 的语言表达就是说，线程池中的线程：</p><ul><li>应当可以执行任意函数——支持任何参数列表，也支持任何返回值类型；</li><li>应当可以将任务的执行结果反馈给任务的发布者；</li><li>应当可以在需要时被唤醒执行任务，而在无需时不占用过多 CPU 资源；</li><li>应当可以被主控线程控制，在适当的时候暂停任务、停止接收任务、丢弃未完成任务等。</li></ul><p>对于第一条，modern C++ 的做法应该是利用 <code>functional</code> 头文件提供的基础设施（<code>std::bind</code>, <code>std::function</code> 等）结合模板参数包来实现。对于第二条，old-fashion 的做法是在发布任务时同时注册回调函数；modern C++ 的做法应该是利用 <code>std::packaged_task</code> 结合 <code>std::future</code> 来实现。对于第三条，若是任务来得不那么频繁，应当考虑使用 <code>std::condition_variable</code> 来实现；若是任务十分频繁，则可以考虑使用 <code>std::this_thread::yield</code>。对于第四条，则可以设置一个内部变量作为标记，让每个工作线程都定期检查该标记来实现。</p><p>我们讨论到了任务。显然，我们会需要一个线程安全的队列来管理其他线程发布的任务。</p><h2 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h2><p>我们不妨直接从代码入手，逐步分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocking_queue</span> : <span class="keyword">protected</span> std::queue&lt;T&gt; &#123;  <span class="comment">// 1.</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> wlock = std::unique_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.a</span></span><br><span class="line">  <span class="keyword">using</span> rlock = std::shared_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.b</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">blocking_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">blocking_queue</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">blocking_queue</span>(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="built_in">blocking_queue</span>(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.b</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>; <span class="comment">// 3.c</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.d</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.a</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.b</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.a</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">push</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.b</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">emplace</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; holder)</span> </span>&#123;  <span class="comment">// 6.</span></span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      holder = std::<span class="built_in">move</span>(std::queue&lt;T&gt;::<span class="built_in">front</span>());</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::shared_mutex mtx_;  <span class="comment">// 7.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>blocking_queue</code> 继承 <code>std::queue</code>，最基本的队列的实现交给标准库。</li><li>利用 <code>std::shared_mutex</code> 结合 <code>std::unique_lock</code> 和 <code>std::shared_lock</code> 实现读写锁。</li><li>此处我们禁用了拷贝和移动构造函数及对应的赋值运算符。这纯粹是因为在实现线程池的过程中我们用不到它们。如果需要，是可以按需实现的。</li><li>在两个 observers 当中，我们使用了只读锁。</li><li><code>push</code> 和 <code>emplace</code> 是类似的操作，都是在队尾追加元素。他们的区别与联系就和标准库容器的接口一样。注意在 <code>emplace</code> 当中，我们用到了完美转发技术。</li><li>这里的 <code>pop</code> 其实更合适称作 <code>try_pop</code>。因为 <code>pop</code> 动作在此处并不一定成功，在队列为空时，函数返回 <code>false</code> 而不会对队列做任何修改。</li><li>这是一把针对整个队列的粗粒度锁。实际上，因为队列的 push 和 pop 一定程度上是分开的，小心地话，可以实现一个细粒度版本的锁，在 push 和 pop 操作都频繁的情况下会有显著的性能提升。关于这一点，我们之后可以单列一篇文章进行讨论。</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>按先前的讨论，我们可以整理出线程池的大致模样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;  <span class="comment">// stop and process all delegated tasks</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">()</span></span>;     <span class="comment">// stop and drop all tasks remained in queue</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 2.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_running</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;  <span class="comment">// 4.</span></span><br><span class="line">  <span class="keyword">mutable</span> blocking_queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks_;  <span class="comment">// 5.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一组的三个接口是整个线程池的控制接口。<code>init</code> 接口启动线程池，其参数 <code>num</code> 即是线程池中线程的数量。<code>terminate</code> 接口终止线程池，不再接受新的任务，并保证将已接受的任务处理完毕。<code>cancel</code> 与 <code>terminate</code> 类似，但它将丢弃已接受但未处理完毕的任务。</li><li>第二组的三个接口均是 observers。</li><li>第三组中的唯一一个接口是线程池接受外部任务的接口。它和标准库提供的 <code>std::async</code> 几乎一致，接受任意函数，并返回一个 <code>std::future</code>。</li><li>这是线程池本体。</li><li>这是任务队列。</li></ol><h3 id="线程池的控制接口"><a href="#线程池的控制接口" class="headerlink" title="线程池的控制接口"></a>线程池的控制接口</h3><p>接下来我们讨论控制接口的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::init</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_, [<span class="keyword">this</span>, num]() &#123;  <span class="comment">// 1.</span></span><br><span class="line">    wlock <span class="built_in">lock</span>(mtx_);  <span class="comment">// 2.</span></span><br><span class="line">    stop_ = <span class="literal">false</span>;</span><br><span class="line">    cancel_ = <span class="literal">false</span>;</span><br><span class="line">    workers_.<span class="built_in">reserve</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      workers_.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;threadpool::spawn, <span class="keyword">this</span>));  <span class="comment">// 3.a</span></span><br><span class="line">    &#125;</span><br><span class="line">    inited_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::spawn</span><span class="params">()</span> </span>&#123;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">bool</span> pop = <span class="literal">false</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">      cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, &amp;pop, &amp;task] &#123;</span><br><span class="line">        pop = tasks_.<span class="built_in">pop</span>(task);</span><br><span class="line">        <span class="keyword">return</span> cancel_ || stop_ || pop;  <span class="comment">// 4.</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cancel_ || (stop_ &amp;&amp; !pop)) &#123;  <span class="comment">// 5.a</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 5.b</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::terminate</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.a</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      stop_ = <span class="literal">true</span>;  <span class="comment">// 7.a</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::cancel</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.b</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      cancel_ = <span class="literal">true</span>;  <span class="comment">// 7.b</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tasks_.<span class="built_in">clear</span>();  <span class="comment">// 8.</span></span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> threadpool::_is_running() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> inited_ &amp;&amp; !stop_ &amp;&amp; !cancel_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>init</code> 完成的工作，在逻辑上只能进行一次。但我们无法保证用户代码确实如我们所想地这样执行。因此，我们利用 <code>std::call_once</code> 保证相关工作只执行一次。</li><li>因为涉及到修改 <code>threadpool</code> 的状态，所以此处使用写入锁。</li><li><code>spawn</code> 接口是线程函数，也就是线程启动后一直运行的函数。</li><li>当线程被唤醒时（无论是意外唤醒，还是被 <code>notify_*</code> 函数唤醒），若线程池没有被 <code>cancel</code> 或是 <code>terminate</code>，也没能从任务队列中取出任务，则线程应该继续沉眠，否则就应该醒来继续处理。</li><li>如果线程池被 <code>cancel</code>，则不执行当前任务；如果线程池被停止并且没能从任务队列中取出任务，则也不执行当前任务；否则就执行当前任务。</li><li><code>terminate</code> 和 <code>cancel</code> 的实现几乎完全相同；</li><li>唯独 <code>terminate</code> 修改 <code>stop_</code> 变量而 <code>cancel</code> 修改 <code>cancel_</code> 变量。</li><li>此外，<code>cancel</code> 接口显式地清空了任务队列。</li></ol><h3 id="线程池的观察器"><a href="#线程池的观察器" class="headerlink" title="线程池的观察器"></a>线程池的观察器</h3><p>观察器比较简单，唯一值得一提的是这里使用了读取锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::inited</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> inited_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::is_running</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> _is_running();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">threadpool::size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> workers_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务接口"><a href="#任务接口" class="headerlink" title="任务接口"></a>任务接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">threadpool::async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">return_t</span> = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 1.a</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">future_t</span> = std::future&lt;<span class="type">return_t</span>&gt;;  <span class="comment">// 1.b</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">task_t</span> = std::packaged_task&lt;<span class="built_in">return_t</span>()&gt;;  <span class="comment">// 1.c</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span> (stop_ || cancel_)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">          <span class="string">&quot;Delegating task to a threadpool &quot;</span></span><br><span class="line">          <span class="string">&quot;that has been terminated or canceled.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bind_func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);  <span class="comment">// 3.</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">task_t</span>&gt; task = std::<span class="built_in">make_shared</span>&lt;<span class="type">task_t</span>&gt;(std::<span class="built_in">move</span>(bind_func));  <span class="comment">// 4.a</span></span><br><span class="line">  <span class="type">future_t</span> fut = task-&gt;<span class="built_in">get_future</span>();  <span class="comment">// 4.b</span></span><br><span class="line">  tasks_.<span class="built_in">emplace</span>([task]() -&gt; <span class="type">void</span> &#123; (*task)(); &#125;);  <span class="comment">// 5.</span></span><br><span class="line">  cond_.<span class="built_in">notify_one</span>();  <span class="comment">// 6.</span></span><br><span class="line">  <span class="keyword">return</span> fut;  <span class="comment">// 4.c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>using</code> 定义的三个类型，见文知意。</li><li>这里不涉及对线程池状态的修改，因此只需要读取锁即可。显然，此处我们禁止对已经 <code>terminate</code> 或是 <code>cancel</code> 的线程池继续发布任务。</li><li>由于任务队列只接收 <code>std::function&lt;void()&gt;</code> 的可调用对象，此处我们利用 <code>std::bind</code> 先匹配参数列表。</li><li>此处我们利用 <code>std::packaged_task</code> 将待执行的任务与一个 <code>std::future</code> 关联起来，并将 <code>std::future</code> 返回给外界，以便任务发布者可以在将来取得任务执行结果。</li><li>这里我们利用一个 lambda，既执行了任务，又将返回值抹去（但会被 future 管理），以便匹配 <code>std::function&lt;void()&gt;</code>。</li><li>此处我们通过条件变量唤醒工作线程。</li></ol><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>完整实现可见 <a href="https://github.com/Liam0205/toy-threadpool">Liam0205&#x2F;toy-threadpool</a>，其中包括了单元测试和相比 <code>std::async</code> 的性能对比。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>这里我们实现了一个可看使用的线程池。但如 GitHub 的 repo 名字一样，它还只是个玩具。若要在工程中使用，还可以做一系列优化。例如说：</p><ul><li>对线程安全队列进行优化，使用更细粒度的锁（完整实现当中已有），或者换用无锁实现。</li><li>完善的线程池，除了支持本文提到的几种状态，还可以有暂停、扩张（任务过多时自动扩张）、收缩（空闲线程过多时自动收缩）等能力。</li></ul><p>这些内容都可以继续去深挖、优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Thread" scheme="https://liam.page/tags/Thread/"/>
    
      <category term="Threadpool" scheme="https://liam.page/tags/Threadpool/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS Monterey 12.3 上因缺失 Python 2.7 导致的问题</title>
    <link href="https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/"/>
    <id>https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/</id>
    <published>2022-04-01T04:10:06.000Z</published>
    <updated>2022-04-16T12:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Termination Reason: Namespace DYLD, Code 1 Library missing</span><br><span class="line">Library not loaded: /System/Library/Frameworks/Python.framework/Versions/2.7/Python</span><br><span class="line">Referenced from: /Applications/CHIRP.app/Contents/CHIRP</span><br><span class="line">Reason: tried: &#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file), &#x27;/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file)</span><br></pre></td></tr></table></figure><p>这是由于 Apple 在 macOS Monterey 12.3 开始，<a href="https://developer.apple.com/documentation/macos-release-notes/macos-12_3-release-notes#Python">移除了随系统发行的 Python 2.7</a>；于是，尚在依赖 Python 2.7 的 App 在启动时的动态链接阶段就会出错而崩溃。</p><p>考虑到部分 App 尚未更新以解除对 Python 2.7 的依赖，这里我们需要手动安装 Python 2.7。为此，我们可在 Python 官网上找到历史版本（<a href="https://www.python.org/ftp/python/2.7.18/python-2.7.18-macosx10.9.pkg">Python 2.7.18</a>）并下载安装。按我的经验，自主安装 Python 2.7.18 之后，问题即得到解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Monterey" scheme="https://liam.page/tags/Monterey/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑬）：C++ 的内存顺序·下</title>
    <link href="https://liam.page/2021/12/14/memory-order-cpp-03/"/>
    <id>https://liam.page/2021/12/14/memory-order-cpp-03/</id>
    <published>2021-12-13T16:14:42.000Z</published>
    <updated>2021-12-18T11:52:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于<a href="/2021/06/05/memory-model-cpp/">内存模型</a>和内存顺序（<a href="/2021/06/06/memory-order-cpp-01/">上</a>、<a href="/2021/12/11/memory-order-cpp-02/">中</a>）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。</p><p>此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。</p><span id="more"></span><h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>让我们从一个最简单的生产者&#x2F;消费者的例子出发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;  <span class="comment">// 1.a.</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 1.b.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">1024</span>);  <span class="comment">// 2.</span></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready.<span class="built_in">load</span>()) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; data[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 5.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::thread a&#123;producer&#125;, b&#123;consumer&#125;;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，(1) 初始化了全局共享的数据 <code>data</code> 和原子标记 <code>ready</code>。生产者线程中，(2) 对全局共享的数据进行修改，并在 (3) 处将标记设置为 <code>true</code>。消费者线程中，(4) 循环等待原子标记（当然，它效率极低；作为示例我们暂时忽略这个问题），而后在 (5) 处读取共享数据。</p><p>我们知道，在多个线程中，并发读写同一个内存位置（此处的 <code>&amp;data[0]</code>）可能造成数据竞争，必须有相应的同步机制。此处同步机制由原子标记 <code>ready</code> 协助建立。</p><ul><li>(2) <ins>先于（happens-before）</ins> (3)；</li><li><strong>当 (4) 读到 <code>ready.load()</code> 为真</strong>，则 (3) 与 (4) 建立<ins>同步（synchronizes-with）</ins>关系，因而有 (3) <ins>先于（happens-before）</ins> (4)；</li><li>(4) <ins>先于（happens-before）</ins> (5)。</li></ul><p>在原子标记 <code>ready</code> 的协助下，我们建立了对 <code>data</code> 的写<ins>先于（happens-before）</ins>读的顺序关系，数据竞争的风险就此解除。</p><p>整体看下来，这一过程非常符合直觉。而我们知道，原子变量除了保证其上原子操作的原子性之外，各个操作还有内存顺序标记。不同的顺序标记会影响编译器优化和 CPU 执行时的行为；更准确地，影响原子操作附近访问内存的顺序。默认的顺序标记是 <code>std::memory_order_seq_cst</code>。之所以将它作为默认标记，是因为它能带来这一符合直觉的结果。</p><p>接下来，我们顺势讨论<ins>先于（happens-before）</ins>关系和<ins>同步（synchronizes-with）</ins>关系。</p><h2 id="两种关系"><a href="#两种关系" class="headerlink" title="两种关系"></a>两种关系</h2><h3 id="同步（synchronizes-with）关系"><a href="#同步（synchronizes-with）关系" class="headerlink" title="同步（synchronizes-with）关系"></a><ins>同步（synchronizes-with）</ins>关系</h3><p><ins>同步（synchronizes-with）</ins>关系，追根究底只能由原子操作提供。我们能见到的所有产生同步关系的办法，其底层都包含了某些原子操作。同步关系是这样建立的，</p><ul><li>首先有在线程 A 中对原子变量 <code>x</code> 打上恰当标记的写入操作 <code>W</code>；</li><li>而后有在线程 B 中对原子变量 <code>x</code> 打上恰当标记的读取操作 <code>R</code>。</li></ul><p>若 <code>R</code> 读到的值，来自以下任意一种情况，则说 <code>W</code> 与 <code>R</code> <ins>同步（synchronizes-with）</ins>。</p><ul><li><code>W</code> 的写入；或者</li><li>线程 A（<code>W</code> 所在线程）中，<code>W</code> 之后的某次写入；或者</li><li>任意线程中的一系列 read-modify-write 操作中的写入值，其中第一次 read-modify-write 操作读到的值来自 <code>W</code> 的写入。</li></ul><p>这得到一个最基本的认知：（在顺序标记恰当的情况下，）如果线程 B 的读取操作读到的是线程 A 的写入操作的写入值，则写入操作与读取操作同步。</p><p>如此一来，所有的细节就在「恰当」二字之上了。不过，我们先来讨论<ins>先于（happens-before）</ins>关系。</p><h2 id="先于（happens-before）关系"><a href="#先于（happens-before）关系" class="headerlink" title="先于（happens-before）关系"></a><ins>先于（happens-before）</ins>关系</h2><p><ins>先于（happens-before）</ins>关系是讨论内存顺序中最重要的基石。若 A <ins>先于（happens-before）</ins> B，则 B 能看到 A 带来的副作用。</p><p>在单线程里面，<ins>先于（happens-before）</ins>关系很简单。单线程当中的<ins>先于（happens-before）</ins>关系即是<ins>先序（sequenced-before）</ins>关系。一般来说，不考虑编译器优化重排和 CPU 乱序执行重排时，在代码当中，靠前的语句当中的操作<ins>先于（happens-before）</ins>靠后的语句当中的操作。但实际上，我们需要考虑编译器优化和 CPU 乱序执行对先序关系带来的影响。</p><p>在线程之间，若线程 A 的写入操作与线程 B 的读取操作<ins>同步（synchronizes-with）</ins>，则该写入操作<ins>线程间先于（inter-thread happens-before）</ins>该读取操作，也因此该写入操作<ins>先于（happens-before）</ins>该读取操作。</p><h2 id="三种顺序模型"><a href="#三种顺序模型" class="headerlink" title="三种顺序模型"></a>三种顺序模型</h2><p>按前文，顺序标记共有六种：</p><ul><li><code>std::memory_order_relaxed</code></li><li><code>std::memory_order_consume</code></li><li><code>std::memory_order_acquire</code></li><li><code>std::memory_order_release</code></li><li><code>std::memory_order_acq_rel</code></li><li><code>std::memory_order_seq_cst</code></li></ul><p>六种标记又能组成三种顺序模型：</p><ul><li>顺序一致模型（sequentially consistent ordering）：最强的顺序模型。对编译器优化限制最多，所需额外 CPU 同步指令最多，性能也最差；但最符合直觉。涉及到的顺序标记是 <code>std::memory_order_seq_cst</code>。</li><li>宽松模型（relaxed ordering）：最弱的顺序模型。对编译器优化限制最少（几乎没有），所需额外 CPU 同步指令最少（几乎没有），性能也最好；但无法建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_relaxed</code>。</li><li>获取-释放模型（acquire-release ordering）：介于二者之间。对编译器优化限制适中，所需额外的 CPU 同步指令也适中（在部分平台上，不许额外同步指令），性能也适中；可以建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_acq_rel</code>, <code>std::memory_order_acquire</code>, <code>std::memory_order_release</code> 和 <code>std::memory_order_consume</code>。</li></ul><blockquote><p>注意，<code>std::memory_order_consume</code> 与 <code>std::memory_order_acquire</code> 相似，但比后者更弱。但完整地实现 <code>std::memory_order_consume</code> 的语义，需要追踪变量之间的依赖链。目前，还没有已知的编译器实现了它。现有的编译器，都将 <code>std::memory_order_consume</code> 提升为 <code>std::memory_order_acquire</code>。故而此处也将 <code>std::memory_order_consume</code> 归在获取-释放模型当中。此外，考虑 <code>std::memory_order_consume</code> 的语义可能发生变化，目前标准也不建议使用 <code>std::memory_order_consume</code>。</p></blockquote><h3 id="顺序一致模型（sequentially-consistent-ordering）"><a href="#顺序一致模型（sequentially-consistent-ordering）" class="headerlink" title="顺序一致模型（sequentially consistent ordering）"></a>顺序一致模型（sequentially consistent ordering）</h3><p>默认的顺序模型是「顺序一致模型」。如果所有原子操作的顺序标记都是 <code>std::memory_order_seq_cst</code>，那么多线程程序的行为就好像这些操作以某一特定的顺序在单一的线程中执行一样。特别地，站在所有被打上 <code>std::memory_order_seq_cst</code> 标记的操作上来看，所有先于该操作发生的原子操作（<code>std::memory_order_seq_cst</code>），都具有同样的顺序。</p><p>这是最符合直觉的模型。多数人第一次接触到多线程，会假定多线程中的各个操作是可能并发执行的，因此将他们理解为按照某个不确定的顺序穿插执行。然后在脑海中想象并构建这一固定的顺序，并按照这一顺序假定各个线程会如何工作。但这种符合直觉的模型并不总是成立。这种多线程之间全局统一的顺序，即是顺序一致性带来的保证。一旦保证不了顺序一致性，则这种基于「穿插执行」假定出来的全局统一顺序也就不成立了。</p><!-- From the point of view of synchronization, a sequentially consistent store synchronizes-with a sequentially consistent load of the same variable that reads the value stored. This provides one ordering constraint on the operation of two (or more) threads, but sequential consistency is more powerful than that. Any sequentially con- sistent atomic operations done after that load must also appear after the store to other threads in the system using sequentially consistent atomic operations. The example in listing 5.4 demonstrates this ordering constraint in action. This constraint doesn’t carry forward to threads that use atomic operations with relaxed memory orderings; they can still see the operations in a different order, so you must use sequentially con- sistent operations on all your threads in order to get the benefit. --><p>站在同步的角度来看，顺序一致 store 操作与读到本次写入值的顺序一致的 load 操作<ins>同步（synchronizes-with）</ins>。如前所述，这种同步关系在线程之间提供了一定的顺序限制。但顺序一致模型还保证，在这一顺序一致的 load 操作之后的顺序一致操作，在其他所有使用顺序一致原子操作的线程看来，也是发生在此次顺序一致 store 之后的。注意，如若某一线程中的某个原子操作没有使用 <code>std::memory_order_seq_cst</code> 标记，则在该操作看来，顺序一致的诸多操作的顺序可能与其他线程看到的不同。</p><p>前作当中的<a href="/2021/12/11/memory-order-cpp-02/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E9%A1%BA%E5%BA%8F%EF%BC%88Sequentially-consistent-ordering%EF%BC%89">例子</a>很好地说明了顺序一致性的效果。</p><!-- This ease of understanding can come at a price, though. On a weakly ordered machine with many processors, it can impose a noticeable performance penalty, because the overall sequence of operations must be kept consistent between the pro- cessors, possibly requiring extensive (and expensive!) synchronization operations between the processors. That said, some processor architectures (such as the common x86 and x86-64 architectures) offer sequential consistency relatively cheaply, so if you’re concerned about the performance implications of using sequentially consis- tent ordering, check the documentation for your target processor architectures. --><p>这种便利是有代价的。在默认的顺序保证相对较弱的平台上（如 ARM），顺序一致模型会引入可观的性能代价。这是因为，全局顺序一致需要在 CPU 逻辑核心之间保持一致性，这使得 CPU 逻辑核心之间需要使用代价高昂的同步操作。相较而言，部分处理器架构（例如 x86 和 x86-64）保证顺序一致性的代价较低。为避免这种同步代价，我们需要拥抱非顺序一致性模型。</p><hr><p>在处理非顺序一致性模型时，我们就要丢弃脑海中那种简洁漂亮的交替执行的思维模型。<strong>它不存在了</strong>。在没有顺序一致性保障的情况下，各个线程看到的原子操作的顺序并不保证统一。也就是说，虽然依旧是并发（所以穿插执行），但是每个线程看到的穿插的顺序可能是不一样的。在非顺序一致模型下写代码时，要时刻关注这一点。</p><p>不过，也有一致的地方。虽说各个线程观察到的原子操作发生的顺序可能不一致，但是，对于<strong>每一个特定的原子变量</strong>，作用在其上的原子操作的修改顺序（modification-order），在各个线程看来是统一的。</p><p>为了充分理解非顺序一致性模型，我们可以先考虑宽松模型。待对非顺序一致性有足够了解之后，再回到获取-释放模型。</p><h3 id="宽松模型（relaxed-ordering）"><a href="#宽松模型（relaxed-ordering）" class="headerlink" title="宽松模型（relaxed ordering）"></a>宽松模型（relaxed ordering）</h3><p>顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作不参与构建<ins>同步（synchronizes-with）</ins>关系。在同一线程中，对<strong>同一</strong>原子变量的原子操作的顺序遵循源代码中的<ins>先序（sequenced-before）</ins>关系（从而有<ins>先于（happens-before）</ins>关系）。但是，在另外的线程看来，这种顺序无法保证。由于未加任何同步限制，顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作只是简单地遵循各个原子变量自身的修改顺序（modification-order）而已。</p><p>首先看一段简单的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    z.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(<span class="number">0</span> != z.<span class="built_in">load</span>());  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照经典的「穿插思维模型」（即顺序一致性模型），(3) 处循环等待直到 <code>y</code> 为真，那么<strong>由于 (1) 先于 (2) 发生，(3) 先于 (4) 发生</strong>，所以 (4) 必然为真，因此 (5) 的断言永不失效。但实际上，由于 (1) -- (4) 的顺序标记都是 <code>std::memory_order_relaxed</code>，此处并无同步保证，也没有单线程中的先序关系保证。这也就是说，上述两个先于关系不一定成立；即便成立，(2) 不必然与 (3) <ins>同步（synchronizes-with）</ins>，因此也就无法传递上述两个先于关系。所以站在 (4) 的角度看，并不保证 (1) <ins>先于（happens-before）</ins> (4) 发生。所以 (4) 可能读到 <code>false</code> 导致断言失败。</p><p>接下来再看一个更加复杂的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> upper&#123;<span class="number">10UL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Snapshot t1[upper];</span><br><span class="line">Snapshot t2[upper];</span><br><span class="line">Snapshot t3[upper];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;* var, Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.a.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.a.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.a.</span></span><br><span class="line">    var-&gt;<span class="built_in">store</span>(i + <span class="number">1</span>, std::memory_order_relaxed);  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; snapshot.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; snapshot.y &lt;&lt; <span class="string">&quot;)&quot;</span>;  <span class="comment">// 5.</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">T1</span><span class="params">(increase, &amp;x, t1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T2</span><span class="params">(increase, &amp;y, t2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T3</span><span class="params">(observe, t3)</span></span>;</span><br><span class="line"></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 1.c.</span></span><br><span class="line"></span><br><span class="line">  T3.<span class="built_in">join</span>();</span><br><span class="line">  T2.<span class="built_in">join</span>();</span><br><span class="line">  T1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(t1);</span><br><span class="line">  <span class="built_in">print</span>(t2);</span><br><span class="line">  <span class="built_in">print</span>(t3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">(0,2),(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,10),(9,10)</span><br><span class="line">(0,0),(0,1),(0,2),(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9)</span><br><span class="line">(1,3),(2,4),(2,5),(3,6),(4,7),(5,8),(6,8),(7,9),(8,10),(8,10)</span><br></pre></td></tr></table></figure><p>我们首先来观察一下代码和结果。</p><p>代码部分，</p><ul><li><code>increase</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 次循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中，而后以 <code>std::memory_order_relaxed</code> 的顺序标记更新 <code>var</code> 指向的原子变量（要么是 <code>x</code>，要么是 <code>y</code>）。</li><li><code>observe</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 词循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中。</li><li><code>print</code> 打印历次循环得到的快照 (5)。每个二元组中，第一个数是当次循环读到的 <code>x</code> 的值；第二个数是对应的 <code>y</code> 的值。</li><li><code>ready</code> 变量确保三个线程在几乎相同的时间开始，以防（例如说）<code>T1</code> 已经执行完毕而 <code>T3</code> 还尚未开始执行。</li></ul><p>结果部分，</p><ul><li>第一行、第二行、第三行分别记录了 <code>T1</code>, <code>T2</code>, <code>T3</code> 在历次循环过程中记录下来的 <code>x</code> 和 <code>y</code> 的值的快照。</li><li>关于写<ul><li>对于 <code>T1</code> 来说，只有该线程修改 <code>x</code> 的值，每次读到它，都恰好自增 <code>1</code>；</li><li>同样对于 <code>T2</code> 来说，<code>y</code> 每次自增 <code>1</code>。</li></ul></li><li>关于读<ul><li>对于 <code>T1</code> 和 <code>T3</code> 来说，它们只读 <code>y</code> 的值。因为 <code>y</code> 的修改序列中，<code>y</code> 的值是递增的；因此 <code>T1</code> 和 <code>T3</code> 每次读到的 <code>y</code> 的值都不小于前一次读到的 <code>y</code> 的值；但递增的步长不一定均衡。</li><li>对于 <code>T2</code> 和 <code>T3</code> 来说，它们只读 <code>x</code> 的值。基于同样的理由，它们每次读到的 <code>x</code> 的值都是非递减的；但递增的步长不一定均衡。</li></ul></li></ul><p>这里我们只给出了一个可能的结果，实际上，符合上述规律的结果，都是可能出现的。</p><p>接下来我们正式地描述宽松模型下的规律。</p><ul><li>对于任意给定的原子变量，其<ins>修改顺序（modification-order）</ins>是全局唯一的。</li><li>对于任意线程，<ul><li>若未曾读取过该变量的值，则可能读取到修改顺序上任意可能的值。</li><li>一旦读取了某个原子变量在修改顺序上的某个值，将来再读取时，要么读取相同的值，要么读取到在修改顺序上更靠后的值，而不可能读到在修改顺序上更靠前的值。</li></ul></li><li>对于任意线程，一旦写入了某个原子变量，将来再读取时，要么读取到此次写入的值，要么读取到修改顺序上相对此次写入更靠后的值。</li></ul><p>我们可以使用这一规律来回顾本节第一段代码。对于变量 <code>x</code> 来说，其修改顺序是：默认值 <code>false</code>，由 <code>write_x_then_y</code> 写入的值 <code>true</code>。在 <code>read_y_then_x</code> 线程当中，由于从未读取过 <code>x</code> 的值，因此可能读到 <code>x</code> 的修改顺序上的任意值。——可能是 <code>false</code>，亦可能是 <code>true</code>。故而断言可能失败。</p><h3 id="获取-释放模型（acquire-release-ordering）"><a href="#获取-释放模型（acquire-release-ordering）" class="headerlink" title="获取-释放模型（acquire-release ordering）"></a>获取-释放模型（acquire-release ordering）</h3><p>接下来，我们讨论居于宽松模型和顺序一致模型当中的获取-释放模型（acquire-release ordering）。</p><p>获取-释放模型当中，依然不存在顺序一致模型当中那样的全局唯一操作顺序，但相较宽松模型，增加了部分同步能力。在获取-释放模型当中，</p><ul><li>原子-store 操作是<ins>释放操作（release-operation）</ins>（<code>std::memory_order_acquire</code>）；</li><li>原子-load 操作是<ins>获取操作（acquire-operation）</ins>（<code>std::memory_order_release</code>）；</li><li>原子-read-modify-write 操作（例如 <code>fetch_add</code> 或是 <code>exchange</code>）则要么是释放操作，要么是获取操作，要么同时是释放-获取操作（<code>std::memory_order_acq_rel</code>）。</li></ul><p>同步总是在线程之间成对出现的。一个线程中的释放操作与另一个线程中读到该次写入的获取操作<ins>同步（synchronizes-with）</ins>。这意味着，不同线程可能观察到不同的操作顺序，但这些顺序是有所限制的。</p><p>同样地，我们来看一个示例。这个例子是从顺序一致性模型的例子上稍加修改而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 6.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// can fire</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，断言可能失败。我们来做进一步分析。</p><p>(1) 处是释放操作；(3) 处通过循环确保读到 (1) 写入的值。因而 (1) 的释放操作与 (3) 的获取操作配对，建立<ins>同步（synchronizes-with）</ins>关系，于是 (1) 顺势与 (4) 建立<ins>先于（happens-before）</ins> 关系。同理，(2) 与 (5) 之间也有同步关系，(2) 顺势与 (6) 建立<ins>先于（happens-before）</ins> 关系。</p><p>然而，我们无法建立 (1) <ins>先于（happens-before）</ins> (6) 的关系。故而 (6) 可能读到变量 <code>x</code> 的修改序列上的任意值。例如说，可能读到 <code>false</code>。同理 (4) 也可能读到 <code>false</code>。二者同时发生时，断言失败。</p><p>因为 store 操作发生在不同的线程，故而我们无法借助一个原子变量的同步关系，构造另一个原子变量的写与读之间的先于关系。这告诉我们两件事情。一是，对于多写多读的场景，我们往往需要顺序一致性模型。二是，若要应用获取-释放模型，store 操作应当发生在同一线程。</p><p>接下来我们再看一例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 3.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑 (1) 和 (2) 在同一线程中，有<ins>先序（sequenced-before）</ins>关系（release 语义保证不乱序）；(3) 处的 spin-wait 保证读到 (2) 的写入，因而 (2) 与 (3) <ins>同步（synchronizes-with）</ins>，再有 (3) 与 (4) 在同一线程中，也有先序关系（acquire 语义保证不乱序）。故而 (1) 必须先于 (4)，从而 (4) 的判断必定成立，而 (5) 的断言永不失败。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>C++ 标准库也提供了内存屏障 <code>std::atomic_thread_fence</code>，它也可以打上顺序标签。</p><p>理解起来，带上 <code>std::memory_order_release</code> 的内存屏障，倾向于向下结合一个 store 操作，将它的内存顺序提升为 <code>std::memory_order_release</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。带上 <code>std::memory_order_acquire</code> 的内存屏障，倾向于向上结合一个 load 操作，将它的内存顺序提升为 <code>std::memory_order_acquire</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。从而建立获取-释放的同步关系。</p><p>我们可以将上例稍加修改得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2.a.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 3.a.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 3.b.</span></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，(2.a) 的 release-屏障向下与 (2.b) 的宽松-store 操作结合，使得该操作提升为 release-store；(3.b) 的 acquire-屏障向上与 (3.a) 的宽松-load 操作结合，使得该操作提升为 acquire-load。reloease-store 和 acquire-load 构成<ins>同步（synchronizes-with）</ins>，又有 release&#x2F;acquire 语义保证局部顺序，因此有 (1) <ins>先于（happens-before）</ins> (4)，从而 (5) 的断言不会失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;和内存顺序（&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;上&lt;/a&gt;、&lt;a href=&quot;/2021/12/11/memory-order-cpp-02/&quot;&gt;中&lt;/a&gt;）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。&lt;/p&gt;
&lt;p&gt;此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
</feed>
