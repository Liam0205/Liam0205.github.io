<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2023-01-19T04:00:30.336Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 越狱后插件推荐</title>
    <link href="https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/"/>
    <id>https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/</id>
    <published>2023-01-19T02:53:10.000Z</published>
    <updated>2023-01-19T04:00:30.336Z</updated>
    
    <content type="html"><![CDATA[<p>手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。</p><span id="more"></span><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><ul><li>iPhone Xʀ</li><li>iOS 14.5.1</li><li>unc0ver 8.0.2</li></ul><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>首先是介绍一下我订阅的软件源。</p><ul><li>Zebra：<a href="https://getzbra.com/repo/">https://getzbra.com/repo/</a></li><li>BigBoss：<a href="http://apt.thebigboss.org/repofiles/cydia/">http://apt.thebigboss.org/repofiles/cydia/</a></li><li>Bingner&#x2F;Elucubratus：<a href="https://apt.bingner.com/">https://apt.bingner.com/</a></li><li>Limneos Repo：<a href="https://limneos.net/repo/">https://limneos.net/repo/</a></li><li>Chariz：<a href="https://repo.chariz.io/">https://repo.chariz.io/</a></li><li>Havoc：<a href="https://havoc.app/">https://havoc.app/</a></li><li>jjolano：<a href="https://ios.jjolano.me/">https://ios.jjolano.me/</a></li><li>opa334&#39;s Repo：<a href="https://opa334.github.io/">https://opa334.github.io/</a></li><li>ichitaso repository：<a href="http://cydia.ichitaso.com/">http://cydia.ichitaso.com/</a></li><li>蜗牛源：<a href="https://repo.snailovet.com/">https://repo.snailovet.com/</a></li><li>AutoTouch：<a href="https://repo.autotouch.net/">https://repo.autotouch.net/</a></li><li>Packix：<a href="https://repo.packix.com/">https://repo.packix.com/</a></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里按照大致的安装时间顺序介绍我目前还在使用的插件。</p><ul><li>Zebra：替代 Cydia 的包管理器。其运行效率和操作流畅度远胜 Cydia。来源：Zebra。</li><li>RespringModule：控制中心插件，点按后可以重载 SpringBoard。来源：BigBoss。</li><li>RebootModule：控制中心插件，点按后可以重启手机。来源：BigBoss。</li><li>OpenSSH CC Toggle：控制中心插件，点按后可以切换手机中 sshd 的运行状态。来源：BigBoss。</li><li>iPonCC：控制中心插件。在控制中心显示 IP 地址。来源：BigBoss。</li><li>Uptime：控制中心插件。在控制中心显示当前系统已经运行的时间。来源：Havoc。</li><li>CCBadgeClear：控制中心插件。点按后可以清除 App 图标右上角的角标数字。来源：BigBoss。</li><li>LocationService (CCSupport)：控制中心插件。点按后可以切换系统定位服务的状态。来源：ichitaso repository。</li><li>Filza File Manager：著名的文件管理器。来源：BigBoss。</li><li>MTerminal：著名的终端模拟器。来源：Bingner&#x2F;Elucubratus。</li><li>左滑返回：允许从屏幕右侧向中间单指滑动执行返回操作（类似于系统默认提供的从屏幕左侧向中间单指滑动的操作）。对于大屏幕的机器，单手操作十分友好。来源：BigBoss。</li><li>kai：可以在锁屏界面和通知中心界面显示各个关联设备（耳机、Apple Watch 等）的电量状态。来源：Chariz。</li><li>NFCWriter XS：著名的 NFC 模拟&#x2F;写入 App。它可以读取外部的 NFC tag，然后模拟出来。例如，可以用来模拟小区门禁卡。来源：Limneos Repo。</li><li>BioProtect XS：著名的生物信安保护插件。它可以按照 App、Folder 等维度，设置是否需要验证生物信安（Face ID&#x2F;Touch ID）。来源：Limneos Repo。</li><li>AudioRecoder XS：著名的通话录音插件。它能自动录制呼入呼出的电话并保存在手机本地，还支持自动上传到云（Google Drive&#x2F;Dropbox）。来源：Limneos Repo。</li><li>vnodebypass：越狱检测屏蔽插件。是已安装的四个同类插件中整体效果最差者。注意，它依赖 libkrw（Bingner&#x2F;Elucubratus），需要手动安装。来源：ichitaso repository。</li><li>Hestia：越狱检测屏蔽插件。是已安装的四个同类插件中整体效果较差者。来源：Havoc。</li><li>A-Bypass：越狱检测屏蔽插件。是已安装四个同类插件中整体效果较好者。来源：MERONA Repo。</li><li>Shadow：越狱检测屏蔽插件。是已安装四个同类插件中整体效果最好者。来源：jjolano。</li><li>Aemulo：可能是最好的 NFC 模拟&#x2F;写入 App。它的功能和 NFCWriter XS 类似，但还额外提供了将 NFC tag 保存入 Apple Wallet 的功能。这使得我们可以在锁屏界面调出 NFC tag，解开小区门禁。来源：Chariz。</li><li>Activator：著名的手势操作插件。来源：BigBoss。</li><li>Choicy：注入管理插件。它可以按照 App 维度，以白名单&#x2F;黑名单的方式禁用插件。来源：opa334&#39;s Repo。</li><li>Apps Manager：可以清除、备份、恢复 App 的 AppData 的插件。来源：BigBoss。</li><li>iCleaner Pro：可以清理 iPhone 上的闪存空间的插件。它还可以对启动项进行调整。来源：MainRepo。</li><li>AppStore++：允许你对来自 AppStore 的 App 进行指定版本的升降级操作，还能设置屏蔽某些 App 的升级。来源：MainRepo。</li><li>AppStore++ 去广告：其功能显而易见。来源：蜗牛源。</li><li>位置自动允许一次 &#x2F;&#x2F; AllowLocationOnce：在 App 请求系统位置服务时，自动点选「允许一次」。来源：蜗牛源。</li><li>AutoTouch：类似 Windows 系统上的「按键精灵」。它可以录制你的手势操作，然后按照指定方式触发，并可搭配 Activator 使用。来源：AutoTouch。</li><li>SmartVPN：它可以按照 App 维度进行设置，在 App 运行时自动启动 VPN，在所有白名单 App 关闭时自动关闭 VPN。来源：BigBoss。</li><li>AutoFolderClose：在启动 App 后，自动关闭 Folder。即是说，从 App 回到主屏幕后，你不会看到还开着的 Folder。来源：Packix。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Tweaks" scheme="https://liam.page/tags/Tweaks/"/>
    
  </entry>
  
  <entry>
    <title>清理加湿器振动片上的水垢以减小其噪声</title>
    <link href="https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/"/>
    <id>https://liam.page/2022/11/24/clean-the-scale-on-the-vibrating-plate-of-the-humidifier-to-reduce-its-noise/</id>
    <published>2022-11-24T11:03:55.000Z</published>
    <updated>2022-11-24T11:23:55.081Z</updated>
    
    <content type="html"><![CDATA[<p>生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。</p><p>常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。</p><p>此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。</p><span id="more"></span><h2 id="水垢的成因"><a href="#水垢的成因" class="headerlink" title="水垢的成因"></a>水垢的成因</h2><p>自来水中不可避免会溶解一些无机盐。特别地，其中的钙盐和镁盐（以碳酸钙、碳酸镁为主，辅有硫酸钙、硫酸镁、氯化钙、氯化镁等）因溶解度较小，容易沉积形成水垢。</p><p>加湿器振动片使水雾化，导致振动片附近的水相对减少、无机盐浓度升高。溶解度较小的钙盐、镁盐便容易在振动片附近沉积。这些沉积的水垢附着在振动片上，导致振动片工作时发出噪声。</p><h2 id="去除水垢的原理和方法"><a href="#去除水垢的原理和方法" class="headerlink" title="去除水垢的原理和方法"></a>去除水垢的原理和方法</h2><p>既已知水垢的成因和主要成分，想要去除水垢便不难。此处我们只需用到初中化学和物理知识即可。</p><p>水垢的主要成分是碳酸、硫酸、盐酸对应的钙盐和镁盐。要软化、去除这些水垢，只需找一合适的阴离子对应的酸性溶液即可。此处我们可以选择生活中常见的醋酸。</p><p>醋酸容易获得，且醋酸是弱酸操作安全。最主要的是，醋酸钙和醋酸镁的溶解度较高，算是易溶解的物质。因此，醋酸与水垢反应，可有效软化、溶解水垢。</p><p>操作步骤：</p><ol><li>购买白醋一瓶（普通使用陈醋也可，但是黑乎乎一片看不清楚效果）。</li><li>将加湿器水槽取下，加湿器底座内余水倾倒干净。</li><li>将白醋倒入加湿器底座，覆盖、没过振动片及其周围水垢区域。</li><li>加入温水（温度不需要太高），以加快反应速度。</li><li>静置 10 -- 20 分钟。此过程可见水槽底座内不断有小气泡产生（二氧化碳），水垢逐渐脱落翻滚（被二氧化碳气体推动而翻滚运动）和逐渐溶解。</li><li>将底座内的醋酸溶液倾倒干净，用手指或软刷将剩余软化的水垢清理干净。</li><li>用清水反复冲洗三至五次底座，减少醋酸残留。（残留醋酸挥发，可能对呼吸道黏膜产生刺激，导致不适）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活在北方，因其气候干燥，加湿器是必不可少的小家电。尤其夜晚睡眠时，若无加湿器保驾护航，半夜常因口咽干燥而起夜补水。&lt;/p&gt;
&lt;p&gt;常见的民用加湿器有几种工作原理。超声振动雾化加湿器又是其中最常见者。其工作原理清晰，结构简单可靠，价格也最便宜。但北方城市水质硬度往往较大，加湿器长期使用后，在振动片和出风口附近容易形成大量水垢。振动片附近的水垢往往导致噪声，对睡眠实不友好。&lt;/p&gt;
&lt;p&gt;此篇介绍水垢及其成因，以及介绍如何方便快捷地取出加湿器振动片附近的水垢。&lt;/p&gt;
    
    </summary>
    
      <category term="Life and Human Nature" scheme="https://liam.page/categories/Life-and-Human-Nature/"/>
    
    
      <category term="Scale" scheme="https://liam.page/tags/Scale/"/>
    
      <category term="Noise" scheme="https://liam.page/tags/Noise/"/>
    
      <category term="Humidifier" scheme="https://liam.page/tags/Humidifier/"/>
    
  </entry>
  
  <entry>
    <title>羽毛球步伐①：启动步</title>
    <link href="https://liam.page/2022/11/20/badminton-footwork-the-start-step/"/>
    <id>https://liam.page/2022/11/20/badminton-footwork-the-start-step/</id>
    <published>2022-11-20T06:29:26.000Z</published>
    <updated>2022-11-20T11:26:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。</p><p>从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。</p><span id="more"></span><h2 id="为什么需要启动步"><a href="#为什么需要启动步" class="headerlink" title="为什么需要启动步"></a>为什么需要启动步</h2><p>羽毛球运动的特点、基本的物理学定律、人的生理结构，三者共同决定了启动步的重要性和必要性。</p><p>羽毛球是速度最快的球类运动之一。若是限定在初始速度的概念上，我们还可以将「之一」去掉。因其速度快、场地小，所以从你击球结束到下一次击球之间的间隔十分短暂。即便在较为缓和的对抗中，这一时间间隔通常也不会超过 3s。在这短暂的间隔中，你需要完成收拍、移动回位、移动到位、准备击球的若干步骤，时间紧迫。此外，在对手击球之前，你无法判断对手回球的落点位置。因此，羽毛球的步伐移动同时具有快速和方向不确定两个重要特点。</p><p>基本的物理学定律告诉我们：若你想要向前加速运动，则势必要让外界对你有向前的合力；向后同理。若你想要相左加速运动，则势必要让外界对你有相左的合力；向右同理。这一合力越大，加速度就越大。在运动上就体现为移动的爆发力越大、突然性越强。在不打滑的情况下，这一水平反向的合力由地面给脚的静摩擦力提供。而静摩擦力的极限大小可由公式 <code>$f_&#123;\text&#123;静&#125;&#125; = \mu_&#123;\text&#123;静&#125;&#125; \cdot F_N$</code> 给出。这也就是说，</p><ul><li>穿一双好的羽毛球鞋（增大抓地力）有助于你快速移动；</li><li>你必须<strong>向斜下方蹬地发力</strong>，才能获得更大的静摩擦力和提供更大的加速度。</li></ul><p>人的生理结构决定了，若要向斜下方蹬地发力，则必须让发力腿的小腿和地面呈现一个 30° 至 60° 的夹角。最典型的例子是 100 米短跑。跑步项目的一个特点是它永远向前跑。因此运动员们在起步阶段会采用蹲立式起跑的方式获得极大的向前的加速度。但羽毛球的启动方向不确定，于是你必须用合理的方式启动，以便能够照顾尽可能多的潜在移动方向。这种合理的方式，即是所谓的「启动步」；具体来说，又有细分：</p><ul><li>当你预期主要向左右方向移动时，应做小跳&#x2F;分腿动作，将腿左右分开，以便向斜下方蹬地发力获得左右方向的加速度。一般而言，起高球应对对方进攻时应采用这种方式。</li><li>当你预期主要向前后方向移动时，应做小跳&#x2F;分腿动作，将腿前后分开，以便向斜下方蹬地发力获得前后方向的加速度。一般而言，自己处在仅供状态时应采用这种方式。</li></ul><p>总结一下。由于羽毛球运动移动的快速和不定向的特性、向斜下方蹬地发力的原理、人的生理结构特点，羽毛球的启动步是重要且必要的。若无合理的启动步，则往往无法击打到球，或只能陷入被动击球。</p><h2 id="启动步要领"><a href="#启动步要领" class="headerlink" title="启动步要领"></a>启动步要领</h2><p>此节我们讲解启动步的要领。首先我们从最简单的静止启动开始讲起，然后再过度到移动中的连贯启动步。</p><h3 id="从静止启动"><a href="#从静止启动" class="headerlink" title="从静止启动"></a>从静止启动</h3><p>首先是准备动作。</p><p>在对手可能击出攻击性的下压球的情况（你发后场高球、挑高球、击平高球、击高远球等），你应当采取双脚左右分立的防守站姿。具体来说，应当</p><ul><li>面向对手击球的方向，双腿左右分立与肩同宽，右脚可以适当向前半步；</li><li>双脚微踮，前脚掌着地、后脚跟微抬；</li><li>膝盖微屈、髋关节微屈；</li><li>上半身向前微弓；</li><li>左右大臂下垂、向外微张，持拍手在胸腹前，拍头在胸口正面前上方位置。</li></ul><p>在对手大概率作出防守的情况，你应当采取双脚前后分立的进攻站姿。具体来说，应当侧身使持拍手在前，面向对手击球方向，双腿前后分立与肩同宽，脚尖朝向斜前方向。其余身体姿态与防守站姿基本相同。</p><p>在对手引拍即将击球的瞬间，开始启动。具体来说：</p><ul><li>双腿分开（可以视情况带有一些小跳）到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里做一些额外说明。</p><ul><li>双腿分开的目的，是为了让小腿与地面呈现的角度便于蹬地发力。因此双腿分开的幅度不应过大（导致发力不便），也不应过小（导致更大比例的发力是水平向上而非水平）。</li><li>分腿&#x2F;小跳的瞬间，你尚未知晓对方的球路。因此<ul><li>在没有把握的情况下，不应做额外假设。也就是说，双腿分开应该基本呈现左右（防守站姿）或前后（进攻站姿），而非是斜前、斜后方向。若不然，将导致二次启动。</li><li>膝盖弯曲、降低重心的过程，需要紧盯对手击球动作和球路，迅速判断落点。</li></ul></li><li>前脚掌着地瞬间发力，不能迟疑。若不然，重心完全下沉后，反而不容易发力，造成二次启动。<ul><li>发力动作当是保证脚踝稳定性的前提下，使用小腿后侧肌肉群和大腿前侧肌肉群协同发力</li></ul></li></ul><h3 id="移动中连贯启动"><a href="#移动中连贯启动" class="headerlink" title="移动中连贯启动"></a>移动中连贯启动</h3><p>从静止启动是较为理想的情况，在实际对抗中较少出现。羽毛球球速极快，对手不可能等你回动到位后、站定后再击球。因此，更多的启动情况发生在回动的过程中的顺势连贯启动。</p><p>举例来说，当你在后场击出高远、平高球，你应当迅速回动至球场中部区域。在回动的过程，应密切注意观察对手击球情况，随时准备启动。此时，可能你尚在回动过程中。例如说，右手持拍的你，重心放在左腿上，而右腿正处在委屈膝盖向前迈步的阶段。此时你的启动应当是（其他情况类比即可）：</p><ul><li>右腿发力，顺势向左垫出一小步；右腿同时协同分开，双腿分开到大约两倍肩宽；</li><li>膝盖弯曲、降低重心，以便观察对手击球球路；</li><li>前脚掌着地瞬间反方向蹬地、发力启动。</li></ul><p>这里着重讲一下顺势的含义。顺势在此处有几层含义：</p><ul><li>首先，你尚在从后向前回动的过程中，身体具有向前运动的惯性。因此，你主观上向左垫出的一小步，实际效果应当是向左前方垫出一小步。若是刻意在垫布的过程中改变方向向后垫步，则是一个容易导致受伤的动作。</li><li>其次，顺势表示不做过多调整。特别地，不能等待右脚落地，再从静止启动。这是因为你尚在向前回动过程中，若要让身体静止下来，势必要双脚着地、下沉重心。这实际上已经是一次启动，只不过是一次对抗自身惯性的一次启动而已。于是，这会事实上造成二次启动。</li></ul><p>为了做到这一点，我个人总结了四个字：<strong>快回·慢踩</strong>。也就是，</p><ul><li>在击球完成后瞬间，应当爆发式地回动。体现在后场正手击球上，就是（以右手持拍为例）左腿应该向后蹬直发力、同时收紧核心，以便快速抵消向后的冲力而后向前回动。这是「快回」。</li><li>「慢踩」是说，在回动的过程中，不用过于着急，而要保持重心稳定、适度慢踩，给移动中连贯启动留下空间。当然，「两步一冲」的李矛步除外。——那是杀上网、吊上网的连贯动作。</li></ul><h2 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h2><p>启动步本身值得持续练习。以下是从入门到高阶的一些练习方式。</p><ul><li>左右开合跳。<ul><li>起始姿势：双脚与肩同宽，前脚掌着地，膝盖微屈，双手向上合掌</li><li>动作（开跳）：发力向上跳，双脚分开至两倍肩宽，前脚掌着地，膝盖弯屈下沉重心，双手两侧分开平举</li><li>复位动作（合跳）：发力向上跳，双脚合拢至一倍肩宽，前脚掌着地，膝盖微屈，双手向上击掌</li><li>目的：强壮踝关节，锻炼小腿后侧肌肉群爆发力</li><li>30 个&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步）：双腿分开至两倍肩宽，膝盖弯曲下沉重心。</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地，回归起始姿势。</li><li>目的：启动步肌肉记忆。</li><li>15 慢速 + 15 快速&#x2F;组，间隔 20s 做 3 组</li></ul></li><li>防守站姿静止启动，左右蹬跨接杀步伐。<ul><li>起始姿势：防守站姿。</li><li>动作（启动步 + 蹬跨）：双腿分开至两倍肩宽，膝盖弯曲下沉重心；单侧腿发力，转髋蹬跨。（注意弓箭步着地动作，避免受伤）</li><li>复位动作：蹬转回位。</li><li>目的：启动步肌肉记忆 + 左右蹬跨肌肉记忆。</li><li>15 个&#x2F;组，间隔 20s 做 3 组。</li></ul></li><li>交叉步行进间启动步（两步一启动为例，还可做一步一启动、交叉步后退中启动）。<ul><li>起始动作：先左后右分别迈步向前（击后场球回动）。</li><li>动作（行进间启动步）：重心在右腿，左腿微屈（第三步尚未踩下），右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：交叉步行进间启动连贯。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li><li>并步行进间启动步（两步一启动为例，还可做并步后退中启动）。<ul><li>起始动作：右脚在前，左脚在后，向前做一次并步（出右脚，左脚并步跟上）。</li><li>动作（行进间启动步）：第二次并步做一半，即是说出右脚，在左脚并步跟上的同时，右腿顺势向右垫半步，同时左脚分开做启动步。（注意重心下沉）</li><li>复位动作：两脚前脚掌着地瞬间同时发力，双腿合拢至一倍肩宽，前脚掌着地。换脚，继续向前迈步。</li><li>目的：并步行进间启动丽娜管。</li><li>10 次&#x2F;组，间隔 20s 做 5 组。</li></ul></li></ul><!-- 谨以此文，献给我曾爱过的刘曼沁女士，祝她 30 周岁生日快乐~！ -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若想要打好羽毛球，能够打到羽毛球无疑是其前提；而想要打到羽毛球，就需要你能够在快速的羽毛球对抗中能够跑到位。因此说，步伐是羽毛球的基本功。在我看来，它的重要性要大于手上的各种花活。因为若你跑不到位，无法击球或是只能在被动情况下击球，无论你的手法技术有多么高明，大概都是无法发挥出来的。反过来讲，若是每球都能够跑到位，即便手法尚不成熟，只要能回击过往，也还有得打。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们讨论羽毛球的步伐。此篇从启动步开始讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Footwork" scheme="https://liam.page/tags/Footwork/"/>
    
      <category term="Start Step" scheme="https://liam.page/tags/Start-Step/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上双开微信</title>
    <link href="https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/"/>
    <id>https://liam.page/2022/11/02/open-two-wechat-instances-on-macOS/</id>
    <published>2022-11-02T09:53:57.000Z</published>
    <updated>2022-11-20T06:16:50.322Z</updated>
    
    <content type="html"><![CDATA[<p>特点：</p><ul><li>不安装第三方插件，无封号之虞。</li><li>双击即可启动。</li><li>启动后不需要维持「终端」；事实上它会自动关闭。</li></ul><span id="more"></span><p>解法：</p><ul><li>打开终端，执行下列代码，而后在桌面双击 <code>WeChat.command</code> 即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将启动命令写入桌面上的文件 WeChat.<span class="built_in">command</span>；如果已有重名文件，请注意修改。</span></span><br><span class="line">echo &quot;nohup /Applications/WeChat.app/Contents/MacOS/WeChat &gt;/dev/null 2&gt;&amp;1 &amp;&quot; &gt; ~/Desktop/WeChat.command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予其可执行属性</span></span><br><span class="line">chmod +x ~/Desktop/WeChat.command</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不安装第三方插件，无封号之虞。&lt;/li&gt;
&lt;li&gt;双击即可启动。&lt;/li&gt;
&lt;li&gt;启动后不需要维持「终端」；事实上它会自动关闭。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="WeChat" scheme="https://liam.page/tags/WeChat/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Yonex AX100zz 打感自测</title>
    <link href="https://liam.page/2022/10/29/Yonex-AX100zz/"/>
    <id>https://liam.page/2022/10/29/Yonex-AX100zz/</id>
    <published>2022-10-29T10:48:51.000Z</published>
    <updated>2022-10-29T11:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是 Yonex AX100zz 的打感自测。</p><span id="more"></span><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>新入手的球拍（简写 AX100zz）情况：</p><ul><li>Yonex Astrox 100zz（老色，藏青色）</li><li>4U&#x2F;G6</li><li>保留底胶 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><p>作为对比，过去六年常用的球拍（简写 Arc11）情况：</p><ul><li>Yonex ArcSaber 11（老色，带亮黄色带）</li><li>3U&#x2F;G5</li><li>去除底胶 + 缓震膜 + 龙骨手胶</li><li>Yonex BG66u, 24&#x2F;26 lbs</li></ul><h2 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h2><p>挥重方面，实测 AX100zz 和 Arc11 的挥重接近。大约是因为 Arc11 去除底胶的缘故，实际平衡点有所前移。</p><p>挥速方面，相同发力的条件下，AX100zz 的挥速较 Arc11 慢。这主要应该是 AX100zz 采用盒式拍框而 Arc11 采用破风拍框的缘故。</p><p>中杆方面，AX100zz 的中杆相对较硬，但硬得有限。传统上，我们习惯用软硬来评价中杆。但 AX100zz 的中杆更为显著的特性是回弹快。这一特性是建立在实心中杆 + 钨丝的黑科技结构上的。这一特性要求你能用 AX100zz 做出足够快的挥速。若然，相较 Arc11，击球感明显更加干脆；若不然，AX100zz 的击球会显得有一些「木」。</p><p>这即是说，AX100zz 对小臂内旋和屈指发力的技术动作要求更高。而一旦动作到位，AX100zz 的击球球速会比 Arc11 要更快。</p><h2 id="后场击球"><a href="#后场击球" class="headerlink" title="后场击球"></a>后场击球</h2><p>高远方面，步伐到位的情况下，AX100zz 的击球感和 Arc11 差别不算很大；被动的情况下，AX100zz 会稍微更废力一些。</p><p>重杀方面，第一次杀球用的还是 Arc11 的发力习惯。相较而言，球路稍微有些发飘，落点更长。稍作调整后，能够感受到更明显的下压感，暴击音也不出期待地非常舒爽。按对手的反馈，球速有区别，但不大。</p><p>点杀方面。有重杀的经验，点杀时加大了屈指的力量，效果喜人。实战中，头顶突击点杀对角，落点可以比较轻松做到在发球线附近。相同的条件，Arc11 打出同样的落点个人感觉更困难一些。</p><p>劈杀方面，这本身不是我可称擅长的技术，平时用得也偏少。实战中，尝试正手区劈杀斜线，许是还没有完全适应发力变化的缘故，总体感觉和 Arc11 区别不算大。</p><p>吊球方面，劈吊和 Arc11 区别不大；而滑板吊的动作由于本身发力更难，使用 AX100zz 的失误率比 Arc11 要明显高一些。</p><p>反手高远方面，AX100zz 对发力的要求明显更高。前三拍感觉都没能很好发力，打得有点木木的。调整后整体感觉 AX100zz 明显吃力一些。</p><h2 id="前场击球"><a href="#前场击球" class="headerlink" title="前场击球"></a>前场击球</h2><p>个人感觉，前场的搓放由于发力小而巧，影响回球质量更多的是拍面大小和拍线（型号和磅数）。实际 AX100zz 的拍面和 Arc11 相比只是稍微小一些，而拍线又完全相同（穿线师傅都是同一个），整体感觉前场搓放差异不大。但是，不知是不是错觉，使用 AX100zz 做假动作搓放时，感觉更得心应手一些。</p><p>挑推方面，个人感觉差异不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>4U 版本的 AX100zz 属于相对容易上手的高端拍。但其对发力的要求，不那么糖水，需要更短粗的爆发发力才能驾驭。</p><p>个人意见，可以视作是 3U 版本 Arc11 的进攻加强版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇是 Yonex AX100zz 的打感自测。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Evaluation" scheme="https://liam.page/tags/Evaluation/"/>
    
      <category term="Badminton" scheme="https://liam.page/tags/Badminton/"/>
    
      <category term="Yonex" scheme="https://liam.page/tags/Yonex/"/>
    
      <category term="Racket" scheme="https://liam.page/tags/Racket/"/>
    
  </entry>
  
  <entry>
    <title>为英文信件选用合适的结束语</title>
    <link href="https://liam.page/2022/06/19/Email-Closing-Lines/"/>
    <id>https://liam.page/2022/06/19/Email-Closing-Lines/</id>
    <published>2022-06-19T09:55:23.000Z</published>
    <updated>2022-06-20T04:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。</p><span id="more"></span><h2 id="对熟人"><a href="#对熟人" class="headerlink" title="对熟人"></a>对熟人</h2><p>从自然到刻意，可选项有：</p><ul><li>什么都不留：都已经比较熟悉了，还留啥结束语呢？</li><li>XOXO：这是表示好友间拍对方屁股那种熟稔的情感表达。</li><li>Tnx：Thanks 的缩写，因为是熟人，所以缩写也没毛病。</li><li>Love&#x2F;With Love&#x2F;Much love：刻意程度依次增加，但都还好。</li><li>Sincerely：熟人用 Sincerely 还是可以的，但是显得刻意。</li><li>Yours truly&#x2F;Yours sincerely：就很刻意有没有！</li></ul><h2 id="对不熟悉的人"><a href="#对不熟悉的人" class="headerlink" title="对不熟悉的人"></a>对不熟悉的人</h2><p>从自然到刻意，可选项有：</p><ul><li>Best&#x2F;Best regards：万金油，如果拿捏不准，就一个 Best 完事儿就好了。完全体的 Best regards 会显得有些生分，初次沟通可以用。</li><li>Cheers：好像是和不熟悉的人，远远干一杯的感觉。</li><li>Sincerely：跟不熟悉的人说 Sincerely 也是合适的，而且因为不熟悉，所以也不会显得那么刻意。</li><li>All the best：不那么自然，但是也不会显得刻意。相对来说比较正式。</li><li>Thank you：正常人谁说「Thank you」呀！</li><li>With warm regards：艾玛，老古板的形象跃然纸上啊哈哈哈！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写英文信件时，盖因备选极多，选用合适的结束语（closing lines）有时候会是一个头疼的问题。这里给一个这些年总结的经验。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Mail" scheme="https://liam.page/tags/Mail/"/>
    
      <category term="E-Mail" scheme="https://liam.page/tags/E-Mail/"/>
    
      <category term="Closing" scheme="https://liam.page/tags/Closing/"/>
    
  </entry>
  
  <entry>
    <title>提升时间机器（Time Machine）的备份速度</title>
    <link href="https://liam.page/2022/05/07/speed-up-time-machine-backup/"/>
    <id>https://liam.page/2022/05/07/speed-up-time-machine-backup/</id>
    <published>2022-05-07T09:47:17.000Z</published>
    <updated>2022-05-07T09:56:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。</p><span id="more"></span><p>经查，类似时间机器备份或是自 MAS 下载和安装软件的行为，苹果将其优先级调低，并设置有限流（throttle）这一设定。这是为了保证这些优先级较低的行为不会占用过多的系统资源，干扰正常的工作。</p><p>这个设定的出发点是好的，但存在一个问题。比如说，对我而言，使用时间机器备份通常发生在无需使用电脑工作的时间段。此时，限流的这个设定就十分让人蛋疼了。为此，我们可以在命令行暂时关闭限流，待备份完成后再重新打开。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭限流功能，加速备份</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=0</span><br><span class="line"><span class="comment"># 备份完成，重新打开限流功能，避免意外的干扰</span></span><br><span class="line">sudo sysctl debug.lowpri_throttle_enabled=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间机器（Time Machine）是苹果针对 macOS 系统的电脑推出的备份方案。自 2014 年接触依赖，它已经数次拯救了我的电脑和数据，可谓功劳甚大。然而，时间机器备份的速度着实令人捉急。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="Time Machine" scheme="https://liam.page/tags/Time-Machine/"/>
    
  </entry>
  
  <entry>
    <title>设计一个线程池</title>
    <link href="https://liam.page/2022/05/05/design-a-thread-pool/"/>
    <id>https://liam.page/2022/05/05/design-a-thread-pool/</id>
    <published>2022-05-05T12:30:35.000Z</published>
    <updated>2022-05-05T15:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。</p><span id="more"></span><h2 id="初步讨论"><a href="#初步讨论" class="headerlink" title="初步讨论"></a>初步讨论</h2><h3 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h3><p>自 C++11 起，在 C++ 中使用线程就变得很简单。最基本地，可以用 <code>std::thread</code> 来管理一个线程。若是要异步地执行任务，搭配使用 <code>std::async</code> 和 <code>std::future</code> 也很方便。在有这些基础设施的基础上，我们为什么还需要线程池？或者说，我们什么时候需要线程池？</p><p>众所周知，线程作为一种系统资源，其创建和销毁是需要时间的。因此，如果创建和销毁线程的时间和执行任务所需的时间处在同一个数量级，那么频繁地创建和销毁线程带来的性能损耗就会变得十分可观。此时，我们就要考虑使用线程池。</p><h3 id="线程池应有哪些特点？"><a href="#线程池应有哪些特点？" class="headerlink" title="线程池应有哪些特点？"></a>线程池应有哪些特点？</h3><p>线程池的本质就是一组待用的线程。在 C++ 中，它可以表示为一个 <code>std::thread</code> 的数组或是向量。在实际工程中，为便于进行可能的扩展，使用 <code>std::vector&lt;std::thread&gt;</code> 显然会更加合适。</p><p>对于线程池中的每个线程，它都可能在某个时刻接收到一个任务。而这个任务具体是什么，在线程创建时并不知道。用 C++ 的语言表达就是说，线程池中的线程：</p><ul><li>应当可以执行任意函数——支持任何参数列表，也支持任何返回值类型；</li><li>应当可以将任务的执行结果反馈给任务的发布者；</li><li>应当可以在需要时被唤醒执行任务，而在无需时不占用过多 CPU 资源；</li><li>应当可以被主控线程控制，在适当的时候暂停任务、停止接收任务、丢弃未完成任务等。</li></ul><p>对于第一条，modern C++ 的做法应该是利用 <code>functional</code> 头文件提供的基础设施（<code>std::bind</code>, <code>std::function</code> 等）结合模板参数包来实现。对于第二条，old-fashion 的做法是在发布任务时同时注册回调函数；modern C++ 的做法应该是利用 <code>std::packaged_task</code> 结合 <code>std::future</code> 来实现。对于第三条，若是任务来得不那么频繁，应当考虑使用 <code>std::condition_variable</code> 来实现；若是任务十分频繁，则可以考虑使用 <code>std::this_thread::yield</code>。对于第四条，则可以设置一个内部变量作为标记，让每个工作线程都定期检查该标记来实现。</p><p>我们讨论到了任务。显然，我们会需要一个线程安全的队列来管理其他线程发布的任务。</p><h2 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h2><p>我们不妨直接从代码入手，逐步分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocking_queue</span> : <span class="keyword">protected</span> std::queue&lt;T&gt; &#123;  <span class="comment">// 1.</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> wlock = std::unique_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.a</span></span><br><span class="line">  <span class="keyword">using</span> rlock = std::shared_lock&lt;std::shared_mutex&gt;;  <span class="comment">// 2.b</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">blocking_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">blocking_queue</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">blocking_queue</span>(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="built_in">blocking_queue</span>(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.b</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> blocking_queue&amp;) = <span class="keyword">delete</span>; <span class="comment">// 3.c</span></span><br><span class="line">  blocking_queue&amp; <span class="keyword">operator</span>=(blocking_queue&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3.d</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.a</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 4.b</span></span><br><span class="line">    <span class="keyword">return</span> std::queue&lt;T&gt;::<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.a</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">push</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 5.b</span></span><br><span class="line">    std::queue&lt;T&gt;::<span class="built_in">emplace</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; holder)</span> </span>&#123;  <span class="comment">// 6.</span></span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::queue&lt;T&gt;::<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      holder = std::<span class="built_in">move</span>(std::queue&lt;T&gt;::<span class="built_in">front</span>());</span><br><span class="line">      std::queue&lt;T&gt;::<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::shared_mutex mtx_;  <span class="comment">// 7.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>blocking_queue</code> 继承 <code>std::queue</code>，最基本的队列的实现交给标准库。</li><li>利用 <code>std::shared_mutex</code> 结合 <code>std::unique_lock</code> 和 <code>std::shared_lock</code> 实现读写锁。</li><li>此处我们禁用了拷贝和移动构造函数及对应的赋值运算符。这纯粹是因为在实现线程池的过程中我们用不到它们。如果需要，是可以按需实现的。</li><li>在两个 observers 当中，我们使用了只读锁。</li><li><code>push</code> 和 <code>emplace</code> 是类似的操作，都是在队尾追加元素。他们的区别与联系就和标准库容器的接口一样。注意在 <code>emplace</code> 当中，我们用到了完美转发技术。</li><li>这里的 <code>pop</code> 其实更合适称作 <code>try_pop</code>。因为 <code>pop</code> 动作在此处并不一定成功，在队列为空时，函数返回 <code>false</code> 而不会对队列做任何修改。</li><li>这是一把针对整个队列的粗粒度锁。实际上，因为队列的 push 和 pop 一定程度上是分开的，小心地话，可以实现一个细粒度版本的锁，在 push 和 pop 操作都频繁的情况下会有显著的性能提升。关于这一点，我们之后可以单列一篇文章进行讨论。</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>按先前的讨论，我们可以整理出线程池的大致模样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;  <span class="comment">// stop and process all delegated tasks</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">()</span></span>;     <span class="comment">// stop and drop all tasks remained in queue</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 2.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">inited</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_running</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;  <span class="comment">// 4.</span></span><br><span class="line">  <span class="keyword">mutable</span> blocking_queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks_;  <span class="comment">// 5.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一组的三个接口是整个线程池的控制接口。<code>init</code> 接口启动线程池，其参数 <code>num</code> 即是线程池中线程的数量。<code>terminate</code> 接口终止线程池，不再接受新的任务，并保证将已接受的任务处理完毕。<code>cancel</code> 与 <code>terminate</code> 类似，但它将丢弃已接受但未处理完毕的任务。</li><li>第二组的三个接口均是 observers。</li><li>第三组中的唯一一个接口是线程池接受外部任务的接口。它和标准库提供的 <code>std::async</code> 几乎一致，接受任意函数，并返回一个 <code>std::future</code>。</li><li>这是线程池本体。</li><li>这是任务队列。</li></ol><h3 id="线程池的控制接口"><a href="#线程池的控制接口" class="headerlink" title="线程池的控制接口"></a>线程池的控制接口</h3><p>接下来我们讨论控制接口的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::init</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_, [<span class="keyword">this</span>, num]() &#123;  <span class="comment">// 1.</span></span><br><span class="line">    wlock <span class="built_in">lock</span>(mtx_);  <span class="comment">// 2.</span></span><br><span class="line">    stop_ = <span class="literal">false</span>;</span><br><span class="line">    cancel_ = <span class="literal">false</span>;</span><br><span class="line">    workers_.<span class="built_in">reserve</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      workers_.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;threadpool::spawn, <span class="keyword">this</span>));  <span class="comment">// 3.a</span></span><br><span class="line">    &#125;</span><br><span class="line">    inited_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::spawn</span><span class="params">()</span> </span>&#123;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">bool</span> pop = <span class="literal">false</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">      cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, &amp;pop, &amp;task] &#123;</span><br><span class="line">        pop = tasks_.<span class="built_in">pop</span>(task);</span><br><span class="line">        <span class="keyword">return</span> cancel_ || stop_ || pop;  <span class="comment">// 4.</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cancel_ || (stop_ &amp;&amp; !pop)) &#123;  <span class="comment">// 5.a</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 5.b</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::terminate</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.a</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      stop_ = <span class="literal">true</span>;  <span class="comment">// 7.a</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">threadpool::cancel</span><span class="params">()</span> </span>&#123;  <span class="comment">// 6.b</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">wlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_running()) &#123;</span><br><span class="line">      cancel_ = <span class="literal">true</span>;  <span class="comment">// 7.b</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tasks_.<span class="built_in">clear</span>();  <span class="comment">// 8.</span></span><br><span class="line">  cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) &#123;</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> threadpool::_is_running() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> inited_ &amp;&amp; !stop_ &amp;&amp; !cancel_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>init</code> 完成的工作，在逻辑上只能进行一次。但我们无法保证用户代码确实如我们所想地这样执行。因此，我们利用 <code>std::call_once</code> 保证相关工作只执行一次。</li><li>因为涉及到修改 <code>threadpool</code> 的状态，所以此处使用写入锁。</li><li><code>spawn</code> 接口是线程函数，也就是线程启动后一直运行的函数。</li><li>当线程被唤醒时（无论是意外唤醒，还是被 <code>notify_*</code> 函数唤醒），若线程池没有被 <code>cancel</code> 或是 <code>terminate</code>，也没能从任务队列中取出任务，则线程应该继续沉眠，否则就应该醒来继续处理。</li><li>如果线程池被 <code>cancel</code>，则不执行当前任务；如果线程池被停止并且没能从任务队列中取出任务，则也不执行当前任务；否则就执行当前任务。</li><li><code>terminate</code> 和 <code>cancel</code> 的实现几乎完全相同；</li><li>唯独 <code>terminate</code> 修改 <code>stop_</code> 变量而 <code>cancel</code> 修改 <code>cancel_</code> 变量。</li><li>此外，<code>cancel</code> 接口显式地清空了任务队列。</li></ol><h3 id="线程池的观察器"><a href="#线程池的观察器" class="headerlink" title="线程池的观察器"></a>线程池的观察器</h3><p>观察器比较简单，唯一值得一提的是这里使用了读取锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::inited</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> inited_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">threadpool::is_running</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> _is_running();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">threadpool::size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> workers_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务接口"><a href="#任务接口" class="headerlink" title="任务接口"></a>任务接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">threadpool::async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">return_t</span> = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 1.a</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">future_t</span> = std::future&lt;<span class="type">return_t</span>&gt;;  <span class="comment">// 1.b</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">task_t</span> = std::packaged_task&lt;<span class="built_in">return_t</span>()&gt;;  <span class="comment">// 1.c</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rlock <span class="title">lock</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span> (stop_ || cancel_)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">          <span class="string">&quot;Delegating task to a threadpool &quot;</span></span><br><span class="line">          <span class="string">&quot;that has been terminated or canceled.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bind_func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);  <span class="comment">// 3.</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">task_t</span>&gt; task = std::<span class="built_in">make_shared</span>&lt;<span class="type">task_t</span>&gt;(std::<span class="built_in">move</span>(bind_func));  <span class="comment">// 4.a</span></span><br><span class="line">  <span class="type">future_t</span> fut = task-&gt;<span class="built_in">get_future</span>();  <span class="comment">// 4.b</span></span><br><span class="line">  tasks_.<span class="built_in">emplace</span>([task]() -&gt; <span class="type">void</span> &#123; (*task)(); &#125;);  <span class="comment">// 5.</span></span><br><span class="line">  cond_.<span class="built_in">notify_one</span>();  <span class="comment">// 6.</span></span><br><span class="line">  <span class="keyword">return</span> fut;  <span class="comment">// 4.c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>using</code> 定义的三个类型，见文知意。</li><li>这里不涉及对线程池状态的修改，因此只需要读取锁即可。显然，此处我们禁止对已经 <code>terminate</code> 或是 <code>cancel</code> 的线程池继续发布任务。</li><li>由于任务队列只接收 <code>std::function&lt;void()&gt;</code> 的可调用对象，此处我们利用 <code>std::bind</code> 先匹配参数列表。</li><li>此处我们利用 <code>std::packaged_task</code> 将待执行的任务与一个 <code>std::future</code> 关联起来，并将 <code>std::future</code> 返回给外界，以便任务发布者可以在将来取得任务执行结果。</li><li>这里我们利用一个 lambda，既执行了任务，又将返回值抹去（但会被 future 管理），以便匹配 <code>std::function&lt;void()&gt;</code>。</li><li>此处我们通过条件变量唤醒工作线程。</li></ol><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>完整实现可见 <a href="https://github.com/Liam0205/toy-threadpool">Liam0205&#x2F;toy-threadpool</a>，其中包括了单元测试和相比 <code>std::async</code> 的性能对比。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>这里我们实现了一个可看使用的线程池。但如 GitHub 的 repo 名字一样，它还只是个玩具。若要在工程中使用，还可以做一系列优化。例如说：</p><ul><li>对线程安全队列进行优化，使用更细粒度的锁（完整实现当中已有），或者换用无锁实现。</li><li>完善的线程池，除了支持本文提到的几种状态，还可以有暂停、扩张（任务过多时自动扩张）、收缩（空闲线程过多时自动收缩）等能力。</li></ul><p>这些内容都可以继续去深挖、优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇我们通过逐步实现线程池，来探讨线程池中的关键技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Thread" scheme="https://liam.page/tags/Thread/"/>
    
      <category term="Threadpool" scheme="https://liam.page/tags/Threadpool/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS Monterey 12.3 上因缺失 Python 2.7 导致的问题</title>
    <link href="https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/"/>
    <id>https://liam.page/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/</id>
    <published>2022-04-01T04:10:06.000Z</published>
    <updated>2022-04-16T12:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Termination Reason: Namespace DYLD, Code 1 Library missing</span><br><span class="line">Library not loaded: /System/Library/Frameworks/Python.framework/Versions/2.7/Python</span><br><span class="line">Referenced from: /Applications/CHIRP.app/Contents/CHIRP</span><br><span class="line">Reason: tried: &#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file), &#x27;/Library/Frameworks/Python.framework/Versions/2.7/Python&#x27; (no such file)</span><br></pre></td></tr></table></figure><p>这是由于 Apple 在 macOS Monterey 12.3 开始，<a href="https://developer.apple.com/documentation/macos-release-notes/macos-12_3-release-notes#Python">移除了随系统发行的 Python 2.7</a>；于是，尚在依赖 Python 2.7 的 App 在启动时的动态链接阶段就会出错而崩溃。</p><p>考虑到部分 App 尚未更新以解除对 Python 2.7 的依赖，这里我们需要手动安装 Python 2.7。为此，我们可在 Python 官网上找到历史版本（<a href="https://www.python.org/ftp/python/2.7.18/python-2.7.18-macosx10.9.pkg">Python 2.7.18</a>）并下载安装。按我的经验，自主安装 Python 2.7.18 之后，问题即得到解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近将手头的 MacBook Pro 的操作系统升级到了最新版本的 macOS Monterey 12.3。启动系统之后，发现部分 App 启动即崩溃。检查详细信息时，发现链接器无法找到 Python 2.7；即有类似下列报错：&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Python" scheme="https://liam.page/tags/Python/"/>
    
      <category term="macOS" scheme="https://liam.page/tags/macOS/"/>
    
      <category term="Monterey" scheme="https://liam.page/tags/Monterey/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑬）：C++ 的内存顺序·下</title>
    <link href="https://liam.page/2021/12/14/memory-order-cpp-03/"/>
    <id>https://liam.page/2021/12/14/memory-order-cpp-03/</id>
    <published>2021-12-13T16:14:42.000Z</published>
    <updated>2021-12-18T11:52:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于<a href="/2021/06/05/memory-model-cpp/">内存模型</a>和内存顺序（<a href="/2021/06/06/memory-order-cpp-01/">上</a>、<a href="/2021/12/11/memory-order-cpp-02/">中</a>）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。</p><p>此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。</p><span id="more"></span><h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>让我们从一个最简单的生产者&#x2F;消费者的例子出发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;  <span class="comment">// 1.a.</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 1.b.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">1024</span>);  <span class="comment">// 2.</span></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready.<span class="built_in">load</span>()) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; data[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 5.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::thread a&#123;producer&#125;, b&#123;consumer&#125;;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，(1) 初始化了全局共享的数据 <code>data</code> 和原子标记 <code>ready</code>。生产者线程中，(2) 对全局共享的数据进行修改，并在 (3) 处将标记设置为 <code>true</code>。消费者线程中，(4) 循环等待原子标记（当然，它效率极低；作为示例我们暂时忽略这个问题），而后在 (5) 处读取共享数据。</p><p>我们知道，在多个线程中，并发读写同一个内存位置（此处的 <code>&amp;data[0]</code>）可能造成数据竞争，必须有相应的同步机制。此处同步机制由原子标记 <code>ready</code> 协助建立。</p><ul><li>(2) <ins>先于（happens-before）</ins> (3)；</li><li><strong>当 (4) 读到 <code>ready.load()</code> 为真</strong>，则 (3) 与 (4) 建立<ins>同步（synchronizes-with）</ins>关系，因而有 (3) <ins>先于（happens-before）</ins> (4)；</li><li>(4) <ins>先于（happens-before）</ins> (5)。</li></ul><p>在原子标记 <code>ready</code> 的协助下，我们建立了对 <code>data</code> 的写<ins>先于（happens-before）</ins>读的顺序关系，数据竞争的风险就此解除。</p><p>整体看下来，这一过程非常符合直觉。而我们知道，原子变量除了保证其上原子操作的原子性之外，各个操作还有内存顺序标记。不同的顺序标记会影响编译器优化和 CPU 执行时的行为；更准确地，影响原子操作附近访问内存的顺序。默认的顺序标记是 <code>std::memory_order_seq_cst</code>。之所以将它作为默认标记，是因为它能带来这一符合直觉的结果。</p><p>接下来，我们顺势讨论<ins>先于（happens-before）</ins>关系和<ins>同步（synchronizes-with）</ins>关系。</p><h2 id="两种关系"><a href="#两种关系" class="headerlink" title="两种关系"></a>两种关系</h2><h3 id="同步（synchronizes-with）关系"><a href="#同步（synchronizes-with）关系" class="headerlink" title="同步（synchronizes-with）关系"></a><ins>同步（synchronizes-with）</ins>关系</h3><p><ins>同步（synchronizes-with）</ins>关系，追根究底只能由原子操作提供。我们能见到的所有产生同步关系的办法，其底层都包含了某些原子操作。同步关系是这样建立的，</p><ul><li>首先有在线程 A 中对原子变量 <code>x</code> 打上恰当标记的写入操作 <code>W</code>；</li><li>而后有在线程 B 中对原子变量 <code>x</code> 打上恰当标记的读取操作 <code>R</code>。</li></ul><p>若 <code>R</code> 读到的值，来自以下任意一种情况，则说 <code>W</code> 与 <code>R</code> <ins>同步（synchronizes-with）</ins>。</p><ul><li><code>W</code> 的写入；或者</li><li>线程 A（<code>W</code> 所在线程）中，<code>W</code> 之后的某次写入；或者</li><li>任意线程中的一系列 read-modify-write 操作中的写入值，其中第一次 read-modify-write 操作读到的值来自 <code>W</code> 的写入。</li></ul><p>这得到一个最基本的认知：（在顺序标记恰当的情况下，）如果线程 B 的读取操作读到的是线程 A 的写入操作的写入值，则写入操作与读取操作同步。</p><p>如此一来，所有的细节就在「恰当」二字之上了。不过，我们先来讨论<ins>先于（happens-before）</ins>关系。</p><h2 id="先于（happens-before）关系"><a href="#先于（happens-before）关系" class="headerlink" title="先于（happens-before）关系"></a><ins>先于（happens-before）</ins>关系</h2><p><ins>先于（happens-before）</ins>关系是讨论内存顺序中最重要的基石。若 A <ins>先于（happens-before）</ins> B，则 B 能看到 A 带来的副作用。</p><p>在单线程里面，<ins>先于（happens-before）</ins>关系很简单。单线程当中的<ins>先于（happens-before）</ins>关系即是<ins>先序（sequenced-before）</ins>关系。一般来说，不考虑编译器优化重排和 CPU 乱序执行重排时，在代码当中，靠前的语句当中的操作<ins>先于（happens-before）</ins>靠后的语句当中的操作。但实际上，我们需要考虑编译器优化和 CPU 乱序执行对先序关系带来的影响。</p><p>在线程之间，若线程 A 的写入操作与线程 B 的读取操作<ins>同步（synchronizes-with）</ins>，则该写入操作<ins>线程间先于（inter-thread happens-before）</ins>该读取操作，也因此该写入操作<ins>先于（happens-before）</ins>该读取操作。</p><h2 id="三种顺序模型"><a href="#三种顺序模型" class="headerlink" title="三种顺序模型"></a>三种顺序模型</h2><p>按前文，顺序标记共有六种：</p><ul><li><code>std::memory_order_relaxed</code></li><li><code>std::memory_order_consume</code></li><li><code>std::memory_order_acquire</code></li><li><code>std::memory_order_release</code></li><li><code>std::memory_order_acq_rel</code></li><li><code>std::memory_order_seq_cst</code></li></ul><p>六种标记又能组成三种顺序模型：</p><ul><li>顺序一致模型（sequentially consistent ordering）：最强的顺序模型。对编译器优化限制最多，所需额外 CPU 同步指令最多，性能也最差；但最符合直觉。涉及到的顺序标记是 <code>std::memory_order_seq_cst</code>。</li><li>宽松模型（relaxed ordering）：最弱的顺序模型。对编译器优化限制最少（几乎没有），所需额外 CPU 同步指令最少（几乎没有），性能也最好；但无法建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_relaxed</code>。</li><li>获取-释放模型（acquire-release ordering）：介于二者之间。对编译器优化限制适中，所需额外的 CPU 同步指令也适中（在部分平台上，不许额外同步指令），性能也适中；可以建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_acq_rel</code>, <code>std::memory_order_acquire</code>, <code>std::memory_order_release</code> 和 <code>std::memory_order_consume</code>。</li></ul><blockquote><p>注意，<code>std::memory_order_consume</code> 与 <code>std::memory_order_acquire</code> 相似，但比后者更弱。但完整地实现 <code>std::memory_order_consume</code> 的语义，需要追踪变量之间的依赖链。目前，还没有已知的编译器实现了它。现有的编译器，都将 <code>std::memory_order_consume</code> 提升为 <code>std::memory_order_acquire</code>。故而此处也将 <code>std::memory_order_consume</code> 归在获取-释放模型当中。此外，考虑 <code>std::memory_order_consume</code> 的语义可能发生变化，目前标准也不建议使用 <code>std::memory_order_consume</code>。</p></blockquote><h3 id="顺序一致模型（sequentially-consistent-ordering）"><a href="#顺序一致模型（sequentially-consistent-ordering）" class="headerlink" title="顺序一致模型（sequentially consistent ordering）"></a>顺序一致模型（sequentially consistent ordering）</h3><p>默认的顺序模型是「顺序一致模型」。如果所有原子操作的顺序标记都是 <code>std::memory_order_seq_cst</code>，那么多线程程序的行为就好像这些操作以某一特定的顺序在单一的线程中执行一样。特别地，站在所有被打上 <code>std::memory_order_seq_cst</code> 标记的操作上来看，所有先于该操作发生的原子操作（<code>std::memory_order_seq_cst</code>），都具有同样的顺序。</p><p>这是最符合直觉的模型。多数人第一次接触到多线程，会假定多线程中的各个操作是可能并发执行的，因此将他们理解为按照某个不确定的顺序穿插执行。然后在脑海中想象并构建这一固定的顺序，并按照这一顺序假定各个线程会如何工作。但这种符合直觉的模型并不总是成立。这种多线程之间全局统一的顺序，即是顺序一致性带来的保证。一旦保证不了顺序一致性，则这种基于「穿插执行」假定出来的全局统一顺序也就不成立了。</p><!-- From the point of view of synchronization, a sequentially consistent store synchronizes-with a sequentially consistent load of the same variable that reads the value stored. This provides one ordering constraint on the operation of two (or more) threads, but sequential consistency is more powerful than that. Any sequentially con- sistent atomic operations done after that load must also appear after the store to other threads in the system using sequentially consistent atomic operations. The example in listing 5.4 demonstrates this ordering constraint in action. This constraint doesn’t carry forward to threads that use atomic operations with relaxed memory orderings; they can still see the operations in a different order, so you must use sequentially con- sistent operations on all your threads in order to get the benefit. --><p>站在同步的角度来看，顺序一致 store 操作与读到本次写入值的顺序一致的 load 操作<ins>同步（synchronizes-with）</ins>。如前所述，这种同步关系在线程之间提供了一定的顺序限制。但顺序一致模型还保证，在这一顺序一致的 load 操作之后的顺序一致操作，在其他所有使用顺序一致原子操作的线程看来，也是发生在此次顺序一致 store 之后的。注意，如若某一线程中的某个原子操作没有使用 <code>std::memory_order_seq_cst</code> 标记，则在该操作看来，顺序一致的诸多操作的顺序可能与其他线程看到的不同。</p><p>前作当中的<a href="/2021/12/11/memory-order-cpp-02/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E9%A1%BA%E5%BA%8F%EF%BC%88Sequentially-consistent-ordering%EF%BC%89">例子</a>很好地说明了顺序一致性的效果。</p><!-- This ease of understanding can come at a price, though. On a weakly ordered machine with many processors, it can impose a noticeable performance penalty, because the overall sequence of operations must be kept consistent between the pro- cessors, possibly requiring extensive (and expensive!) synchronization operations between the processors. That said, some processor architectures (such as the common x86 and x86-64 architectures) offer sequential consistency relatively cheaply, so if you’re concerned about the performance implications of using sequentially consis- tent ordering, check the documentation for your target processor architectures. --><p>这种便利是有代价的。在默认的顺序保证相对较弱的平台上（如 ARM），顺序一致模型会引入可观的性能代价。这是因为，全局顺序一致需要在 CPU 逻辑核心之间保持一致性，这使得 CPU 逻辑核心之间需要使用代价高昂的同步操作。相较而言，部分处理器架构（例如 x86 和 x86-64）保证顺序一致性的代价较低。为避免这种同步代价，我们需要拥抱非顺序一致性模型。</p><hr><p>在处理非顺序一致性模型时，我们就要丢弃脑海中那种简洁漂亮的交替执行的思维模型。<strong>它不存在了</strong>。在没有顺序一致性保障的情况下，各个线程看到的原子操作的顺序并不保证统一。也就是说，虽然依旧是并发（所以穿插执行），但是每个线程看到的穿插的顺序可能是不一样的。在非顺序一致模型下写代码时，要时刻关注这一点。</p><p>不过，也有一致的地方。虽说各个线程观察到的原子操作发生的顺序可能不一致，但是，对于<strong>每一个特定的原子变量</strong>，作用在其上的原子操作的修改顺序（modification-order），在各个线程看来是统一的。</p><p>为了充分理解非顺序一致性模型，我们可以先考虑宽松模型。待对非顺序一致性有足够了解之后，再回到获取-释放模型。</p><h3 id="宽松模型（relaxed-ordering）"><a href="#宽松模型（relaxed-ordering）" class="headerlink" title="宽松模型（relaxed ordering）"></a>宽松模型（relaxed ordering）</h3><p>顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作不参与构建<ins>同步（synchronizes-with）</ins>关系。在同一线程中，对<strong>同一</strong>原子变量的原子操作的顺序遵循源代码中的<ins>先序（sequenced-before）</ins>关系（从而有<ins>先于（happens-before）</ins>关系）。但是，在另外的线程看来，这种顺序无法保证。由于未加任何同步限制，顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作只是简单地遵循各个原子变量自身的修改顺序（modification-order）而已。</p><p>首先看一段简单的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    z.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(<span class="number">0</span> != z.<span class="built_in">load</span>());  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照经典的「穿插思维模型」（即顺序一致性模型），(3) 处循环等待直到 <code>y</code> 为真，那么<strong>由于 (1) 先于 (2) 发生，(3) 先于 (4) 发生</strong>，所以 (4) 必然为真，因此 (5) 的断言永不失效。但实际上，由于 (1) -- (4) 的顺序标记都是 <code>std::memory_order_relaxed</code>，此处并无同步保证，也没有单线程中的先序关系保证。这也就是说，上述两个先于关系不一定成立；即便成立，(2) 不必然与 (3) <ins>同步（synchronizes-with）</ins>，因此也就无法传递上述两个先于关系。所以站在 (4) 的角度看，并不保证 (1) <ins>先于（happens-before）</ins> (4) 发生。所以 (4) 可能读到 <code>false</code> 导致断言失败。</p><p>接下来再看一个更加复杂的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> upper&#123;<span class="number">10UL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Snapshot t1[upper];</span><br><span class="line">Snapshot t2[upper];</span><br><span class="line">Snapshot t3[upper];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;* var, Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.a.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.a.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.a.</span></span><br><span class="line">    var-&gt;<span class="built_in">store</span>(i + <span class="number">1</span>, std::memory_order_relaxed);  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; snapshot.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; snapshot.y &lt;&lt; <span class="string">&quot;)&quot;</span>;  <span class="comment">// 5.</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">T1</span><span class="params">(increase, &amp;x, t1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T2</span><span class="params">(increase, &amp;y, t2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T3</span><span class="params">(observe, t3)</span></span>;</span><br><span class="line"></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 1.c.</span></span><br><span class="line"></span><br><span class="line">  T3.<span class="built_in">join</span>();</span><br><span class="line">  T2.<span class="built_in">join</span>();</span><br><span class="line">  T1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(t1);</span><br><span class="line">  <span class="built_in">print</span>(t2);</span><br><span class="line">  <span class="built_in">print</span>(t3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">(0,2),(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,10),(9,10)</span><br><span class="line">(0,0),(0,1),(0,2),(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9)</span><br><span class="line">(1,3),(2,4),(2,5),(3,6),(4,7),(5,8),(6,8),(7,9),(8,10),(8,10)</span><br></pre></td></tr></table></figure><p>我们首先来观察一下代码和结果。</p><p>代码部分，</p><ul><li><code>increase</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 次循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中，而后以 <code>std::memory_order_relaxed</code> 的顺序标记更新 <code>var</code> 指向的原子变量（要么是 <code>x</code>，要么是 <code>y</code>）。</li><li><code>observe</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 词循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中。</li><li><code>print</code> 打印历次循环得到的快照 (5)。每个二元组中，第一个数是当次循环读到的 <code>x</code> 的值；第二个数是对应的 <code>y</code> 的值。</li><li><code>ready</code> 变量确保三个线程在几乎相同的时间开始，以防（例如说）<code>T1</code> 已经执行完毕而 <code>T3</code> 还尚未开始执行。</li></ul><p>结果部分，</p><ul><li>第一行、第二行、第三行分别记录了 <code>T1</code>, <code>T2</code>, <code>T3</code> 在历次循环过程中记录下来的 <code>x</code> 和 <code>y</code> 的值的快照。</li><li>关于写<ul><li>对于 <code>T1</code> 来说，只有该线程修改 <code>x</code> 的值，每次读到它，都恰好自增 <code>1</code>；</li><li>同样对于 <code>T2</code> 来说，<code>y</code> 每次自增 <code>1</code>。</li></ul></li><li>关于读<ul><li>对于 <code>T1</code> 和 <code>T3</code> 来说，它们只读 <code>y</code> 的值。因为 <code>y</code> 的修改序列中，<code>y</code> 的值是递增的；因此 <code>T1</code> 和 <code>T3</code> 每次读到的 <code>y</code> 的值都不小于前一次读到的 <code>y</code> 的值；但递增的步长不一定均衡。</li><li>对于 <code>T2</code> 和 <code>T3</code> 来说，它们只读 <code>x</code> 的值。基于同样的理由，它们每次读到的 <code>x</code> 的值都是非递减的；但递增的步长不一定均衡。</li></ul></li></ul><p>这里我们只给出了一个可能的结果，实际上，符合上述规律的结果，都是可能出现的。</p><p>接下来我们正式地描述宽松模型下的规律。</p><ul><li>对于任意给定的原子变量，其<ins>修改顺序（modification-order）</ins>是全局唯一的。</li><li>对于任意线程，<ul><li>若未曾读取过该变量的值，则可能读取到修改顺序上任意可能的值。</li><li>一旦读取了某个原子变量在修改顺序上的某个值，将来再读取时，要么读取相同的值，要么读取到在修改顺序上更靠后的值，而不可能读到在修改顺序上更靠前的值。</li></ul></li><li>对于任意线程，一旦写入了某个原子变量，将来再读取时，要么读取到此次写入的值，要么读取到修改顺序上相对此次写入更靠后的值。</li></ul><p>我们可以使用这一规律来回顾本节第一段代码。对于变量 <code>x</code> 来说，其修改顺序是：默认值 <code>false</code>，由 <code>write_x_then_y</code> 写入的值 <code>true</code>。在 <code>read_y_then_x</code> 线程当中，由于从未读取过 <code>x</code> 的值，因此可能读到 <code>x</code> 的修改顺序上的任意值。——可能是 <code>false</code>，亦可能是 <code>true</code>。故而断言可能失败。</p><h3 id="获取-释放模型（acquire-release-ordering）"><a href="#获取-释放模型（acquire-release-ordering）" class="headerlink" title="获取-释放模型（acquire-release ordering）"></a>获取-释放模型（acquire-release ordering）</h3><p>接下来，我们讨论居于宽松模型和顺序一致模型当中的获取-释放模型（acquire-release ordering）。</p><p>获取-释放模型当中，依然不存在顺序一致模型当中那样的全局唯一操作顺序，但相较宽松模型，增加了部分同步能力。在获取-释放模型当中，</p><ul><li>原子-store 操作是<ins>释放操作（release-operation）</ins>（<code>std::memory_order_acquire</code>）；</li><li>原子-load 操作是<ins>获取操作（acquire-operation）</ins>（<code>std::memory_order_release</code>）；</li><li>原子-read-modify-write 操作（例如 <code>fetch_add</code> 或是 <code>exchange</code>）则要么是释放操作，要么是获取操作，要么同时是释放-获取操作（<code>std::memory_order_acq_rel</code>）。</li></ul><p>同步总是在线程之间成对出现的。一个线程中的释放操作与另一个线程中读到该次写入的获取操作<ins>同步（synchronizes-with）</ins>。这意味着，不同线程可能观察到不同的操作顺序，但这些顺序是有所限制的。</p><p>同样地，我们来看一个示例。这个例子是从顺序一致性模型的例子上稍加修改而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 6.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// can fire</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，断言可能失败。我们来做进一步分析。</p><p>(1) 处是释放操作；(3) 处通过循环确保读到 (1) 写入的值。因而 (1) 的释放操作与 (3) 的获取操作配对，建立<ins>同步（synchronizes-with）</ins>关系，于是 (1) 顺势与 (4) 建立<ins>先于（happens-before）</ins> 关系。同理，(2) 与 (5) 之间也有同步关系，(2) 顺势与 (6) 建立<ins>先于（happens-before）</ins> 关系。</p><p>然而，我们无法建立 (1) <ins>先于（happens-before）</ins> (6) 的关系。故而 (6) 可能读到变量 <code>x</code> 的修改序列上的任意值。例如说，可能读到 <code>false</code>。同理 (4) 也可能读到 <code>false</code>。二者同时发生时，断言失败。</p><p>因为 store 操作发生在不同的线程，故而我们无法借助一个原子变量的同步关系，构造另一个原子变量的写与读之间的先于关系。这告诉我们两件事情。一是，对于多写多读的场景，我们往往需要顺序一致性模型。二是，若要应用获取-释放模型，store 操作应当发生在同一线程。</p><p>接下来我们再看一例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 3.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑 (1) 和 (2) 在同一线程中，有<ins>先序（sequenced-before）</ins>关系（release 语义保证不乱序）；(3) 处的 spin-wait 保证读到 (2) 的写入，因而 (2) 与 (3) <ins>同步（synchronizes-with）</ins>，再有 (3) 与 (4) 在同一线程中，也有先序关系（acquire 语义保证不乱序）。故而 (1) 必须先于 (4)，从而 (4) 的判断必定成立，而 (5) 的断言永不失败。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>C++ 标准库也提供了内存屏障 <code>std::atomic_thread_fence</code>，它也可以打上顺序标签。</p><p>理解起来，带上 <code>std::memory_order_release</code> 的内存屏障，倾向于向下结合一个 store 操作，将它的内存顺序提升为 <code>std::memory_order_release</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。带上 <code>std::memory_order_acquire</code> 的内存屏障，倾向于向上结合一个 load 操作，将它的内存顺序提升为 <code>std::memory_order_acquire</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。从而建立获取-释放的同步关系。</p><p>我们可以将上例稍加修改得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2.a.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 3.a.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 3.b.</span></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，(2.a) 的 release-屏障向下与 (2.b) 的宽松-store 操作结合，使得该操作提升为 release-store；(3.b) 的 acquire-屏障向上与 (3.a) 的宽松-load 操作结合，使得该操作提升为 acquire-load。reloease-store 和 acquire-load 构成<ins>同步（synchronizes-with）</ins>，又有 release&#x2F;acquire 语义保证局部顺序，因此有 (1) <ins>先于（happens-before）</ins> (4)，从而 (5) 的断言不会失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;和内存顺序（&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;上&lt;/a&gt;、&lt;a href=&quot;/2021/12/11/memory-order-cpp-02/&quot;&gt;中&lt;/a&gt;）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。&lt;/p&gt;
&lt;p&gt;此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑫）：C++ 的内存顺序·中</title>
    <link href="https://liam.page/2021/12/11/memory-order-cpp-02/"/>
    <id>https://liam.page/2021/12/11/memory-order-cpp-02/</id>
    <published>2021-12-11T00:27:42.000Z</published>
    <updated>2021-12-13T16:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇（<a href="/2021/06/05/memory-model-cpp/">内存模型</a>与<a href="/2021/06/06/memory-order-cpp-01/">内存顺序·上</a>）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>的翻译，但会展开做一些讨论。</p><span id="more"></span><h2 id="六种内存顺序标记"><a href="#六种内存顺序标记" class="headerlink" title="六种内存顺序标记"></a>六种内存顺序标记</h2><p>C++ 标准库定义了六中内存顺序标记（memory order tag）。他们被定义为一个枚举类型。在 C++11 之后、C++20 之前，定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p>在 C++20 中，则使用新的 <code>enum class</code> 重新定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">memory_order</span> : <span class="comment">/*unspecified*/</span> &#123;</span><br><span class="line">    relaxed, consume, acquire, release, acq_rel, seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_relaxed = memory_order::relaxed;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_consume = memory_order::consume;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acquire = memory_order::acquire;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_release = memory_order::release;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acq_rel = memory_order::acq_rel;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_seq_cst = memory_order::seq_cst;</span><br></pre></td></tr></table></figure><p>我们知道，原子变量上没有数据竞争，从而提供了良定义的多线程并发读写能力。因此，原子变量有可能实际上建立了线程间的同步关系，于是建立了某种<ins>先于（happens-before）</ins>关系。</p><p>在原子操作上添加六种内存顺序标记（中的一部分），会<strong>影响（但不一定改变；视 CPU 架构）原子操作附近的内存访问顺序（包括其他原子操作，亦包含对非原子变量的读写操作）</strong>。注意，内存顺序（通过六种标记）讨论的实际上是线程内原子操作附近非原子操作访问内存的顺序，而非是多线程之间的执行顺序。只不过，因为原子变量自身可能建立了线程间的同步关系，所以<strong>两个线程内各自的内存顺序会经由原子变量的同步建立间接的顺序关系</strong>。亦即，<strong>内存顺序本质上是在讨论单线程内指令执行顺序对多线程影响</strong>的问题。显然，通过添加内存顺序标记，编译器优化和 CPU 指令多发射（multiple issue）、CPU 乱序执行（out-of-order execution）都可能受到一定影响。</p><p>所有原子操作默认的内存顺序标记是 <code>std::memory_order_seq_cst</code>，亦即，提供顺序一致性的顺序保证（后续讨论）。目前而言，在绝大多数 CPU 架构上，顺序一致性模型都需要或多或少地在原子操作前后加上内存屏障（memory fence）。因而，顺序一致性虽好，但会损失部分性能。使用其它内存顺序标记则或多或少降低顺序一致性的保证。</p><table><thead><tr><th>标记</th><th>作用</th></tr></thead><tbody><tr><td><code>memory_order_relaxed</code></td><td>宽松操作：仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。</td></tr><tr><td><code>memory_order_consume</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E6%B6%88%E8%B4%B9%E6%93%8D%E4%BD%9C%EF%BC%88consume-operation%EF%BC%89">消费操作（consume operation）</a></ins>：当前线程中，所有依赖当前 load 操作读取的值的读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>依赖的变量的写入，对当前线程是可见的。多数平台上，该标记仅影响编译器优化。</td></tr><tr><td><code>memory_order_acquire</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E5%8D%A0%E6%9C%89%E6%93%8D%E4%BD%9C%EF%BC%88aquire-operation%EF%BC%89">占有操作（aquire operation）</a></ins>：当前线程中，所有读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前线程是可见的。</td></tr><tr><td><code>memory_order_release</code></td><td>打上此标记的 store 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%EF%BC%88release-operation%EF%BC%89">释放操作（release operation）</a></ins>：当前线程中，所有读写操作不得重排至当前操作之后。因此，当前操作所在线程之前的写入操作，在其他线程中，对该原子变量施加<ins>占有操作（aquire operation）</ins>之后是可见的。也因此，当前操作所在线程中，当前操作所依赖的写入操作，在其他线程中，对该原子变量施加<ins>消费操作（consume operation）</ins>之后是可见的。</td></tr><tr><td><code>memory_order_acq_rel</code></td><td>打上此标记的 read-modify-write 操作既是<ins>占有操作（aquire operation）</ins>又是<ins>释放操作（release operation）</ins>：当前线程中的读写操作不能重排至当前操作之后（如果原本在之前），亦不能重排至当前操作之前（如果原本在之后）。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前 modification 是可见的；该 modification 对其他线程中相同原子变量<ins>占有操作（aquire operation）</ins>之后亦是可见的。</td></tr><tr><td><code>memory_order_seq_cst</code></td><td>打上此标记的 load 操作对相关内存位置施加<ins>占有操作（aquire operation）</ins>；打上此标记的 store 操作对相关内存位置施加<ins>释放操作（release operation）</ins>；打上此标记的 read-modify-write 对相关内存位置施加<ins>占有操作（aquire operation）</ins>和<ins>释放操作（release operation）</ins>。此外，对所有线程来说，所有打上该标记的写操作，存在一个全局修改顺序（尽管具体顺序在执行时才确定）。也就是说，对于所有线程来说，看见的这些写操作的顺序是一致的。</td></tr></tbody></table><h2 id="宽松顺序（Relaxed-ordering）"><a href="#宽松顺序（Relaxed-ordering）" class="headerlink" title="宽松顺序（Relaxed ordering）"></a>宽松顺序（Relaxed ordering）</h2><p>宽松顺序仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。因此，它们不是同步操作，仅保证原子变量上读写操作的原子性，以及各个原子变量自身修改顺序的一致性（对于同一个变量的两次修改，虽然顺序不一定，但是所有其他线程观察到的修改顺序都是相同的）。</p><p>假定 <code>x</code> 和 <code>y</code> 是两个全局变量，均被初始化为零，则下列代码执行完毕之后，存在 <code>r1 == r2 == 42</code> 的可能性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed);  <span class="comment">// B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// C</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// D</span></span><br></pre></td></tr></table></figure><p>这是因为，虽然在线程 1 和线程 2 之间没有任何同步；于是，对于原子变量 <code>y</code> 的<ins>修改顺序（Modification Order）</ins>来说，D 可能先于 A 发生；同样，对于原子变量 <code>x</code> 的<ins>修改顺序（Modification Order）</ins>来说，B 可能先于 C 发生。</p><p>宽松顺序的典型场景是不断增加的计数器。计数器的增加只需有原子性的保证，而对同步或是内存顺序没有要去。例如，<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> 当中的引用计数的增加。实例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        cnt.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : v) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final counter value is 10000</span><br></pre></td></tr></table></figure><p>不过，对于 <code>std::shard_ptr</code> 当中的引用计数来说，其减少需要与析构函数当中的 load 操作有 acquire-release 的同步。</p><h2 id="释放-获取顺序（Release-Acquire-ordering）"><a href="#释放-获取顺序（Release-Acquire-ordering）" class="headerlink" title="释放-获取顺序（Release-Acquire ordering）"></a>释放-获取顺序（Release-Acquire ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_acquire</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行释放操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在部分强顺序的 CPU 架构中（例如 <code>x86</code>, SPARC TSO, IBM mainframe 等），释放-获取顺序对大多数操作来说都是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将非原子的 load 操作挪到原子 load-acquire 操作之前）。</p><p>在弱顺序的 CPU 架构中（例如 ARM,Itanium, PowerPC），则需加入额外的 CPU 指令或是内存屏障。</p><p>互斥锁（例如 <a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>&#x2F;<a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag">atomic spinlock</a>）亦属于释放-获取同步：当锁被线程 A 释放而后被线程 B 获取，则在锁被释放之前临界区中所有对共享变量的写入操作在线程 B 获取锁之后均可见。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的获取-释放同步，因此两个 <code>assert</code> 永远不会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="type">int</span> data&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_acquire)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例则展示了在三个线程之中，获取-释放顺序的传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_acq_rel)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放-消费顺序（Release-Consume-ordering）"><a href="#释放-消费顺序（Release-Consume-ordering）" class="headerlink" title="释放-消费顺序（Release-Consume ordering）"></a>释放-消费顺序（Release-Consume ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_consume</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中依赖该原子变量的表达式和函数看来都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 中依赖该原子变量的表达式和函数可见线程 A 写入内存的所有内容。</p><p>这一同步仅只建立在对同一原子变量执行消费操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p><p>在除 DEC Alpha 之外的主流 CPU 上，释放-消费顺序（亦称：依赖顺序）是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将涉及到依赖链的非原子的 load 操作挪到原子 load-consume 操作之前）。</p><p>该顺序的使用，往往见于对并发共享数据结构有频繁读取而极少写入的场景（例如路由表、安全策略、防火墙规则等）。</p><p>注意，截至 2015 年 2 月，尚未有编译器追踪了依赖链条，因此，消费操作被提升为获取操作。</p><p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的释放-消费同步，因此第一个 <code>assert</code> 永远不会失败，但第二个 <code>assert</code> 可能失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序一致顺序（Sequentially-consistent-ordering）"><a href="#顺序一致顺序（Sequentially-consistent-ordering）" class="headerlink" title="顺序一致顺序（Sequentially-consistent ordering）"></a>顺序一致顺序（Sequentially-consistent ordering）</h2><p>标记上 <code>std::memory_order_seq_cst</code> 的原子操作不仅满足释放-获取顺序的要求（一个线程中 store-release 之前的写入操作在另一个 load-acquire 之后都可见），而且为所有如此标记的原子操作建立了<strong>唯一的全局统一修改顺序（single total modification order）</strong>。</p><p>正式地说，在不考虑 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence"><code>std::atomic_thread_fence</code></a> 的情况下，对于每个 load 原子变量 M 的操作 B（标记为 <code>std::memory_order_seq_cst</code>），它读取到的值来自以下三种可能：</p><ul><li>在上述<strong>唯一的全局统一修改顺序</strong>中的上一个修改了 M 的操作 A 的结果；</li><li>若存在这样的 A，B 还可能读到另一个修改了 M 的操作 C，它没有标记为 <code>std::memory_order_seq_cst</code>，并且不<ins>先于（happens-before）</ins> A；</li><li>若不存在这样的 A，B 读取的结果来自另一个修改了 M 的没有标记为 <code>std::memory_order_seq_cst</code>的操作 D。</li></ul><!-- Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order. --><p>顺序一致对于多生产者多消费者的情形是必要的。这是因为，所有消费者必须能够以相同的顺序观察到所有生产者的行为。</p><!-- Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core. --><p>在所有多核系统中（注：逻辑核），完全的顺序一致都会插入大量内存屏障指令。这使得相应的内存访问需要对所有核心进行广播，因而可能成为性能瓶颈。</p><!-- This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads c and d to observe changes to the atomics x and y in opposite order. --><p>下例中，顺序一致即是必要的。其他更弱的顺序模型可能导致线程 C 和线程 D 观察到原子变量 <code>x</code> 和 <code>y</code> 以不同的顺序修改，从而导致 <code>assert</code> 失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// will never happen</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与-volatile-的关系"><a href="#与-volatile-的关系" class="headerlink" title="与 volatile 的关系"></a>与 <code>volatile</code> 的关系</h2><!-- Within a thread of execution, accesses (reads and writes) through volatile glvalues cannot be reordered past observable side-effects (including other volatile accesses) that are sequenced-before or sequenced-after within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. --><p>在<strong>同一线程</strong>中，对 <code>volatile</code> 修饰的<a href="https://en.cppreference.com/w/cpp/language/value_category#glvalue">泛左值</a>（包括左值和将亡值）的访问（包括读写）不允许被重排序至<ins>先序于（sequenced-before）</ins>该操作的可观测的副作用（包括其他 <code>volatile</code> 访问）之前，亦不允许被重排序至<ins>后序于（sequenced-after）</ins>该操作的可观测的副作用（同上）之后。然而，<code>volatile</code> 访问并未建立线程之间的同步，故而在其他线程中，上述顺序无法得到保证。</p><!-- In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access). --><p>此外，对 <code>volatile</code> 修饰的泛左值的访问不是原子的（这意味着读写同一内存位置上的 <code>volatile</code> 变量属于<a href="https://en.cppreference.com/w/cpp/language/memory_model">数据竞争</a>），同时也不影响内存顺序（非 <code>volatile</code>-访问可以在 <code>volatile</code>-访问附近自由重排序）。</p><!-- One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (Microsoft Docs), and thus volatiles may be used for inter-thread synchronization. Standard volatile semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a std::signal handler that runs in the same thread when applied to sig_atomic_t variables. --><p>一个例外是 Visual Studio。根据<a href="https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp">微软提供的文档</a>，在默认设置下，<code>volatile</code>-读自带 acquire 语义而 <code>volatile</code>-写自带 release 语义。因此，这些 <code>volatile</code>-访问可被用来建立线程间的同步。但要注意，标准的 <code>volatile</code> 语义不应被用于多线程编程。（这一点在<a href="/2018/01/18/volatile-in-C-and-Cpp/">前作</a>中也有讨论）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇（&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;内存模型&lt;/a&gt;与&lt;a href=&quot;/2021/06/06/memory-order-cpp-01/&quot;&gt;内存顺序·上&lt;/a&gt;）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;对应页面&lt;/a&gt;的翻译，但会展开做一些讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
      <category term="Memory Order" scheme="https://liam.page/tags/Memory-Order/"/>
    
  </entry>
  
  <entry>
    <title>论善良</title>
    <link href="https://liam.page/2021/06/17/discussion-on-kind/"/>
    <id>https://liam.page/2021/06/17/discussion-on-kind/</id>
    <published>2021-06-17T13:07:31.000Z</published>
    <updated>2021-06-17T15:52:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。</p><span id="more"></span><h2 id="善良是什么？"><a href="#善良是什么？" class="headerlink" title="善良是什么？"></a>善良是什么？</h2><p>善良一词，与我所见最早者，当出自《礼记·学记》。曰：「发虑宪，求善良，足以謏闻，不足以动众。」</p><p>按文言一贯作风，善良虽在现代汉语中成词已久，但在文言中大概是分别表意的。在文言文词典中，<a href="https://wyw.hwxnet.com/view/hwxE5hwx96hwx84.html">善</a>作名词表示「好的行为」，作形容词表示「赞许的」或是「熟悉」。显然，此处应取「值得赞许的」的含义。<a href="https://wyw.hwxnet.com/view/hwxE8hwx89hwxAF.html">良</a>作形容词表示「好」。因此，讲白了，文言中的「善良」大约就是人类品德中所有好的品德的集合体。</p><p>在现代汉语中，善良的表意某种意义上被圈定在「和善」、「心地好」这样的意思上了。</p><h2 id="人善被人欺？"><a href="#人善被人欺？" class="headerlink" title="人善被人欺？"></a>人善被人欺？</h2><p>大多数生长于传统中国家庭的孩子，大都从小被教育「要善良」。与之相应，孩子被要求「爱分享」、「乐于助人」等。</p><p>然而，步入社会之后，或多或少地，这些从小被教育要善良的孩子，都因「善良」吃过亏。其中不乏「屡教不改」抑或是「执迷不悔」的人，当然也有些人从此「黑化」或是抑郁。</p><p>这些时候，「孩子们」大约会想起父母的另一句话「害人之心不可有，防人之心不可无」。可是，爸爸妈妈，你们从来没教过我们要如何才能「防人」呀……</p><p>所以，到底要怎么办？</p><h2 id="善心？善举？"><a href="#善心？善举？" class="headerlink" title="善心？善举？"></a>善心？善举？</h2><p>面对这个问题，我们不能逃避。因为你能逃一次，但将来不断发生的事情，会不断质疑你的内心。最终逃无可逃，必须直面。</p><p>为了解决这个问题，我们将善良分为两个部分，或者说两个层次：善心和善举。善心是无条件的，行善举是有条件的。若是行善举会危害到自己的核心利益，那便要慎重。世人多被要求善良，却不分善举和善心。无差别的善举最终往往害人害己。</p><p>对于以善良为代表的一切「美好的德行」，都有<strong>论心不论迹</strong>。也就是说，我们要将善心和善举区分开来；而后，常怀善心，擅行善举。</p><h2 id="何时行善举？"><a href="#何时行善举？" class="headerlink" title="何时行善举？"></a>何时行善举？</h2><p>是否要行善举，这其实是一个选择题。</p><p>在我看来，这一选择题理当无有特殊性。也就是说，人生中其他类似的选择题如何做，这一道选择题就如何做。亦即，人自身的一切行为，都要有统一的标准去考量。不能因为善举于道德地位更高，就降低评判标准，而后决定施行，而不顾其可能带来的负面影响。</p><p>操作层面上，当意图行善时，脑回路里加一个步骤：这事儿做了之后最坏的结果自己能不能接受。如果不能接受的话，哪怕是善举，也慎重一些。</p><h2 id="不为善其与为恶异乎？"><a href="#不为善其与为恶异乎？" class="headerlink" title="不为善其与为恶异乎？"></a>不为善其与为恶异乎？</h2><p>或曰：「不为善者与为恶者，无异也」。曰：「道德绑架者也。」</p><p>有人认为，善而不为，其与恶无异。此类谬误有二。一者，忽略世界的多样性，将善恶二元对立，认为非善即恶。他们认为，不做善事就是恶；不作恶事就是善。二者，将善良至于绝对片面的语境之下，忽略实际情况，忽略自身自我，将善良狭隘化为一个放之四海而皆准的道德标尺。殊不知，因为行善举，而将自己置于无法承受的危险之下，实际上是忽略了自我。「我」都没有了，还谈什么善良呢？这不是善良，而是伪善。</p><p>这些人可能也会拿汉昭烈帝的「勿以善小而不为」来做例证。然而，刘备遗诏中的意思，是强调善举大小、影响范围，却没有教刘禅不分青红皂白应当一律行善。</p><p>因此，认为不行善举即是作恶的人，其实就是道德绑架罢了。</p><h2 id="真正的英雄主义"><a href="#真正的英雄主义" class="headerlink" title="真正的英雄主义"></a>真正的英雄主义</h2><p>罗曼·罗兰说：「世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它」。</p><p>如何能做到这一点？</p><p>自己的善举可能为自己带来危害，这也是生活的真相之一。被伤害过后，你还愿意保持善良吗？被伤害过后，你能控制自己不去伤害别人吗？换言之，被伤害过后，你还热爱这个世界吗？</p><p>广义地看待善良，将善心和善举分开，常怀善心、擅行善举，则哪怕不能成为真的英雄，也常在成为英雄的路上了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客虽以技术文章为主，但仍夹杂有不少杂文。此篇讨论善良。&lt;/p&gt;
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://liam.page/categories/Miscellaneous/"/>
    
    
      <category term="Kind" scheme="https://liam.page/tags/Kind/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（⑪）：C++ 的内存顺序·上</title>
    <link href="https://liam.page/2021/06/06/memory-order-cpp-01/"/>
    <id>https://liam.page/2021/06/06/memory-order-cpp-01/</id>
    <published>2021-06-06T04:16:06.000Z</published>
    <updated>2021-06-06T12:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇继<a href="/2021/06/05/memory-model-cpp/">前文</a>讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>术语部分的翻译，有删减和补充。</p><span id="more"></span><p>线程间同步及内存顺序决定表达式的<ins>求值（evaluations）</ins>及其<ins>副作用（side effects）</ins>在不同线程中的顺序。首先有相关术语的定义。</p><h2 id="消费操作（consume-operation）"><a href="#消费操作（consume-operation）" class="headerlink" title="消费操作（consume operation）"></a>消费操作（consume operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_consume</code></a> 或更强的内存顺序的原子读操作是消费操作（consume operation）。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比消费操作更强。</p><h2 id="占有操作（aquire-operation）"><a href="#占有操作（aquire-operation）" class="headerlink" title="占有操作（aquire operation）"></a>占有操作（aquire operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_acquire</code></a> 或更强的内存顺序的原子读操作是占有操作（aquire operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex">互斥量（mutex）</a>上执行 <code>lock()</code> 操作亦属于占有操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比占有操作更强。</p><h2 id="释放操作（release-operation）"><a href="#释放操作（release-operation）" class="headerlink" title="释放操作（release operation）"></a>释放操作（release operation）</h2><p>配置了 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order_release</code></a> 或更强的内存顺序的原子读操作是释放操作（release operation）。在<a href="https://en.cppreference.com/w/cpp/named_req/Mutex">互斥量（mutex）</a>上执行 <code>unlock()</code> 操作亦属于释放操作。</p><p>注意：<code>std::atomic_thread_fence</code> 引入的同步机制比释放操作更强。</p><h2 id="表达式求值（evaluations-of-expressions）"><a href="#表达式求值（evaluations-of-expressions）" class="headerlink" title="表达式求值（evaluations of expressions）"></a>表达式求值（evaluations of expressions）</h2><p>对一个表达式<ins>求值（evaluation）</ins>包含以下两个部分：</p><ul><li><ins>值计算（value computations）</ins>：计算表达式的返回值。其中可能涉及到对象的识别（identity of the object；左值求值）或是读取对象中保存的值（右值求值）。前者例如返回某个对象的引用，后者例如返回一个数值。</li><li><ins>副作用（side effect）</ins>：通过一个易变左值访问（读&#x2F;写）对象；修改对象；调用函数库中的 I&#x2F;O 函数；或调用包含上述操作的其他函数。</li></ul><h2 id="先序（sequenced-before）关系"><a href="#先序（sequenced-before）关系" class="headerlink" title="先序（sequenced-before）关系"></a>先序（sequenced-before）关系</h2><p>先序关系描述同一个线程中两次求值之间的偏序关系。</p><ul><li>若 A <ins>先序于（sequenced-before）</ins> B，则 A 将在 B 开始执行之前完成。</li><li>若 A 不先序于 B，而 B 先序于 A，则 B 将在 A 开始执行之前完成。</li><li>若 A 不先序于 B 而 B 亦不先序于 A，则有两种可能性<ul><li>A 和 B 的求值不存在序列关系：二者可能以任意顺序求值，并且它们的求值动作在时间上可能重叠（在同一线程中，编译器可能打乱组成 A 和 B 的指令的顺序，使他们相互穿插）。</li><li>A 和 B 的求值序列关系不确定：二者可能以任意顺序求值，但它们的求值动作在时间上不可能重叠。此外，程序再次执行时，二者的执行顺序可能和上一次不同。</li></ul></li></ul><h2 id="带去依赖（Carries-dependency）"><a href="#带去依赖（Carries-dependency）" class="headerlink" title="带去依赖（Carries dependency）"></a>带去依赖（Carries dependency）</h2><p>在同一线程中，若 A <ins>先序于</ins> B，则在下列情况下，A 为 B 带去依赖（即，B 依赖于 A）：</p><ul><li>A 的返回值是 B 的操作数，但下列情形除外：<ul><li>B 是对 <a href="https://en.cppreference.com/w/cpp/atomic/kill_dependency"><code>std::kill_dependency</code></a> 的调用；</li><li>A 的返回值是内建 <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code> 或是 <code>,</code> 运算符的左操作数。</li></ul></li><li>执行 A 的过程中写入标量 M，而执行 B 的过程读取标量 M。</li><li>A 为 X 带去依赖，而 X 为 B 带去依赖。（即依赖关系具有传递性）</li></ul><h2 id="修改顺序（Modification-Order）"><a href="#修改顺序（Modification-Order）" class="headerlink" title="修改顺序（Modification Order）"></a>修改顺序（Modification Order）</h2><p>对于某个原子变量来说，其全部写入操作组成一个全局修改顺序。</p><p>所有原子操作都保证符合以下四个要求：</p><ol><li>写写一致性：若对原子变量 M 的写入操作 A <ins>先于（happens-before）</ins>对同一原子变量的写入操作 B。则在 M 的<ins>修改顺序（modification order）</ins>中，A 在 B 之前。</li><li>读读一致性：若 A 和 B 的值计算均读取原子变量 M，且 A <ins>先于</ins> B；又假定 A 读到的原子变量 M 的值来自某个对 M 有写操作的表达式 X；则 B 读到的值，要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li><li>读写一致性：若 A 的值计算读取原子变量 M 而 B 写入 M，且 A <ins>先于</ins> B；则 A 读到的值来自在 M 的<ins>修改顺序（modification order）</ins>中早于 B 的某个写入 X。</li><li>写读一致性：若 X 对原子变量 M 有写入，而 B 的值计算读取原子变量 M；又假定 X <ins>先于</ins> B；则 B 读到的值要么来自 X 的写入，要么来自在 M 的<ins>修改顺序（modification order）</ins>中晚于 X 的某个写入 Y。</li></ol><h2 id="释放序列（Release-sequence）"><a href="#释放序列（Release-sequence）" class="headerlink" title="释放序列（Release sequence）"></a>释放序列（Release sequence）</h2><p>假定 A 是原子变量 M 上的一个<ins>释放操作（release operation）</ins>。则在 M 的修改顺序中，<strong>位于 A 之后</strong>的由下列操作组成的最长连续子序列被称为以 A 为首的<ins>释放序列（release sequence）</ins>：</p><ol><li>执行 A 的线程中，对 M 的写入操作（until C++20）；</li><li>任意线程对 M 的读-改-写操作（CAS 成功时的操作）。</li></ol><h2 id="依赖顺序上先于（Dependency-ordered-before）"><a href="#依赖顺序上先于（Dependency-ordered-before）" class="headerlink" title="依赖顺序上先于（Dependency-ordered before）"></a>依赖顺序上先于（Dependency-ordered before）</h2><p>满足下列某个情况时，我们称表达式 A 在<ins>依赖顺序上先于（dependency-ordered before）</ins>表达式 B——其中 A 和 B 处于不同线程。</p><ol><li>A 对原子变量 M 执行<ins>释放操作（release operation）</ins>，在另一线程中 B 对同一原子变量 M 执行<ins>消费操作（consume operation）</ins>，且 B 读取的值来自 A（以 A 为首的<ins>释放序列（release sequence）</ins>中的任意部分（until C++20））的写入。</li><li>A 在依赖顺序上先于 X，而 X 为 B 带去依赖。</li></ol><h2 id="线程间先于（Inter-thread-happens-before）"><a href="#线程间先于（Inter-thread-happens-before）" class="headerlink" title="线程间先于（Inter-thread happens-before）"></a>线程间先于（Inter-thread happens-before）</h2><p>若满足下列条件之一，则称对表达式 A 的求值<ins>线程间先于（inter-thread happens-before）</ins>对表达式 B 的求值：</p><ol><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>依赖顺序上先于</ins> B；</li><li>A 与某个表达式 X <ins>同步</ins>，而 X <ins>先序于</ins> B；</li><li>A <ins>先序于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B；</li><li>A <ins>线程间先于</ins> 某个表达式 X 的求值，而 X <ins>线程间先于</ins> B。</li></ol><h2 id="先于（happens-before）"><a href="#先于（happens-before）" class="headerlink" title="先于（happens-before）"></a>先于（happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>线程间先于（inter-thread happens-before）</ins> B。</li></ol><p>编译器实现应当引入必要的同步措施，以保证表达式求值之间的先于关系链不成环。（仅当引入消费操作（consume operation）时有此必要；参见 <a href="http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf">Betty 等的论文</a>）</p><p>若某个求值操作修改了一个内存位置（见<a href="/2021/06/05/memory-model-cpp/">前文</a>），另一个求值操作读写同一内存位置，且至少其一不是原子操作，除非二者之间存在<ins>先于</ins>关系，程序行为未定义（程序有数据竞争）。</p><h2 id="简单先于（Simply-happens-before；since-C-20）"><a href="#简单先于（Simply-happens-before；since-C-20）" class="headerlink" title="简单先于（Simply happens-before；since C++20）"></a>简单先于（Simply happens-before；since C++20）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>简单先于（happens-before）</ins>对表达式 B 的求值：</p><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>简单先于</ins> 某个表达式 X 的求值，而 X <ins>简单先于</ins> B。</li></ol><p>注：没有消费操作（consume operation）时，简单先于等价于先于。</p><h2 id="强先于（Strongly-happens-before）"><a href="#强先于（Strongly-happens-before）" class="headerlink" title="强先于（Strongly happens-before）"></a>强先于（Strongly happens-before）</h2><p>无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值<ins>强先于（strongly happens-before）</ins>对表达式 B 的求值：</p><h3 id="until-C-20"><a href="#until-C-20" class="headerlink" title="until C++20"></a>until C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：C++20 之前的强先于，即是 C++20 及之后的简单先于。</p><h3 id="since-C-20"><a href="#since-C-20" class="headerlink" title="since C++20"></a>since C++20</h3><ol><li>A <ins>先序于（sequenced-before）</ins> B；</li><li>A 与 B <ins>同步（synchronizes-with）</ins>，且 A&#x2F;B 均为顺序一致（sequentially consistent）的原子操作；</li><li>A <ins>先序于（sequenced-before）</ins> X，X <ins>简单先于</ins> Y，Y <ins>先序于（sequenced-before）</ins> B；</li><li>A <ins>强先于</ins> 某个表达式 X 的求值，而 X <ins>强先于</ins> B。</li></ol><p>注：不正式地讲，若 A <ins>强先于（strongly happens-before）</ins> B，则在任何上下文中，A 都先于 B 求值。</p><p>注：强先于关系排除了消费操作（consume operation）。</p><h2 id="可见副作用（Visible-side-effects）"><a href="#可见副作用（Visible-side-effects）" class="headerlink" title="可见副作用（Visible side-effects）"></a>可见副作用（Visible side-effects）</h2><p>若下列条件均成立，则 A 对于标量 M 的副作用（写操作）于在标量 M 上的求值 B（读操作）可见：</p><ol><li>A <ins>先于</ins> B；</li><li>任意满足 A <ins>先于</ins> X 且 X <ins>先于</ins> B 的表达式 X 对标量 M 没有副作用。</li></ol><p>若 A 的副作用对 B 可见，则在 M 的修改顺序当中 B 之前的最长连续副作用子集称之为 B 可见的副作用序列。（B 见到的 M 的值是上述副作用其中之一写入的）</p><p>注：线程间同步本质是要通过建立<ins>先于（happens-before）</ins>关系来避免数据竞争以及定义在哪些条件下哪些副作用可见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇继&lt;a href=&quot;/2021/06/05/memory-model-cpp/&quot;&gt;前文&lt;/a&gt;讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;对应页面&lt;/a&gt;术语部分的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养（十）：C++ 的内存模型</title>
    <link href="https://liam.page/2021/06/05/memory-model-cpp/"/>
    <id>https://liam.page/2021/06/05/memory-model-cpp/</id>
    <published>2021-06-05T02:36:41.000Z</published>
    <updated>2021-12-11T14:18:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上<a href="https://en.cppreference.com/w/cpp/language/memory_model">对应页面</a>的翻译，有删减和补充。</p><span id="more"></span><p>内存模型为 C++ 抽象机器定义了计算机内存存储语义。</p><p>C++ 程序可用的内存是一个或多个连续的字节序列。每个字节有自己独有的内存地址。</p><h2 id="字节（Byte）"><a href="#字节（Byte）" class="headerlink" title="字节（Byte）"></a>字节（Byte）</h2><p>字节是内存中的最小可寻址单元，由连续的多个比特组成。C++ 中，<code>char</code>&#x2F;<code>unsigned char</code>&#x2F;<code>signed char</code> 的对象存储和<a href="https://en.cppreference.com/w/cpp/language/object">值表示</a>均使用恰好 1 字节。于是，字节中有多少比特，可以通过 <a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><code>std::numeric_limits&lt;unsigned char&gt;::digits</code></a>取得。</p><h2 id="内存位置（Memory-Location）"><a href="#内存位置（Memory-Location）" class="headerlink" title="内存位置（Memory Location）"></a>内存位置（Memory Location）</h2><p>内存位置是</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/type">标量类型</a>（算数类型、指针类型、枚举类型或是 <code>std::nullptr_t</code>）的对象；</li><li>或是，长度不为零的<a href="https://en.cppreference.com/w/cpp/language/bit_field">位域</a>组成的最长连续序列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">// memory location #1</span></span><br><span class="line">    <span class="type">int</span> b : <span class="number">5</span>;  <span class="comment">// memory location #2</span></span><br><span class="line">    <span class="type">int</span> c : <span class="number">11</span>, <span class="comment">// memory location #2 (continued)</span></span><br><span class="line">          : <span class="number">0</span>,  <span class="comment">// zero-length, as a delimiter of continued sequence of bit-fields</span></span><br><span class="line">        d : <span class="number">8</span>;  <span class="comment">// memory location #3</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">int</span> ee : <span class="number">8</span>; <span class="comment">// memory location #4</span></span><br><span class="line">    &#125; e;</span><br><span class="line">&#125; obj; <span class="comment">// The object &#x27;obj&#x27; consists of 4 separate memory locations</span></span><br></pre></td></tr></table></figure><p>注意：语言中的许多特性会引入额外的内存位置。这些内存位置程序无法访问，而是为编译器实现自行管理。这些特性例如：<a href="https://en.cppreference.com/w/cpp/language/reference">引用</a>和<a href="https://en.cppreference.com/w/cpp/language/virtual">虚函数</a>。</p><h2 id="线程与数据竞争（Thread-and-data-races）"><a href="#线程与数据竞争（Thread-and-data-races）" class="headerlink" title="线程与数据竞争（Thread and data races）"></a>线程与数据竞争（Thread and data races）</h2><p>程序中的线程是自 <a href="https://en.cppreference.com/w/cpp/thread/thread/thread"><code>std::thread::thread</code></a>, <a href="https://en.cppreference.com/w/cpp/thread/async"><code>std::async</code></a> 或者其他方式调用顶层函数开始的控制流。</p><p>任一线程都可能访问程序中的任意对象。其中，原子及<a href="https://en.cppreference.com/w/cpp/language/storage_duration">线程内部存储</a>亦可能为其它线程通过指针或引用来访问。</p><p>在没有同步或阻塞的情况下，不同线程可并发访问（读&#x2F;写）不同内存位置。</p><p>若一个表达式求值对某一内存位置进行写操作，而另一求值过程对同一内存位置进行读或写操作，则两个求值过程存在冲突。除非满足下列条件，程序中冲突的求值操作将引发数据竞争：</p><ul><li>存在冲突的求值操作在同一线程中执行，或在同一<a href="https://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler">信号处理函数</a>中执行；或者</li><li>存在冲突的求值操作均是原子操作（参见 <a href="https://en.cppreference.com/w/cpp/atomic/atomic"><code>std::atomic</code></a>）；或者</li><li>存在冲突的求值操作，其一<ins>先于（happens-before）</ins>另一发生（参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order</code></a>）。</li></ul><p>数据竞争将导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using atomic variable</span></span><br></pre></td></tr></table></figure><p>特别地，对于同一个 <a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>，在一个线程中释放它与在另一线程中获取它是<ins>同步的（synchronized-with）</ins>，故而释放动作<ins>先于（happens-before）</ins>获取动作。因此，可用 <code>std::mutex</code> 来避免数据竞争。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123; std::lock_guard&lt;std::mutex&gt; <span class="built_in">lk</span>(mtx); cnt++; &#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;;  <span class="comment">// OK, by using mutex to ensure happens-before semantic</span></span><br></pre></td></tr></table></figure><h2 id="内存顺序（Memory-Order）"><a href="#内存顺序（Memory-Order）" class="headerlink" title="内存顺序（Memory Order）"></a>内存顺序（Memory Order）</h2><p>线程自某个内存位置取值时，读到的可能是它的初始值，也可能是当前线程写入的值，亦可能是其他线程写入的值。有关内存顺序的细节可参见 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><code>std::memory_order</code></a>；其中讨论了线程的写入操作在其他线程可见性的问题。</p><h2 id="前向执行（Forward-Progress）"><a href="#前向执行（Forward-Progress）" class="headerlink" title="前向执行（Forward Progress）"></a>前向执行（Forward Progress）</h2><h3 id="无阻塞（Obstruction-freedom）"><a href="#无阻塞（Obstruction-freedom）" class="headerlink" title="无阻塞（Obstruction freedom）"></a>无阻塞（Obstruction freedom）</h3><p>仅有一个未被标准库函数阻塞的线程在执行无锁<a href="https://en.cppreference.com/w/cpp/atomic">原子函数（atomic function）</a>时，该原子函数必能执行完毕（标准库内所有无锁操作均<a href="obstruction-free">无阻塞</a>）。</p><h3 id="无锁（Lock-freedom）"><a href="#无锁（Lock-freedom）" class="headerlink" title="无锁（Lock freedom）"></a>无锁（Lock freedom）</h3><p>一个或更多无锁原子函数并发执行时，至少其中之一必能执行完毕（标准库内所有无所操作均<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom">无锁</a>——编译器实现会保证它们不会被一直锁住，例如持续地被窃走缓存行（cache-line stealing；一种因为执行其他线程的 CPU 核心对内存数据做预取而导致当前 CPU 核心缓存行变脏的现象））。</p><blockquote><p>关于 cache-line stealing，参见：<a href="https://www.researchgate.net/publication/221497089_Tackling_Cache-Line_Stealing_Effects_Using_Run-Time_Adaptation">这篇论文</a>。</p></blockquote><h3 id="执行之担保（Progress-guarantee）"><a href="#执行之担保（Progress-guarantee）" class="headerlink" title="执行之担保（Progress guarantee）"></a>执行之担保（Progress guarantee）</h3><p>在正确的 C++ 程序当中，所有线程终将执行到下列情形之一：</p><ul><li>终止；</li><li>调用 I&#x2F;O 库的函数；</li><li>经由<a href="https://en.cppreference.com/w/cpp/language/cv">易变（volatile）</a>的左值（lvalue）或者将亡值（xvalue）——拥有内存地址的长寿对象——访问外部设备；</li><li>执行原子操作或是同步操作。</li></ul><p>若一个线程执行上述任一操作（I&#x2F;O, volatile, 原子操作或是同步操作），或是阻塞在标准库函数当中，亦或是因其他为阻塞线程正在并发执行导致调用一个无锁原子操作却尚未完成，则称该线程<ins>有进展（make progress）</ins>。</p><h3 id="并发前向执行（Concurrent-forward-progress-since-C-17）"><a href="#并发前向执行（Concurrent-forward-progress-since-C-17）" class="headerlink" title="并发前向执行（Concurrent forward progress; since C++17）"></a>并发前向执行（Concurrent forward progress; since C++17）</h3><p>若某线程有<ins>并发前向执行之担保（concurrent forward progress guarantee）</ins>，则在它终止之前，无论其他线程（若有）是否有进展，它都将于有限时间内取得如上定义之<ins>进展（make progress）</ins>。</p><p>C++ 标准鼓励（但并不强求）主线程和其他由 <code>std::thread</code> 启动的线程提供<ins>并发前向执行之担保</ins>。</p><h3 id="并行前向执行（Parallel-forward-progress-since-C-17）"><a href="#并行前向执行（Parallel-forward-progress-since-C-17）" class="headerlink" title="并行前向执行（Parallel forward progress; since C++17）"></a>并行前向执行（Parallel forward progress; since C++17）</h3><p>若某线程有<ins>并行前向执行之担保（parallel forward progress guarantee）</ins>，则</p><ul><li>在它尚未执行任何步骤（I&#x2F;O, volatile, 原子操作或是同步操作）时，编译器实现不保证它在有限时间内有<ins>进展</ins>；</li><li>而一旦它执行了某一步骤，它提供<ins>并发前向执行之担保</ins>。</li></ul><p>此规则表明，线程池中的线程可以按照任意顺序执行任务。</p><h3 id="弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）"><a href="#弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）" class="headerlink" title="弱并行前向执行（Weakly parallel forward progress; since C++17）"></a>弱并行前向执行（Weakly parallel forward progress; since C++17）</h3><p>若某线程有<ins>弱并行前向执行之担保（weakly parallel forward progress guarantee）</ins>，则无论其他线程是否有<ins>进展</ins>，它都不保证它在有限时间内有<ins>进展</ins>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/memory_model&quot;&gt;对应页面&lt;/a&gt;的翻译，有删减和补充。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Atomics" scheme="https://liam.page/tags/Atomics/"/>
    
      <category term="Memory Model" scheme="https://liam.page/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>xTR 预估任务中的特征工程</title>
    <link href="https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/"/>
    <id>https://liam.page/2021/05/23/feature-engineering-in-pxtr-tasks/</id>
    <published>2021-05-23T13:59:12.000Z</published>
    <updated>2021-07-31T07:45:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&gt; W&amp;D 系列 -&gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。</p><p>此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。</p><span id="more"></span><h2 id="时间类特征"><a href="#时间类特征" class="headerlink" title="时间类特征"></a>时间类特征</h2><blockquote><p>作者：大博<br>链接：<a href="https://www.zhihu.com/question/350863682/answer/860524396">https://www.zhihu.com/question/350863682/answer/860524396</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>考虑问题中的「时间」。从三个角度：用户的时间，商品的时间，用户与商品间的时间。每个角度可以包括的时间类型：时间绝对值，时间间隔值。每个时间类型可以有不同的计算方法：统计型，独立型。（备注：一下就计算来的值算独立型，通过一堆独立值统计来的，用「平均&#x2F;最大」等描述的特征算统计型。）</p><ul><li>用户的时间：(刻画用户本身的习惯)<ul><li>时间绝对值<ul><li>统计型：一个月内最高频的浏览时间</li><li>独立型：用户当前浏览时间&#x2F;用户上一次浏览时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户曾经两次浏览的时间间隔的「平均」</li><li>独立型：用户本次浏览与上次浏览的时间间隔</li></ul></li></ul></li><li>商品的时间：(刻画商品本身的属性)<ul><li>时间绝对值<ul><li>统计型：商品最常被购买的时间</li><li>独立型：商品上架时间&#x2F;预计下架时间（上下架指一个动作）</li></ul></li><li>时间间隔值<ul><li>统计型：三天除以三天内商品被购买次数</li><li>独立型：商品的在线时间&#x2F;当前时间与商品常被购买时间的间隔</li></ul></li></ul></li><li>用户与商品间的时间：(刻画该用户到该商品的匹配程度)<ul><li>时间绝对值<ul><li>统计型：用户历史购买该商品的平均时间分布</li><li>独立型：用户上次购买该商品的时间&#x2F;用户上次购买该商品所属品类的时间</li></ul></li><li>时间间隔值<ul><li>统计型：用户历史购买该品类商品的平均时间间隔</li><li>独立型：用户上次购买该商品到当前时间的时间间隔</li></ul></li></ul></li></ul><p>最后总结下思路：</p><ol><li>一般强特征都是用户到商品的交叉特征，「商品」要从商品id扩展到「品类」&#x2F;「商户」&#x2F;「标签」等等能交叉的角度。</li><li>时间间隔一般是强特。</li><li>历史统计型特征可以用条件概率去理解，虽不是强特，但多了是有用的。</li><li>哪怕是从「时间」考虑特征，特征所反应的含义应该是：这个人平时愿不愿意买东西，这件商品平时的受众是怎样的，这个人对这个商品的敏感程度是怎样的。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xTR 预估任务是搜索、推荐、广告、电商领域的一大类问题。此类问题的建模相对简单明了——构建一个针对 xTR 的二分类任务即可。从过往的工作经验来看，在数据量达到一定规模之前，NN 模型上的花活（DNN -&amp;gt; W&amp;amp;D 系列 -&amp;gt; 多目标系列）带来的提升有限；ROI 更高的做法是在数据清洗、特征工程上做细致的工作。&lt;/p&gt;
&lt;p&gt;此篇将讨论 xTR 预估任务当中的特征工程。因内容宏大，难以一时完成；故而将会分批陆续更新。因涉及广泛，故而与博客内其他文章不同，此篇文章的内容，会很大程度上借鉴以至摘抄同好之文章，并做好引述工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="xTR" scheme="https://liam.page/tags/xTR/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之十：名词性从句</title>
    <link href="https://liam.page/2021/05/09/noun-subordinate-clauses/"/>
    <id>https://liam.page/2021/05/09/noun-subordinate-clauses/</id>
    <published>2021-05-09T09:28:51.000Z</published>
    <updated>2021-05-09T14:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第十篇。<a href="/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/">前作</a>介绍了复合句的概念，并介绍了分析和练习复合句的方法。</p><p>考虑到合句本身简单，所以在本系列中略去不讲，将来另开一系列讨论。本系列从此篇开始，介绍各种类型的复句。此篇介绍名词性从句。</p><span id="more"></span><h2 id="复句的种类"><a href="#复句的种类" class="headerlink" title="复句的种类"></a>复句的种类</h2><p>在英文当中，除动词外，几种主要词类在剧中充当成分时，都能为相应的从句代替，从而与主句一起组成复句。由此，我们可知英文当中有以下复句类型：</p><ul><li>名词性从句<ul><li>主语从句</li><li>宾语从句</li><li>补语从句（表语从句）</li><li>同位语从句</li></ul></li><li>形容词性从句<ul><li>各类状语从句</li></ul></li><li>副词性从句<ul><li>各类关系从句</li></ul></li></ul><p>此篇我们介绍名词性从句。</p><h2 id="名词性从句的主要特点"><a href="#名词性从句的主要特点" class="headerlink" title="名词性从句的主要特点"></a>名词性从句的主要特点</h2><p>名词性从句有以下一些特点：</p><ol><li>在句中充当名词的角色。这也是名词性从句的由来。</li><li>本身是一个完整的独立子句。也就是说，名词性从句自身可归于五种基本句型里去，并且有相应的组成成分。</li><li>名词性从句通常以一个有时可以省略的 <code>that</code> 开头；它不表意，只有语法功能，表示引导了一个名词性从句。当名词性从句的引导词需要参与表意时，往往需要相应的 <code>wh-</code> 疑问词或是 <code>whether</code>&#x2F;<code>if</code> 来引导。</li></ol><h2 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h2><p>当名词性从句出现在主语位置时，它就是主语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong><em>That he finished writing the composition in such a short time</em> surprised us all.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>he finished writing the composition in such a short time. | 他于短时间内写完作文。</li><li>something surprised us all. | 某事震惊了我们所有人。</li></ol><p>以 <code>that</code> 加在第一个独立子句之前，形成主语从句，替代第二个独立子句的 <code>something</code> 即得到原句。原句翻译为：他于短时间内写完作文震惊了我们所有人。</p><p>此句重点在于表达「我们所有人都惊了」，至于为何事震惊实际处于次要地位。因此，于修辞计，考虑到从句很长，我们倾向于让主句的内容先出来。为此，我们用附加虚词 <code>it</code> 来代替主语从句的内容，作为「形式主语」。原句变为：「It surprised us all <em>that he finished writing the composition in such a short time</em>.」</p><p><strong><em>Who you are</em> doesn&#39;t matter at all.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>who you are. | 你是谁？</li><li>the question doesn&#39;t matter at all. | 这问题根本不重要。</li></ol><p><code>wh-</code> 疑问词 <code>who</code> 一方面具有表意功能，另一方面可以直接引导句子。因而，第一个独立子句可以直接替换主句中的 <code>the question</code>，充作主语从句而得到原句。原句的翻译为：你是谁（这个问题）根本不重要。</p><p>当名词性从句替换的名词是一个问题（the question&#x2F;a question）时，我们往往需要 <code>wh-</code> 疑问词参与表意。</p><p><strong><em>Whether he is telling the truth or not</em> is anyone&#39;s guess.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>which he is telling either the truth or not. | 他在讲真话还是假话？</li><li>the question is anyone&#39;s guess. | 这问题谁也不知道答案。</li></ol><p><code>wh-</code> 疑问词 <code>which</code> 一方面具有表意功能，另一方面可以直接引导句子。再注意到，<code>whether</code> 实际是 <code>which</code> 和 <code>either</code> 的合成。因而，第一个独立子句可以直接替换主句中的 <code>the question</code>，充作主语从句而得到原句。原句的翻译为：他在讲真话还是假话（这个问题）谁也不知道答案。</p><p>既知 <code>whether</code> 是 <code>which</code> 和 <code>either</code> 的合成，那么，在表达「是否」的含义并引导名词性从句时我们就可以用它了。在成词日久之后，由于 <code>if</code> 也能表示「是否」的含义，所以在一些情况下以 <code>whether</code> 引导名词性从句时也可以由 <code>if</code> 来引导。但并非所有情形都适合做这样的替换。以下距离不能替换的场景：</p><ul><li><code>whether</code> 引导名词性从句位于句首时。此时 <code>if</code> 容易被误认为是在引导一个条件状语从句，产生歧义，故不可。</li><li><code>whether</code> 引导名词性从句位于介词之后，充当介词宾语时（此时必然是宾语从句）。此时，介词与 <code>which</code> 组成固定短语，不适合替换成 <code>if</code>，而只能由合成词 <code>whether</code> 来担此任务。</li></ul><h2 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h2><p>当名词性从句出现在宾语位置时，它就是宾语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong>Liam swears <em>that he will love Sophia forever.</em></strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>Liam swears something. | Liam 发誓说了什么。</li><li>he will love Sophia forever. | 他会永远爱 Sophia。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成宾语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「Liam 发誓说他会永远爱 Sophia」。</p><p>这里，因为 <code>swears</code> 是一个及宾动词。陈述句中，位于及宾动词之后的，肯定是宾语。所以，此处即使去掉 <code>that</code>，读者也能看出这是一个宾语从句，不至于引起歧义：「Liam swears *he will love Sophia forever.*」于是，在及宾动词之后，于修辞计，引导宾语从句的 <code>that</code> 可以省略。</p><p>举一个反例，若我们在 <code>swears</code> 之后加上方式状语 <code>on the Bible</code>，变成：「Liam swears on the Bible *that he will love Sophia forever.*」，引导词 <code>that</code> 就不适合省略了。若不然，句子变成「Liam swears on the Bible *he will love Sophia forever.*」很容易让人困惑。</p><p><strong>We all found <em>that he finished writing the composition in such a short time</em> surprising.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>We all found something surprising. | 我们都发现了某事令人惊奇。</li><li>he finished writing the composition in such a short time. | 他于短时间内写完作文。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成宾语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「我们都发现他于短时间内写完作文这件事令人惊奇」。</p><p>和主语从句的情形类似。此句重点在于表达「我们所有人都惊了」，至于为何事震惊实际处于次要地位。因此，于修辞计，考虑到从句很长，我们倾向于让主句的主要成分之一的补语（surprising）先出来。为此，我们用附加虚词 <code>it</code> 来代替宾语从句的内容，作为「形式宾语」。原句变为：「We all found it surprising <em>that he finished writing the composition in such a short time</em>.」</p><p>与主语从句的情况类似，宾语从句也可以由 <code>wh-</code> 疑问词引导。读者可自己试着造句，此处不做展开。</p><p>在某些情况下，宾语从句的内容比主句本身要重要。这时候，宾语从句会被提前。（山东人民应该会感到舒服，笑~）我们来看一个例子。</p><p><strong>This is what you&#39;ve done, I suppose.</strong></p><p>这里，正常语序实际应该是：I suppose that this is what you&#39;ve done. 不过，因为宾语从句的内容比「我猜」更重要，所以它被提到前面，同时去掉引导词 <code>that</code> 并和主句之间用逗号分隔开。</p><h2 id="补语从句"><a href="#补语从句" class="headerlink" title="补语从句"></a>补语从句</h2><p>当名词性从句出现在补语位置时，它就是补语从句。充作主语的补语时，传统语法也称之为表语从句。此处举几个例子，并随附说明一些注意要点。</p><p><strong>The point is <em>that nobody died in the accident</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The point is something. | 要点在于某事。</li><li>nobody died in the accident. | 事故中无人死亡。</li></ol><p>以 <code>that</code> 加在第二个独立子句之前，形成补语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「要点在于事故中无人死亡」。</p><p>与宾语从句的情况类似，位于联系动词之后的，肯定是补语。所以，此处即使去掉 <code>that</code>，读者也能看出这是一个补语从句，不至于引起歧义：「The point is <em>nobody died in the accident</em>.」因此，充作主语补语的补语从句，其引导词 <code>that</code> 在非正式场合下也可以省略。</p><p><strong>My education and my experience made me <em>that&#x2F;who I am today</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>My education and my experience made me something. | 我所接受的教育和过去的经历塑造我成为某事。</li><li>I am today. | 我如今的样子。</li></ol><p>以 <code>that</code>&#x2F;<code>who</code> 加在第二个独立子句之前，形成（宾语）补语从句，替代第一个独立子句的 <code>something</code> 即得到原句。原句翻译为：「我所接受的教育和过去的经历塑造我成为我如今的样子」。注意这里的 <code>am</code> 单独出现，表示「存在」。「我如今的存在」即是「我如今的样子」。</p><p>继续 <code>that</code> 省略的讨论。此处，由于补语从句充作宾语的补语，故而前面没有明确的联系动词作为提示。故而，此处不宜将引导词 <code>that</code> 省略。</p><p>此处还要额外注意一点。实际上，充当补语的既可以是名词也可以是形容词。因此，简单地说补语从句是一种名词性从句，其实并不能另所有人信服。基于同样的原因，将它归类为形容词性从句，也会有同样的问题。若是把补语从句同时归纳于名词性从句和形容词性从句里面，又生造了一个特例，无甚必要。处理这一问题，我们还是要从表意的角度出发，不要过度纠结，以简御繁为上。</p><h2 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h2><p>名词性从句当中，比较容易产生误会的就是同位语从句了。为此，我们先来确定一下什么是同位语。所谓同位语，就是用不同的方式，把一个概念再说一遍，并且用逗号隔开。它通常是对抽象概念的解释说明——毕竟，确切的概念也就不必反复说明了嘛。</p><p>举几个🌰：</p><ul><li>My wife, <em>Sophia</em>, is compatible with me very well. | 我爱人，Sophia，与我很合得来。</li><li>The fact, <em>rabbit eats carrot</em>, is not suprising. | 兔子爱吃胡萝卜这一事实不会令人意外。</li></ul><p>两个例子中，<em>Sophia</em> 和 <em>rabbit eats carrot</em> 都是各自主语的同位语，他们和各自的主语是同一个概念。对于同位语，我们往往可以用联系动词将同位语和它解释的对象连起来。比如：</p><ul><li>My wife is Sophia.</li><li>The fact is that rabbit eats carrot.</li></ul><p>同位语可以解释主语，也可以解释宾语。比如：</p><ul><li>I love my wife, <em>Sophia</em>. | 我爱我的妻子 Sophia。</li></ul><p>同样，宾语 my wife 及其同位语，也可以用联系动词连起来。比如：</p><ul><li>My wife is Sophia.</li></ul><p>以上例子应该足够讲清楚同位语是什么。同时我们也不难发现，<strong>同位语和补语之间有不少相似之处</strong>。在后续的文章里，我们会再次看到这一点。</p><hr><p>现在我们来看同位语从句。同样地，此处举几个例子，并随附说明一些注意要点。</p><p><strong>The fact <em>that rabbit eats carrot</em> is not suprising.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The fact is not suprising. | 这一事实不会令人意外。</li><li>rabbit eats carrot. | 兔子吃胡萝卜。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中的主语 <em>the fact</em> 本身。于是我们在第二个独立子句之前加上引导词  <code>that</code> ，形成同位语从句，作为第一个独立子句的 the fact 的同位语即得到原句。原句翻译为：「兔子爱吃胡萝卜这一事实不会令人意外」。</p><p>类似地，我们可以改造出一个对宾语做同位语从句的例子。</p><p><strong>One will not be suprised by the fact <em>that rabbit eats carrot</em>.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>One will not be suprised by the fact. | 人们不会对这一事实感到惊讶。</li><li>rabbit eats carrot. | 兔子吃胡萝卜。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中的宾语 <em>the fact</em> 本身。于是我们在第二个独立子句之前加上引导词  <code>that</code> ，形成同位语从句，作为第一个独立子句的 the fact 的同位语即得到原句。原句翻译为：「人们不会对兔子吃胡萝卜这一事实感到惊讶」。</p><p>和其他名词从句类似，当被同位语解释的对象是一个问题时，<code>wh-</code> 疑问词就会登场。</p><p><strong>The question <em>who the killer is</em> is on the police officer&#39;s mind.</strong></p><p>这句话由以下几个独立子句组成：</p><ol><li>The question is on the police officer&#39;s mind. | 这个问题萦绕在警官心头。</li><li>who the killer is. | 杀手是谁。</li></ol><p>注意这里，第二个子句讲述的内容，就是第一个子句当中主语 <em>the question</em> 本身。考虑到第二个子句是个问句，已经有 <code>wh-</code> 疑问词 <em>who</em>，此处无需 <code>that</code> 做引导即可作为同位语从句。原句翻译为：「杀手是谁这一问题萦绕在警官心头」。</p><blockquote><p> 有这三个例子打底，我们来分析一下同位语从句和定语从句的区别。在这里，同位语从句和限定修饰先行名词的定语从句十分相似。他们同样放在名词后面，同样可以由 <code>that</code> 或者 <code>wh-</code> 疑问词引导。从形式上来看，他们很相似。同位语从句和限定修饰先行名词的定语从句之间的区别，主要体现在两个方面：</p><ul><li>从表意上说：<ul><li>同位语从句的内容，就是被其解释的抽象名词本身。因此，被解释的名词和同位语从句之间，可以用联系动词连起来，形成 SVC 的结构。这也体现了同位语和补语之间紧密的联系——实际上在某些语法体系里面，甚至没有同位语的概念，而是将之作为补语的一种来处理。</li><li>限定修饰先行名词的定语从句的内容，对先行名词起到限定修饰的作用。先行名词和定语从句之间，无法用联系动词直接连接在一起。</li></ul></li><li>从形式上说：<ul><li>同位语的 <code>that</code> 只有语法功能，没有表意能力；从句去掉 <code>that</code> 是一个完整句子。</li><li>定语从句的 <code>that</code> 不仅有语法功能，还在从句中充当先行词本身；从句去掉 <code>that</code> 变得不完整。</li></ul></li></ul><p> 借助上述三个例子，我们择其一来观察同位语从句和定语从句之间的区别。</p><ul><li>The fact <em>that rabbit eats carrot</em> is not suprising. | 兔子爱吃胡萝卜这一事实不会令人意外。</li><li>The fact <em>that is figured out by Liam</em> is not suprising. | 为 Liam 所指出的事实不会令人意外。</li></ul><p> 第二个例子当中 <code>that</code> 引导的是定语从句，限定修饰先行词 the fact。显然，我们没法讲：「The fact is that is figured out by Liam」。一是因为表意上不通；二是因为 <code>that</code> 后的句子看起来是个补语从句，但是缺少主语。</p><p> 如此，读者应该能比较明确地分辨同位语从句和定语从句。</p></blockquote><p>上述三个例子都是比较典型的同位语从句。下面举三个不那么典型的同位语从句。</p><ul><li>I&#39;m afraid <em>that I cannot help you</em>. | 我恐怕没法帮你。</li><li>You should take care <em>that the baby is sleeping well</em>. | 你应当小心让宝贝睡好。</li><li>I&#39;m not sure <em>whether the police officer will find the killer or not</em>. | 我不确定警官是否能找出杀手。</li></ul><p>在这三个例子当中，去掉斜体标识的同位语从句，在主句中我们找不到可供同位语从句解释说明的名词。实际上，这类 case 的主句有被简化。如果把主句改成下面这样，就不难理解了：</p><ul><li>I&#39;m afraid <strong>of the thing</strong>.</li><li>You should take care <strong>of the thing</strong>.</li><li>I&#39;m not sure <strong>about the thing</strong>.</li></ul><p>原来，同位语从句是在解释说明被省略掉的 the thing。只不过，在长期的语言实践当中，由于 the thing 本身太虚，没有含义，处于修辞的考虑，就被省略掉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第十篇。&lt;a href=&quot;/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/&quot;&gt;前作&lt;/a&gt;介绍了复合句的概念，并介绍了分析和练习复合句的方法。&lt;/p&gt;
&lt;p&gt;考虑到合句本身简单，所以在本系列中略去不讲，将来另开一系列讨论。本系列从此篇开始，介绍各种类型的复句。此篇介绍名词性从句。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
      <category term="Subordinate Clause" scheme="https://liam.page/tags/Subordinate-Clause/"/>
    
      <category term="Subjective Clause" scheme="https://liam.page/tags/Subjective-Clause/"/>
    
      <category term="Predicative Clause" scheme="https://liam.page/tags/Predicative-Clause/"/>
    
      <category term="Objective Clause" scheme="https://liam.page/tags/Objective-Clause/"/>
    
      <category term="Appositive Clause" scheme="https://liam.page/tags/Appositive-Clause/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之⑨：忘记长难句，欢迎来到复合句的世界</title>
    <link href="https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/"/>
    <id>https://liam.page/2021/05/07/introduction-to-compound-sentence-and-complex-sentence/</id>
    <published>2021-05-07T14:46:19.000Z</published>
    <updated>2021-05-09T09:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第⑨篇。<a href="/2021/05/06/model-verbs-and-moods-in-English/">前作</a>处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。</p><p>从此篇开始，我们要进入复合句的世界。</p><span id="more"></span><h2 id="忘记长难句"><a href="#忘记长难句" class="headerlink" title="忘记长难句"></a>忘记长难句</h2><p>前北京新东方 GMAT 名师杨鹏著有《GRE&amp;GMAT 阅读难句教程》一书。因书中对 GRE 和 GMAT 考试阅读题中常常出现的长句难句做了一些解读，故而被坊间惯称为「杨鹏长难句」。然而，以数学系学生的视角，我对这本书是不甚满意的。这种不满在于它没有很好地解决一个基本问题：到底多长算长句，又到底多难算难句？对于难句，是你觉得难算难，还是我觉得难算难？因为缺少一个客观稳定的标准，在我的视角，它很难提出一个完备的方案去处理所有的情况。</p><p>因此，虽然《长难句》一书仍可一看，但忘记「长难句」这一概念却是必要的。</p><h2 id="破而立……什么？"><a href="#破而立……什么？" class="headerlink" title="破而立……什么？"></a>破而立……什么？</h2><p>或曰：「你不能光顾着破坏，还要负责建设」。</p><p>忘记长难句，我们要以怎样的视角去切入英文中那些看起来很长又很难的句子呢？答案是，以简单句和复合句的视角。</p><p>我们在系列第一篇介绍了五种基本句型，在系列第五篇（非谓语动词篇）里又提到了独立子句（independent clause）的概念。据此，我们可以给出一个明确的结论：有且只有一套主谓结构的句子，是独立子句。独立子句必属于五种基本句型之一。独立子句单独成句时，就是简单句。</p><p>在简单句的定义基础上，我们又能「非此即彼」地定义出复合句：不是简单句的句子，就是复合句。复合句由若干个独立子句组合而成。独立子句组成复合句又有两种方式。一是由 and&#x2F;or&#x2F;but 等连接词连接的两个并列子句组成的合句（compound sentence）；二是由各种从句与主句连接而成的复句（complex sentence）。</p><p>你看，按照这样的定义，绝不会有一个句子被遗漏。于是我们有信心能处理所有的情况。</p><h2 id="怎样分析和练习复合句？"><a href="#怎样分析和练习复合句？" class="headerlink" title="怎样分析和练习复合句？"></a>怎样分析和练习复合句？</h2><p>系列的后续文章，会处理各种类型的复合句。这里提前讲一讲，在理解各种类型复合句的基础上，如何分析和练习。在这里，分析是为了解决阅读方面的问题，让你在阅读遇到复合句时不至于抓瞎；练习是为了解决写作方面的问题，让你在写作时能自如地应用复合句。</p><p>这里总结整理了一个四步分析法：</p><ol><li>标记出复合句当中的各个独立子句。</li><li>对于每个独立子句，识别其应用的基本句型，而后标出其中的主要成分。</li><li>对于每个独立子句，翻译之。</li><li>将独立子句的翻译组合起来，得到整个复合句的翻译。——注意，一定要写下来翻译成通顺的人话（可以打字）。</li></ol><p>反复应用这一分析法，按我这等笨人的经验，每天坚持分析五个句子并坚持一个月能在阅读 GRE&#x2F;GMAT&#x2F;LSAT 级别的文章上有一个质的飞跃。（当然 GRE 级别的文章不只是复合句一个问题需要解决就是了。）相信读者老爷们这么聪明，应当相比当年的我，能更快获得提升。</p><p>分析完成之后，就要练习。练习的方法也很简单：模仿造句——牙牙学语嘛！对每个你初时感到困难的复合句进行三到五次模仿造句——模仿它的句子结构，也模仿子句之间的逻辑关系。</p><p>按照这样分析和练习的方法，每天花费大概半个小时的时间，你将能一劳永逸地征服英语复合句。它不香吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第⑨篇。&lt;a href=&quot;/2021/05/06/model-verbs-and-moods-in-English/&quot;&gt;前作&lt;/a&gt;处理了情态动词与虚拟语气，解决了简单句当中最后一个较大的问题。在简单句中，还剩下一些重要的问题没有处理（例如介词）。这些问题虽然重要，但十分零碎，无法用通常的办法以简御繁，更多地是要依靠大量阅读输入来解决。因此，这些问题不放在这一系列文章中，待将来另开一系列，专门解决各类小毛病。&lt;/p&gt;
&lt;p&gt;从此篇开始，我们要进入复合句的世界。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Single Sentence" scheme="https://liam.page/tags/Single-Sentence/"/>
    
      <category term="Compound Sentence" scheme="https://liam.page/tags/Compound-Sentence/"/>
    
      <category term="Complex Sentence" scheme="https://liam.page/tags/Complex-Sentence/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之八：情态动词与虚拟语气</title>
    <link href="https://liam.page/2021/05/06/model-verbs-and-moods-in-English/"/>
    <id>https://liam.page/2021/05/06/model-verbs-and-moods-in-English/</id>
    <published>2021-05-06T13:36:57.000Z</published>
    <updated>2021-06-05T02:16:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第八篇。<a href="/2021/04/29/adverbs/">前作</a>处理了副词，此篇我们引出语气的问题，然后处理情态动词。</p><span id="more"></span><h2 id="语气是什么"><a href="#语气是什么" class="headerlink" title="语气是什么"></a>语气是什么</h2><p>我们从<a href="/2014/06/21/basic-sentence-and-the-complement/">系列第一篇</a>开始（在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇中又一次强调），就从表意的角度解读：一个完整句子表达的无非是「一个人&#x2F;一个东西怎么样（了）」。但这其实是一个「善意的谎言」；若说它不是谎言，也至少是不完整的。它欠缺的部分，就是「语气」。</p><p>语气的英文是 mood。在 AHD 中可见它有几层与文法中的语气相关意思：</p><ul><li>心情、情绪：A state of mind or emotion.</li><li>印象、感受：A pervading impression of an observer.</li><li>倾向、意愿：Inclination; disposition.</li></ul><p>无论何种解释，mood 都是「唯心」的，天然带有一层模糊的、不确定的感觉；这与「一个人&#x2F;一个东西怎么样（了）」这种确定性的表述有明显差别。于是我们有：</p><ul><li><strong>语气其实就是句子表意过程中的不确定性</strong>；</li><li>确定的表意总是相似的；</li><li>不确定的表意则各有各的不确定（在不确定的程度和不确定的方式上）。</li></ul><p>在英文中，普通动词本身只能表达确定性的语义。例如：I like math. 若是要表达不确定性的语义，则必须有其他动词的帮助才行。帮助其他动词进行表意的动词，通称「助动词」。表达各种类别和各种程度的不确定性的助动词，是情态动词（modal verbs）。</p><blockquote><p>情态动词这个翻译，我认为不好。但因已成惯例，所以不去改它。更好的翻译应该是「语气动词」。modal 这个词，在 AHD 当中关于文法的解释只有一条「Of, relating to, or expressing the mood of a verb.」，即：语气的：属于，有关或表达一个动词的语气的。可见「语气动词」翻译之贴切。</p></blockquote><p>接下来的问题是，英文当中都有哪些语气呢？这是个令人头秃的问题，因为不同的语法专家对此的认知并不相同。有人认为英文当中语气分三种：陈述语气、祈使语气、虚拟语气。有人认为英文当中语气分四类，在上述三类基础上增加「疑问语气」。有人认为应当分五类，在上述四类基础上增加「感叹语气」。</p><p>于我看来，不论如何分类，祈使语气、疑问语气和感叹语气是不会有太多争议的。表达这三种语气时，在句法上会有很规律的变化，以至于有「祈使句」、「疑问句」和「感叹句」之说。因而人们想要弄混它们都不太容易。我们的宗旨是从表意和修辞出发。既然它们不容易弄混，我们就干脆地将他们放下，不尊「务虚论理者多，经世致用者少」那等做派。这样一来，剩下的问题就在陈述语气和虚拟语气当中了。</p><h2 id="以简御繁：关于不确定性的讨论"><a href="#以简御繁：关于不确定性的讨论" class="headerlink" title="以简御繁：关于不确定性的讨论"></a>以简御繁：关于不确定性的讨论</h2><p>以简御繁的手段是去摸索句子表意当中的不确定性。</p><h3 id="陈述语气（indicative）"><a href="#陈述语气（indicative）" class="headerlink" title="陈述语气（indicative）"></a>陈述语气（indicative）</h3><p>如果一个句子的表意十分确定，那显然就是陈述语气了。例如有：</p><ul><li>It rains. | 天在下雨。</li><li>You are right. | 你是对的。</li><li>I like mathematics. | 我喜欢数学。</li><li>Sophia gives me her pencil. | Sophia 将她的铅笔给我。</li><li>Liam finds the house big. | Liam 发现房子很大。</li></ul><h3 id="条件语气（conditional）"><a href="#条件语气（conditional）" class="headerlink" title="条件语气（conditional）"></a>条件语气（conditional）</h3><p>若在陈述语气的基础上，加上心情、情绪（例如 must）或是印象、感受（例如 can&#x2F;could, may&#x2F;might）亦或是倾向、意愿（例如 will&#x2F;would, shall&#x2F;should；注意此处并不表示将来时态，而是表示倾向意愿），句子中就有了不确定性了。在上述例子的基础上，我们处理一下：</p><ul><li>It <em>may&#x2F;might</em> rain. | 天可能在下雨。</li><li>You <em>must</em> be right. | 你一定是对的。</li><li>I <em>shall</em> like mathematics. | 我应当喜欢数学。</li><li>Sophia <em>can&#x2F;could</em> give me her pencil. | Sophia 可以将她的铅笔给我。</li><li>Liam <em>shall&#x2F;should</em> have found the house big. | Liam 应当已经发现房子很大了。</li></ul><p>此处有两点需要注意。一是我们在<a href="/2020/02/27/nonfinite-verb/">非谓语动词</a>篇里讲过的，情态动词后面，实际上是无修饰的不定式，因而要用动词原型。二是尽管部分情态动词有其过去式的形态，但对「不确定性」表达过去本身无意义，因此需要借用完成式来表达对过去的猜测（或曰，表达过去时态下的不确定性）。</p><p>在陈述语气的句子上，直接加上情态动词（可能还需要对动词做一些变形）可以表达不同类型和程度的不确定性。但这些不确定性，都没有否定陈述句意本身，只是在语气上的弱化。为便于归纳，我们把这类语法现象称之为条件语气。</p><h3 id="虚拟语气（subjunctive）"><a href="#虚拟语气（subjunctive）" class="headerlink" title="虚拟语气（subjunctive）"></a>虚拟语气（subjunctive）</h3><p>还有一种情况，我们的表意需要否定陈述句意本身。这种表意发生在假定一个不存在的事实的基础上，作出的推定。这里有四点需要注意的地方：</p><ul><li>因为假定非事实，所以称为虚拟语气；</li><li>因为假定非事实，所以从句中假定本身需要比正常时态退一格（现在 -&gt; 过去；过去 -&gt; 过去完成；将来 -&gt; 过去将来）；</li><li>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式表达强烈的不确定性；</li><li>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式。</li></ul><p>对虚拟语气，举几个例子。</p><p><strong>If I <em>were</em> you, I <em>would</em> fend off that shot. | 要我是你的话，我会把那一球扑出去。</strong></p><p>表达「我是你」，应该用 I am you 才对。但我不是你，这非是事实，所以要退一格，用过去式来表意。那么为什么是 <code>were</code> 而非是 <code>was</code> 呢？因为 <code>be</code> 这个动词是这样的：</p><ul><li>原型：be</li><li>第一人称单数现在陈述语气：am</li><li>第三人称单数现在陈述语气：is</li><li>其余人称和单复数的现在陈述语气：are</li><li>现在分词：being</li><li>过去分词：been</li><li>第一和第三人称单数过去陈述语气：was</li><li>第二人称单数和复数，第一人称复数，第三人称复数，过去陈述语气：were</li><li>过去虚拟语气：were</li></ul><p>亦即，在虚拟语气中，be-动词的过去式就是 were，不区分单复数，也不区分人称。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>would</code> 表达强烈的不确定性。</p><p><strong>If I <em>had known</em> that earlier, I <em>might have revised</em> for the examination harder. | 要早知道的话，我会为考试更努力复习。</strong></p><p>表达「我知道」，应该用 I knew that earlier 才对。但实际我并不知道，这非是事实，所以要退一格，用过去完成式来表意，变成 <code>had known</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>might</code> 表达强烈的不确定性。</p><p>因为要用情态动词表达不确定性，所以主句中对过去的不确定性的表意需要借助完成式，有 <code>might have revised</code>。</p><p><strong>If I <em>should take</em> the bribe, <em>could</em> you <em>keep</em> the secret for me? | 要我收下了那笔贿赂，你能替我保守秘密吗？</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>should take</code>。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><p><strong>If I <em>were to take</em> the bribe, my fingers <em>could be</em> illicit from then on. | 要我收下了那笔贿赂，我的手就再也不干净了。</strong></p><p>表达「我将会收下贿赂」，应该用 I will take the bribe 才对。但实际我并不知道，这非是事实，所以要退一格，用过去将来式来表意，变成 <code>were to take</code>。这和上例的 <code>should take</code> 又有所不同。虽然都非是事实，用 should take 表示还有一些 take 的可能性，而用 were to take 则十分决绝，毫无可能。</p><p>因为假定非事实，所以不确定性极高，因此主句中需要用情态动词的过去式 <code>could</code> 表达强烈的不确定性。</p><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>借助「不确定性」的表意，我们轻而易举地处理了虚拟语气，可见其以简御繁的为例。</p><p>虚拟语气中还有一个倒装的问题，属修辞范畴。我们在后续的文章中再来讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第八篇。&lt;a href=&quot;/2021/04/29/adverbs/&quot;&gt;前作&lt;/a&gt;处理了副词，此篇我们引出语气的问题，然后处理情态动词。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Model Verbs" scheme="https://liam.page/tags/Model-Verbs/"/>
    
      <category term="Moods" scheme="https://liam.page/tags/Moods/"/>
    
  </entry>
  
  <entry>
    <title>英语语法之七：副词</title>
    <link href="https://liam.page/2021/04/29/adverbs/"/>
    <id>https://liam.page/2021/04/29/adverbs/</id>
    <published>2021-04-29T13:47:12.000Z</published>
    <updated>2021-04-30T14:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95">系列</a>文章的第七篇。<a href="/2021/04/21/adjectives/">前作</a>处理了形容词，此篇我们处理同为修饰词类的副词。</p><p>从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。</p><p>除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。</p><p>除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 <code>-ly</code>。因此，在双音节的副词变为比较级和最高级时，若是以 <code>-ly</code> 结尾，则应保持不变，通过联合 <code>more</code> 及 <code>most</code> 来实现。</p><span id="more"></span><h2 id="两大法宝"><a href="#两大法宝" class="headerlink" title="两大法宝"></a>两大法宝</h2><p>如何以简御繁？这是很重要的问题。</p><p>从系列第一篇读至此的朋友，若是细心就会发现我们至今为止以简御繁的两大法宝：</p><ul><li>从表意上考量——我们相信文法是为表意服务的；</li><li>从修辞上考量——我们相信文法形成过程中，人们有趋同的修辞偏好。</li></ul><p>这两大法宝将在整个系列贯穿始终、提纲挈领。我们从表意上，把副词分为以下几大类，分别处理：</p><ul><li>表达方式方法的副词；</li><li>表达强调的副词；</li><li>修饰句子的副词。</li></ul><h2 id="表达方式方法的副词"><a href="#表达方式方法的副词" class="headerlink" title="表达方式方法的副词"></a>表达方式方法的副词</h2><p>表达方式方法的副词，在传统语法当中被称为「方式状语」。方式状语直接修饰动词，表达动作发出的方式方法。</p><p>至于副词的位置——因为方式状语直接修饰动词，所以理想状态，它应该距离动词较近；若不然，人们很难领会到二者之间修饰 - 被修饰的关系。又考虑到动词本身肯定比修饰语要重要一些，所以作为修饰语的副词，一般性应该要放在动词后面。这是表达方式方法的副词的典型位置。</p><p>接下来，我们按<a href="/2014/06/21/basic-sentence-and-the-complement/">五种基本句型</a>各举一例，说明表达方式方法的副词在句子中位置应当如何处理。</p><ul><li>The girl cries <em>sadly</em> after being betrayed by her ex-boyfriend. | 被前男友背叛后，女孩哭得很伤心。</li></ul><p>句子中，我们把表达方式方法的副词放在动词 cries 后面。可选的位置还有两个。一是放在 cries 之前。这样做是可以的，但是 cries 后面没有句子主干成分了（宾语、补语之类）；所以还是放在 cries 后面，凸显动词更佳。另一是放在整个 after 短语之后。但这样距离 cries 太远，反而距离另一个动词 betrayed 更近，造成句意不明。</p><ul><li>The girl swings her bat <em>vigorously</em>. | 女孩用力挥动她的棒球棒。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是和上例一样，放在动词 swing 后面。但这样就把句子的主干成分 her bat（句子中做宾语）挤到后面去了，不利于表意。另一是放在 swing 之前。这也属于可以考虑的方案，但此处宾语并不冗长，放在宾语之后距离被修饰的动词 swing 也不算太远，所以显得有些鸡肋。但如果换成下面的句子，副词就最好放在动词 swing 之前了——若不然，就距离动词太遥远了。</p><blockquote><p>The girl <em>vigorously</em> swings her brand new Italian aluminum alloy bat. | 女孩用力挥动她那崭新的意大利产铝合金棒球棒。</p></blockquote><ul><li>The girl becomes mature <em>gradually</em>. | 女孩逐渐变得成熟。</li></ul><p>句子中，我们表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一个是放在动词 becomes 之前，这没问题。另一是放在动词 becomes 之后，变成「The girl becomes <em>gradually</em> mature.」。这样一来，因为副词既可以修饰动词，又可以修饰形容词，放在这里的 gradually 很容易让人困惑它到底是修饰 becomes 的还是修饰 mature 的。</p><ul><li>The girl gave him a jar of honey <em>readily</em>. | 女孩爽快地给了他一罐蜂蜜。</li></ul><p>句子中，我们把表达方式方法的副词，放在了句子最后面。可选的位置还有两个。一是放在动词 gave 之前，这没问题。另一是放在动词 gave 之后，变成「The girl gave <em>readily</em> him a jar of honey.」。这样做，表意上倒是不至于有歧义，但副词 readily 把句子的主干成分（直接宾语 + 间接宾语）挤到后面去了，所以在修辞上不好。</p><ul><li>The priest <em>happily</em> announced the boy and the girl man and wife. | 神父高兴地宣布男孩和女孩结为夫妻。</li></ul><p>句子中，我们把表达方式方法的副词放在了动词 announced 之前。可选的位置还有两个。一是放在动词 announced 之后，但这会让句子的主干成分（宾语 + 宾语补语）后移，在修辞上不佳。二是放在句子最后。但这个句子重点是要强调二者结为夫妻，若是将 happily 放在句子最后，一则显得我们在强调神父是高兴的，二则让副词和被修饰的动词距离过远。</p><h2 id="表达强调的副词"><a href="#表达强调的副词" class="headerlink" title="表达强调的副词"></a>表达强调的副词</h2><p>副词当中，还有一大类是表达强调的副词（Intensifier）。这些副词的修饰对象广泛，可以修饰几乎全部词类，特别是可以修饰几种主要词类：名词、动词、形容词、副词。因之，这些副词必须和被修饰的对象紧密相连（而且通常都是放在被修饰对象的前面）。若不然，可能会被误以为是修饰其他句子成分，表意出现漂移。</p><p>表达强调意味的副词，大致有三类。以下分别处理。</p><h3 id="强调范围的副词"><a href="#强调范围的副词" class="headerlink" title="强调范围的副词"></a>强调范围的副词</h3><p>表达强调的副词中，有一部分是用来强调所谈事物的范围的，将所谈事物的范围限定在一个小的范围内。这类副词加与不加、加在何处，对句子的表意影响很大。这类副词中，一个典型是「只有」。举例如下。</p><p>原句：Liam studied mathematics when he was young. | Liam 年轻时学习数学。</p><p>添加「只有」：</p><ul><li><em>Only</em> Liam studied mathematics when he was young. | 只有 Liam 年轻时学习数学。——别人年轻时不学。</li><li>Liam <em>only</em> studied mathematics when he was young. | Liam 年轻时只学习数学。——但没对数学做别的事情；比如对数学并不热爱。</li><li>Liam studied <em>only</em> mathematics when he was young. | Liam 年轻时只学习数学。——但没学别的学科。</li><li>Liam studied mathematics <em>only</em> when he was young. | Liam 只在年轻时学习数学。——长大之后不学了。</li></ul><p>不难发现，添加「只有」之后的四个变种，其表意各不相同，亦与原句表意不同。由此可见「这类副词加与不加、加在何处，对句子的表意影响很大」之说。此又印证「这些副词必须和被修饰的对象紧密相连」之言。</p><p>常见的用于强调表意范围的副词还有：</p><ul><li>only &#x2F; just &#x2F; merely | 只有</li><li>also | 也</li><li>especially &#x2F; particularly | 尤其、特别地</li><li>even | 更加、甚至、居然、恰如</li><li>exactly &#x2F; precisely | 恰恰</li><li>……</li></ul><h3 id="强调程度的副词"><a href="#强调程度的副词" class="headerlink" title="强调程度的副词"></a>强调程度的副词</h3><p>表达强调的副词中的第二类是强调程度的副词。这些副词也是句子表意中很重要的一部分；同样地，这类副词加与不加对句意影响很大。举一例：</p><ul><li>原句：Liam knows Wenyue well. | Liam 了解 Wenyue。</li><li>改程度：Liam knows Wenyue <em>rather</em> well. | Liam 还算了解 Wenyue。</li></ul><p>再举一例：</p><ul><li>原句：The task is done. | 任务已完成。</li><li>改程度：The task is <em>almost</em> done. | 任务已近完成。</li></ul><p>不难发现，这些表达程度的副词也是句子表意的重要组成部分。若是去掉它们，句子表意会发生巨大变化。常见的用于强调程度的副词不少，就不举例了。</p><h3 id="强调语气的副词"><a href="#强调语气的副词" class="headerlink" title="强调语气的副词"></a>强调语气的副词</h3><p>强调语气的副词看起来和强调程度的副词很像。但是，去掉句子当中强调语气的副词只是影响语气，不影响句子表意。举几例：</p><ul><li>Fat XXX looks <em>very much</em> a ball. | 胖子 XXX 看着就是个球。</li><li>XXX is <em>absolutely</em> insane. | XXX 绝对是疯了。</li><li>XXX <em>urgently</em> need being hospitalized. | XXX急需入院治疗。</li></ul><h2 id="修饰句子的副词"><a href="#修饰句子的副词" class="headerlink" title="修饰句子的副词"></a>修饰句子的副词</h2><p>这是一类特殊的副词。和一般（狭隘的）认知不同，有些副词可以用来修饰整个句子。举例来说：</p><ul><li><em>Therefore</em>, Wenyue is less than too fat. | 因此，Wenyue 还称不上太胖。</li><li><em>Frankly</em>, Wenyue is very much a gentleman. | 坦率地说，Wenyue 是个绅♂士。</li></ul><p>例中，无论是 <em>therefore</em> 还是 <em>frankly</em>，在句中都找不到被它们直接修饰的句子成分。这是因为它们都是修饰整个句子的副词。此二例中，看着相似，但实际仍有区别。第二例中的 <em>frankly</em>，实际是一条件状语从句的缩写：</p><blockquote><p>If we are specking frankly, Wenyue is very much a gentleman.</p></blockquote><p>对于这类从副词从句缩写而来的副词，我们称之为分离副词。此外，不难发现，分离副词前后的逗号，原就是两个句子之间的逗号。这种简化，最早应是出于修辞的考虑；简化之后保留逗号，则是出自表意的考虑。</p><p>第一例中的 <em>therefore</em> 本身能表达逻辑关系。因之，此类副词被称为连接副词。这些副词还有</p><ul><li>表达逻辑等号的：therefore, besides, futhermore, ...</li><li>表达逻辑不等号的：however, nonetheless, ...</li></ul><h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>此篇，我们通过「两大法宝」，串起了几大类副词，同时辨析了各类副词在句中的用法。所谓渔重于🐟，读者在了解各类副词用法的同时，更重要地是善用两大法宝，复习过去学过的文法和学习新的文法知识。</p><p>下一篇我们处理情态动词和虚拟语气。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;/series/#%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95&quot;&gt;系列&lt;/a&gt;文章的第七篇。&lt;a href=&quot;/2021/04/21/adjectives/&quot;&gt;前作&lt;/a&gt;处理了形容词，此篇我们处理同为修饰词类的副词。&lt;/p&gt;
&lt;p&gt;从被修饰的对象来说，相较而言，副词比形容词要复杂得多。形容词基本上只能用来修饰名词，但副词可以修饰除名此外的其他成分；甚至，副词还可以修饰一整个句子。&lt;/p&gt;
&lt;p&gt;除去被修饰的对象，副词的复杂性，还体现在它在句子当中所处的位置。它可以出现在动词前，也可以出现在动词后；它可以紧挨着动词，也可以距离动词挺远；甚至，它可以独立成句。&lt;/p&gt;
&lt;p&gt;除此二者之外，副词也有比较级和最高级。不过，副词的比较级和最高级和形容词规则几乎完全一样。唯独要注意的是，副词的典型词缀是 &lt;code&gt;-ly&lt;/code&gt;。因此，在双音节的副词变为比较级和最高级时，若是以 &lt;code&gt;-ly&lt;/code&gt; 结尾，则应保持不变，通过联合 &lt;code&gt;more&lt;/code&gt; 及 &lt;code&gt;most&lt;/code&gt; 来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://liam.page/categories/English/"/>
    
    
      <category term="Adverbs" scheme="https://liam.page/tags/Adverbs/"/>
    
  </entry>
  
  <entry>
    <title>喉咙和声带的结构</title>
    <link href="https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/"/>
    <id>https://liam.page/2021/04/27/autopsy-structure-of-throat-and-vocal-folds/</id>
    <published>2021-04-26T16:28:03.000Z</published>
    <updated>2021-04-26T16:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！</p><span id="more"></span><p>声带是两片相对的膜状韧带，有长度宽度和厚度。</p><p>声带附近有四块软骨：甲状软骨、勺状软骨（两块）和环状软骨。</p><p>连接软骨有肌肉：甲杓（读音：彪）肌（连接甲状软骨和勺状软骨；TA 肌）、杓间肌（连接两块勺状软骨，横向一条，斜向两条；IA 肌）、环杓侧肌（在侧面连接环状软骨和勺状软骨；LCA 肌）、环杓后肌（在后面连接勺状软骨和环状软骨；PCA 肌）、环甲肌（在前面连接环状软骨和甲状软骨；CT 肌）。</p><p>肌肉通过拉扯软骨，来改变连接着软骨的声带的形状。相对来说，有四种：</p><ul><li>变短变厚：甲杓肌收缩，发出响亮的中低音，传说中的「真声」。</li><li>变长变薄：环甲肌收缩，引起整个环状软骨绕环甲连接处转动，从而带动勺状软骨后移，拉动声带变长变薄。</li><li>闭合：杓间肌和环杓侧肌收缩，拉近两块勺状软骨之间的距离。</li><li>张开：环杓后肌收缩，拉开两块勺状软骨之间的距离，声带分开。</li></ul><p>当声带闭合，又有气流从下而上推出，两片声带在气流的冲击和伯努利效应（边界层表面效应）的作用下会不断相互拍击，发出声音。</p><p>接下来的问题就是，要想唱好歌，本质上就是要在各种情况下，相应的肌肉都有足够的力量，去使声带作出相应的动作。所以，练歌，本质上和去健身房撸铁没啥区别——都是要锻炼肌肉。下回如果有人跟你说要去撸铁，不一定是去健身房，也可能是去练歌房。</p><p>唔哈哈哈，是不是很有趣~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究发出声音这件事情，然后就研究人体脖颈和咽喉的解剖结构。超有趣哎！&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics and Natural Sciences" scheme="https://liam.page/categories/Mathematics-and-Natural-Sciences/"/>
    
    
      <category term="Vocal" scheme="https://liam.page/tags/Vocal/"/>
    
      <category term="Autopsy" scheme="https://liam.page/tags/Autopsy/"/>
    
  </entry>
  
</feed>
